<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>RAG的简单流程实现</title>
      <link href="/2025/07/02/RAG%E7%AE%80%E5%8D%95%E6%B5%81%E7%A8%8B%E5%AE%9E%E7%8E%B0/"/>
      <url>/2025/07/02/RAG%E7%AE%80%E5%8D%95%E6%B5%81%E7%A8%8B%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="RAG的简单流程实现"><a href="#RAG的简单流程实现" class="headerlink" title="RAG的简单流程实现"></a>RAG的简单流程实现</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>RAG的简单流程实现。</p><hr><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><ul><li><p>准备知识库</p><p>规范格式</p></li><li><p>chunking分块&#x2F;段</p><p>通用分块；父子分块</p><p>分隔符、最大块长度、块重叠长度（连接上下文长度）、…</p></li><li><p>embedding嵌入</p><p>1.embedding嵌入模型</p><p>word2vec</p><p>经济索引（每块10个关键字搜）；高质量索引（embedding模型处理搜）</p><p>vector db</p></li><li><p>检索测试</p></li><li><p>查询同理，匹配相似度高&#x2F;向量距离近&#x2F;数据库相近的几条</p><p>2.rerank检索排序（多路）召回模型</p><p>向量搜索；全文&#x2F;倒排搜索；混合搜索（向量语义（索引）+关键词（索引））</p><p>分数阈值；topK</p></li></ul><hr><h1 id="缺点和优化"><a href="#缺点和优化" class="headerlink" title="缺点和优化"></a>缺点和优化</h1><p>缺点</p><ul><li>分块不准 </li><li>多句没有哪句特别相关</li></ul><p>优化</p><ul><li><p>graph rag知识图谱rag</p><p>图联系上下文，减少传统rag缺点</p></li></ul><hr><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.准备知识库————————————————————</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_knowledge_base</span>() -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;knowledge_base.md&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">return</span> f.read()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.chunking分块/段————————————————————</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">divide_chunks</span>() -&gt; <span class="built_in">list</span>[<span class="built_in">str</span>]:</span><br><span class="line">    text = read_knowledge_base()</span><br><span class="line">    tmp_chunks = text.split(<span class="string">&quot;\n\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># title不分块，和下一块合并</span></span><br><span class="line">    chunks = []</span><br><span class="line">    title = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> tmp_chunks:</span><br><span class="line">        <span class="keyword">if</span> c.startswith(<span class="string">&quot;#&quot;</span>):</span><br><span class="line">            title += <span class="string">f&quot;<span class="subst">&#123;c&#125;</span>\n&quot;</span>  <span class="comment"># 记录</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            chunks.append(<span class="string">f&quot;<span class="subst">&#123;title&#125;</span><span class="subst">&#123;c&#125;</span>&quot;</span>)  <span class="comment"># 合并</span></span><br><span class="line">            title = <span class="string">&quot;&quot;</span>  <span class="comment"># 重置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> chunks</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># if __name__ == &quot;__main__&quot;:</span></span><br><span class="line"><span class="comment">#     chunks = divide_chunks()</span></span><br><span class="line"><span class="comment">#     for c in chunks:</span></span><br><span class="line"><span class="comment">#         print(c)</span></span><br><span class="line"><span class="comment">#         print(&quot;---------------&quot;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.embedding嵌入————————————————————</span></span><br><span class="line"><span class="keyword">from</span> google <span class="keyword">import</span> genai</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取api密钥：https://aistudio.google.com/apikey（需要魔法）</span></span><br><span class="line"><span class="comment"># 作者已删除该密钥</span></span><br><span class="line">genai_client = genai.Client(api_key=<span class="string">&quot;AIzaSyDOai6QVu_r_fMRbFeLv5-rSyljpqpAhWc&quot;</span>)</span><br><span class="line">EMBED_MODEL = <span class="string">&quot;gemini-embedding-exp-03-07&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">embed</span>(<span class="params">text: <span class="built_in">str</span>, store: <span class="built_in">bool</span></span>) -&gt; <span class="built_in">list</span>[<span class="built_in">float</span>]:  <span class="comment"># 模型分为存储和查询模式</span></span><br><span class="line">    result = genai_client.models.embed_content(</span><br><span class="line">        model=EMBED_MODEL,</span><br><span class="line">        contents=text,</span><br><span class="line">        config=&#123;<span class="string">&quot;task_type&quot;</span>: <span class="string">&quot;RETRIEVAL_DOCUMENT&quot;</span> <span class="keyword">if</span> store <span class="keyword">else</span> <span class="string">&quot;RETRIEVAL_QUERY&quot;</span>&#125;,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> result.embeddings</span><br><span class="line">    <span class="keyword">assert</span> result.embeddings[<span class="number">0</span>].values</span><br><span class="line">    <span class="keyword">return</span> result.embeddings[<span class="number">0</span>].values</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># if __name__ == &quot;__main__&quot;:</span></span><br><span class="line"><span class="comment">#     chunks = divide_chunks()</span></span><br><span class="line"><span class="comment">#     print(embed(chunks[0], store=True))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> chromadb</span><br><span class="line"></span><br><span class="line">chromadb_client = chromadb.PersistentClient(<span class="string">&quot;./chroma.db&quot;</span>)  <span class="comment"># 库</span></span><br><span class="line">chromadb_collection = chromadb_client.get_or_create_collection(<span class="string">&quot;linghuchong&quot;</span>)  <span class="comment"># 表</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">store_db</span>() -&gt; <span class="literal">None</span>:</span><br><span class="line">    chunks = divide_chunks()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> idx, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(chunks):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Process: <span class="subst">&#123;c&#125;</span>&quot;</span>)</span><br><span class="line">        vec = embed(c, store=<span class="literal">True</span>)</span><br><span class="line">        chromadb_collection.upsert(ids=<span class="built_in">str</span>(idx), documents=c, embeddings=vec)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># if __name__ == &quot;__main__&quot;:</span></span><br><span class="line"><span class="comment">#     store_db()  # 可能会因为网络失败</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.检索测试</span></span><br><span class="line"><span class="comment"># 5.查询同理，匹配相似度高/向量距离近/数据库相近的几条</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">query_db</span>(<span class="params">question: <span class="built_in">str</span></span>) -&gt; <span class="built_in">list</span>[<span class="built_in">str</span>]:</span><br><span class="line">    vec = embed(question, store=<span class="literal">False</span>)</span><br><span class="line">    result = chromadb_collection.query(query_embeddings=vec, n_results=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> result[<span class="string">&quot;documents&quot;</span>]</span><br><span class="line">    <span class="keyword">return</span> result[<span class="string">&quot;documents&quot;</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LLM_MODEL = <span class="string">&quot;gemini-2.5-flash-preview-05-20&quot;</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># store_db()</span></span><br><span class="line"></span><br><span class="line">    question = <span class="string">&quot;令狐冲领悟了什么魔法？&quot;</span></span><br><span class="line">    context = query_db(question)</span><br><span class="line"></span><br><span class="line">    system_prompt = <span class="string">&quot;You are clever\n&quot;</span></span><br><span class="line">    user_prompt = <span class="string">&quot;Please answer user&#x27;s question according to context\n&quot;</span></span><br><span class="line">    user_prompt += <span class="string">f&quot;Question: <span class="subst">&#123;question&#125;</span>\n&quot;</span></span><br><span class="line">    user_prompt += <span class="string">&quot;Context:\n&quot;</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> context:</span><br><span class="line">        user_prompt += <span class="string">f&quot;<span class="subst">&#123;c&#125;</span>\n&quot;</span></span><br><span class="line">        user_prompt += <span class="string">&quot;-------------\n&quot;</span></span><br><span class="line">    prompt = system_prompt + user_prompt</span><br><span class="line"></span><br><span class="line">    result = genai_client.models.generate_content(model=LLM_MODEL, contents=prompt)</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line">    <span class="comment"># 没有继续提取answer了</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p>divide_chunk()</p><p><img src="/..%5Cimg%5Csimlpe_rag%5Cdivide_chunk().png" alt="divide_chunk()"></p><p>embed()</p><p><img src="/..%5Cimg%5Csimlpe_rag%5Cembed().png" alt="embed()"></p><p>store_db()</p><p><img src="/..%5Cimg%5Csimlpe_rag%5Cstore_db().png" alt="store_db()"></p><p>query()</p><p><img src="/..%5Cimg%5Csimlpe_rag%5Cquery().png" alt="query()"></p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.bilibili.com/video/BV19RJhzyEWN?spm_id_from=333.788.videopod.sections&vd_source=9ac1c0a6d496218112b60d49bc768cd7">这就是RAG 一看就懂的个人知识库架构_哔哩哔哩_bilibili</a></li><li><a href="https://www.bilibili.com/video/BV1XzQqYaEBP/?spm_id_from=333.788.player.switch&vd_source=9ac1c0a6d496218112b60d49bc768cd7&p=8">08-个人知识库资料存储和检索的流程_哔哩哔哩_bilibili</a></li><li><a href="https://www.bilibili.com/video/BV1zoKuzoENM?spm_id_from=333.788.videopod.sections&vd_source=9ac1c0a6d496218112b60d49bc768cd7">AI知识图谱 GraphRAG 是怎么回事？_哔哩哔哩_bilibili</a></li><li><a href="https://www.bilibili.com/video/BV168j7zCE6D/?spm_id_from=333.788.videopod.sections&vd_source=9ac1c0a6d496218112b60d49bc768cd7">从零写AI RAG 个人知识库_哔哩哔哩_bilibili</a></li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提示词（工程）的基础概念</title>
      <link href="/2025/07/01/%E6%8F%90%E7%A4%BA%E8%AF%8D%E5%B7%A5%E7%A8%8B%E7%9A%84%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
      <url>/2025/07/01/%E6%8F%90%E7%A4%BA%E8%AF%8D%E5%B7%A5%E7%A8%8B%E7%9A%84%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="提示词（工程）的基础概念"><a href="#提示词（工程）的基础概念" class="headerlink" title="提示词（工程）的基础概念"></a>提示词（工程）的基础概念</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>提示词（工程）的基础概念。</p><hr><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><ul><li><p>system prompt系统提示词</p><p>llm的人设</p></li><li><p>user prompt用户提示词</p><p>用户的问题</p></li><li><p>assistant prompt助手提示词</p><p>llm的上一轮输出，即回答的反馈&#x2F;上下文状态</p></li></ul><hr><h2 id="组成和技巧"><a href="#组成和技巧" class="headerlink" title="组成和技巧"></a>组成和技巧</h2><p>组成</p><ul><li><p>指令</p><p>背景</p><p>角色</p><p>步骤</p></li><li><p>输入</p></li><li><p>输出</p></li><li><p>例子</p></li></ul><p>技巧</p><ul><li>思维链：一步步想，上一步生成更丰富的上文辅助下一步回答</li><li>思维树：多维度思维链（如样式和价格）</li><li>投票法：多次验算，再总结</li></ul><hr><h2 id="漏洞和防御"><a href="#漏洞和防御" class="headerlink" title="漏洞和防御"></a>漏洞和防御</h2><p>漏洞</p><ul><li><p>提示词注入</p><p>泄露信息</p><p>非法信息</p></li></ul><p>防御</p><ul><li><p>分类拦截</p><p>每个用户问题都重新强调规则</p></li><li><p>内容审核</p></li></ul><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.bilibili.com/video/BV1n9CwYoEro?spm_id_from=333.788.videopod.episodes&vd_source=9ac1c0a6d496218112b60d49bc768cd7">【AI大模型实战】2小时彻底掌握提示词工程（Prompt Engineering）深入浅出，草履虫都能听懂！——LLM&#x2F;大模型入门&#x2F;大模型学习路线_哔哩哔哩_bilibili</a></li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中介者和访问者模式（行为型设计模式）的 C++ 代码示例模板</title>
      <link href="/2023/12/25/%E4%B8%AD%E4%BB%8B%E8%80%85%E5%92%8C%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%89%E7%9A%84%20C++%20%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E6%A8%A1%E6%9D%BF/"/>
      <url>/2023/12/25/%E4%B8%AD%E4%BB%8B%E8%80%85%E5%92%8C%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%89%E7%9A%84%20C++%20%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>中介者和访问者模式（行为型设计模式）的 C++ 代码示例模板。</p><hr><h1 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h1><ul><li><a href="https://github.com/yezhening/Programming-examples">yezhening&#x2F;Programming-examples: 编程实例 (github.com)</a></li><li><a href="https://gitee.com/yezhening/Programming-examples">Programming-examples: 编程实例 (gitee.com)</a></li></ul><hr><h1 id="中介者模式（Mediator）"><a href="#中介者模式（Mediator）" class="headerlink" title="中介者模式（Mediator）"></a>中介者模式（Mediator）</h1><p>结构</p><ul><li>抽象同事类</li><li>抽象中介者类</li><li>具体中介者类 <strong>（协调交互 的对象）</strong></li><li>具体同事类 <strong>（需要交互 的对象）</strong></li><li></li><li>抽象同事类 封装 抽象中介者指针（实际上指向一个具体中介者对象）<strong>（同事 需要认识 中介者）</strong>、发送消息方法 和 接收消息方法</li><li>抽象中介者类 封装 转发消息方法</li><li>具体中介者类 封装 抽象同事指针（实际上指向一个具体同事对象）<strong>（中介者 需要认识 同事）</strong></li><li>具体中介者类 重写 转发消息方法 <strong>（形式上 调用 具体中介者类的 转发消息方法，实际上 调用 具体同事类的 接收消息方法（中介者 转发消息，同事 接收消息））</strong></li><li>具体同事类 重写 发送消息方法 <strong>（形式上 调用 具体同事类的 发送消息方法，实际上 调用 具体中介者类的 转发消息方法（当前同事 发送消息，委托 中介者 转发消息）） 和 接收消息方法</strong></li></ul><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意 类的定义顺序</span></span><br><span class="line"><span class="comment">// 前置声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractMediator</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象同事类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractColleague</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AbstractColleague</span>(AbstractMediator *mediator) : <span class="built_in">mediator</span>(mediator) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">send_message</span><span class="params">(string message)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 接收消息</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">recv_message</span><span class="params">(string message)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 抽象中介者指针（实际上指向一个具体中介者对象）（同事 需要认识 中介者）</span></span><br><span class="line">    AbstractMediator *mediator;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象中介者类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractMediator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 转发消息</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">forward_message</span><span class="params">(string message, AbstractColleague *colleague)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体中介者类（协调交互 的对象）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteMediator</span> : <span class="keyword">public</span> AbstractMediator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 设置同事</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_colleague_A</span><span class="params">(AbstractColleague *colleague)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;colleague_A = colleague;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_colleague_B</span><span class="params">(AbstractColleague *colleague)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;colleague_B = colleague;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转发消息</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">forward_message</span><span class="params">(string message, AbstractColleague *colleague)</span> <span class="keyword">override</span> <span class="comment">// 形式上 调用 具体中介者类的 转发消息方法</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (colleague == <span class="keyword">this</span>-&gt;colleague_A)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;colleague_B-&gt;<span class="built_in">recv_message</span>(message); <span class="comment">// 实际上 调用 具体同事类的 接收消息方法（中介者 转发消息，同事 接收消息）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (colleague == <span class="keyword">this</span>-&gt;colleague_B) <span class="comment">// 发送者 是 同事B</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;colleague_A-&gt;<span class="built_in">recv_message</span>(message); <span class="comment">// 接收者 是 同事A</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 抽象同事指针（实际上指向一个具体同事对象）（中介者 需要认识 同事）</span></span><br><span class="line">    AbstractColleague *colleague_A;</span><br><span class="line">    AbstractColleague *colleague_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体同事A类（需要交互 的对象）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteColleagueA</span> : <span class="keyword">public</span> AbstractColleague</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteColleagueA</span>(AbstractMediator *mediator) : <span class="built_in">AbstractColleague</span>(mediator) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">send_message</span><span class="params">(string message)</span> <span class="keyword">override</span> <span class="comment">// 形式上 调用 具体同事A类的 发送消息方法</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Colleague A sends message: &quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        mediator-&gt;forward_message(message, <span class="keyword">this</span>); <span class="comment">// 实际上 调用 具体中介者类的 转发消息方法（当前同事 发送消息，委托 中介者 转发消息）。发送者 是 同事A（this）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收消息</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">recv_message</span><span class="params">(string message)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Colleague A receives message: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体同事类B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteColleagueB</span> : <span class="keyword">public</span> AbstractColleague</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteColleagueB</span>(AbstractMediator *mediator) : <span class="built_in">AbstractColleague</span>(mediator) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">send_message</span><span class="params">(string message)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Colleague B sends message: &quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        mediator-&gt;forward_message(message, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">recv_message</span><span class="params">(string message)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Colleague B receives message: &quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 具体中介者指针（实际上指向一个具体中介者对象）</span></span><br><span class="line">    ConcreteMediator *mediator = <span class="keyword">new</span> <span class="built_in">ConcreteMediator</span>();</span><br><span class="line">    <span class="comment">// 具体同事指针（实际上指向一个具体同事对象）（同事 需要认识 中介者）</span></span><br><span class="line">    ConcreteColleagueA *colleague_A = <span class="keyword">new</span> <span class="built_in">ConcreteColleagueA</span>(mediator);</span><br><span class="line">    ConcreteColleagueB *colleague_B = <span class="keyword">new</span> <span class="built_in">ConcreteColleagueB</span>(mediator);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置中介者的同事对象（中介者 需要认识同事）</span></span><br><span class="line">    mediator-&gt;<span class="built_in">set_colleague_A</span>(colleague_A);</span><br><span class="line">    mediator-&gt;<span class="built_in">set_colleague_B</span>(colleague_B);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同事对象间 委托中介者 交互</span></span><br><span class="line">    colleague_A-&gt;<span class="built_in">send_message</span>(<span class="string">&quot;Hello from Colleague A&quot;</span>);</span><br><span class="line">    colleague_B-&gt;<span class="built_in">send_message</span>(<span class="string">&quot;Hi from Colleague B&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> colleague_B;</span><br><span class="line">    <span class="keyword">delete</span> colleague_A;</span><br><span class="line">    <span class="keyword">delete</span> mediator;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">Colleague A sends message: Hello from Colleague A</span></span><br><span class="line"><span class="comment">Colleague B receives message: Hello from Colleague A</span></span><br><span class="line"><span class="comment">Colleague B sends message: Hi from Colleague B</span></span><br><span class="line"><span class="comment">Colleague A receives message: Hi from Colleague B</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h1 id="访问者模式（Visitor）"><a href="#访问者模式（Visitor）" class="headerlink" title="访问者模式（Visitor）"></a>访问者模式（Visitor）</h1><p>结构</p><ul><li>抽象访问者类</li><li>抽象元素类</li><li>具体元素类</li><li>具体访问者类</li><li>对象结构类</li><li></li><li>抽象访问者类 封装 访问方法（接收参数是具体元素指针）</li><li>抽象元素类 封装 接收方法（接收参数是抽象访问者指针）</li><li>具体元素类 重写 接收方法 <strong>（形式上 调用 具体元素类的 接收方法，实际上 调用 具体访问者类的 访问方法。发送参数是 this，表示 允许 访问者 访问 自身），</strong> 封装操作方法</li><li>具体访问者类 重写 访问方法 <strong>（形式上 调用 具体访问者类的 访问方法，实际上 调用 具体元素类的 操作方法）</strong></li><li>对象结构类 封装 抽象元素指针（实际上指向一个具体元素对象）的集合、添加元素方法 和 接收方法 <strong>（形式上 调用 对象结构类的 接收方法，实际上 调用 具体元素类的 接收方法）</strong></li></ul><p><strong>访问过程</strong></p><ul><li>对象结构类的 接收方法，发送参数是 访问者对象（对象结构 需要 访问者访问）</li><li>具体元素类的 接收方法，发送参数是 访问者对象（元素 需要 访问者访问）</li><li>具体访问者类的 访问方法，发送参数是 具体元素对象（元素 允许 访问者访问）</li><li>具体访问者类的 操作方法（访问者 访问 元素）</li></ul><p><strong>重点理解</strong></p><ul><li>分离 稳定的数据结构（元素） 和 变化的算法（访问者）</li><li>当需要添加新的操作时，只需要创建新的访问者类并实现相应的方法，而不需要修改现有的元素类</li></ul><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意 类的定义顺序</span></span><br><span class="line"><span class="comment">// 前置声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteElementA</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteElementB</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象访问者类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractVisitor</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 访问</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">visit_element_A</span><span class="params">(ConcreteElementA *element)</span> </span>= <span class="number">0</span>; <span class="comment">// 接收参数是具体元素指针</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">visit_element_B</span><span class="params">(ConcreteElementB *element)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象元素类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractElement</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 接收</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">accept</span><span class="params">(AbstractVisitor *visitor)</span> </span>= <span class="number">0</span>; <span class="comment">// 接收参数是抽象访问者指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体元素 A 类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteElementA</span> : <span class="keyword">public</span> AbstractElement</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 接收</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">accept</span><span class="params">(AbstractVisitor *visitor)</span> <span class="keyword">override</span> <span class="comment">// 形式上 调用 具体元素类的 接收方法</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        visitor-&gt;<span class="built_in">visit_element_A</span>(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 实际上 调用 具体访问者类的 访问方法</span></span><br><span class="line">        <span class="comment">// 发送参数是 this，表示 允许 访问者 访问 自身</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 操作</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operation_A</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ConcreteElementA operation&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体元素B类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteElementB</span> : <span class="keyword">public</span> AbstractElement</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">accept</span><span class="params">(AbstractVisitor *visitor)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        visitor-&gt;<span class="built_in">visit_element_B</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operation_B</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ConcreteElementB operation&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体访问者类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteVisitor</span> : <span class="keyword">public</span> AbstractVisitor</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 访问</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit_element_A</span><span class="params">(ConcreteElementA *element)</span> <span class="keyword">override</span> <span class="comment">// 形式上 调用 具体访问者类的 访问方法</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ConcreteVisitor visits ConcreteElementA&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        element-&gt;<span class="built_in">operation_A</span>(); <span class="comment">// 实际上 调用 具体元素类的 操作方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit_element_B</span><span class="params">(ConcreteElementB *element)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ConcreteVisitor ConcreteElementB&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        element-&gt;<span class="built_in">operation_B</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当需要添加新的操作时，只需要创建新的访问者类并实现相应的方法，而不需要修改现有的元素类</span></span><br><span class="line"><span class="comment">// 具体访问者新类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteVisitorNew</span> : <span class="keyword">public</span> AbstractVisitor</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 访问</span></span><br><span class="line">    <span class="comment">// 新的操作</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit_element_A</span><span class="params">(ConcreteElementA *element)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ConcreteVisitorNew visits ConcreteElementA&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        element-&gt;<span class="built_in">operation_A</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit_element_B</span><span class="params">(ConcreteElementB *element)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ConcreteVisitorNew ConcreteElementB&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        element-&gt;<span class="built_in">operation_B</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象结构类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ObjectStructure</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 添加元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add_element</span><span class="params">(AbstractElement *element)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;element_vec.<span class="built_in">push_back</span>(element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">accept</span><span class="params">(AbstractVisitor *visitor)</span> <span class="comment">// 形式上 调用 对象结构类的 接收方法</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (AbstractElement *element : <span class="keyword">this</span>-&gt;element_vec)</span><br><span class="line">        &#123;</span><br><span class="line">            element-&gt;<span class="built_in">accept</span>(visitor); <span class="comment">// 实际上 调用 具体元素类的 接收方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 抽象元素指针（实际上指向一个具体元素对象）的集合</span></span><br><span class="line">    vector&lt;AbstractElement *&gt; element_vec;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 具体元素对象</span></span><br><span class="line">    ConcreteElementA element_A;</span><br><span class="line">    ConcreteElementB element_B;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象结构对象</span></span><br><span class="line">    ObjectStructure object_structure;</span><br><span class="line">    object_structure.<span class="built_in">add_element</span>(&amp;element_A); <span class="comment">// 对象结构 添加元素</span></span><br><span class="line">    object_structure.<span class="built_in">add_element</span>(&amp;element_B);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体访问者对象</span></span><br><span class="line">    ConcreteVisitor visitor;</span><br><span class="line">    object_structure.<span class="built_in">accept</span>(&amp;visitor); <span class="comment">// 对象结构 接收 访问者的访问</span></span><br><span class="line">    <span class="comment">// 访问过程：</span></span><br><span class="line">    <span class="comment">// object_structure.accept(&amp;visitor); -&gt;</span></span><br><span class="line">    <span class="comment">// 对象结构类的 接收方法，发送参数是 访问者对象（对象结构 需要 访问者访问）</span></span><br><span class="line">    <span class="comment">// element-&gt;accept(visitor); -&gt;</span></span><br><span class="line">    <span class="comment">// 具体元素类的 接收方法，发送参数是 访问者对象（元素 需要 访问者访问）</span></span><br><span class="line">    <span class="comment">// visitor-&gt;visit_element_A(this);</span></span><br><span class="line">    <span class="comment">// 具体访问者类的 访问方法，发送参数是 具体元素对象（元素 允许 访问者访问）</span></span><br><span class="line">    <span class="comment">// element-&gt;operation_A();</span></span><br><span class="line">    <span class="comment">// 具体访问者类的 操作方法（访问者 访问 元素）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体访问者新对象</span></span><br><span class="line">    ConcreteVisitorNew visitor_new;</span><br><span class="line">    object_structure.<span class="built_in">accept</span>(&amp;visitor_new);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">ConcreteVisitor visits ConcreteElementA</span></span><br><span class="line"><span class="comment">ConcreteElementA operation</span></span><br><span class="line"><span class="comment">ConcreteVisitor ConcreteElementB</span></span><br><span class="line"><span class="comment">ConcreteElementB operation</span></span><br><span class="line"><span class="comment">ConcreteVisitorNew visits ConcreteElementA</span></span><br><span class="line"><span class="comment">ConcreteElementA operation</span></span><br><span class="line"><span class="comment">ConcreteVisitorNew ConcreteElementB</span></span><br><span class="line"><span class="comment">ConcreteElementB operation</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>中介者和访问者模式（行为型设计模式）的 C++ 代码示例模板。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://blog.csdn.net/m0_62083249/article/details/126137029">行为型设计模式总结_设计模式行为型模式的设计与实现心得体会-CSDN博客</a></li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>备忘录、迭代器和解释器模式（行为型设计模式）的 C++ 代码示例模板</title>
      <link href="/2023/12/24/%E5%A4%87%E5%BF%98%E5%BD%95%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%88%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%89%E7%9A%84%20C++%20%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E6%A8%A1%E6%9D%BF/"/>
      <url>/2023/12/24/%E5%A4%87%E5%BF%98%E5%BD%95%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%88%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%89%E7%9A%84%20C++%20%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>备忘录、迭代器和解释器模式（行为型设计模式）的 C++ 代码示例模板。</p><hr><h1 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h1><ul><li><a href="https://github.com/yezhening/Programming-examples">yezhening&#x2F;Programming-examples: 编程实例 (github.com)</a></li><li><a href="https://gitee.com/yezhening/Programming-examples">Programming-examples: 编程实例 (gitee.com)</a></li></ul><hr><h1 id="备忘录模式（Memento）"><a href="#备忘录模式（Memento）" class="headerlink" title="备忘录模式（Memento）"></a>备忘录模式（Memento）</h1><p>结构</p><ul><li>备忘录类（保存 发起者对象 的状态）</li><li>发起者类（需要保存和恢复状态 的对象）</li><li>管理者类（管理备忘录对象）</li><li></li><li>备忘录类 封装 状态属性，保存状态方法，获取状态方法</li><li>发起者类 封装 状态属性，设置状态方法，创建备忘录（保存状态）方法（将状态交给备忘录保存），恢复备忘录（恢复状态）方法（从备忘录获取&#x2F;恢复状态）</li><li>管理者类 封装 添加备忘录方法，获取备忘录方法</li><li>备忘录过程：发起者 调用 创建备忘录（保存状态）方法 -&gt; 管理者 调用 添加备忘录方法；管理者 调用 获取备忘录方法 -&gt; 发起者 调用 恢复备忘录（恢复状态）方法</li><li></li><li>基于嵌套类的实现中，备忘录类 是 发起者类 的内部类，发起者类 管理 备忘录类 的创建和恢复，通常不需要管理者类</li></ul><p>类型：</p><ul><li>基于非嵌套类&#x2F;接口的实现：支持和不支持嵌套类的编程语言（如 PHP） 可以实现</li><li>基于嵌套类的实现：只能在 支持嵌套类的编程语言（如 C++、 C# 和 Java） 实现</li></ul><p>代码（基于非嵌套类&#x2F;接口的实现）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 备忘录类（保存 发起者对象 的状态）</span></span><br><span class="line"><span class="comment">// 备忘录类 封装 状态属性，保存状态方法，获取状态方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memento</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Memento</span>(string state) : <span class="built_in">state</span>(state) &#123;&#125; <span class="comment">// 保存状态</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置状态</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取状态</span></span><br><span class="line">    <span class="function">string <span class="title">get_state</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string state; <span class="comment">// 状态</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发起者类（需要保存和恢复状态 的对象）</span></span><br><span class="line"><span class="comment">// 发起者类 封装 状态属性，设置状态方法，创建备忘录（保存状态）方法（将状态交给备忘录保存），恢复备忘录（恢复状态）方法（从备忘录获取/恢复状态）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Initiator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 设置状态</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_state</span><span class="params">(string state)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;state = state;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Current state: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;state &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取状态</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建备忘录（保存状态）</span></span><br><span class="line">    <span class="function">Memento <span class="title">create_memento</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Memento</span>(<span class="keyword">this</span>-&gt;state); <span class="comment">// 将状态交给备忘录保存</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复备忘录（恢复状态）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">restore_memento</span><span class="params">(Memento memento)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;state = memento.<span class="built_in">get_state</span>(); <span class="comment">// 从备忘录获取/恢复状态</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;State restores to: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;state &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string state; <span class="comment">// 状态</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 管理者类（管理备忘录对象）</span></span><br><span class="line"><span class="comment">// 管理者类 封装 添加备忘录方法，获取备忘录方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Administrator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 添加备忘录</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add_memento</span><span class="params">(Memento memento)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;memento_vec.<span class="built_in">push_back</span>(memento);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取备忘录</span></span><br><span class="line">    <span class="function"><span class="type">const</span> Memento <span class="title">get_memento</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;memento_vec.<span class="built_in">at</span>(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;Memento&gt; memento_vec;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 发起者对象</span></span><br><span class="line">    Initiator initiator;</span><br><span class="line">    <span class="comment">// 管理者对象</span></span><br><span class="line">    Administrator administrator;</span><br><span class="line"></span><br><span class="line">    initiator.<span class="built_in">set_state</span>(<span class="string">&quot;State 1&quot;</span>); <span class="comment">// 设置状态</span></span><br><span class="line">    <span class="comment">// 备忘录对象</span></span><br><span class="line">    Memento memento_1 = initiator.<span class="built_in">create_memento</span>(); <span class="comment">// 1. 创建备忘录（保存状态）</span></span><br><span class="line">    administrator.<span class="built_in">add_memento</span>(memento_1);           <span class="comment">// 2. 添加备忘录</span></span><br><span class="line"></span><br><span class="line">    initiator.<span class="built_in">set_state</span>(<span class="string">&quot;State 2&quot;</span>);                   <span class="comment">// 设置状态</span></span><br><span class="line">    Memento memento_2 = administrator.<span class="built_in">get_memento</span>(<span class="number">0</span>); <span class="comment">// 3. 获取备忘录</span></span><br><span class="line">    initiator.<span class="built_in">restore_memento</span>(memento_2);             <span class="comment">// 4. 恢复备忘录（恢复状态）</span></span><br><span class="line">    <span class="comment">// 备忘录过程：</span></span><br><span class="line">    <span class="comment">// 发起者 调用 创建备忘录（保存状态）方法 -&gt; 管理者 调用 添加备忘录方法</span></span><br><span class="line">    <span class="comment">// 管理者 调用 获取备忘录方法 -&gt; 发起者 调用 恢复备忘录（恢复状态）方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">Current state: State 1</span></span><br><span class="line"><span class="comment">Current state: State 2</span></span><br><span class="line"><span class="comment">State restores to: State 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>代码（基于嵌套类的实现）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发起者类（需要保存和恢复状态 的对象）</span></span><br><span class="line"><span class="comment">// 发起者类 封装 状态属性，设置状态方法，创建备忘录（保存状态）方法（将状态交给备忘录保存），恢复备忘录（恢复状态）方法（从备忘录获取/恢复状态）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Initiator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 备忘录类（保存 发起者对象 的状态）</span></span><br><span class="line">    <span class="comment">// 备忘录类 封装 状态属性，保存状态方法，获取状态方法</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Memento</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Memento</span>(string state) : <span class="built_in">state</span>(state) &#123;&#125; <span class="comment">// 保存状态</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置状态</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取状态</span></span><br><span class="line">        <span class="function">string <span class="title">get_state</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;state;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        string state; <span class="comment">// 状态</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 设置状态</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_state</span><span class="params">(string state)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;state = state;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Current state: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;state &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取状态</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建备忘录（保存状态）</span></span><br><span class="line">    <span class="function">Memento <span class="title">create_memento</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Memento</span>(<span class="keyword">this</span>-&gt;state); <span class="comment">// 将状态交给备忘录保存</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复备忘录（恢复状态）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">restore_memento</span><span class="params">(Memento memento)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;state = memento.<span class="built_in">get_state</span>(); <span class="comment">// 从备忘录获取/恢复状态</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;State restores to: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;state &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string state; <span class="comment">// 状态</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于嵌套类的实现中，备忘录类 是 发起者类 的内部类，发起者类 管理 备忘录类 的创建和恢复，通常不需要管理者类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 发起者对象</span></span><br><span class="line">    Initiator initiator;</span><br><span class="line"></span><br><span class="line">    initiator.<span class="built_in">set_state</span>(<span class="string">&quot;State 1&quot;</span>); <span class="comment">// 设置状态</span></span><br><span class="line">    <span class="comment">// 备忘录对象</span></span><br><span class="line">    Initiator::Memento memento_1 = initiator.<span class="built_in">create_memento</span>(); <span class="comment">// 1. 创建备忘录（保存状态）</span></span><br><span class="line"></span><br><span class="line">    initiator.<span class="built_in">set_state</span>(<span class="string">&quot;State 2&quot;</span>);       <span class="comment">// 设置状态</span></span><br><span class="line">    initiator.<span class="built_in">restore_memento</span>(memento_1); <span class="comment">// 2. 恢复备忘录（恢复状态）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">Current state: State 1</span></span><br><span class="line"><span class="comment">Current state: State 2</span></span><br><span class="line"><span class="comment">State restores to: State 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h1 id="迭代器模式（Iterator）"><a href="#迭代器模式（Iterator）" class="headerlink" title="迭代器模式（Iterator）"></a>迭代器模式（Iterator）</h1><p>结构</p><ul><li>项目类（需要迭代 的对象）</li><li>抽象迭代器类</li><li>具体迭代器类（帮助迭代 的对象）</li><li>抽象聚合类</li><li>具体聚合类（连接 项目集合 和 迭代器，获取 并 使用 项目集合 创建 迭代器）</li><li></li><li>抽象迭代器类 封装 获取第一个项目方法 和 获取下一个项目方法</li><li>具体迭代器类 封装 项目指针（实际上指向一个项目对象）的集合属性 和  项目集合的当前索引属性</li><li>具体迭代器类 重写 获取第一个项目方法 和 获取下一个项目方法</li><li>抽象聚合类 封装 创建迭代器方法</li><li>具体聚合类 封装 项目指针（实际上指向一个项目对象）的集合属性 和 重写 创建迭代器方法（抽象迭代器指针类型 的 具体迭代器指针）</li></ul><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 项目类（需要迭代 的对象）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Item</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Item</span>(string name) : <span class="built_in">name</span>(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取名称</span></span><br><span class="line">    <span class="function">string <span class="title">get_name</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name; <span class="comment">// 名称</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象迭代器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractIterator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Item *<span class="title">get_first</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 获取第一个项目</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Item *<span class="title">get_next</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 获取下一个项目</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体迭代器类（帮助迭代 的对象）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteIterator</span> : <span class="keyword">public</span> AbstractIterator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteIterator</span>(vector&lt;Item *&gt; item_vec) : <span class="built_in">item_vec</span>(item_vec), <span class="built_in">cur_index</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取第一个项目</span></span><br><span class="line">    <span class="function">Item *<span class="title">get_first</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Item *item = <span class="keyword">this</span>-&gt;item_vec[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (item != <span class="literal">nullptr</span>) <span class="comment">// 有第一个项目</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> item; <span class="comment">// 返回第一个项目</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 无第一个项目</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>; <span class="comment">// 返回空指针</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取下一个项目</span></span><br><span class="line">    <span class="function">Item *<span class="title">get_next</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">this</span>-&gt;cur_index &lt; (<span class="keyword">this</span>-&gt;item_vec.<span class="built_in">size</span>() - <span class="number">1</span>)) == <span class="literal">true</span>)</span><br><span class="line">        <span class="comment">// 索引 = 大小 - 1</span></span><br><span class="line">        <span class="comment">// 如果 项目的当前索引 小于 项目集合的大小 - 1，返回 true，有下一个项目</span></span><br><span class="line">        <span class="comment">// 如果 项目的当前索引 等于或大于 项目集合的大小 - 1，返回 false，无下一个项目</span></span><br><span class="line">        &#123;</span><br><span class="line">            ++<span class="keyword">this</span>-&gt;cur_index;</span><br><span class="line">            Item *item = <span class="keyword">this</span>-&gt;item_vec[<span class="keyword">this</span>-&gt;cur_index];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> item;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;Item *&gt; item_vec; <span class="comment">// 项目指针（实际上指向一个项目对象）的集合</span></span><br><span class="line">    <span class="type">size_t</span> cur_index;        <span class="comment">// 项目集合的当前索引</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象聚合类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractAggregate</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> AbstractIterator *<span class="title">create_iterator</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 创建迭代器</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体聚合类（连接 项目集合 和 迭代器，获取 并 使用 项目集合 创建 迭代器）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteAggregate</span> : <span class="keyword">public</span> AbstractAggregate</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteAggregate</span>(vector&lt;Item *&gt; item_vec) : <span class="built_in">item_vec</span>(item_vec) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建迭代器（抽象迭代器指针类型 的 具体迭代器指针）</span></span><br><span class="line">    <span class="function">AbstractIterator *<span class="title">create_iterator</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ConcreteIterator</span>(<span class="keyword">this</span>-&gt;item_vec);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;Item *&gt; item_vec;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 项目对象的集合</span></span><br><span class="line">    Item *item_1 = <span class="keyword">new</span> <span class="built_in">Item</span>(<span class="string">&quot;Item1&quot;</span>);</span><br><span class="line">    Item *item_2 = <span class="keyword">new</span> <span class="built_in">Item</span>(<span class="string">&quot;Item2&quot;</span>);</span><br><span class="line">    Item *item_3 = <span class="keyword">new</span> <span class="built_in">Item</span>(<span class="string">&quot;Item3&quot;</span>);</span><br><span class="line">    vector&lt;Item *&gt; item_vec = &#123;item_1, item_2, item_3&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体聚合对象</span></span><br><span class="line">    <span class="function">ConcreteAggregate <span class="title">aggregate</span><span class="params">(item_vec)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象迭代器指针类型 的 具体迭代器指针</span></span><br><span class="line">    AbstractIterator *iterator = aggregate.<span class="built_in">create_iterator</span>(); <span class="comment">// 创建迭代器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 具体迭代器指针 遍历 项目对象的集合</span></span><br><span class="line">    <span class="keyword">for</span> (Item *item = iterator-&gt;<span class="built_in">get_first</span>(); item != <span class="literal">nullptr</span>; item = iterator-&gt;<span class="built_in">get_next</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Item: &quot;</span> &lt;&lt; item-&gt;<span class="built_in">get_name</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> iterator;</span><br><span class="line">    <span class="keyword">for</span> (Item *item : item_vec)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">Item: Item1</span></span><br><span class="line"><span class="comment">Item: Item2</span></span><br><span class="line"><span class="comment">Item: Item3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h1 id="解释器模式（Interpreter）"><a href="#解释器模式（Interpreter）" class="headerlink" title="解释器模式（Interpreter）"></a>解释器模式（Interpreter）</h1><p>结构</p><ul><li>抽象表达式类</li><li>终结符表达式类 <strong>（树叶结点；用于将 变量 解释为 值）</strong></li><li>非终结符表达式类 <strong>（树枝结点；用于将 表达式 解释为 操作）</strong></li><li>上下文类（用于 设置 变量和值的映射 和 获取 变量 映射的 值）</li><li></li><li>抽象表达式类 封装 解释方法</li><li>终结符表达式类 封装 变量 和 重写 解释方法</li><li>非终结符表达式类 封装 抽象表达式指针（实际上指向一个 终结符表达式对象 或 非终结符表达式对象） 和 重写 解释方法（形式上 调用 非终结符表达式类的 解释方法， 实际上 调用 终结符表达式类 或 非终结符表达式类的 解释方法（递归））</li><li>上下文类 封装 上下文&#x2F;变量和值的映射属性、设置 变量和值的映射方法 和 获取 变量 映射的 值方法</li><li></li><li>创建过程：反向创建：先创建树叶，后创建树枝</li><li>解释过程：正向解释：先解释树枝，后解释树叶（树状递归）</li></ul><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::unordered_map;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象表达式类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractExpression</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 解释</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">interpret</span><span class="params">(unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; context_unmap)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 终结符表达式类（树叶结点；用于将 变量 解释为 值）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TerminalExpression</span> : <span class="keyword">public</span> AbstractExpression</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TerminalExpression</span>(<span class="type">char</span> var) : <span class="built_in">var</span>(var) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解释</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">interpret</span><span class="params">(unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; context_unmap)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> context_unmap[<span class="keyword">this</span>-&gt;var];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 变量</span></span><br><span class="line">    <span class="type">char</span> var;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非终结符表达式类（树枝结点；用于将 表达式 解释为 操作）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NonTerminalExpression</span> : <span class="keyword">public</span> AbstractExpression</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NonTerminalExpression</span>(AbstractExpression *expr_1, AbstractExpression *expr_2) : <span class="built_in">expr_1</span>(expr_1), <span class="built_in">expr_2</span>(expr_2) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解释</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">interpret</span><span class="params">(unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; context_unmap)</span> <span class="keyword">override</span> <span class="comment">// 形式上 调用 非终结符表达式类的 解释方法</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 这里 解释为 加法操作</span></span><br><span class="line">        <span class="keyword">return</span> expr_1-&gt;<span class="built_in">interpret</span>(context_unmap) + expr_2-&gt;<span class="built_in">interpret</span>(context_unmap); <span class="comment">// 实际上 调用 终结符表达式类 或 非终结符表达式类的 解释方法（递归）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 抽象表达式指针（实际上指向一个 终结符表达式对象 或 非终结符表达式对象）</span></span><br><span class="line">    AbstractExpression *expr_1;</span><br><span class="line">    AbstractExpression *expr_2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上下文类（用于 设置和获取 变量和值的映射）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Context</span>() : <span class="built_in">context_unmap</span>() &#123;&#125; <span class="comment">// unordered_map&lt;&gt; 的默认构造方法 初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 变量和值的映射</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_var_value</span><span class="params">(<span class="type">char</span> var, <span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;context_unmap[var] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 变量和值的映射</span></span><br><span class="line">    <span class="function">unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; <span class="title">get_var_value</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;context_unmap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 上下文/变量和值的映射</span></span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; context_unmap;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 构建表达式：a + b</span></span><br><span class="line">    AbstractExpression *expr_1 = <span class="keyword">new</span> <span class="built_in">TerminalExpression</span>(<span class="string">&#x27;a&#x27;</span>); <span class="comment">// 抽象表达式指针（实际上指向一个终结符表达式对象)</span></span><br><span class="line">    AbstractExpression *expr_2 = <span class="keyword">new</span> <span class="built_in">TerminalExpression</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">    AbstractExpression *expr_3 = <span class="keyword">new</span> <span class="built_in">NonTerminalExpression</span>(expr_1, expr_2); <span class="comment">// 抽象表达式指针（实际上指向一个非终结符表达式对象）</span></span><br><span class="line"></span><br><span class="line">    Context context; <span class="comment">// 上下文对象</span></span><br><span class="line">    <span class="comment">// 设置 变量和值的映射</span></span><br><span class="line">    context.<span class="built_in">set_var_value</span>(<span class="string">&#x27;a&#x27;</span>, <span class="number">10</span>);</span><br><span class="line">    context.<span class="built_in">set_var_value</span>(<span class="string">&#x27;b&#x27;</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  获取 变量和值的映射</span></span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; context_unmap = context.<span class="built_in">get_var_value</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解释</span></span><br><span class="line">    <span class="type">int</span> result = expr_3-&gt;<span class="built_in">interpret</span>(context_unmap);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 创建过程：</span></span><br><span class="line">    <span class="comment">// 反向创建：先创建树叶，后创建树枝</span></span><br><span class="line">    <span class="comment">// 解释过程：</span></span><br><span class="line">    <span class="comment">// 正向解释：先解释树枝，后解释树叶（树状递归）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> expr_3;</span><br><span class="line">    <span class="keyword">delete</span> expr_2;</span><br><span class="line">    <span class="keyword">delete</span> expr_1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">Result: 30</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>备忘录、迭代器和解释器模式（行为型设计模式）的 C++ 代码示例模板。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://blog.csdn.net/m0_62083249/article/details/126137029">行为型设计模式总结_设计模式行为型模式的设计与实现心得体会-CSDN博客</a></li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>状态、命令和观察者模式（行为型设计模式）的 C++ 代码示例模板</title>
      <link href="/2023/12/23/%E7%8A%B6%E6%80%81%E3%80%81%E5%91%BD%E4%BB%A4%E5%92%8C%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%89%E7%9A%84%20C++%20%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E6%A8%A1%E6%9D%BF/"/>
      <url>/2023/12/23/%E7%8A%B6%E6%80%81%E3%80%81%E5%91%BD%E4%BB%A4%E5%92%8C%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%89%E7%9A%84%20C++%20%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>状态、命令和观察者模式（行为型设计模式）的 C++ 代码示例模板。</p><hr><h1 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h1><ul><li><a href="https://github.com/yezhening/Programming-examples">yezhening&#x2F;Programming-examples: 编程实例 (github.com)</a></li><li><a href="https://gitee.com/yezhening/Programming-examples">Programming-examples: 编程实例 (gitee.com)</a></li></ul><hr><h1 id="状态模式（State）"><a href="#状态模式（State）" class="headerlink" title="状态模式（State）"></a>状态模式（State）</h1><p>结构</p><ul><li>抽象状态类</li><li>具体状态类</li><li>上下文类</li><li></li><li>抽象状态类 封装 处理方法</li><li>具体状态类 重写 处理方法</li><li></li><li>上下文类 封装 抽象状态指针（实际上指向一个具体状态对象）</li><li>上下文类 封装 转换状态方法（删除上一个状态即当前状态， 保存下一个状态为当前状态）</li><li>上下文类 封装 处理状态方法（形式上 调用 上下文类的 处理状态方法，实际上 调用 具体状态对象的处理方法）</li></ul><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象状态类</span></span><br><span class="line"><span class="comment">// 抽象状态类 封装 处理方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractState</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">handle</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体状态1类</span></span><br><span class="line"><span class="comment">// 具体状态类 重写 处理方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteState1</span> : <span class="keyword">public</span> AbstractState</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handle</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ConcreteState1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体状态2类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteState2</span> : <span class="keyword">public</span> AbstractState</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handle</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ConcreteState2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上下文类</span></span><br><span class="line"><span class="comment">// 上下文类 封装 抽象状态指针（实际上指向一个具体状态对象）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 转换状态方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">convert_state</span><span class="params">(AbstractState *next_state)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;current_state;       <span class="comment">// 删除上一个状态即当前状态</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;current_state = next_state; <span class="comment">// 保存下一个状态为当前状态</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理状态方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handle_state</span><span class="params">()</span> <span class="comment">// 形式上 调用 上下文类的 处理状态方法</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;current_state-&gt;<span class="built_in">handle</span>(); <span class="comment">// 实际上 调用 具体状态对象的处理方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    AbstractState *current_state = <span class="literal">nullptr</span>; <span class="comment">// 当前状态，默认为空</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 抽象状态指针（实际上指向一个具体状态对象）</span></span><br><span class="line">    AbstractState *abstract_state_1 = <span class="keyword">new</span> <span class="built_in">ConcreteState1</span>();</span><br><span class="line">    AbstractState *abstract_state_2 = <span class="keyword">new</span> <span class="built_in">ConcreteState2</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上下文对象</span></span><br><span class="line">    Context context;</span><br><span class="line"></span><br><span class="line">    context.<span class="built_in">convert_state</span>(abstract_state_1); <span class="comment">// 转换状态 nullptr -&gt; abstract_state_1</span></span><br><span class="line">    context.<span class="built_in">handle_state</span>();                  <span class="comment">// 处理状态</span></span><br><span class="line"></span><br><span class="line">    context.<span class="built_in">convert_state</span>(abstract_state_2);</span><br><span class="line">    context.<span class="built_in">handle_state</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> abstract_state_2;</span><br><span class="line">    <span class="comment">// delete abstract_state_1; 转换状态时隐式析构</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">ConcreteState1</span></span><br><span class="line"><span class="comment">ConcreteState2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h1 id="命令模式（Command）"><a href="#命令模式（Command）" class="headerlink" title="命令模式（Command）"></a>命令模式（Command）</h1><p>结构</p><ul><li>接收者类</li><li>抽象命令类</li><li>具体命令类</li><li>发送者类</li><li></li><li>接收者类 封装 行为方法</li><li>抽象命令类 封装 执行方法</li><li>具体命令类 重写 执行方法（形式上 调用 具体命令对象的执行方法，实际上 调用 接收者对象的行为方法）</li><li>具体命令类 封装 接收者对象（如果在 抽象命令类 封装 接收者对象，接收者类型一致；如果在 具体命令类 封装 接收者对象，接收者类型可以不同）</li><li>发送者类 封装 抽象命令指针（实际上指向一个具体命令对象）</li><li>发送者类 封装 设置命令方法 和 执行命令方法（形式上 调用 发送者对象的执行命令方法，实际上 调用 具体命令对象的执行方法）</li><li></li><li>命令执行过程：发送者 调用 执行命令方法 -&gt; 命令 调用 执行方法 -&gt; 接收者 调用 行为方法</li></ul><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收者类</span></span><br><span class="line"><span class="comment">// 接收者类 封装 行为方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Receiver</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">action</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Receiver&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象命令类</span></span><br><span class="line"><span class="comment">// 抽象命令类 封装 执行方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractCommand</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">execute</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体命令类</span></span><br><span class="line"><span class="comment">// 具体命令类 重写 执行方法</span></span><br><span class="line"><span class="comment">// 具体命令类 封装 接收者对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteCommand</span> : <span class="keyword">public</span> AbstractCommand</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteCommand</span>() : <span class="built_in">receiver</span>() &#123;&#125; <span class="comment">// 接收者类的默认构造方法 初始化 接收者对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">override</span> <span class="comment">// 形式上 调用 具体命令对象的执行方法</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        receiver.<span class="built_in">action</span>(); <span class="comment">// 实际上 调用 接收者对象的行为方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Receiver receiver;</span><br><span class="line">    <span class="comment">// 如果在 抽象命令类 封装 接收者对象，接收者类型一致</span></span><br><span class="line">    <span class="comment">// 如果在 具体命令类 封装 接收者对象，接收者类型可以不同</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送者类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sender</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 设置命令方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_command</span><span class="params">(AbstractCommand *abstract_command)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;abstract_command = abstract_command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行命令方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">execute_command</span><span class="params">()</span> <span class="comment">// 形式上 调用 发送者对象的执行命令方法</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;abstract_command-&gt;<span class="built_in">execute</span>(); <span class="comment">// 实际上 调用 具体命令对象的执行方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 封装 抽象命令指针（实际上指向一个具体命令对象）</span></span><br><span class="line">    AbstractCommand *abstract_command;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 抽象命令指针（实际上指向一个具体命令对象）</span></span><br><span class="line">    AbstractCommand *abstract_command = <span class="keyword">new</span> <span class="built_in">ConcreteCommand</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送者对象</span></span><br><span class="line">    Sender sender;</span><br><span class="line">    sender.<span class="built_in">set_command</span>(abstract_command); <span class="comment">// 设置命令</span></span><br><span class="line">    sender.<span class="built_in">execute_command</span>();             <span class="comment">// 执行命令</span></span><br><span class="line">    <span class="comment">// 命令执行过程：发送者 调用 执行命令方法 -&gt; 命令 调用 执行方法 -&gt; 接收者 调用 行为方法</span></span><br><span class="line">    <span class="comment">// ender.execute_command() -&gt; this-&gt;abstract_command-&gt;execute() -&gt; receiver.action()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> abstract_command;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">Receiver</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h1 id="观察者模式（Observer）"><a href="#观察者模式（Observer）" class="headerlink" title="观察者模式（Observer）"></a>观察者模式（Observer）</h1><p>结构</p><ul><li>抽象观察者类</li><li>具体观察者类</li><li>抽象目标类</li><li>具体目标类</li><li></li><li>抽象观察者类 封装 更新方法</li><li>具体观察者类 重写 更新方法</li><li>抽象目标类 封装 抽象观察者指针（实际上指向一个具体观察者对象）的集合属性，添加观察者方法，移除观察者方法，通知观察者方法（形式上 调用 具体目标对象的 通知观察者方法，实际上 调用 具体观察者对象的 更新方法）</li><li>抽象目标类 封装 状态属性，设置状态方法（设置状态后，通知观察者），获取状态方法</li><li></li><li>观察过程：目标设置（改变）状态 -&gt; 通知观察者 -&gt; 观察者更新</li></ul><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象观察者类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractObserver</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 更新方法</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">update</span><span class="params">(string message)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体观察者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteObserver</span> : <span class="keyword">public</span> AbstractObserver</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteObserver</span>(string name) : <span class="built_in">name</span>(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// （重写）更新方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(string message)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Observer &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; <span class="string">&quot; receives message: &quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name; <span class="comment">// 名称</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象目标类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractTarget</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AbstractTarget</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (AbstractObserver *observer : <span class="keyword">this</span>-&gt;observer_vec)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> observer;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;observer_vec.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加观察者方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add_observer</span><span class="params">(AbstractObserver *observer)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;observer_vec.<span class="built_in">push_back</span>(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除观察者方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove_observer</span><span class="params">(AbstractObserver *observer)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;AbstractObserver *&gt;::iterator it = std::<span class="built_in">remove</span>(<span class="keyword">this</span>-&gt;observer_vec.<span class="built_in">begin</span>(), <span class="keyword">this</span>-&gt;observer_vec.<span class="built_in">end</span>(), observer);</span><br><span class="line">        <span class="keyword">this</span>-&gt;observer_vec.<span class="built_in">erase</span>(it, <span class="keyword">this</span>-&gt;observer_vec.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 移除的观察者可能还需要，这里不 delete，由客户端构造和析构</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知观察者方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">notify_observer</span><span class="params">(string message)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (AbstractObserver *observer : <span class="keyword">this</span>-&gt;observer_vec) <span class="comment">// 形式上 调用 具体目标对象的 通知观察者方法</span></span><br><span class="line">        &#123;</span><br><span class="line">            observer-&gt;<span class="built_in">update</span>(message); <span class="comment">// 实际上 调用 具体观察者对象的 更新方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置状态方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_state</span><span class="params">(string state)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;state = state;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">notify_observer</span>(<span class="string">&quot;State changes to: &quot;</span> + <span class="keyword">this</span>-&gt;state); <span class="comment">// 设置状态后，通知观察者</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取状态方法</span></span><br><span class="line">    <span class="comment">// string get_state()</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     return this-&gt;state;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 抽象观察者指针（实际上指向一个具体观察者对象）的集合属性</span></span><br><span class="line">    vector&lt;AbstractObserver *&gt; observer_vec;</span><br><span class="line">    string state; <span class="comment">// 状态属性</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体目标类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteTarget</span> : <span class="keyword">public</span> AbstractTarget</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 简单实现，不需要额外内容</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 具体目标类</span></span><br><span class="line">    ConcreteTarget concrete_target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体观察者对象</span></span><br><span class="line">    AbstractObserver *concrete_observer_1 = <span class="keyword">new</span> <span class="built_in">ConcreteObserver</span>(<span class="string">&quot;concrete_observer_1&quot;</span>);</span><br><span class="line">    AbstractObserver *concrete_observer_2 = <span class="keyword">new</span> <span class="built_in">ConcreteObserver</span>(<span class="string">&quot;concrete_observer_2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加观察者</span></span><br><span class="line">    concrete_target.<span class="built_in">add_observer</span>(concrete_observer_1); <span class="comment">// 具体观察者对象1 观察 具体目标</span></span><br><span class="line">    concrete_target.<span class="built_in">add_observer</span>(concrete_observer_2); <span class="comment">// 具体观察者对象2 观察 具体目标</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置状态</span></span><br><span class="line">    concrete_target.<span class="built_in">set_state</span>(<span class="string">&quot;state1&quot;</span>);</span><br><span class="line">    <span class="comment">// 观察过程：</span></span><br><span class="line">    <span class="comment">// 目标设置（改变）状态 -&gt; 通知观察者 -&gt; 观察者更新</span></span><br><span class="line">    <span class="comment">// concrete_target.set_state() -&gt; this-&gt;notify_observer() -&gt; observer-&gt;update()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除观察者</span></span><br><span class="line">    concrete_target.<span class="built_in">remove_observer</span>(concrete_observer_1);</span><br><span class="line">    <span class="keyword">delete</span> concrete_observer_1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置状态</span></span><br><span class="line">    concrete_target.<span class="built_in">set_state</span>(<span class="string">&quot;state2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 局部变量 concrete_target 销毁，隐式析构 delete concrete_observer_2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">Observer concrete_observer_1 receives message: State changes to: state1</span></span><br><span class="line"><span class="comment">Observer concrete_observer_2 receives message: State changes to: state1</span></span><br><span class="line"><span class="comment">Observer concrete_observer_2 receives message: State changes to: state2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>状态、命令模式和观察者模式（行为型设计模式）的 C++ 代码示例模板。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://blog.csdn.net/m0_62083249/article/details/126137029">行为型设计模式总结_设计模式行为型模式的设计与实现心得体会-CSDN博客</a></li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模板方法、策略和职责链模式（行为型设计模式）的 C++ 代码示例模板</title>
      <link href="/2023/12/22/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E3%80%81%E7%AD%96%E7%95%A5%E5%92%8C%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F%EF%BC%88%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%89%E7%9A%84%20C++%20%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E6%A8%A1%E6%9D%BF/"/>
      <url>/2023/12/22/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E3%80%81%E7%AD%96%E7%95%A5%E5%92%8C%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F%EF%BC%88%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%89%E7%9A%84%20C++%20%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>模板方法、策略和职责链模式（行为型设计模式）的 C++ 代码示例模板。</p><hr><h1 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h1><ul><li><a href="https://github.com/yezhening/Programming-examples">yezhening&#x2F;Programming-examples: 编程实例 (github.com)</a></li><li><a href="https://gitee.com/yezhening/Programming-examples">Programming-examples: 编程实例 (gitee.com)</a></li></ul><hr><h1 id="模板方法模式（Template-Method）"><a href="#模板方法模式（Template-Method）" class="headerlink" title="模板方法模式（Template Method）"></a>模板方法模式（Template Method）</h1><p>结构</p><ul><li>抽象类</li><li>具体类</li><li></li><li>抽象类 声明 步骤方法（零个或多个）（由派生类重写&#x2F;实现）</li><li>抽象类 定义 模板方法。形式上 调用 模板方法，实际上 调用 步骤方法。即 哪些 步骤方法 何时 调用（规定组合内容和执行时序）<strong>（抽象的模板，不变行为）</strong></li><li>具体类（零个或多个） 重写&#x2F;实现 步骤方法 <strong>（具体的步骤，变化行为）</strong></li><li>抽象类指针（实际上指向一个具体类） 调用 抽象类&#x2F;父类的模板方法 就是一个方案</li></ul><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Abstraction</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 抽象类 定义 模板方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">template_method</span><span class="params">()</span> <span class="comment">// 形式上 调用 模板方法</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;template_method()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 实际上 调用 步骤方法。即 哪些 步骤方法 何时 调用（规定组合内容和执行时序） （抽象的模板，不变行为）</span></span><br><span class="line">        <span class="built_in">step_func_1</span>();</span><br><span class="line">        <span class="built_in">step_func_2</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 抽象类 声明 步骤方法（零个或多个）（由派生类重写/实现）</span></span><br><span class="line">    <span class="comment">// 步骤方法1</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">step_func_1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 步骤方法2</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">step_func_2</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体1类</span></span><br><span class="line"><span class="comment">// 具体类（零个或多个） 重写/实现 步骤方法 （具体的步骤，变化行为）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Concreteness1</span> : <span class="keyword">public</span> Abstraction</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">step_func_1</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Concreteness1 - step_func_1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">step_func_2</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Concreteness1 - step_func_2()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体1类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Concreteness2</span> : <span class="keyword">public</span> Abstraction</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">step_func_1</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Concreteness2 - step_func_1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">step_func_2</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Concreteness2 - step_func_2()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 抽象类指针（实际上指向一个具体类）</span></span><br><span class="line">    Abstraction *abstraction_1 = <span class="keyword">new</span> <span class="built_in">Concreteness1</span>();</span><br><span class="line">    abstraction_1-&gt;<span class="built_in">template_method</span>(); <span class="comment">// 抽象类指针（实际上指向一个具体类） 调用 抽象类/父类的模板方法 就是一个方案</span></span><br><span class="line">    <span class="keyword">delete</span> abstraction_1;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Abstraction *abstraction_2 = <span class="keyword">new</span> <span class="built_in">Concreteness2</span>();</span><br><span class="line">    abstraction_2-&gt;<span class="built_in">template_method</span>();</span><br><span class="line">    <span class="keyword">delete</span> abstraction_2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">template_method()</span></span><br><span class="line"><span class="comment">Concreteness1 - step_func_1()</span></span><br><span class="line"><span class="comment">Concreteness1 - step_func_2()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">template_method()</span></span><br><span class="line"><span class="comment">Concreteness2 - step_func_1()</span></span><br><span class="line"><span class="comment">Concreteness2 - step_func_2()</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h1 id="策略模式（Strategy）"><a href="#策略模式（Strategy）" class="headerlink" title="策略模式（Strategy）"></a>策略模式（Strategy）</h1><p>结构</p><ul><li>抽象策略类</li><li>具体策略类</li><li>上下文类</li><li></li><li>上下文类 封装 抽象策略指针（实际上指向一个具体策略对象）</li><li>上下文类 封装 设置策略方法 和 执行策略方法</li><li>形式上调用 上下文对象的 执行策略方法，实际上调用 具体策略对象的 执行方法</li></ul><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象策略类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractStrategy</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">execute</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略1类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStrategy1</span> : <span class="keyword">public</span> AbstractStrategy</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ConcreteStrategy1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略2类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStrategy2</span> : <span class="keyword">public</span> AbstractStrategy</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ConcreteStrategy2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上下文类</span></span><br><span class="line"><span class="comment">// 上下文类 封装 抽象策略指针（实际上指向一个具体策略对象）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Context</span>(AbstractStrategy *strategy) : <span class="built_in">strategy</span>(strategy) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置策略方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_strategy</span><span class="params">(AbstractStrategy *strategy)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行策略方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">execute_strategy</span><span class="params">()</span> <span class="comment">// 形式上调用 上下文对象的 执行策略方法</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;strategy-&gt;<span class="built_in">execute</span>(); <span class="comment">// 实际上调用 具体策略对象的 执行方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    AbstractStrategy *strategy;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 具体策略对象</span></span><br><span class="line">    ConcreteStrategy1 concrete_strategy_1;</span><br><span class="line">    ConcreteStrategy2 concrete_strategy_2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上下文对象</span></span><br><span class="line">    <span class="function">Context <span class="title">context</span><span class="params">(&amp;concrete_strategy_1)</span></span>; <span class="comment">// 设置策略</span></span><br><span class="line">    context.<span class="built_in">execute_strategy</span>();            <span class="comment">// 执行策略</span></span><br><span class="line"></span><br><span class="line">    context.<span class="built_in">set_strategy</span>(&amp;concrete_strategy_2); <span class="comment">// 设置策略</span></span><br><span class="line">    context.<span class="built_in">execute_strategy</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">ConcreteStrategy1</span></span><br><span class="line"><span class="comment">ConcreteStrategy2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h1 id="职责链模式（Chain-of-Responsibility-CoR）"><a href="#职责链模式（Chain-of-Responsibility-CoR）" class="headerlink" title="职责链模式（Chain of Responsibility&#x2F;CoR）"></a>职责链模式（Chain of Responsibility&#x2F;CoR）</h1><p>结构</p><ul><li>请求类</li><li>抽象处理者类</li><li>具体处理者类</li><li></li><li>抽象处理者类 封装 抽象处理者指针（实际上指向一个具体处理者对象，该对象是当前具体处理对象的下一个具体处理对象&#x2F;下一个处理者&#x2F;继任者）</li><li>抽象处理者类 封装 设置继任者方法 和 处理请求方法（如果有继任者，继任者 调用 处理请求方法处理请求；如果没有继任者，无法处理请求）</li><li>具体处理者类 重写 处理请求方法（获取并判断请求的类型，如果有权处理请求，当前具体处理对象处理请求；如果无权处理请求，调用基类&#x2F;抽象处理者类的处理请求方法（将请求交给继任者处理））</li></ul><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Request</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Request</span>(<span class="type">int</span> type) : <span class="built_in">type</span>(type) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取请求的类型</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_type</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> type; <span class="comment">// 请求的类型</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象处理者类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractHandler</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AbstractHandler</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;successor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置继任者方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_successor</span><span class="params">(AbstractHandler *successor)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;successor = successor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理请求方法</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">handle_request</span><span class="params">(Request request)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;successor != <span class="literal">nullptr</span>) <span class="comment">// 如果有继任者，继任者 调用 处理请求方法处理请求</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;successor-&gt;<span class="built_in">handle_request</span>(request);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 如果没有继任者，无法处理请求</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Request not handled&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 抽象处理者类 封装 抽象处理者指针（实际上指向一个具体处理者对象，该对象是当前具体处理对象的下一个具体处理对象/下一个处理者/继任者）</span></span><br><span class="line">    AbstractHandler *successor = <span class="literal">nullptr</span>; <span class="comment">// 默认没有继任者</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体处理者1类</span></span><br><span class="line"><span class="comment">// 具体处理者类 重写 处理请求方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteHandler1</span> : <span class="keyword">public</span> AbstractHandler</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handle_request</span><span class="params">(Request request)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 获取并判断请求的类型</span></span><br><span class="line">        <span class="keyword">if</span> (request.<span class="built_in">get_type</span>() == <span class="number">1</span>) <span class="comment">// 如果有权处理请求，当前具体处理对象处理请求</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;ConcreteHandler1 handles the request&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 如果无权处理请求，调用基类/抽象处理者类的处理请求方法（将请求交给继任者处理）</span></span><br><span class="line">        &#123;</span><br><span class="line">            AbstractHandler::<span class="built_in">handle_request</span>(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体处理者2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteHandler2</span> : <span class="keyword">public</span> AbstractHandler</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handle_request</span><span class="params">(Request request)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request.<span class="built_in">get_type</span>() == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;ConcreteHandler2 handles the request&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            AbstractHandler::<span class="built_in">handle_request</span>(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 抽象处理者指针（实际上指向一个具体处理者对象）</span></span><br><span class="line">    AbstractHandler *concrete_handler_1 = <span class="keyword">new</span> <span class="built_in">ConcreteHandler1</span>();</span><br><span class="line">    AbstractHandler *concrete_handler_2 = <span class="keyword">new</span> <span class="built_in">ConcreteHandler2</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置处理者链：concrete_handler_1 -&gt; concrete_handler_2</span></span><br><span class="line">    concrete_handler_1-&gt;<span class="built_in">set_successor</span>(concrete_handler_2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求对象</span></span><br><span class="line">    <span class="function">Request <span class="title">request_1</span><span class="params">(<span class="number">1</span>)</span></span>; <span class="comment">// 1类型的请求</span></span><br><span class="line">    <span class="function">Request <span class="title">request_2</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">Request <span class="title">request_3</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理请求</span></span><br><span class="line">    concrete_handler_1-&gt;<span class="built_in">handle_request</span>(request_1);</span><br><span class="line">    concrete_handler_1-&gt;<span class="built_in">handle_request</span>(request_2);</span><br><span class="line">    concrete_handler_1-&gt;<span class="built_in">handle_request</span>(request_3);</span><br><span class="line">    <span class="comment">// 1类型的请求，具体处理1对象有权处理</span></span><br><span class="line">    <span class="comment">// 2类型的请求，具体处理1对象无权处理，将请求交给继任者处理；具体处理2对象有权处理</span></span><br><span class="line">    <span class="comment">// 3类型的请求，具体处理1对象无权处理，将请求交给继任者处理；具体处理2对象无权处理，没有继任者；无法处理请求</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> concrete_handler_1; <span class="comment">// 递归析构 delete concrete_handler_2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">ConcreteHandler1 handles the request</span></span><br><span class="line"><span class="comment">ConcreteHandler2 handles the request</span></span><br><span class="line"><span class="comment">Request not handled</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>模板方法、策略和职责链模式（行为型设计模式）的 C++ 代码示例模板。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://blog.csdn.net/m0_62083249/article/details/126137029">行为型设计模式总结_设计模式行为型模式的设计与实现心得体会-CSDN博客</a></li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>桥接和享元模式（结构型设计模式）的 C++ 代码示例模板</title>
      <link href="/2023/12/21/%E6%A1%A5%E6%8E%A5%E5%92%8C%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%EF%BC%88%E7%BB%93%E6%9E%84%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%89%E7%9A%84%20C++%20%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E6%A8%A1%E6%9D%BF/"/>
      <url>/2023/12/21/%E6%A1%A5%E6%8E%A5%E5%92%8C%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%EF%BC%88%E7%BB%93%E6%9E%84%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%89%E7%9A%84%20C++%20%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>桥接和享元模式（结构型设计模式）的 C++ 代码示例模板。</p><hr><h1 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h1><ul><li><a href="https://github.com/yezhening/Programming-examples">yezhening&#x2F;Programming-examples: 编程实例 (github.com)</a></li><li><a href="https://gitee.com/yezhening/Programming-examples">Programming-examples: 编程实例 (gitee.com)</a></li></ul><hr><h1 id="桥接模式（Bridge）"><a href="#桥接模式（Bridge）" class="headerlink" title="桥接模式（Bridge）"></a>桥接模式（Bridge）</h1><p>结构</p><ul><li>抽象实现类</li><li>具体实现类</li><li>抽象抽象类</li><li>具体抽象类</li><li></li><li>桥接过程1：抽象抽象类 封装（保护权限） 抽象实现指针（实际上指向一个具体实现对象）</li><li>桥接过程2：形式上调用 抽象的方法；实际上调用 抽象的内容 + 实现的方法</li></ul><p><strong>重点理解</strong></p><ul><li>多维结构</li><li>合成聚合原则（C&#x2F;ARP），聚合&#x2F;组合关系</li><li>拆分抽象内容和实现内容，使用聚合&#x2F;组合关系桥接</li><li></li><li>抽象内容：不是指抽象类和接口，指一个独立维度&#x2F;类层次，如手机品牌类</li><li>实现内容：不是指具体类和实现类，指一个独立维度&#x2F;类层次，如手机软件类</li><li>聚合&#x2F;组合关系：手机品牌对象 封装 相关的手机软件对象</li><li>桥接方式：手机品牌对象 通过 手机软件对象 使用手机软件类的属性和方法，不必知道手机软件类的状态和行为</li><li>无桥接方式（使用继承关系）：每个手机品牌类 继承 相关的手机软件类，类的数量呈树状结构几何递增，难以维护</li></ul><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractImplementation</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">impl_func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体实现类 A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteImplementationA</span> : <span class="keyword">public</span> AbstractImplementation</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">impl_func</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ConcreteImplementationA&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体实现类 B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteImplementationB</span> : <span class="keyword">public</span> AbstractImplementation</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">impl_func</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ConcreteImplementationB&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象抽象类</span></span><br><span class="line"><span class="comment">// 桥接过程1：抽象抽象类 封装（保护权限） 抽象实现指针（实际上指向一个具体实现对象）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractAbstraction</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AbstractAbstraction</span>(AbstractImplementation *abst_impl) : <span class="built_in">abst_impl</span>(abst_impl) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">AbstractAbstraction</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;abst_impl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">abst_func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    AbstractImplementation *abst_impl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体抽象类 A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteAbstractionA</span> : <span class="keyword">public</span> AbstractAbstraction</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteAbstractionA</span>(AbstractImplementation *abst_impl) : <span class="built_in">AbstractAbstraction</span>(abst_impl) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 桥接过程2：</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">abst_func</span><span class="params">()</span> <span class="keyword">override</span> <span class="comment">// 形式上调用 抽象的方法</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ConcreteAbstractionA&quot;</span> &lt;&lt; endl; <span class="comment">// 实际上调用 抽象的内容+ 实现的方法</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;abst_impl-&gt;<span class="built_in">impl_func</span>();           <span class="comment">// + 实现的方法</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体抽象类 B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteAbstractionB</span> : <span class="keyword">public</span> AbstractAbstraction</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteAbstractionB</span>(AbstractImplementation *abst_impl) : <span class="built_in">AbstractAbstraction</span>(abst_impl) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">abst_func</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ConcreteAbstractionB&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;abst_impl-&gt;<span class="built_in">impl_func</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 具体实现 A 对象</span></span><br><span class="line">    AbstractImplementation *abst_impl_A = <span class="keyword">new</span> <span class="built_in">ConcreteImplementationA</span>();</span><br><span class="line">    <span class="comment">// 具体抽象 A 对象</span></span><br><span class="line">    AbstractAbstraction *abst_abst_A = <span class="keyword">new</span> <span class="built_in">ConcreteAbstractionA</span>(abst_impl_A); <span class="comment">// 桥接抽象内容 A 和实现内容 A</span></span><br><span class="line">    abst_abst_A-&gt;<span class="built_in">abst_func</span>();</span><br><span class="line">    <span class="keyword">delete</span> abst_abst_A; <span class="comment">// delete abst_impl_A</span></span><br><span class="line"></span><br><span class="line">    AbstractImplementation *abst_impl_B = <span class="keyword">new</span> <span class="built_in">ConcreteImplementationB</span>();</span><br><span class="line">    AbstractAbstraction *abst_abst_B = <span class="keyword">new</span> <span class="built_in">ConcreteAbstractionB</span>(abst_impl_B);</span><br><span class="line">    abst_abst_B-&gt;<span class="built_in">abst_func</span>();</span><br><span class="line">    <span class="keyword">delete</span> abst_abst_B; <span class="comment">// delete abst_impl_B</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">ConcreteAbstractionA</span></span><br><span class="line"><span class="comment">ConcreteImplementationA</span></span><br><span class="line"><span class="comment">ConcreteAbstractionB</span></span><br><span class="line"><span class="comment">ConcreteImplementationB</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h1 id="享元模式（Flyweight）"><a href="#享元模式（Flyweight）" class="headerlink" title="享元模式（Flyweight）"></a>享元模式（Flyweight）</h1><blockquote><p><strong>享元 即 共享</strong></p></blockquote><p>结构</p><ul><li>抽象享元类</li><li>具体享元类（需要共享的内容）</li><li>具体不共享类（不需要共享的内容）</li><li>享元工厂类</li><li></li><li>内部状态（需要共享的内容）：对象的不变状态，可以被多个对象共享，不取决于外部环境，通常存储在具体享元对象内部</li><li>外部状态（不需要共享的内容）：对象的可变状态，不可以被多个对象共享，取决于外部环境，需要时作为参数传递给具体享元&#x2F;具体不共享对象</li><li>具体享元类 有内部状态，<strong>可以</strong>有外部状态</li><li>具体不共享类 没有内部状态，有外部状态</li><li></li><li>享元工厂 封装 享元集合（实际上 封装 具体享元对象）（具体享元对象是共享的，具有共性，可以用工厂&#x2F;集合统一管理；具体不共享对象是不共享的，不具有共性，一般不统一管理，需要时再创建）</li><li>享元工厂 获取抽象享元指针（实际上指向一个具体享元对象）</li><li>享元工厂 获取抽象享元指针（实际上指向一个具体不共享对象）</li></ul><p><strong>重点理解</strong></p><ul><li>具体不共享类 和 外部状态（不需要共享的内容）</li><li>具体享元类 和 内部状态（需要共享的内容）</li><li></li><li>具体享元对象和内部状态是共享的，从享元工厂创建或获取（无时创建，有时获取）</li><li>具体不共享对象和外部状态是不共享的，从享元工厂创建（需要时创建）</li></ul><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::pair;</span><br><span class="line"><span class="keyword">using</span> std::unordered_map;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象享元类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractFlyweight</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> external_state)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 外部状态（不需要共享的内容）：对象的可变状态，不可以被多个对象共享，取决于外部环境，需要时作为参数传递给具体享元/具体不共享对象</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体享元类（需要共享的内容）</span></span><br><span class="line"><span class="comment">// 具体享元类 有内部状态，可以 有外部状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFlyweight</span> : <span class="keyword">public</span> AbstractFlyweight</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteFlyweight</span>(<span class="type">int</span> internal_state) : <span class="built_in">internal_state</span>(internal_state) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> external_state)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;external_state: &quot;</span> &lt;&lt; external_state &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;internal_state: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;internal_state &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> internal_state;</span><br><span class="line">    <span class="comment">// 内部状态（需要共享的内容）：对象的不变状态，可以被多个对象共享，不取决于外部环境，通常存储在具体享元对象内部</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体不共享类（不需要共享的内容）</span></span><br><span class="line"><span class="comment">// 具体不共享类 没有内部状态，有外部状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteUnshared</span> : <span class="keyword">public</span> AbstractFlyweight</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> external_state)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;external_state: &quot;</span> &lt;&lt; external_state &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 享元工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FlyweightFactory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 统一析构</span></span><br><span class="line">    ~<span class="built_in">FlyweightFactory</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (pair&lt;<span class="type">int</span>, AbstractFlyweight *&gt; p : <span class="keyword">this</span>-&gt;flyweight_unmap)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> p.second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 享元工厂 获取抽象享元指针（实际上指向一个具体享元对象）</span></span><br><span class="line">    <span class="function">AbstractFlyweight *</span></span><br><span class="line"><span class="function">    <span class="title">get_concrete_flyweight</span><span class="params">(<span class="type">int</span> key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 若不存在创建</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;flyweight_unmap.<span class="built_in">find</span>(key) == <span class="keyword">this</span>-&gt;flyweight_unmap.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;flyweight_unmap[key] = <span class="keyword">new</span> <span class="built_in">ConcreteFlyweight</span>(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若存在返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;flyweight_unmap[key];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 享元工厂 获取抽象享元指针（实际上指向一个具体不共享对象）</span></span><br><span class="line">    <span class="function">AbstractFlyweight *<span class="title">get_concrete_unshared</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ConcreteUnshared</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, AbstractFlyweight *&gt; flyweight_unmap;</span><br><span class="line">    <span class="comment">// 享元工厂 封装 享元集合（实际上 封装 具体享元对象）</span></span><br><span class="line">    <span class="comment">// 具体享元对象是共享的，具有共性，可以用工厂/集合统一管理</span></span><br><span class="line">    <span class="comment">// 具体不共享对象是不共享的，不具有共性，一般不统一管理，需要时再创建</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 享元工厂对象</span></span><br><span class="line">    FlyweightFactory flyweight_factory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象享元指针（实际上指向具体享元对象）</span></span><br><span class="line">    AbstractFlyweight *concrete_flyweight_1 = flyweight_factory.<span class="built_in">get_concrete_flyweight</span>(<span class="number">10</span>); <span class="comment">// 设置内部状态</span></span><br><span class="line">    concrete_flyweight_1-&gt;<span class="built_in">func</span>(<span class="number">100</span>);                                                        <span class="comment">// 传递外部状态</span></span><br><span class="line"></span><br><span class="line">    AbstractFlyweight *concrete_flyweight_2 = flyweight_factory.<span class="built_in">get_concrete_flyweight</span>(<span class="number">10</span>); <span class="comment">// 获取同一个具体享元对象，共享的体现</span></span><br><span class="line">    concrete_flyweight_2-&gt;<span class="built_in">func</span>(<span class="number">200</span>);                                                        <span class="comment">// 不共享的体现</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象享元指针（实际上指向具体不共享对象）</span></span><br><span class="line">    AbstractFlyweight *concrete_unshared = flyweight_factory.<span class="built_in">get_concrete_unshared</span>();</span><br><span class="line">    concrete_unshared-&gt;<span class="built_in">func</span>(<span class="number">300</span>); <span class="comment">// 传递外部状态；不共享的体现</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> concrete_unshared; <span class="comment">// 显式析构具体不共享对象</span></span><br><span class="line">    <span class="comment">// 析构享元工厂对象时 隐式析构享元对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">external_state: 100</span></span><br><span class="line"><span class="comment">internal_state: 10</span></span><br><span class="line"><span class="comment">external_state: 200</span></span><br><span class="line"><span class="comment">internal_state: 10</span></span><br><span class="line"><span class="comment">external_state: 300</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>桥接和享元模式（结构型设计模式）的 C++ 代码示例模板。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://blog.csdn.net/m0_62083249/article/details/126156063">结构型设计模式总结_结构型设计模式实验总结-CSDN博客</a></li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>外观、装饰和组合模式（结构型设计模式）的 C++ 代码示例模板</title>
      <link href="/2023/12/20/%E5%A4%96%E8%A7%82%E3%80%81%E8%A3%85%E9%A5%B0%E5%92%8C%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%EF%BC%88%E7%BB%93%E6%9E%84%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%89%E7%9A%84%20C++%20%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E6%A8%A1%E6%9D%BF%E3%80%82/"/>
      <url>/2023/12/20/%E5%A4%96%E8%A7%82%E3%80%81%E8%A3%85%E9%A5%B0%E5%92%8C%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%EF%BC%88%E7%BB%93%E6%9E%84%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%89%E7%9A%84%20C++%20%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E6%A8%A1%E6%9D%BF%E3%80%82/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>外观、装饰和组合模式（结构型设计模式）的 C++ 代码示例模板。</p><hr><h1 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h1><ul><li><a href="https://github.com/yezhening/Programming-examples">yezhening&#x2F;Programming-examples: 编程实例 (github.com)</a></li><li><a href="https://gitee.com/yezhening/Programming-examples">Programming-examples: 编程实例 (gitee.com)</a></li></ul><hr><h1 id="外观模式（Facade）"><a href="#外观模式（Facade）" class="headerlink" title="外观模式（Facade）"></a>外观模式（Facade）</h1><p>结构</p><ul><li>子系统类（多个）（被管理者）</li><li>外观类（管理者）</li><li></li><li>外观类 封装 子系统对象</li><li>外观类的方案方法 调用子系统对象的方法 搭配成不同方案 <strong>（不同对象、方法（内容）和时序&#x2F;步骤等）</strong></li><li></li><li>客户端只知道外观类，不知道子系统类</li></ul><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子系统类（多个）（被管理者）</span></span><br><span class="line"><span class="comment">// 子系统 A 类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubsystemA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func_A</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;func_A()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子系统 B 类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubsystemB</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func_B</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;func_B()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 外观类（管理者）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Facade</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Facade</span>() : <span class="built_in">subsystem_A</span>(), <span class="built_in">subsystem_B</span>() &#123;&#125; <span class="comment">// 子系统类的 默认构造方法初始化 子系统对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 外观类的方案方法 调用子系统对象的方法 搭配成不同方案（不同对象、方法（内容）和时序/步骤等）</span></span><br><span class="line">    <span class="comment">// 方案1</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">option1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        subsystem_A.<span class="built_in">func_A</span>();</span><br><span class="line">        subsystem_B.<span class="built_in">func_B</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方案2</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">option2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        subsystem_B.<span class="built_in">func_B</span>();</span><br><span class="line">        subsystem_A.<span class="built_in">func_A</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方案n...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 外观类 封装 子系统对象</span></span><br><span class="line">    SubsystemA subsystem_A;</span><br><span class="line">    SubsystemB subsystem_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 客户端只知道外观类，不知道子系统类</span></span><br><span class="line">    Facade facade;</span><br><span class="line"></span><br><span class="line">    facade.<span class="built_in">option1</span>(); <span class="comment">// 使用方案1</span></span><br><span class="line">    facade.<span class="built_in">option2</span>(); <span class="comment">// 使用方案2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">func_A()</span></span><br><span class="line"><span class="comment">func_B()</span></span><br><span class="line"><span class="comment">func_B()</span></span><br><span class="line"><span class="comment">func_A()</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h1 id="装饰模式（Decorator）"><a href="#装饰模式（Decorator）" class="headerlink" title="装饰模式（Decorator）"></a>装饰模式（Decorator）</h1><p>结构</p><ul><li>抽象组件类</li><li>具体组件类（被装饰者）</li><li>抽象装饰类</li><li>具体装饰类（装饰者）</li><li></li><li><strong>抽象装饰类 继承 抽象组件类</strong></li><li><strong>抽象装饰类 封装 抽象组件指针（实际上会指向一个具体组件对象）（装饰者包装被装饰者）</strong></li><li>抽象装饰类 重写 抽象组件类的方法</li><li>形式上 调用 装饰类的方法</li><li>实际上 调用 抽象组件指针&#x2F;具体组件对象的方法（原本内容） + 装饰类的额外内容（装饰内容） <strong>（重点理解）</strong></li><li></li><li>具体装饰类 重写 抽象组件类的方法</li><li>形式上 调用 装饰类的方法</li><li>实际上 调用 抽象组件指针&#x2F;具体组件对象的方法（原本内容） + 装饰类的额外内容（装饰内容） <strong>（重点理解）</strong></li><li></li><li>注意浅拷贝和深拷贝问题：相同组件不同装饰，需要浅拷贝</li><li>注意同一组件不同装饰的重复析构问题</li></ul><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象组件类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractComponent</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AbstractComponent</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体组件类（被装饰者）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteComponent</span> : <span class="keyword">public</span> AbstractComponent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;component&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象装饰类</span></span><br><span class="line"><span class="comment">// 抽象装饰类 继承 抽象组件类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractDecorator</span> : <span class="keyword">public</span> AbstractComponent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 注意浅拷贝和深拷贝问题：相同组件不同组件，需要浅拷贝</span></span><br><span class="line">    <span class="built_in">AbstractDecorator</span>(AbstractComponent *abstract_component) : <span class="built_in">abstract_component</span>(abstract_component) &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AbstractDecorator</span>() <span class="keyword">override</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;abstract_component;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象装饰类 重写 抽象组件类的方法</span></span><br><span class="line">    <span class="comment">// 形式上 调用 装饰类的方法</span></span><br><span class="line">    <span class="comment">// 实际上 调用 抽象组件指针/具体组件对象的方法（原本内容） + 装饰类的额外内容（装饰内容）（重点理解）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;abstract_component != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;abstract_component-&gt;<span class="built_in">func</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 抽象装饰类 封装 抽象组件指针（实际上会指向一个具体组件对象）（装饰者包装被装饰者）</span></span><br><span class="line">    AbstractComponent *abstract_component;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体装饰 A 类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteDecoratorA</span> : <span class="keyword">public</span> AbstractDecorator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteDecoratorA</span>(AbstractComponent *abstract_component) : <span class="built_in">AbstractDecorator</span>(abstract_component) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体装饰类 重写 抽象组件类的方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> <span class="comment">// 形式上 调用 装饰类的方法</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        AbstractDecorator::<span class="built_in">func</span>();            <span class="comment">// 实际上 调用 抽象组件指针/具体组件对象的方法（原本内容）</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ConcreteDecoratorA&quot;</span> &lt;&lt; endl; <span class="comment">// + 装饰类的额外内容（装饰内容）（重点理解）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体装饰 B 类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteDecoratorB</span> : <span class="keyword">public</span> AbstractDecorator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteDecoratorB</span>(AbstractComponent *abstract_component) : <span class="built_in">AbstractDecorator</span>(abstract_component) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体装饰类 重写 抽象组件类的方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> <span class="comment">// 形式上 调用 装饰类的方法</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        AbstractDecorator::<span class="built_in">func</span>();            <span class="comment">// 实际上 调用 抽象组件指针/具体组件对象的方法（原本内容）</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ConcreteDecoratorB&quot;</span> &lt;&lt; endl; <span class="comment">// + 装饰类的额外内容（装饰内容）（重点理解）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 注意同一组件不同装饰的重复析构问题</span></span><br><span class="line">    <span class="comment">// AbstractComponent *abstract_component = new ConcreteComponent(); // 抽象组件指针/具体组件对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// // 抽象组件指针/具体装饰 A 对象装饰组件</span></span><br><span class="line">    <span class="comment">// AbstractComponent *concrete_decorator_A = new ConcreteDecoratorA(abstract_component);</span></span><br><span class="line">    <span class="comment">// concrete_decorator_A-&gt;func(); // 形式上 调用 装饰类的方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// AbstractComponent *concrete_decorator_B = new ConcreteDecoratorB(abstract_component);</span></span><br><span class="line">    <span class="comment">// concrete_decorator_B-&gt;func();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// delete concrete_decorator_B; // 第一次 delete abstract_component</span></span><br><span class="line">    <span class="comment">// delete concrete_decorator_A; // 第二次 delete abstract_component</span></span><br><span class="line">    <span class="comment">// delete abstract_component;   // 第三次 delete abstract_component</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解决1：使用智能指针，shared_ptr&lt;&gt;</span></span><br><span class="line">    <span class="comment">// 解决2：手动实现引用计数机制</span></span><br><span class="line">    <span class="comment">// 解决3：程序结束自动释放全部</span></span><br><span class="line">    <span class="comment">// 解决4：使用相同组件的不同副本</span></span><br><span class="line">    <span class="comment">// 解决5：使用不同组件</span></span><br><span class="line">    <span class="comment">// 解决n...</span></span><br><span class="line">    <span class="comment">// 使用解决5</span></span><br><span class="line">    AbstractComponent *abstract_component_a = <span class="keyword">new</span> <span class="built_in">ConcreteComponent</span>(); <span class="comment">// 抽象组件指针/具体组件对象</span></span><br><span class="line">    <span class="comment">// 抽象组件指针/具体装饰 A 对象装饰组件</span></span><br><span class="line">    AbstractComponent *concrete_decorator_A = <span class="keyword">new</span> <span class="built_in">ConcreteDecoratorA</span>(abstract_component_a);</span><br><span class="line">    concrete_decorator_A-&gt;<span class="built_in">func</span>(); <span class="comment">// 形式上 调用 装饰类的方法</span></span><br><span class="line">    <span class="keyword">delete</span> concrete_decorator_A;  <span class="comment">// 第一次 delete abstract_component</span></span><br><span class="line">    <span class="comment">// delete abstract_component_a;  // 第二次 delete abstract_component</span></span><br><span class="line"></span><br><span class="line">    AbstractComponent *abstract_component_b = <span class="keyword">new</span> <span class="built_in">ConcreteComponent</span>();</span><br><span class="line">    AbstractComponent *concrete_decorator_B = <span class="keyword">new</span> <span class="built_in">ConcreteDecoratorB</span>(abstract_component_b);</span><br><span class="line">    concrete_decorator_B-&gt;<span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">delete</span> concrete_decorator_B;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="组合模式（Composite）"><a href="#组合模式（Composite）" class="headerlink" title="组合模式（Composite）"></a>组合模式（Composite）</h1><p>结构</p><ul><li>组件类</li><li>树叶类（树的叶节点）</li><li>树枝类（树的非叶节点）</li><li></li><li>树叶类 继承 组件类，重写 虚方法</li><li>树枝类 继承 组件类，封装 组件类的集合（实际上包含零个或多个树叶对象或树枝对象），重写 虚方法</li><li>客户端 以相同的方式处理&#x2F;一致地使用 简单和复杂元素&#x2F;单个和组合对象</li></ul><p>类型</p><ul><li>透明方式：组件类有管理子对象的方法（添加组件方法和删除组件方法等），树枝类和叶子类的行为一致；但叶子类继承和实现该些方法没有意义，违反接口隔离原则（ISP）</li><li>安全方式：组件类没有管理子对象的方法，树枝类有管理子对象的方法</li></ul><p>代码（安全方式）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 安全方式：组件类没有管理子对象的方法，树枝类有管理子对象的方法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Component</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Component</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 树叶类（树的叶节点）</span></span><br><span class="line"><span class="comment">// 树叶类 继承 组件类，重写 虚方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Leaf</span> : <span class="keyword">public</span> Component</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Leaf</span>(<span class="type">int</span> value) : <span class="built_in">value</span>(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Leaf: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;value &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 树枝类（树的非叶节点）</span></span><br><span class="line"><span class="comment">// 树枝类 继承 组件类，封装 组件类的集合（实际上包含零个或多个树叶对象或树枝对象），重写 虚方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Branch</span> : <span class="keyword">public</span> Component</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Branch</span>() : <span class="built_in">component_vec</span>() &#123;&#125; <span class="comment">// vector&lt;&gt; 的 默认构造方法初始化 属性</span></span><br><span class="line">    ~<span class="built_in">Branch</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (Component *component : <span class="keyword">this</span>-&gt;component_vec)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> component;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(Component *component)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;component_vec.<span class="built_in">push_back</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Branch: &quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span> (Component *component : <span class="keyword">this</span>-&gt;component_vec)</span><br><span class="line">        &#123;</span><br><span class="line">            component-&gt;<span class="built_in">func</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;Component *&gt; component_vec;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 树叶</span></span><br><span class="line">    Leaf *leaf_1 = <span class="keyword">new</span> <span class="built_in">Leaf</span>(<span class="number">10</span>);</span><br><span class="line">    Leaf *leaf_2 = <span class="keyword">new</span> <span class="built_in">Leaf</span>(<span class="number">20</span>);</span><br><span class="line">    Leaf *leaf_3 = <span class="keyword">new</span> <span class="built_in">Leaf</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 树枝</span></span><br><span class="line">    Branch *branch_1 = <span class="keyword">new</span> <span class="built_in">Branch</span>();</span><br><span class="line">    branch_1-&gt;<span class="built_in">add</span>(leaf_1);</span><br><span class="line">    branch_1-&gt;<span class="built_in">add</span>(leaf_2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 树枝/根</span></span><br><span class="line">    Branch *branch_2 = <span class="keyword">new</span> <span class="built_in">Branch</span>();</span><br><span class="line">    branch_2-&gt;<span class="built_in">add</span>(leaf_3);</span><br><span class="line">    branch_2-&gt;<span class="built_in">add</span>(branch_1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 客户端 以相同的方式处理/一致地使用 简单和复杂元素/单个和组合对象</span></span><br><span class="line">    leaf_2-&gt;<span class="built_in">func</span>();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    branch_2-&gt;<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> branch_2; <span class="comment">// 会自动递归 delete branch_1、leaf_2、leaf_1 和 leaf_3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Leaf: 20</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Branch:</span></span><br><span class="line"><span class="comment">Leaf: 30</span></span><br><span class="line"><span class="comment">Branch:</span></span><br><span class="line"><span class="comment">Leaf: 10</span></span><br><span class="line"><span class="comment">Leaf: 20</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>外观、装饰和组合模式（结构型设计模式）的 C++ 代码示例模板。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://blog.csdn.net/m0_62083249/article/details/126156063">结构型设计模式总结_结构型设计模式实验总结-CSDN博客</a></li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代理和适配器模式（结构型设计模式）的 C++ 代码示例模板</title>
      <link href="/2023/12/19/%E4%BB%A3%E7%90%86%E5%92%8C%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%88%E7%BB%93%E6%9E%84%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%89%E7%9A%84%20C++%20%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E6%A8%A1%E6%9D%BF/"/>
      <url>/2023/12/19/%E4%BB%A3%E7%90%86%E5%92%8C%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%88%E7%BB%93%E6%9E%84%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%89%E7%9A%84%20C++%20%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>代理和适配器模式（结构型设计模式）的 C++ 代码示例模板。</p><hr><h1 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h1><ul><li><a href="https://github.com/yezhening/Programming-examples">yezhening&#x2F;Programming-examples: 编程实例 (github.com)</a></li><li><a href="https://gitee.com/yezhening/Programming-examples">Programming-examples: 编程实例 (gitee.com)</a></li></ul><hr><h1 id="代理模式（Proxy）"><a href="#代理模式（Proxy）" class="headerlink" title="代理模式（Proxy）"></a>代理模式（Proxy）</h1><p>结构</p><ul><li>抽象服务类</li><li>具体服务类（被代理者）</li><li>代理类（代理者）</li><li></li><li>代理类 继承（多态） 抽象服务类，和具体服务类有相同的对外<strong>方法&#x2F;接口</strong></li><li>代理类 <strong>封装&#x2F;隐藏</strong> 具体服务对象，调用代理对象的方法 func()，实际上是 func() 内部调用具体服务对象的方法</li></ul><p>核心</p><ul><li>封装</li><li>继承</li><li>多态</li><li></li><li>使用代理对象，实际上是使用具体服务对象</li></ul><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象服务类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractService</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体服务类（被代理者）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteService</span> : <span class="keyword">public</span> AbstractService</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;func()&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理类（代理者）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Proxy</span> : <span class="keyword">public</span> AbstractService <span class="comment">// 代理类 继承（多态） 抽象服务类，和具体服务类有相同的对外 方法/接口</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Proxy</span>() : <span class="built_in">concrete_service</span>()&#123;&#125;; <span class="comment">// 具体服务类的默认构造方法 初始化 具体服务对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> <span class="comment">// 代理类 封装/隐藏 具体服务对象，调用代理对象的方法 func()，实际上是 func() 内部调用具体服务对象的方法</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;concrete_service.<span class="built_in">func</span>(); <span class="comment">// 2. 具体服务对象 调用 方法</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ConcreteService concrete_service;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Proxy proxy; <span class="comment">// 代理类的默认构造方法 初始化 代理对象</span></span><br><span class="line"></span><br><span class="line">    proxy.<span class="built_in">func</span>(); <span class="comment">// 1. 代理对象 调用 方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">func()</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h1 id="适配器模式（Adapter）"><a href="#适配器模式（Adapter）" class="headerlink" title="适配器模式（Adapter）"></a>适配器模式（Adapter）</h1><p>类型</p><ul><li>类适配器模式：使用多继承机制： 适配器继承两个类。 只能在支持多继承的编程语言中实现， 如 C++</li><li>对象适配器模式：使用关联关系： 适配器继承一个类， 封装另一个类对象。 大部分支持面向对象编程范式的编程语言可以实现</li></ul><h2 id="类适配器模式"><a href="#类适配器模式" class="headerlink" title="类适配器模式"></a>类适配器模式</h2><p>结构</p><ul><li>被适配类（客户端<strong>期望&#x2F;可以使用&#x2F;形式上使用</strong>的<strong>接口</strong>；适配者）</li><li>目标类（客户端<strong>不兼容&#x2F;无法使用&#x2F;实际上使用</strong>的接口；被适配者）</li><li>适配器类（中间者）</li><li></li><li>适配器类 <strong>多继承</strong> 被适配类和目标类</li><li>适配器类 私有继承（封装）被适配类</li><li></li><li>适配器类中 形式上使用的接口 调用 实际上使用的接口（适配过程）</li><li>客户端<strong>可以只知道</strong>目标类和适配器类，不知道被适配类</li></ul><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被适配类（客户端 不兼容/无法使用/实际上使用 的接口；被适配者）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adaptee</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">adaptee_func</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;adaptee_func()&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标类（客户端 期望/可以使用/形式上使用 的 接口；适配者）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Target</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">target_func</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 适配器类（中间者）</span></span><br><span class="line"><span class="comment">// 适配器类 多继承 被适配类和目标类;</span></span><br><span class="line"><span class="comment">// 适配器类 私有继承（封装） 被适配类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adapter</span> : <span class="keyword">public</span> Target, <span class="keyword">private</span> Adaptee</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 适配器类中 形式上使用的接口 调用 实际上使用的接口（适配过程）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">target_func</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> <span class="comment">// 形式上使用的接口</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Adaptee::<span class="built_in">adaptee_func</span>(); <span class="comment">// 实际上使用的接口</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 客户端 可以只知道 目标类和适配器类，不知道被适配类</span></span><br><span class="line">    Target *target = <span class="keyword">new</span> <span class="built_in">Adapter</span>();</span><br><span class="line">    target-&gt;<span class="built_in">target_func</span>(); <span class="comment">// 形式上使用的接口</span></span><br><span class="line">    <span class="keyword">delete</span> target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">adaptee_func()</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h2 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h2><p>结构</p><ul><li>被适配类（客户端<strong>期望&#x2F;可以使用&#x2F;形式上使用</strong>的<strong>接口</strong>；适配者）</li><li>目标类（客户端<strong>不兼容&#x2F;无法使用&#x2F;实际上使用</strong>的接口；被适配者）</li><li>适配器类（中间者）</li><li></li><li>适配器类 继承 目标类</li><li>适配器类 <strong>封装</strong> 被适配类对象</li><li></li><li>适配器类中 形式上使用的接口 调用 实际上使用的接口（适配过程）</li><li>客户端<strong>可以只知道</strong>目标类和适配器类，不知道被适配类</li></ul><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被适配类（客户端 期望/可以使用/形式上使用 的 接口；适配者）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adaptee</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">adaptee_func</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;adaptee_func()&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标类（客户端 期望/可以使用/形式上使用 的 接口；适配者）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Target</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">target_func</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 适配器类（中间者）</span></span><br><span class="line"><span class="comment">// 适配器类 继承 目标类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adapter</span> : <span class="keyword">public</span> Target</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Adapter</span>() : <span class="built_in">adaptee</span>() &#123;&#125; <span class="comment">// 被适配类的 默认构造方法初始化 被适配类对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 适配器类中 形式上使用的接口 调用 实际上使用的接口（适配过程）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">target_func</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> <span class="comment">// 形式上使用的接口</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        adaptee.<span class="built_in">adaptee_func</span>(); <span class="comment">// 实际上使用的接口</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Adaptee adaptee; <span class="comment">// 适配器类 封装 被适配类对象</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 客户端 可以只知道 目标类和适配器类，不知道被适配类</span></span><br><span class="line">    Target *target = <span class="keyword">new</span> <span class="built_in">Adapter</span>(); <span class="comment">// 适配器类的 默认构造方法初始化 适配器类对象</span></span><br><span class="line">    target-&gt;<span class="built_in">target_func</span>();          <span class="comment">// 形式上使用的接口</span></span><br><span class="line">    <span class="keyword">delete</span> target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">adaptee_func()</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>代理和适配器模式（结构型设计模式）的 C++ 代码示例模板。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://blog.csdn.net/m0_62083249/article/details/126156063">结构型设计模式总结_结构型设计模式实验总结-CSDN博客</a></li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式（创建型设计模式）的 C++ 代码示例模板</title>
      <link href="/2023/11/21/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%89%E7%9A%84%20C++%20%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E6%A8%A1%E6%9D%BF/"/>
      <url>/2023/11/21/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%89%E7%9A%84%20C++%20%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>单例模式（创建型设计模式）的 C++ 代码示例模板。</p><hr><h1 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h1><ul><li><a href="https://github.com/yezhening/Programming-examples">yezhening&#x2F;Programming-examples: 编程实例 (github.com)</a></li><li><a href="https://gitee.com/yezhening/Programming-examples">Programming-examples: 编程实例 (gitee.com)</a></li></ul><hr><h1 id="单例模式（Singleton）"><a href="#单例模式（Singleton）" class="headerlink" title="单例模式（Singleton）"></a>单例模式（Singleton）</h1><p>结构</p><ul><li>单例类</li><li></li><li>私有静态单例对象</li><li>私有构造方法 </li><li>公有静态获取单例对象方法</li></ul><blockquote><p>返回引用的原因：保证是同一单例对象而不是副本；减少返回值的拷贝开销；返回值拷贝被删除</p></blockquote><ul><li><strong>私有或删除</strong>拷贝构造方法和拷贝赋值运算符</li></ul><blockquote><p>设置为私有：允许类内将单例对象作为参数或返回值传递（公有静态获取单例对象方法 可以返回值而不是引用）<br>设置为删除：禁止拷贝<br>设置为私有和删除：禁止拷贝</p></blockquote><p>核心</p><ul><li>私有静态单例对象：单例类内保存<strong>同一</strong>单例对象</li><li>私有构造方法：禁止客户端创建<strong>多个</strong>单例对象</li><li>公有静态获取单例对象方法：允许客户端<strong>创建或获取同一</strong>单例对象</li></ul><blockquote><p>一般 饿汉式是获取，懒汉式是创建或获取。</p></blockquote><ul><li>私有或删除拷贝构造方法和拷贝赋值运算符：禁止客户端<strong>或单例类内</strong>创建<strong>一个或多个</strong>拷贝单例对象</li></ul><p>类型</p><ul><li>饿汉式</li><li>懒汉式</li></ul><hr><h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><ul><li><strong>程序启动时（main() 执行前）</strong> 创建单例对象（不管用不用都提前创建）</li><li><strong>在类外初始化私有静态单例对象</strong>（保证在程序启动时（main() 执行前）创建单例对象）</li></ul><blockquote><p>在类外初始化私有静态单例对象 注意：<br>静态非 const 整数类型（short 和 int 等） 或 静态非 constexpr 内置类型（char 和 float 等）的成员属性 只能在类外初始化；<br>因为构造方法是私有权限，所以在类外只能是隐式调用无参构造方法；<br>如果单例类需要传参并初始化成员属性，可以考虑额外 定义设置成员属性方法 或 在公有静态获取单例对象方法中设置成员属性</p></blockquote><ul><li>线程安全</li><li><strong>公有静态获取单例对象方法直接返回单例对象</strong>（因为在程序启动时（main() 执行前）已经创建单例对象，且线程安全，无需其他逻辑）</li><li><strong>创建或获取单例对象时使用引用</strong></li></ul><blockquote><p>使用引用的原因：保证是同一单例对象而不是副本；减少返回值的拷贝开销；返回值拷贝被删除</p></blockquote><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 饿汉式：程序启动时（main() 执行前） 创建单例对象（不管用不用都提前创建）</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单例类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公有静态获取单例对象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">static</span> Singleton &amp;<span class="title">getInstance</span><span class="params">()</span> <span class="comment">// 返回引用的原因：保证是同一单例对象而不是副本；减少返回值的拷贝开销；返回值拷贝被删除</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton; <span class="comment">// 直接返回单例对象：因为在程序启动时（main() 执行前）已经创建单例对象，且线程安全，无需其他逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有构造方法</span></span><br><span class="line">    <span class="built_in">Singleton</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Singleton()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有或删除拷贝构造方法和拷贝赋值运算符</span></span><br><span class="line">    <span class="comment">// 设置为私有：允许类内将单例对象作为参数或返回值传递（公有静态获取单例对象方法 可以返回值而不是引用）</span></span><br><span class="line">    <span class="comment">// 设置为删除：禁止拷贝</span></span><br><span class="line">    <span class="comment">// 设置为私有和删除：禁止拷贝</span></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有静态单例对象</span></span><br><span class="line">    <span class="type">static</span> Singleton singleton;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在类外初始化私有静态单例对象 注意：</span></span><br><span class="line"><span class="comment">// 静态非 const 整数类型（short 和 int 等） 或 静态非 constexpr 内置类型（char 和 float 等）的成员属性 只能在类外初始化</span></span><br><span class="line"><span class="comment">// 因为构造方法是私有权限，所以在类外只能是隐式调用无参构造方法</span></span><br><span class="line"><span class="comment">// 如果单例类需要传参并初始化成员属性，可以考虑额外 定义设置成员属性方法 或 在公有静态获取单例对象方法中设置成员属性</span></span><br><span class="line">Singleton Singleton::singleton; <span class="comment">// 隐式调用无参构造方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建或获取单例对象</span></span><br><span class="line">    Singleton &amp;singleton_1 = Singleton::<span class="built_in">getInstance</span>(); <span class="comment">// 使用引用的原因：保证是同一单例对象而不是副本；减少返回值的拷贝开销；返回值拷贝被删除</span></span><br><span class="line">    Singleton &amp;singleton_2 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出单例对象地址：地址相同，说明是同一单例对象</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Singleton_1: &quot;</span> &lt;&lt; &amp;singleton_1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Singleton_2: &quot;</span> &lt;&lt; &amp;singleton_2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">Singleton()</span></span><br><span class="line"><span class="comment">Singleton_1: 0x407030</span></span><br><span class="line"><span class="comment">Singleton_2: 0x407030</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><ul><li><strong>程序运行时</strong>创建单例类对象（需要用了才创建）</li><li>在类外初始化私有静态单例对象 和 私有静态互斥锁（保证在程序运行时创建单例类对象）</li></ul><blockquote><p>在类外初始化私有静态单例对象 和 互斥锁 注意：<br>静态非 const 整数类型（short 和 int 等） 或 静态非 constexpr 内置类型（char 和 float 等）的成员属性 只能在类外初始化；<br>因为构造方法是私有权限，所以在类外只能是隐式调用无参构造方法；<br>如果单例类需要传参并初始化成员属性，可以考虑额外 定义设置成员属性方法 或 在公有静态获取单例对象方法中设置成员属性</p></blockquote><ul><li><strong>线程不安全</strong>（如多个线程同时调用公有静态获取单例对象方法）</li><li><strong>公有静态获取单例对象方法使用 私有静态互斥锁 和 双重检查锁定</strong>（保证线程安全）</li><li>创建或获取单例对象时使用引用</li></ul><blockquote><p>使用引用的原因：保证是同一单例对象而不是副本；减少返回值的拷贝开销；返回值拷贝被禁止</p></blockquote><p>代码（懒汉式）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 懒汉式：程序运行时创建单例类对象（需要用了才创建）</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::lock_guard;</span><br><span class="line"><span class="keyword">using</span> std::make_unique;</span><br><span class="line"><span class="keyword">using</span> std::mutex;</span><br><span class="line"><span class="keyword">using</span> std::unique_ptr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单例类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公有静态获取单例对象方法</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton &amp;<span class="title">getsingleton</span><span class="params">()</span> <span class="comment">// 返回引用的原因：保证是同一单例对象而不是副本；减少返回值的拷贝开销；返回值拷贝被删除</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 线程不安全（如多个线程同时调用公有静态获取单例对象方法）</span></span><br><span class="line">        <span class="comment">// 使用 私有静态互斥锁 和 双重检查锁定（保证线程安全）</span></span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">nullptr</span>) <span class="comment">// 第一重检查锁定</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">lock_guard&lt;mutex&gt; <span class="title">mutex_lock_guard</span><span class="params">(mutex_lock)</span></span>; <span class="comment">// 上锁</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (singleton == <span class="literal">nullptr</span>) <span class="comment">// 第二重检查锁定</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// make_unique&lt;&gt; 是非成员函数模板，不是类的成员，即使在类内也不能访问类内私有成员，需要声明为友元</span></span><br><span class="line">                singleton = <span class="built_in">make_unique</span>&lt;Singleton&gt;();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 隐式解锁</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有构造方法</span></span><br><span class="line">    <span class="built_in">Singleton</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Singleton()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有或删除拷贝构造方法和拷贝赋值运算符</span></span><br><span class="line">    <span class="comment">// 设置为私有：允许类内将单例对象作为参数或返回值传递（公有静态获取单例对象方法 可以返回值而不是引用）</span></span><br><span class="line">    <span class="comment">// 设置为删除：禁止拷贝</span></span><br><span class="line">    <span class="comment">// 设置为私有和删除：禁止拷贝</span></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有静态单例对象</span></span><br><span class="line">    <span class="type">static</span> unique_ptr&lt;Singleton&gt; singleton;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有静态互斥锁</span></span><br><span class="line">    <span class="type">static</span> mutex mutex_lock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明 make_unique&lt;&gt; 为友元</span></span><br><span class="line">    <span class="keyword">friend</span> unique_ptr&lt;Singleton&gt; <span class="built_in">make_unique</span>&lt;Singleton&gt;();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在类外初始化私有静态单例对象为空 和 私有静态互斥锁 注意：</span></span><br><span class="line"><span class="comment">// 静态非 const 整数类型（short 和 int 等） 或 静态非 constexpr 内置类型（char 和 float 等）的成员属性 只能在类外初始化</span></span><br><span class="line"><span class="comment">// 因为构造方法是私有权限，所以在类外只能是隐式调用无参构造方法</span></span><br><span class="line"><span class="comment">// 如果单例类需要传参并初始化成员属性，可以考虑额外 定义设置成员属性方法 或 在公有静态获取单例对象方法中设置成员属性</span></span><br><span class="line">unique_ptr&lt;Singleton&gt; Singleton::singleton = <span class="literal">nullptr</span>;</span><br><span class="line">mutex Singleton::mutex_lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建或获取单例对象</span></span><br><span class="line">    Singleton &amp;singleton_1 = Singleton::<span class="built_in">getsingleton</span>(); <span class="comment">// 使用引用的原因：保证是同一单例对象而不是副本；减少返回值的拷贝开销；返回值拷贝被禁止</span></span><br><span class="line">    Singleton &amp;singleton_2 = Singleton::<span class="built_in">getsingleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出单例对象地址：地址相同，说明是同一单例对象</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Singleton_1: &quot;</span> &lt;&lt; &amp;singleton_1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Singleton_2: &quot;</span> &lt;&lt; &amp;singleton_2 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">Singleton()</span></span><br><span class="line"><span class="comment">Singleton_1: 0x25624e0</span></span><br><span class="line"><span class="comment">Singleton_2: 0x25624e0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>单例模式（创建型设计模式）的 C++ 代码示例模板。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://blog.csdn.net/m0_62083249/article/details/126052943">【精选】创建型设计模式总结_夜悊的博客-CSDN博客</a></li><li><a href="https://www.bilibili.com/video/BV1ot411f7Q1/?p=21&vd_source=9ac1c0a6d496218112b60d49bc768cd7">21-设计模式（单例模式）_哔哩哔哩_bilibili</a></li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型和建造者模式（创建型设计模式）的 C++ 代码示例模板</title>
      <link href="/2023/11/20/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%89%E7%9A%84%20C++%20%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E6%A8%A1%E6%9D%BF/"/>
      <url>/2023/11/20/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%89%E7%9A%84%20C++%20%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>原型和建造者模式（创建型设计模式）的 C++ 代码示例模板。</p><hr><h1 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h1><ul><li><a href="https://github.com/yezhening/Programming-examples">yezhening&#x2F;Programming-examples: 编程实例 (github.com)</a></li><li><a href="https://gitee.com/yezhening/Programming-examples">Programming-examples: 编程实例 (gitee.com)</a></li></ul><hr><h1 id="原型模式（Prototype）"><a href="#原型模式（Prototype）" class="headerlink" title="原型模式（Prototype）"></a>原型模式（Prototype）</h1><p>结构</p><ul><li>抽象原型类</li><li>具体原型类</li><li></li><li>具体原型对象的克隆方法通过拷贝构造函数创建<strong>当前</strong>对象的副本</li></ul><p>核心</p><ul><li>继承</li><li>多态</li><li>拷贝构造函数注意浅拷贝和深拷贝问题</li><li>克隆方法通过拷贝构造函数创建副本</li></ul><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::make_unique;</span><br><span class="line"><span class="keyword">using</span> std::unique_ptr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象原型类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractPrototype</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AbstractPrototype</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AbstractPrototype</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">inline</span> unique_ptr&lt;AbstractPrototype&gt; <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>; <span class="comment">// 克隆方法</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体原型类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcretePrototype</span> : <span class="keyword">public</span> AbstractPrototype</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcretePrototype</span>(<span class="type">int</span> data) : <span class="built_in">data</span>(<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(data)) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">ConcretePrototype</span>() <span class="keyword">override</span> = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="comment">// 注意浅拷贝和深拷贝问题</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非指针属性：不存在浅拷贝和深拷贝问题</span></span><br><span class="line">    <span class="comment">// 静态内存分配/栈区的指针属性：不存在浅拷贝和深拷贝问题</span></span><br><span class="line">    <span class="comment">// 动态内存分配/堆区的指针属性：存在浅拷贝和深拷贝问题，不应使用浅拷贝，应使用深拷贝</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 浅拷贝：复制值</span></span><br><span class="line">    <span class="comment">// 深拷贝：创建新对象再复制值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// unique_ptr&lt;&gt; 可以移动，不可以（浅）拷贝</span></span><br><span class="line">    <span class="comment">// shared_ptr&lt;&gt; 可以（浅/深）拷贝</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ConcretePrototype(const ConcretePrototype &amp;other) : data(other.data) // 浅拷贝</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; &quot;Shallow copy&quot; &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="built_in">ConcretePrototype</span>(<span class="type">const</span> ConcretePrototype &amp;other) : <span class="built_in">data</span>(<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(*(other.data))) <span class="comment">// 深拷贝</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Deep copy&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 克隆方法创建当前具体原型对象的副本</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> unique_ptr&lt;AbstractPrototype&gt; <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">make_unique</span>&lt;ConcretePrototype&gt;(*<span class="keyword">this</span>); <span class="comment">// 调用拷贝构造函数（类比：ConcretePrototype clone(*this)）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ConcretePrototype: &quot;</span> &lt;&lt; *<span class="keyword">this</span>-&gt;data &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>&gt; data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建具体原型对象</span></span><br><span class="line">    unique_ptr&lt;ConcretePrototype&gt; original = <span class="built_in">make_unique</span>&lt;ConcretePrototype&gt;(<span class="number">10</span>);</span><br><span class="line">    original-&gt;<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 克隆具体原型对象</span></span><br><span class="line">    unique_ptr&lt;AbstractPrototype&gt; clone = original-&gt;<span class="built_in">clone</span>();</span><br><span class="line">    clone-&gt;<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">ConcretePrototype: 10</span></span><br><span class="line"><span class="comment">Deep copy</span></span><br><span class="line"><span class="comment">ConcretePrototype: 10</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h1 id="建造者模式（Builder）"><a href="#建造者模式（Builder）" class="headerlink" title="建造者模式（Builder）"></a>建造者模式（Builder）</h1><p>结构</p><ul><li>产品类</li><li></li><li>抽象建造者类</li><li>具体建造者类</li><li></li><li>指挥者类</li><li></li><li>创建具体建造者对象（建造准备1）</li><li>创建具体建造者对象时，创建产品对象（建造准备2）</li><li>使用具体建造者对象，创建指挥者对象（建造准备3）</li><li></li><li>指挥者对象调用建造方法（建造过程1）</li><li>建造方法中，具体建造者对象调用建造产品方法（建造过程2）</li><li>建造产品方法中，产品对象调用相关方法（建造过程3）</li><li></li><li>具体建造者对象调用获取产品方法（获取结果）</li><li></li><li>产品对象调用展示方法（展示结果）</li></ul><p>核心</p><ul><li>继承</li><li>多态</li><li>产品，表现需要建造的内容（如建造桌子，需要建造桌面，需要建造桌腿）</li><li>建造者 建造 产品，实现建造过程的内容（如建造桌子，建造桌面是光滑的，建造桌腿是稳固的）</li><li>指挥者 指挥 建造者，控制建造过程的时序（如建造桌子，先建造桌面，后建造桌腿）</li></ul><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::make_shared;</span><br><span class="line"><span class="keyword">using</span> std::shared_ptr;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 产品类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Product</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">Product</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_part_a</span><span class="params">(<span class="type">const</span> string &amp;part_a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;part_a = part_a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_part_b</span><span class="params">(<span class="type">const</span> string &amp;part_b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;part_b = part_b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Product parts: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;part_a &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;part_b &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string part_a;</span><br><span class="line">    string part_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象建造者类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractBuilder</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AbstractBuilder</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AbstractBuilder</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">build_part_a</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 建造产品方法</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">build_part_b</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Product <span class="title">get_product</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 获取产品方法</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体建造者类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteBuilder</span> : <span class="keyword">public</span> AbstractBuilder</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteBuilder</span>() : <span class="built_in">product</span>() &#123;&#125; <span class="comment">// 使用默认构造函数创建产品对象</span></span><br><span class="line">    ~<span class="built_in">ConcreteBuilder</span>() <span class="keyword">override</span> = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build_part_a</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;product.<span class="built_in">set_part_a</span>(<span class="string">&quot;Part A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build_part_b</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;product.<span class="built_in">set_part_b</span>(<span class="string">&quot;Part B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> Product <span class="title">get_product</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;product;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Product product;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指挥者类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Director</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Director</span>(shared_ptr&lt;AbstractBuilder&gt; abstract_builder) : <span class="built_in">abstract_builder</span>(abstract_builder)&#123;&#125;;</span><br><span class="line">    ~<span class="built_in">Director</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> <span class="comment">// 建造方法</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        abstract_builder-&gt;<span class="built_in">build_part_a</span>();</span><br><span class="line">        abstract_builder-&gt;<span class="built_in">build_part_b</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    shared_ptr&lt;AbstractBuilder&gt; abstract_builder;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建具体建造者对象</span></span><br><span class="line">    shared_ptr&lt;AbstractBuilder&gt; concrete_builder = <span class="built_in">make_shared</span>&lt;ConcreteBuilder&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建指挥者对象</span></span><br><span class="line">    <span class="function">Director <span class="title">director</span><span class="params">(concrete_builder)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建造过程</span></span><br><span class="line">    director.<span class="built_in">build</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取产品</span></span><br><span class="line">    Product product = concrete_builder-&gt;<span class="built_in">get_product</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 展示产品</span></span><br><span class="line">    product.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">Product parts: Part A, Part B</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>原型模式和建造者模式（创建型设计模式）的 C++ 代码示例模板。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://blog.csdn.net/m0_62083249/article/details/126052943">【精选】创建型设计模式总结_夜悊的博客-CSDN博客</a></li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单工厂、工厂方法和抽象工厂模式（创建型设计模式）的 C++ 代码示例模板</title>
      <link href="/2023/11/19/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E3%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E5%92%8C%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%89%E7%9A%84%20C++%20%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E6%A8%A1%E6%9D%BF/"/>
      <url>/2023/11/19/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E3%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E5%92%8C%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%89%E7%9A%84%20C++%20%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>简单工厂、工厂方法和抽象工厂模式（创建型设计模式）的 C++ 代码示例模板。</p><hr><h1 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h1><ul><li><a href="https://github.com/yezhening/Programming-examples">yezhening&#x2F;Programming-examples: 编程实例 (github.com)</a></li><li><a href="https://gitee.com/yezhening/Programming-examples">Programming-examples: 编程实例 (gitee.com)</a></li></ul><hr><h1 id="简单工厂模式（Simple-Factory）"><a href="#简单工厂模式（Simple-Factory）" class="headerlink" title="简单工厂模式（Simple Factory）"></a>简单工厂模式（Simple Factory）</h1><p>结构</p><ul><li>抽象产品类</li><li>具体产品类 A</li><li>具体产品类 B</li><li></li><li>简单工厂类</li><li></li><li>简单工厂类的静态方法创建具体产品对象 A 和具体产品对象 B</li></ul><p>核心</p><ul><li>继承</li><li>多态</li><li>一个工厂创建多类产品</li></ul><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cerr;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::make_unique;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::unique_ptr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象产品类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractProduct</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AbstractProduct</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AbstractProduct</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品类 A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductA</span> : <span class="keyword">public</span> AbstractProduct</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteProductA</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">ConcreteProductA</span>() <span class="keyword">override</span> = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ConcreteProductA&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品类 B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductB</span> : <span class="keyword">public</span> AbstractProduct</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteProductB</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">ConcreteProductB</span>() <span class="keyword">override</span> = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ConcreteProductB&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleFactory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 静态方法依据类型创建不同的具体产品</span></span><br><span class="line">    <span class="function"><span class="type">static</span> unique_ptr&lt;AbstractProduct&gt; <span class="title">create_concrete_product</span><span class="params">(<span class="type">const</span> string &amp;concrete_product_type)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (concrete_product_type == <span class="string">&quot;A&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">make_unique</span>&lt;ConcreteProductA&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (concrete_product_type == <span class="string">&quot;B&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">make_unique</span>&lt;ConcreteProductB&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cerr &lt;&lt; <span class="string">&quot;Unknown type of concrete product&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用简单工厂创建不同类型的具体产品</span></span><br><span class="line">    unique_ptr&lt;AbstractProduct&gt; concrete_product_a = SimpleFactory::<span class="built_in">create_concrete_product</span>(<span class="string">&quot;A&quot;</span>); <span class="comment">// 创建具体产品对象 A</span></span><br><span class="line">    <span class="keyword">if</span> (concrete_product_a != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        concrete_product_a-&gt;<span class="built_in">func</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unique_ptr&lt;AbstractProduct&gt; concrete_product_b = SimpleFactory::<span class="built_in">create_concrete_product</span>(<span class="string">&quot;B&quot;</span>); <span class="comment">// 创建具体产品对象 B</span></span><br><span class="line">    <span class="keyword">if</span> (concrete_product_b != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        concrete_product_b-&gt;<span class="built_in">func</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unique_ptr&lt;AbstractProduct&gt; concrete_product_c = SimpleFactory::<span class="built_in">create_concrete_product</span>(<span class="string">&quot;C&quot;</span>); <span class="comment">// 创建具体产品对象 C</span></span><br><span class="line">    <span class="keyword">if</span> (concrete_product_c != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        concrete_product_c-&gt;<span class="built_in">func</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">ConcreteProductA</span></span><br><span class="line"><span class="comment">ConcreteProductB</span></span><br><span class="line"><span class="comment">Unknown type of concrete product</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h1 id="工厂方法模式（Factory-Method）"><a href="#工厂方法模式（Factory-Method）" class="headerlink" title="工厂方法模式（Factory Method）"></a>工厂方法模式（Factory Method）</h1><p>结构</p><ul><li>抽象产品类</li><li>具体产品类 A</li><li>具体产品类 B</li><li></li><li>抽象工厂类</li><li>具体工厂类 A</li><li>具体工厂类 B</li><li></li><li>具体工厂对象 A 的方法创建具体产品对象 A</li><li>具体工厂对象 B 的方法创建具体产品对象 B</li></ul><p>核心</p><ul><li>继承</li><li>多态</li><li>一类工厂创建一类产品</li></ul><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::make_unique;</span><br><span class="line"><span class="keyword">using</span> std::unique_ptr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象产品类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractProduct</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AbstractProduct</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AbstractProduct</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品类 A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductA</span> : <span class="keyword">public</span> AbstractProduct</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteProductA</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">ConcreteProductA</span>() <span class="keyword">override</span> = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ConcreteProductA&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品类 B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductB</span> : <span class="keyword">public</span> AbstractProduct</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteProductB</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">ConcreteProductB</span>() <span class="keyword">override</span> = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ConcreteProductB&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractFactory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AbstractFactory</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AbstractFactory</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> unique_ptr&lt;AbstractProduct&gt; <span class="title">create_concrete_product</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂类 A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFactoryA</span> : <span class="keyword">public</span> AbstractFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteFactoryA</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">ConcreteFactoryA</span>() <span class="keyword">override</span> = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> unique_ptr&lt;AbstractProduct&gt; <span class="title">create_concrete_product</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">make_unique</span>&lt;ConcreteProductA&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂类 B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFactoryB</span> : <span class="keyword">public</span> AbstractFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteFactoryB</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">ConcreteFactoryB</span>() <span class="keyword">override</span> = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> unique_ptr&lt;AbstractProduct&gt; <span class="title">create_concrete_product</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">make_unique</span>&lt;ConcreteProductB&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用工厂方法创建不同类型的具体产品</span></span><br><span class="line">    unique_ptr&lt;AbstractFactory&gt; concrete_factory_a = <span class="built_in">make_unique</span>&lt;ConcreteFactoryA&gt;();               <span class="comment">// 创建具体工厂对象 A</span></span><br><span class="line">    unique_ptr&lt;AbstractProduct&gt; concrete_product_a = concrete_factory_a-&gt;<span class="built_in">create_concrete_product</span>(); <span class="comment">// 创建具体产品对象 A</span></span><br><span class="line">    concrete_product_a-&gt;<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    unique_ptr&lt;AbstractFactory&gt; concrete_factory_b = <span class="built_in">make_unique</span>&lt;ConcreteFactoryB&gt;();               <span class="comment">// 创建具体工厂对象 B</span></span><br><span class="line">    unique_ptr&lt;AbstractProduct&gt; concrete_product_b = concrete_factory_b-&gt;<span class="built_in">create_concrete_product</span>(); <span class="comment">// 创建具体产品对象 B</span></span><br><span class="line">    concrete_product_b-&gt;<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">ConcreteProductA</span></span><br><span class="line"><span class="comment">ConcreteProductB</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h1 id="抽象工厂模式（Abstract-Factory）"><a href="#抽象工厂模式（Abstract-Factory）" class="headerlink" title="抽象工厂模式（Abstract Factory）"></a>抽象工厂模式（Abstract Factory）</h1><p>结构</p><ul><li>抽象产品类 A</li><li>具体产品类 A1</li><li>具体产品类 B1</li><li></li><li>抽象产品类 B</li><li>具体产品类 B1</li><li>具体产品类 B2</li><li></li><li>抽象工厂类1</li><li>具体工厂类1</li><li></li><li>抽象工厂类2</li><li>具体工厂类2</li><li></li><li>具体工厂对象1 的方法创建具体产品对象 A1 和 具体产品对象 B1</li><li>具体工厂对象2 的方法创建具体产品对象 A2 和 具体产品对象 B2</li></ul><p>核心</p><ul><li>继承</li><li>多态</li><li>产品和工厂形成二维结构：工厂1创建产品 A1 和 B1，工厂2创建产品 A2 和 B2</li></ul><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::make_unique;</span><br><span class="line"><span class="keyword">using</span> std::unique_ptr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象产品类 A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractProductA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AbstractProductA</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AbstractProductA</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品类 A1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductA1</span> : <span class="keyword">public</span> AbstractProductA</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteProductA1</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">ConcreteProductA1</span>() <span class="keyword">override</span> = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ConcreteProductA1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品类 A2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductA2</span> : <span class="keyword">public</span> AbstractProductA</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteProductA2</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">ConcreteProductA2</span>() <span class="keyword">override</span> = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ConcreteProductA2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象产品类 B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractProductB</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AbstractProductB</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AbstractProductB</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品类 B1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductB1</span> : <span class="keyword">public</span> AbstractProductB</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteProductB1</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">ConcreteProductB1</span>() <span class="keyword">override</span> = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ConcreteProductB1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品类 B2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductB2</span> : <span class="keyword">public</span> AbstractProductB</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteProductB2</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">ConcreteProductB2</span>() <span class="keyword">override</span> = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ConcreteProductB2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractFactory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AbstractFactory</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AbstractFactory</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> unique_ptr&lt;AbstractProductA&gt; <span class="title">create_product_a</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> unique_ptr&lt;AbstractProductB&gt; <span class="title">create_product_b</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂类 1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFactory1</span> : <span class="keyword">public</span> AbstractFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteFactory1</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ConcreteFactory1</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> unique_ptr&lt;AbstractProductA&gt; <span class="title">create_product_a</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">make_unique</span>&lt;ConcreteProductA1&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> unique_ptr&lt;AbstractProductB&gt; <span class="title">create_product_b</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">make_unique</span>&lt;ConcreteProductB1&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂类 2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFactory2</span> : <span class="keyword">public</span> AbstractFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteFactory2</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ConcreteFactory2</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> unique_ptr&lt;AbstractProductA&gt; <span class="title">create_product_a</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">make_unique</span>&lt;ConcreteProductA2&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> unique_ptr&lt;AbstractProductB&gt; <span class="title">create_product_b</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">make_unique</span>&lt;ConcreteProductB2&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用抽象工厂创建不同类型的具体产品</span></span><br><span class="line">    unique_ptr&lt;AbstractFactory&gt; concrete_factory_1 = <span class="built_in">make_unique</span>&lt;ConcreteFactory1&gt;();          <span class="comment">// 创建具体工厂对象1</span></span><br><span class="line">    unique_ptr&lt;AbstractProductA&gt; concrete_product_a1 = concrete_factory_1-&gt;<span class="built_in">create_product_a</span>(); <span class="comment">// 创建具体产品对象 A1</span></span><br><span class="line">    unique_ptr&lt;AbstractProductB&gt; concrete_product_b1 = concrete_factory_1-&gt;<span class="built_in">create_product_b</span>(); <span class="comment">// 创建具体产品对象 B1</span></span><br><span class="line">    concrete_product_a1-&gt;<span class="built_in">func</span>();</span><br><span class="line">    concrete_product_b1-&gt;<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    unique_ptr&lt;AbstractFactory&gt; concrete_factory_2 = <span class="built_in">make_unique</span>&lt;ConcreteFactory2&gt;();          <span class="comment">// 创建具体工厂2</span></span><br><span class="line">    unique_ptr&lt;AbstractProductA&gt; concrete_product_a2 = concrete_factory_2-&gt;<span class="built_in">create_product_a</span>(); <span class="comment">// 创建具体产品对象 B1</span></span><br><span class="line">    unique_ptr&lt;AbstractProductB&gt; concrete_product_b2 = concrete_factory_2-&gt;<span class="built_in">create_product_b</span>(); <span class="comment">// 创建具体产品对象 B1</span></span><br><span class="line">    concrete_product_a2-&gt;<span class="built_in">func</span>();</span><br><span class="line">    concrete_product_b2-&gt;<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">ConcreteProductA1</span></span><br><span class="line"><span class="comment">ConcreteProductB1</span></span><br><span class="line"><span class="comment">ConcreteProductA2</span></span><br><span class="line"><span class="comment">ConcreteProductB2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>简单工厂、工厂方法和抽象工厂模式（创建型设计模式）的 C++ 代码示例模板。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://blog.csdn.net/m0_62083249/article/details/126052943">【精选】创建型设计模式总结_夜悊的博客-CSDN博客</a></li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C 和 C++ 可变参数介绍</title>
      <link href="/2023/11/08/C%20%E5%92%8C%20C++%20%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E4%BB%8B%E7%BB%8D/"/>
      <url>/2023/11/08/C%20%E5%92%8C%20C++%20%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>C 和 C++ 可变参数介绍。</p><hr><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>可变（长）&#x2F;不定（长）参数：<strong>函数</strong>可以接收任意数量的参数（函数在声名和定义时不明确参数的数量）</p><hr><h1 id="C-的可变参数"><a href="#C-的可变参数" class="headerlink" title="C 的可变参数"></a>C 的可变参数</h1><h2 id="参数列表-va-list-4组宏"><a href="#参数列表-va-list-4组宏" class="headerlink" title="参数列表 #va_list 4组宏"></a>参数列表 #va_list 4组宏</h2><p>头文件</p><ul><li>&lt;stdarg.h&gt;</li></ul><p>宏</p><ul><li>#va_list：类型宏；参数列表</li><li>#va_start()：函数宏；va_list 指向参数列表的第一个参数</li><li>#va_arg()：函数宏；依据类型，va_list 指向参数列表的下一个参数</li><li>#va_end()：函数宏；清理 va_list</li></ul><p>底层原理</p><ul><li>#va_list：字符指针</li><li>#va_start()：指针指向第一个元素</li><li>#va_arg()：指针指向下一个元素</li><li>#va_end()：指针置空</li></ul><p>缺点</p><ul><li>代码逻辑需要明确参数的数量和每个参数的类型</li><li>…</li></ul><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span> <span class="comment">// #va_list、#va_start()、#va_arg()、#va_end()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 形参的一般形式：</span></span><br><span class="line"><span class="comment">// num：参数数量</span></span><br><span class="line"><span class="comment">// ...：参数列表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> num, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 定义 va_list</span></span><br><span class="line">    va_list para_list; <span class="comment">// 类型宏；参数列表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 初始化 va_list</span></span><br><span class="line">    va_start(para_list, num); <span class="comment">// 函数宏；va_list 指向参数列表的第一个参数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 遍历 va_list</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, va_arg(para_list, <span class="type">int</span>)); <span class="comment">// 函数宏；依据类型，va_list 指向参数列表的下一个参数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 清理 va_list</span></span><br><span class="line">    va_end(para_list); <span class="comment">// 函数宏；清理 va_list</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 实参的一般形式：</span></span><br><span class="line">    <span class="comment">// 2：参数数量</span></span><br><span class="line">    <span class="comment">// 0 1：参数列表</span></span><br><span class="line"></span><br><span class="line">    print(<span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 0 1</span></span><br><span class="line"><span class="comment">// 0 1 2</span></span><br></pre></td></tr></table></figure></h2><h1 id="C-的可变参数-1"><a href="#C-的可变参数-1" class="headerlink" title="C++ 的可变参数"></a>C++ 的可变参数</h1><h2 id="参数列表-va-list-4组宏-1"><a href="#参数列表-va-list-4组宏-1" class="headerlink" title="参数列表 #va_list 4组宏"></a>参数列表 #va_list 4组宏</h2><p>见 “C 的可变参数” 内容。</p><hr><h2 id="初始化列表-initializer-list-类模板"><a href="#初始化列表-initializer-list-类模板" class="headerlink" title="初始化列表 initializer_list&lt;&gt; 类模板"></a>初始化列表 initializer_list&lt;&gt; 类模板</h2><p>头文件</p><ul><li><initializer_list></li></ul><p>原理</p><ul><li>类比容器 vector&lt;&gt; </li><li>比容器轻量</li><li>封装参数（指向参数的指针、参数的数量和参数的类型等）的<strong>包装器&#x2F;对象</strong></li></ul><p>缺点</p><ul><li>代码逻辑需要明确参数的类型</li><li><strong>一个</strong> initializer_list&lt;&gt; 对象只支持<strong>一种</strong>类型（可以使用<strong>多个</strong> initializer_list&lt;&gt; 对象<strong>按序</strong>支持<strong>多种</strong>类型）</li></ul><blockquote><p>按序：如一个 initializer_list&lt;int&gt; 对象表示一部分参数都是 int 类型，另一个 initializer_list&lt;string&gt; 对象表示另一部分参数都是 string 类型；不能是一个 initializer_list&lt;int&gt; 对象表示一部分参数既有 int 类型又有 string 类型</p></blockquote><ul><li>…</li></ul><p>代码示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #include &lt;initializer_list&gt; // initializer_list&lt;&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::initializer_list;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(initializer_list&lt;<span class="type">int</span>&gt; li)</span> <span class="comment">// 使用 initializer_list&lt;&gt; 对象接收可变参数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> l : li)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; l &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;); <span class="comment">// 使用列表初始化创建匿名 initializer_list&lt;&gt; 对象并作为参数</span></span><br><span class="line">    <span class="built_in">print</span>(&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 0 1</span></span><br><span class="line"><span class="comment">// 0 1 2</span></span><br></pre></td></tr></table></figure><hr><h2 id="可变参数模板"><a href="#可变参数模板" class="headerlink" title="可变参数模板"></a>可变参数模板</h2><p>相关语法</p><ul><li>typename…：定义模板参数包</li><li>Args：<strong>模板参数（抽象概念）</strong> 包的名称，可自定义名称，表示任意类型和数量的模板参数</li><li>Args…：模板参数包</li><li>args：<strong>具体参数（具体概念）</strong> 包的名称，可自定义名称，表示任意类型和数量的具体参数</li><li>args…：展开具体参数包</li><li>sizeof…(具体参数包)：获取具体参数包参数的数量</li><li>…：折叠表达式</li></ul><blockquote><p>折叠表达式的概念和语法较复杂 <strong>（作者觉得很怪异）</strong>，在此不深入讲解。<br>可参见：<a href="https://blog.csdn.net/baidu_41388533/article/details/109621822">（C++模板编程）：折叠表达式、可变参表达式_c++模板折叠-CSDN博客</a></p></blockquote><p>解包方式</p><ul><li>递归展开1</li><li>递归展开2（C++ 17支持）</li><li>逗号表达式展开1</li><li>逗号表达式展开2（优化）</li><li>逗号表达式3（优化）</li><li>折叠表达式展开（C++ 17支持）</li></ul><p>缺点</p><ul><li>概念较复杂</li><li>语法较复杂</li><li>…</li></ul><p>获取具体参数包参数的数量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(Args... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">0</span>, <span class="string">&#x27;c&#x27;</span>); <span class="comment">// 2个不同类型的参数</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">0</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&quot;str&quot;</span>); <span class="comment">// 3个不同类型的参数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">逐行解释：</span></span><br><span class="line"><span class="comment">2：具体参数包参数的数量是2</span></span><br><span class="line"><span class="comment">3：具体参数包参数的数量是3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>递归展开1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数数量 == 1的函数模板</span></span><br><span class="line"><span class="comment">// 递归终止时调用</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; value &lt;&lt; endl; <span class="comment">// 参数值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变参数模板</span></span><br><span class="line"><span class="comment">// 参数数量 &gt; 1的函数模板</span></span><br><span class="line"><span class="comment">// 递归时调用</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T value, Args... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; value &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 参数值</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(args...); <span class="comment">// 递归调用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">0</span>, <span class="string">&#x27;c&#x27;</span>);        <span class="comment">// 2个不同类型的参数</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">0</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&quot;str&quot;</span>); <span class="comment">// 3个不同类型的参数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">0 c</span></span><br><span class="line"><span class="comment">0 c str</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>递归展开2（C++ 17支持）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变参数模板</span></span><br><span class="line"><span class="comment">// 参数数量 &gt;= 1的函数模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T value, Args... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; value &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 参数值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数数量为0时无法递归调用：print(args...);，需要递归终止</span></span><br><span class="line">    <span class="comment">// C++ 17标准支持“if constexpr()”语法，可以在编译而不是运行时求值以终止递归，使得编译通过</span></span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="keyword">sizeof</span>...(args) &gt; <span class="number">0</span>)</span> <span class="comment">// 递归调用</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(args...);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 递归终止</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">0</span>, <span class="string">&#x27;c&#x27;</span>);        <span class="comment">// 2个不同类型的参数</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">0</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&quot;str&quot;</span>); <span class="comment">// 3个不同类型的参数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">0 c</span></span><br><span class="line"><span class="comment">0 c str</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>逗号表达式展开1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// #include &lt;initializer_list&gt;  // initializer_list&lt;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::initializer_list;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变参数模板</span></span><br><span class="line"><span class="comment">// 参数数量 &gt;= 1的函数模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T value, Args... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; value &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 第一个参数值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重点理解：</span></span><br><span class="line">    <span class="comment">// [args]&#123;cout &lt;&lt; args &lt;&lt; &quot; &quot;;&#125;：Lambda 表达式</span></span><br><span class="line">    <span class="comment">// [args]&#123;cout &lt;&lt; args &lt;&lt; &quot; &quot;;&#125;()：调用 Lambda 表达式</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// value：第一个参数的值</span></span><br><span class="line">    <span class="comment">// (,)：逗号表达式：先计算左表达式，再计算右表达式，结果是右表达式的值</span></span><br><span class="line">    <span class="comment">// ([args]&#123;cout &lt;&lt; args &lt;&lt; &quot; &quot;;&#125;(), value)：先调用 Lambda 表达式，再计算第一个参数的值，结果是第一个参数的值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// args...：展开具体参数包</span></span><br><span class="line">    <span class="comment">// ([args]&#123;cout &lt;&lt; args &lt;&lt; &quot; &quot;;&#125;(), value)...：展开具体参数包，对每一个参数，先调用 Lambda 表达式，再计算第一个参数值，结果是第一个参数值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// typename T：第一个参数的类型</span></span><br><span class="line">    <span class="comment">// initializer_list&lt;&gt;&#123;&#125;：initializer_list&lt;&gt; 对象</span></span><br><span class="line">    <span class="comment">// initializer_list&lt;T&gt;&#123;&#125;：匿名 initializer_list&lt;&gt; 对象，值类型是第一个参数的类型</span></span><br><span class="line">    <span class="comment">// initializer_list&lt;T&gt;&#123;([args]&#123;cout &lt;&lt; args &lt;&lt; &quot; &quot;;&#125;(), value)...&#125;;：第一个参数作为匿名 initializer_list&lt;&gt; 对象的值，值类型是第一个参数的类型</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// C++11 和 C++14 标准，没有提供一种直接将具体参数包展开到函数调用参数列表中的语法</span></span><br><span class="line">    <span class="comment">// 所以可以使用 initializer_list&lt;&gt; 结合 args... 展开具体参数包</span></span><br><span class="line">    <span class="comment">// 又因为 initializer_list&lt;&gt; 的值需要相同类型</span></span><br><span class="line">    <span class="comment">// 所以可以使用逗号表达式，无论左表达式怎么计算，都返回第一个参数的类型和值 T value</span></span><br><span class="line">    <span class="comment">// 所以函数模板需要定义 typename T，函数需要定义 T value</span></span><br><span class="line">    initializer_list&lt;T&gt;&#123;([args]</span><br><span class="line">                         &#123; cout &lt;&lt; args &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;(),</span><br><span class="line">                         value)...&#125;;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">0</span>, <span class="string">&#x27;c&#x27;</span>);        <span class="comment">// 2个不同类型的参数</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">0</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&quot;str&quot;</span>); <span class="comment">// 3个不同类型的参数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">0 c</span></span><br><span class="line"><span class="comment">0 c str</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>逗号表达式展开2（优化）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// #include &lt;initializer_list&gt;  // initializer_list&lt;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::initializer_list;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变参数模板</span></span><br><span class="line"><span class="comment">// 参数数量 &gt;= 1的函数模板</span></span><br><span class="line"><span class="comment">// 依据“逗号表达式展开1”的分析，模板参数 typename T、初始化列表 initializer_list&lt;&gt; 的类型 T、第一个参数值 value 和逗号表达式的右表达式 value 有意义但无用途，可以优化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(Args... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    initializer_list&lt;<span class="type">int</span>&gt;&#123;([args]</span><br><span class="line">                           &#123; cout &lt;&lt; args &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;(),</span><br><span class="line">                           <span class="number">0</span>)...&#125;;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">0</span>, <span class="string">&#x27;c&#x27;</span>);        <span class="comment">// 2个不同类型的参数</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">0</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&quot;str&quot;</span>); <span class="comment">// 3个不同类型的参数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">0 c</span></span><br><span class="line"><span class="comment">0 c str</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>逗号表达式展开3（优化）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变参数模板</span></span><br><span class="line"><span class="comment">// 参数数量 &gt;= 1的函数模板</span></span><br><span class="line"><span class="comment">// 依据“逗号表达式展开1”的分析，对于可以使用列表初始化 &#123;&#125; 的对象，数组和向量 vector&lt;&gt; 等，可以结合 args... 展开具体参数包</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(Args... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[]&#123;([args]</span><br><span class="line">               &#123; cout &lt;&lt; args &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;(),</span><br><span class="line">               <span class="number">0</span>)...&#125;;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;&#123;([args]</span><br><span class="line">                 &#123; cout &lt;&lt; args &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;(),</span><br><span class="line">                 <span class="number">0</span>)...&#125;;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">0</span>, <span class="string">&#x27;c&#x27;</span>);        <span class="comment">// 2个不同类型的参数</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">0</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&quot;str&quot;</span>); <span class="comment">// 3个不同类型的参数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">0 c</span></span><br><span class="line"><span class="comment">0 c</span></span><br><span class="line"><span class="comment">0 c str</span></span><br><span class="line"><span class="comment">0 c str</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>折叠表达式展开（C++ 17支持）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变参数模板</span></span><br><span class="line"><span class="comment">// 参数数量 &gt;= 1的函数模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(Args... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 二元左折叠表达式（概念复杂）</span></span><br><span class="line">    <span class="comment">// (,)：逗号表达式：连接折叠表达式和操作</span></span><br><span class="line">    <span class="comment">// 对每一个参数，先输出参数，再输出空格</span></span><br><span class="line">    (..., (cout &lt;&lt; args &lt;&lt; <span class="string">&#x27; &#x27;</span>));</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">0</span>, <span class="string">&#x27;c&#x27;</span>);        <span class="comment">// 2个不同类型的参数</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">0</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&quot;str&quot;</span>); <span class="comment">// 3个不同类型的参数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">0 c</span></span><br><span class="line"><span class="comment">0 c str</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>C 和 C++ 可变参数介绍。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.runoob.com/cprogramming/c-variable-arguments.html">C 可变参数 | 菜鸟教程 (runoob.com)</a></li><li><a href="https://www.bilibili.com/video/BV11N411Y79G?p=2&vd_source=9ac1c0a6d496218112b60d49bc768cd7">02_可变长参数的基础_哔哩哔哩_bilibili</a></li><li><a href="https://blog.csdn.net/ZKR_HN/article/details/99558135">va_list原理及用法-CSDN博客</a></li><li><a href="https://www.cnblogs.com/ofnoname/p/16524932.html#tp2">C++ 实现可变参数的三个方法 - Ofnoname - 博客园 (cnblogs.com)</a></li><li><a href="https://changkun.de/modern-cpp/zh-cn/02-usability/#%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF">第 2 章 语言可用性的强化 现代 C++ 教程: 高速上手 C++ 11&#x2F;14&#x2F;17&#x2F;20 - Modern C++ Tutorial: C++ 11&#x2F;14&#x2F;17&#x2F;20 On the Fly (changkun.de)</a></li><li><a href="https://www.cnblogs.com/pandamohist/p/13856489.html">c++11之函数参数包展开 - mohist - 博客园 (cnblogs.com)</a></li><li><a href="https://blog.csdn.net/baidu_41388533/article/details/109621822">（C++模板编程）：折叠表达式、可变参表达式_c++模板折叠-CSDN博客</a></li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 代码实例：并查集简单创建工具</title>
      <link href="/2023/11/06/C++%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E4%BE%8B%EF%BC%9A%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AE%80%E5%8D%95%E5%88%9B%E5%BB%BA%E5%B7%A5%E5%85%B7/"/>
      <url>/2023/11/06/C++%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E4%BE%8B%EF%BC%9A%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AE%80%E5%8D%95%E5%88%9B%E5%BB%BA%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>C++ 代码实例：并查集简单创建工具。</p><hr><h1 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h1><ul><li><a href="https://github.com/yezhening/Programming-examples">yezhening&#x2F;Programming-examples: 编程实例 (github.com)</a></li><li><a href="https://gitee.com/yezhening/Programming-examples">Programming-examples: 编程实例 (gitee.com)</a></li></ul><hr><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul><li>简单地创建并查集</li><li><strong>注释有详细的步骤解析</strong></li><li>还可优化的点：使用cmake；使用右值传递复杂容器减小开销</li></ul><blockquote><p>注：半个晚上完成，大概测试了下</p></blockquote><hr><h2 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a>main.cpp</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::pair;</span><br><span class="line"><span class="keyword">using</span> std::sort;</span><br><span class="line"><span class="keyword">using</span> std::unordered_map;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DisjointSet</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造并查集</span></span><br><span class="line">    <span class="comment">// 参数：等价关系元素值的大小/范围，等价关系集合向量</span></span><br><span class="line">    <span class="built_in">DisjointSet</span>(<span class="type">const</span> <span class="type">int</span> &amp;e_q_s, <span class="type">const</span> vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; &amp;e_r_v) : <span class="built_in">eq_rel_size</span>(e_q_s), <span class="built_in">eq_rel_vec</span>(e_r_v)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 1. 初始化元素父节点向量，大小是等价关系元素值的大小/范围，每个元素的父节点约定为自身</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;parent_vec.<span class="built_in">resize</span>(<span class="keyword">this</span>-&gt;eq_rel_size); <span class="comment">// 元素父节点的向量的大小是等价关系元素值的大小/范围</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;eq_rel_size; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            parent_vec[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 初始化元素深度向量，大小是等价关系元素值的大小/范围，每个元素作为根节点约定为0即第0层</span></span><br><span class="line">        <span class="comment">// 合并操作依据树的深度优化，即优先将深度大的树的根挂接到深度小的树的根</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;depth_vec.<span class="built_in">resize</span>(<span class="keyword">this</span>-&gt;eq_rel_size, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 按照字典序排序等价关系集合向量</span></span><br><span class="line">        <span class="built_in">sort</span>(<span class="keyword">this</span>-&gt;eq_rel_vec.<span class="built_in">begin</span>(), <span class="keyword">this</span>-&gt;eq_rel_vec.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 合并集合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;eq_rel_pair : eq_rel_vec) <span class="comment">// 对每一个等价关系集合，如：&#123;1, 2&#125;</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 4.1 分别查找两关系元素的根节点</span></span><br><span class="line">            <span class="type">int</span> first_root = <span class="keyword">this</span>-&gt;<span class="built_in">find_parent</span>(eq_rel_pair.first);</span><br><span class="line">            <span class="type">int</span> second_root = <span class="keyword">this</span>-&gt;<span class="built_in">find_parent</span>(eq_rel_pair.second);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4.2 依据根节点情况合并挂接</span></span><br><span class="line">            <span class="keyword">if</span> (first_root == second_root) <span class="comment">// 相等不操作</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// first_root != second_root</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;depth_vec[first_root] &lt; <span class="keyword">this</span>-&gt;depth_vec[second_root]) <span class="comment">// 优先将深度大的树的根挂接到深度小的树的根</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">this</span>-&gt;parent_vec[first_root] = second_root;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;depth_vec[first_root] &gt; <span class="keyword">this</span>-&gt;depth_vec[second_root])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">this</span>-&gt;parent_vec[second_root] = first_root;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="comment">// == 树的深度相等，约定将第二个根挂接到第一个根，第一个根的深度加深一层</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">this</span>-&gt;parent_vec[second_root] = first_root;</span><br><span class="line">                    ++<span class="keyword">this</span>-&gt;depth_vec[first_root];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 构建结果</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; root_vec&#123;&#125;; <span class="comment">// 哈希表，记录 根节点值-该根节点下的元素向量，一个向量是一棵新树</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;eq_rel_size; ++i) <span class="comment">// 遍历元素值</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> root = <span class="keyword">this</span>-&gt;<span class="built_in">find_parent</span>(i); <span class="comment">// 取根节点</span></span><br><span class="line">            root_vec[root].<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> pair&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; &amp;pair_tree : root_vec) <span class="comment">// 遍历每棵树，加入到结果集</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;disjoint_set.<span class="built_in">insert</span>(<span class="keyword">this</span>-&gt;disjoint_set.<span class="built_in">begin</span>(), pair_tree.second);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取并查集</span></span><br><span class="line">    <span class="keyword">inline</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">get_disjoint_set</span>() <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;disjoint_set;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印并查集</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">print_disjoint_set</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;并查集: &quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; set : <span class="keyword">this</span>-&gt;disjoint_set)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> num : set)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> eq_rel_size;             <span class="comment">// 等价关系元素值的大小/范围</span></span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; eq_rel_vec; <span class="comment">// 等价关系集合向量</span></span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; parent_vec; <span class="comment">// 记录元素父节点的向量</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; depth_vec;  <span class="comment">// 记录元素深度的向量，约定元素值/树的根是索引，根的深度从0、1往上加</span></span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; disjoint_set; <span class="comment">// 并查集，并查集类固有的本质内容</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归查找当前元素值的根节点</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find_parent</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 递归逻辑</span></span><br><span class="line">        <span class="comment">// 如果不是，parent[x] != x，则使用当前节点的父节点作为参数，调用当前函数，递归继续找爷节点：find_parent(parent[x])</span></span><br><span class="line">        <span class="comment">// 把找到的根节点记录在查找路径中每个节点的 元素父节点的向量 中：parent_vec[x] =</span></span><br><span class="line">        <span class="comment">// 相当于把该些节点，都挂接到根节点上，树变得扁平</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 即路径压缩优化：在并查集中，每个元素都有一个父节点，通常在查找操作中，我们会沿着父节点链一直向上找到根节点</span></span><br><span class="line">        <span class="comment">// 这个过程就是在寻找元素所在集合的过程。但是，在普通的查找操作中，路径的长度可能会很长，导致后续的查找操作效率较低。</span></span><br><span class="line">        <span class="comment">// 路径压缩是一种优化技术，它的思想是：当我们在进行查找操作时，不仅找到元素所在集合的根节点，</span></span><br><span class="line">        <span class="comment">// 还顺便将经过的所有节点的父节点都设置为根节点。这样，当下次再次查找这些节点时，路径就会更短，查找效率就会更高。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如：1为根节点，23为子节点，有1 - 2 - 3的三层树，从叶节点3开始找，找到1根节点，然后依次递归返回把2、3的根节点设置为1</span></span><br><span class="line">        <span class="comment">// 成为1 - 2，1 - 3的两层树</span></span><br><span class="line">        <span class="keyword">if</span> (parent_vec[x] != x)</span><br><span class="line">        &#123;</span><br><span class="line">            parent_vec[x] = <span class="built_in">find_parent</span>(parent_vec[x]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 递归出口</span></span><br><span class="line">        <span class="comment">// 如果x的父节点是自己，说明它是根节点，返回</span></span><br><span class="line">        <span class="comment">// parent_vec[x] == x</span></span><br><span class="line">        <span class="comment">// 把return放在if会有到不了该条件if的警告：control reaches end of non-void function [-Wreturn-type]</span></span><br><span class="line">        <span class="keyword">return</span> parent_vec[x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> eq_rel_size = <span class="number">9</span>;                                                                          <span class="comment">// 等价关系元素值的大小/范围</span></span><br><span class="line">    <span class="type">const</span> vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; eq_rel_vec = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>&#125;, &#123;<span class="number">6</span>, <span class="number">7</span>&#125;, &#123;<span class="number">0</span>, <span class="number">2</span>&#125;, &#123;<span class="number">4</span>, <span class="number">6</span>&#125;, &#123;<span class="number">0</span>, <span class="number">8</span>&#125;&#125;; <span class="comment">// 等价关系集合向量，内容必须是0~ eq_rel_size - 1（并查集类的逻辑定义了）</span></span><br><span class="line"></span><br><span class="line">    <span class="function">DisjointSet <span class="title">ds</span><span class="params">(eq_rel_size, eq_rel_vec)</span></span>; <span class="comment">// 并查集对象</span></span><br><span class="line">    ds.<span class="built_in">print_disjoint_set</span>();                 <span class="comment">// 打印并查集</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.PHONY : all</span><br><span class="line">all : main.exe</span><br><span class="line"></span><br><span class="line">main.exe : main.cpp</span><br><span class="line">g++ <span class="literal">-o</span> <span class="variable">$</span><span class="selector-tag">@</span> <span class="variable">$</span>^</span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line"><span class="built_in">del</span> *.exe</span><br></pre></td></tr></table></figure><hr><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p><img src="/../img/disjoint_set/one.png" alt="在这里插入图片描述"></p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>C++ 代码实例：并查集简单创建工具。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>学校《高级算法设计与分析》课程课件的算法思路</li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 代码实例：多项式除法简单计算工具</title>
      <link href="/2023/11/05/C++%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E4%BE%8B%EF%BC%9A%E5%A4%9A%E9%A1%B9%E5%BC%8F%E9%99%A4%E6%B3%95%E7%AE%80%E5%8D%95%E8%AE%A1%E7%AE%97%E5%B7%A5%E5%85%B7/"/>
      <url>/2023/11/05/C++%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E4%BE%8B%EF%BC%9A%E5%A4%9A%E9%A1%B9%E5%BC%8F%E9%99%A4%E6%B3%95%E7%AE%80%E5%8D%95%E8%AE%A1%E7%AE%97%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>C++ 代码实例：多项式除法简单计算工具。</p><hr><h1 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h1><ul><li><a href="https://github.com/yezhening/Programming-examples">yezhening&#x2F;Programming-examples: 编程实例 (github.com)</a></li><li><a href="https://gitee.com/yezhening/Programming-examples">Programming-examples: 编程实例 (gitee.com)</a></li></ul><hr><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul><li>由于代码篇幅较多，在博客中直接粘贴并呈现会显得冗长，因此未在博客中放置<strong>完整</strong>代码，只展示<strong>核心片段</strong>代码。请前往”代码仓库”查看或获取相关代码</li><li>简单地计算多项式除法</li><li><strong>注释有详细的步骤解析</strong></li><li>好用的多项式除法在线计算网址：<a href="https://zh.planetcalc.com/7717/">在线计算器: 多项式除法 (planetcalc.com)</a></li><li>多项式除法，被除数和除数写在程序中：main.exe、main.cpp、polynomial.cpp、polynomial.h</li><li>多项式除法，在终端输入被除数和除数：main1.exe、main1.cpp、polynomial.cpp、polynomial.h</li></ul><blockquote><p>注：一个晚上一个早上完成，应该大部分结果对，若出现小部分结果错误懒得管了，逻辑差不多那样</p></blockquote><hr><h2 id="核心片段"><a href="#核心片段" class="headerlink" title="核心片段"></a>核心片段</h2><p>polynomial.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> POLYNOMIAL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLYNOMIAL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::ostream;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多项式类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Polynomial</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Polynomial</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;p)</span> : poly_vec(p) &#123;</span>&#125; <span class="comment">// 私有成员只能在类的成员函数内部被初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载运算符 “&lt;&lt;” 输出多项式</span></span><br><span class="line">    <span class="comment">// friend：类外会用该运算符访问类的成员，不写报错：too many parameters for this operator function</span></span><br><span class="line">    <span class="comment">// 返回输出流对象引用，可以链式操作</span></span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;output, <span class="type">const</span> Polynomial &amp;obj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载运算符 “/” 进行多项式除法</span></span><br><span class="line">    <span class="comment">// 返回值：商</span></span><br><span class="line">    <span class="comment">// 参数：除数</span></span><br><span class="line">    Polynomial <span class="keyword">operator</span>/(<span class="type">const</span> Polynomial &amp;divisor) <span class="type">const</span>; <span class="comment">// const表示不会改变调用该方法的被除数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载运算符 “%” 进行多项式除法求余</span></span><br><span class="line">    <span class="comment">// 返回值：余数</span></span><br><span class="line">    <span class="comment">// 参数：除数</span></span><br><span class="line">    <span class="comment">// 照搬除法逻辑，只改动最后return的返回值，最后的余数就是最后更新的被除数</span></span><br><span class="line">    Polynomial <span class="keyword">operator</span>%(<span class="type">const</span> Polynomial &amp;divisor) <span class="type">const</span>; <span class="comment">// const表示不会改变调用该方法的被除数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> vector&lt;<span class="type">int</span>&gt; poly_vec; <span class="comment">// 多项式的向量表示</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// POLYNOMIAL_H</span></span></span><br></pre></td></tr></table></figure><p>polynomial.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重载运算符 “&lt;&lt;” 输出多项式</span></span><br><span class="line"><span class="comment">// 不需要friend、类作用域声名，因为是类外的运算符</span></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;output, <span class="type">const</span> Polynomial &amp;obj)</span><br><span class="line">&#123;</span><br><span class="line">    UINT terminal_code_page = <span class="built_in">GetConsoleOutputCP</span>(); <span class="comment">// 获取当前终端的输出代码页</span></span><br><span class="line">    <span class="keyword">if</span> (terminal_code_page != <span class="number">65001</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;chcp 65001&quot;</span>); <span class="comment">// 终端切换使用utf8字符集显示，以可以显示utf8的上标</span></span><br><span class="line">        <span class="comment">// 注意：会切换终端页，需要重新运行程序</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 65001</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = obj.poly_vec.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) <span class="comment">// 从高位到低位    i既表示索引也表示次数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 1. 系数的符号</span></span><br><span class="line">        <span class="comment">// 正数显示+，负数不显示-，系数负数已有-</span></span><br><span class="line">        <span class="keyword">if</span> (obj.poly_vec.<span class="built_in">at</span>(i) &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;+&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// obj.poly.at(i) &lt; 0</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot; - &quot;;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 系数</span></span><br><span class="line">        cout &lt;&lt; obj.poly_vec.<span class="built_in">at</span>(i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 形式参数</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;x&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 次数</span></span><br><span class="line">        <span class="comment">// 上标号的utf8编码</span></span><br><span class="line">        <span class="comment">// 如：0上标号⁰的utf8编码在索引0为\u2070，1上标号¹的utf8编码在索引1为\u00B9，以此类推</span></span><br><span class="line">        vector&lt;string&gt; superscript_utf8&#123;<span class="string">&quot;\u2070&quot;</span>, <span class="string">&quot;\u00B9&quot;</span>, <span class="string">&quot;\u00B2&quot;</span>, <span class="string">&quot;\u00B3&quot;</span>, <span class="string">&quot;\u2074&quot;</span>, <span class="string">&quot;\u2075&quot;</span>, <span class="string">&quot;\u2076&quot;</span>, <span class="string">&quot;\u2077&quot;</span>, <span class="string">&quot;\u2078&quot;</span>, <span class="string">&quot;\u2079&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; superscript_utf<span class="number">8.</span><span class="built_in">at</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载运算符 “/” 进行多项式除法</span></span><br><span class="line"><span class="comment">// 返回值：商</span></span><br><span class="line"><span class="comment">// 参数：除数</span></span><br><span class="line">Polynomial Polynomial::<span class="keyword">operator</span>/(<span class="type">const</span> Polynomial &amp;divisor) <span class="type">const</span> <span class="comment">// const表示不会改变调用该方法的被除数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 准备被除数、除数和商</span></span><br><span class="line">    <span class="comment">// 解封装，获取被除数和除数向量</span></span><br><span class="line">    <span class="comment">// 1.1 方便操作</span></span><br><span class="line">    <span class="comment">// 1.2 不再是const，可以修改再封装出去</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dividend_vec</span><span class="params">(<span class="keyword">this</span>-&gt;poly_vec)</span></span>;  <span class="comment">// 被除数</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">divisor_vec</span><span class="params">(divisor.poly_vec)</span></span>; <span class="comment">// 除数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 商初始的次数是被除数最高项次数 - 除数最高项次数 + 1</span></span><br><span class="line">    <span class="comment">// 如：</span></span><br><span class="line">    <span class="comment">// 4x³ + 3x² + 2x + 1，的个数是4，最高项次数次数是 4 - 1 = 3</span></span><br><span class="line">    <span class="comment">// x² + 2x + 1的个数是3，最高项次数次数是 3 - 1 = 2</span></span><br><span class="line">    <span class="comment">// 最高项相除，4x³ / x² = 4x，商的最高项次数是 3 - 2 = 1</span></span><br><span class="line">    <span class="comment">// 因为索引从0开始，所以需要+1，商系数的个数是1 + 1 = 2，初始化为0</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">quotient_vec</span><span class="params">((dividend_vec.size() - <span class="number">1</span>) - (divisor_vec.size() - <span class="number">1</span>) + <span class="number">1</span>, <span class="number">0</span>)</span></span>; <span class="comment">// 商</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 除法运算</span></span><br><span class="line">    <span class="comment">// 2.1 如果被除数最高项次数 &lt; 除数最高项次数，即 dividend_vec.size() - 1 &lt; divisor_vec.size() - 1，商返回0</span></span><br><span class="line">    <span class="comment">// 如：4x³ + 3x² + 2x + 1 / x⁵ + 2x + 3，被除数最高项 4x³ 次数4 &lt; 除数最高项 x⁵ 次数5，无法除，返回0（只有1个元素，索引0值0）</span></span><br><span class="line">    <span class="keyword">if</span> ((dividend_vec.<span class="built_in">size</span>() - <span class="number">1</span>) &lt; (divisor_vec.<span class="built_in">size</span>() - <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        quotient_vec.<span class="built_in">resize</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载运算符 “%” 进行多项式除法求余</span></span><br><span class="line"><span class="comment">// 返回值：余数</span></span><br><span class="line"><span class="comment">// 参数：除数</span></span><br><span class="line"><span class="comment">// 照搬除法逻辑，只改动最后return的返回值，最后的余数就是最后更新的被除数</span></span><br><span class="line">Polynomial Polynomial::<span class="keyword">operator</span>%(<span class="type">const</span> Polynomial &amp;divisor) <span class="type">const</span> <span class="comment">// const表示不会改变调用该方法的被除数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;polynomial.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// int 型向量表示多项式，x作为形式参数无具体意义只有方便理解的展示意义，索引表示次数，值表示系数</span></span><br><span class="line">    <span class="comment">// 如 &#123;1, 2&#125;，索引0值1表示1x⁰，索引1值2表示2x¹，所以多项式是：2x¹ + 1x⁰ = 2x + 1</span></span><br><span class="line">    <span class="type">const</span> vector&lt;<span class="type">int</span>&gt; dividend_vec&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;; <span class="comment">// 被除数，4x³ + 3x² + 2x + 1</span></span><br><span class="line">    <span class="type">const</span> vector&lt;<span class="type">int</span>&gt; divisor_vec&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;        <span class="comment">// 除数，x² + 2x + 3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多项式类表示多项式，进一步封装</span></span><br><span class="line">    <span class="function"><span class="type">const</span> Polynomial <span class="title">dividend</span><span class="params">(dividend_vec)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> Polynomial <span class="title">divisor</span><span class="params">(divisor_vec)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;被除数: &quot;</span> &lt;&lt; dividend &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;除数: &quot;</span> &lt;&lt; divisor &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多项式除法求商</span></span><br><span class="line">    Polynomial quotient = dividend / divisor;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;商: &quot;</span> &lt;&lt; quotient &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多项式除法求余数</span></span><br><span class="line">    Polynomial remainder = dividend % divisor;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;余数: &quot;</span> &lt;&lt; remainder &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main1.cpp</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;sstream&gt; // istringstream</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#include &quot;polynomial.h&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::getline;</span><br><span class="line"><span class="keyword">using</span> std::istringstream;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    // 终端输入被除数和除数</span><br><span class="line">    // int 型向量表示多项式，x作为形式参数无具体意义只有方便理解的展示意义，索引表示次数，值表示系数</span><br><span class="line">    // 如 &#123;<span class="number">1</span>, <span class="number">2</span>&#125;，索引<span class="number">0</span>值<span class="number">1</span>表示<span class="number">1</span>x⁰，索引<span class="number">1</span>值<span class="number">2</span>表示<span class="number">2</span>x¹，所以多项式是：<span class="number">2</span>x¹ + <span class="number">1</span>x⁰ = <span class="number">2</span>x + <span class="number">1</span></span><br><span class="line">    // <span class="number">1</span>. 被除数</span><br><span class="line">    vector&lt;int&gt; dividend_vec(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;被除数系数，从高到低位输入，空格分隔，回车结束: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    string input(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    getline(cin, input); // 从终端获取一行输入</span><br><span class="line"></span><br><span class="line">    istringstream iss(input); // 字符串 -&gt; 输入流对象</span><br><span class="line">    int num(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (iss &gt;&gt; num) // 输入流对象 -&gt; 数字</span><br><span class="line">    &#123;</span><br><span class="line">        dividend_vec.insert(dividend_vec.begin(), num); // 从后往前插入</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // <span class="number">2</span>. 除数</span><br><span class="line">    vector&lt;int&gt; divisor_vec(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;除数系数，从高到低位输入，空格分隔，回车结束: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    input = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    getline(cin, input);</span><br><span class="line"></span><br><span class="line">    iss.clear(); // 清楚流状态，否则获取不到数字</span><br><span class="line">    iss.str(input);</span><br><span class="line">    num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (iss &gt;&gt; num)</span><br><span class="line">    &#123;</span><br><span class="line">        divisor_vec.insert(divisor_vec.begin(), num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 多项式类表示多项式，进一步封装</span><br><span class="line">    const Polynomial dividend(dividend_vec);</span><br><span class="line">    const Polynomial divisor(divisor_vec);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;被除数: &quot;</span> &lt;&lt; dividend &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;除数: &quot;</span> &lt;&lt; divisor &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    // 多项式除法求商</span><br><span class="line">    Polynomial quotient = dividend / divisor;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;商: &quot;</span> &lt;&lt; quotient &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    // 多项式除法求余数</span><br><span class="line">    Polynomial remainder = dividend % divisor;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;余数: &quot;</span> &lt;&lt; remainder &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Makefile</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.PHONY : all</span><br><span class="line">all : main.exe main1.exe</span><br><span class="line"></span><br><span class="line">main.exe : main.cpp polynomial.cpp</span><br><span class="line">g++ <span class="literal">-o</span> <span class="variable">$</span><span class="selector-tag">@</span> <span class="variable">$</span>^</span><br><span class="line"></span><br><span class="line">main1.exe : main1.cpp polynomial.cpp</span><br><span class="line">g++ <span class="literal">-o</span> <span class="variable">$</span><span class="selector-tag">@</span> <span class="variable">$</span>^</span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line"><span class="built_in">del</span> *.exe</span><br></pre></td></tr></table></figure><hr><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p><img src="/../img/polynomial_division/one.png" alt="在这里插入图片描述"></p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>C++ 代码实例：多项式除法简单计算工具。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>无具体的参考资料</li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ STL 六组件介绍</title>
      <link href="/2023/11/03/C++%20STL%20%E5%85%AD%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D/"/>
      <url>/2023/11/03/C++%20STL%20%E5%85%AD%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>C++ STL 六组件介绍。</p><hr><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><ul><li><p>C++：编程语言</p></li><li><p>STL（Standard Template Library，标准模板库）：C++ 标准库的一部分，提供相关工具（<strong>函数模板</strong>、<strong>类模板</strong>和函数等）</p></li></ul><blockquote><p><strong>“函数模板”</strong> 和 <strong>“类模板”</strong> 是“抽象”概念，<strong>“模板函数”</strong> 和 <strong>“模板类”</strong> 是“具体”概念。</p></blockquote><ul><li><p>六组件：容器，算法，迭代器，适配器，仿函数，分配器</p></li><li><p><strong>基础（常用）</strong> 三组件：容器，算法，迭代器</p></li><li><p><strong>拓展（少用）</strong> 三组件：适配器，仿函数，分配器</p></li></ul><hr><h1 id="容器（container）"><a href="#容器（container）" class="headerlink" title="容器（container）"></a>容器（container）</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><ul><li>组织数据的结构（所以称作：容纳物体的器具 -&gt; 容器）</li><li>特性：静态</li><li>类比：数组</li></ul><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>顺序容器</p><ul><li>数组&#x2F;向量</li><li>链表</li><li>队列</li><li>栈</li></ul><p>关联容器</p><ul><li>图&#x2F;映射</li><li>集合</li><li>对组</li><li>元组</li></ul><p>数组&#x2F;向量</p><table><thead><tr><th>名称</th><th>底层原理</th><th>说明</th></tr></thead><tbody><tr><td>array</td><td>静态数组</td><td>C++11 标准</td></tr><tr><td>vector</td><td>动态数组</td><td></td></tr></tbody></table><p> 链表</p><table><thead><tr><th>名称</th><th>底层原理</th><th>说明</th></tr></thead><tbody><tr><td>list</td><td>双向链表</td><td></td></tr><tr><td>forward_list</td><td>单向链表</td><td>C++11 标准</td></tr></tbody></table><p> 队列</p><table><thead><tr><th>名称</th><th>底层原理</th><th>说明</th></tr></thead><tbody><tr><td>deque</td><td>管理数组+多个被管理数组</td><td></td></tr><tr><td>queue</td><td>deque</td><td>容器适配器</td></tr><tr><td>priority_queue</td><td>vector；堆（完全二叉树）</td><td>容器适配器</td></tr></tbody></table><p>栈</p><table><thead><tr><th>名称</th><th>底层原理</th><th>说明</th></tr></thead><tbody><tr><td>stack</td><td>deque</td><td>容器适配器</td></tr></tbody></table><p> 图&#x2F;映射</p><table><thead><tr><th>名称</th><th>底层原理</th><th>说明</th></tr></thead><tbody><tr><td>map</td><td>红黑树</td><td></td></tr><tr><td>multimap</td><td>红黑树</td><td></td></tr><tr><td>unordered_map</td><td>哈希表</td><td>C++11 标准</td></tr><tr><td>unordered_multimap</td><td>哈希表</td><td>C++11 标准</td></tr></tbody></table><p>集合</p><table><thead><tr><th>名称</th><th>底层原理</th><th>说明</th></tr></thead><tbody><tr><td>set</td><td>红黑树</td><td></td></tr><tr><td>multiset</td><td>红黑树</td><td></td></tr><tr><td>unordered_set</td><td>哈希表</td><td>C++11 标准</td></tr><tr><td>unordered_multiset</td><td>哈希表</td><td>C++11 标准</td></tr></tbody></table><p>对组</p><table><thead><tr><th>名称</th><th>底层原理</th><th>说明</th></tr></thead><tbody><tr><td>pair</td><td>结构体struct</td><td></td></tr></tbody></table><p>元组</p><table><thead><tr><th>名称</th><th>底层原理</th><th>说明</th></tr></thead><tbody><tr><td>tuple</td><td>递归继承类</td><td>C++11 标准</td></tr></tbody></table><p> 总表</p><table><thead><tr><th>名称</th><th>底层原理</th><th>说明</th></tr></thead><tbody><tr><td>array</td><td>静态数组</td><td>C++11 标准</td></tr><tr><td>vector</td><td>动态数组</td><td></td></tr><tr><td>list</td><td>双向链表</td><td></td></tr><tr><td>forward_list</td><td>单向链表</td><td>C++11 标准</td></tr><tr><td>deque</td><td>管理数组+多个被管理数组</td><td></td></tr><tr><td>queue</td><td>deque</td><td>容器适配器</td></tr><tr><td>priority_queue</td><td>vector；堆（完全二叉树）</td><td></td></tr><tr><td>stack</td><td>deque</td><td>容器适配器</td></tr><tr><td>map</td><td>红黑树</td><td></td></tr><tr><td>multimap</td><td>红黑树</td><td></td></tr><tr><td>unordered_map</td><td>哈希表</td><td>C++11 标准</td></tr><tr><td>unordered_multimap</td><td>哈希表</td><td>C++11 标准</td></tr><tr><td>set</td><td>红黑树</td><td></td></tr><tr><td>multiset</td><td>红黑树</td><td></td></tr><tr><td>unordered_set</td><td>哈希表</td><td>C++11 标准</td></tr><tr><td>unordered_multiset</td><td>哈希表</td><td>C++11 标准</td></tr><tr><td>pair</td><td>结构体 struct</td><td></td></tr><tr><td>tuple</td><td>递归继承类</td><td>C++11 标准</td></tr></tbody></table><hr><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span> <span class="comment">// vector&lt;&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 容器</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;; <span class="comment">// 存储“0、1和2”3个数据</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; vec.<span class="built_in">at</span>(<span class="number">0</span>) &lt;&lt; endl; <span class="comment">// 访问索引“0”的数据“0”</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 输出：0</span></span><br></pre></td></tr></table></figure><hr><h2 id="作用（为什么需要）"><a href="#作用（为什么需要）" class="headerlink" title="作用（为什么需要）"></a>作用（为什么需要）</h2><ul><li>可以高效地组织数据</li><li>如：直接使用 vector&lt;&gt; 存储数据，而无需自己编写与数组类似并比数组“高级”的“顺序表”数据结构</li><li>如：直接使用 list&lt;&gt; 存储数据，而无需自己编写“双向链表”数据结构</li></ul><hr><h1 id="算法（algorithm）"><a href="#算法（algorithm）" class="headerlink" title="算法（algorithm）"></a>算法（algorithm）</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><ul><li>处理数据的操作（所以称作：算术的法门 -&gt; 算法）</li><li>特性：动态</li><li>类比：函数</li></ul><h2 id="类型-1"><a href="#类型-1" class="headerlink" title="类型"></a>类型</h2><blockquote><p>这里只列举部分算法，更多参见：<a href="https://zh.cppreference.com/w/cpp/algorithm">算法库 - cppreference.com</a></p></blockquote><p>不修改序列的操作</p><ul><li>count()</li><li>find()</li></ul><p>修改序列的操作</p><ul><li>copy()</li><li>swap()</li></ul><p> 划分操作</p><ul><li>partition()</li><li>stable_partition()</li></ul><p>排序操作</p><ul><li>sort()</li><li>stable_sort()</li></ul><p>二分搜索操作（在已排序范围上）</p><ul><li>lower_bound()</li><li>binary_search()</li></ul><p>其他已排序范围上的操作</p><ul><li>merge()</li><li>inplace_merge()</li></ul><p>集合操作（在已排序范围上）</p><ul><li>includes()</li><li>set_difference()</li></ul><p>堆操作</p><ul><li>is_heap()</li><li>sort_heap()</li></ul><p>最小&#x2F;最大操作</p><ul><li>max()</li><li>min()</li></ul><p>比较操作</p><ul><li>equal()</li><li>lexicographical_compare()</li></ul><p>排列操作</p><ul><li>is_permutation()</li><li>next_permutation()</li></ul><p>数值运算</p><ul><li>iota()</li><li>accumulate()</li></ul><p>未初始化内存上的操作</p><ul><li>destroy_at()</li><li>construct_at()</li></ul><p>C 库</p><ul><li>qsort()</li><li>bsearch()</li></ul><hr><h2 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// #include &lt;algorithm&gt;// max()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> num1 = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> num2 = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 算法</span></span><br><span class="line">    cout &lt;&lt; std::<span class="built_in">max</span>(num1, num2) &lt;&lt; endl; <span class="comment">// 获取最大值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 输出：2</span></span><br></pre></td></tr></table></figure><hr><h2 id="作用（为什么需要）-1"><a href="#作用（为什么需要）-1" class="headerlink" title="作用（为什么需要）"></a>作用（为什么需要）</h2><ul><li>可以高效地处理数据</li><li>如：直接使用 max() 比较数据，而无需自己编写比较并返回数据的比较函数算法</li><li>如：直接使用 find() 查找数据，而无需自己编写遍历、比较并返回数据的查找函数算法</li></ul><hr><h1 id="迭代器（iterator）"><a href="#迭代器（iterator）" class="headerlink" title="迭代器（iterator）"></a>迭代器（iterator）</h1><h2 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h2><ul><li><strong>连接</strong>容器和算法</li><li><strong>代表</strong>容器组织的数据：无需关心数据的内部实现细节，以统一的方式表示数据</li><li><strong>通过</strong>算法处理数据：操作数据时，以“逐一访问”&#x2F;遍历的表现形式（所以称作：迭代物品的器具 -&gt; 迭代器）</li><li>特性：静 -&gt; 动态</li><li>类比：数组下标&#x2F;索引&#x2F;位置&#x2F;指针&#x2F;地址</li></ul><h2 id="常用迭代器"><a href="#常用迭代器" class="headerlink" title="常用迭代器"></a>常用迭代器</h2><ul><li>正向迭代器：iterator&lt;&gt;</li><li>常量正向迭代器：const_iterator&lt;&gt;</li><li>反向迭代器：reverse_iterator&lt;&gt;</li><li>常量反向迭代器：const_reverse_iterator&lt;&gt;</li></ul><h2 id="类型和代码示例"><a href="#类型和代码示例" class="headerlink" title="类型和代码示例"></a>类型和代码示例</h2><p>类型</p><ul><li>输入迭代器</li><li>输出迭代器</li><li>前向迭代器</li><li>双向迭代器</li><li>随机访问迭代器</li><li>连续迭代器</li></ul><p>输入迭代器</p><ul><li>从<strong>输入流</strong>中<strong>逐个</strong>读出数据</li><li>支持单次遍历</li><li>istream_iterator&lt;&gt;</li></ul><blockquote><p>将“流”看作是一种容器，迭代器可以作用于它。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::istream_iterator;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 输入迭代器</span></span><br><span class="line">    <span class="function">istream_iterator&lt;<span class="type">int</span>&gt; <span class="title">input_it</span><span class="params">(cin)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = *input_it; <span class="comment">// 注意：“*”解引用操作就是输入操作</span></span><br><span class="line">    cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    ++input_it; <span class="comment">// 迭代器需要“前进”偏移，否则会指向同一个“位置”</span></span><br><span class="line">    num = *input_it;</span><br><span class="line">    cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输入：123</span></span><br><span class="line"><span class="comment">// 输出：123</span></span><br><span class="line"><span class="comment">// 输入：456</span></span><br><span class="line"><span class="comment">// 输出：456</span></span><br></pre></td></tr></table></figure><p>输出迭代器</p><ul><li>向<strong>输出流</strong>中<strong>逐个</strong>写入数据</li><li>支持单次遍历</li><li>ostream_iterator&lt;&gt;</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::ostream_iterator;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 输出迭代器</span></span><br><span class="line">    <span class="comment">// ostream_iterator&lt;int&gt; output_it(cout);</span></span><br><span class="line">    <span class="function">ostream_iterator&lt;<span class="type">int</span>&gt; <span class="title">output_it</span><span class="params">(cout, <span class="string">&quot; &quot;</span>)</span></span>;<span class="comment">// 第二个参数：每数据的分隔符</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="number">123</span>;</span><br><span class="line">    *output_it = num; <span class="comment">// 注意：“*”解引用操作就是输出操作</span></span><br><span class="line"></span><br><span class="line">    num = <span class="number">456</span>;</span><br><span class="line">    *output_it = num;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：123 456</span></span><br></pre></td></tr></table></figure><p>前向迭代器</p><ul><li>支持<strong>逐个前进</strong>，不支持<strong>逐个后退</strong></li></ul><blockquote><p>“前进”指“增加”即“++&#x2F;+1”操作，“后退”指“减少”即“–&#x2F;-1”操作。</p></blockquote><ul><li>支持多次遍历</li><li><strong>没有特定的类模板， 是 符合前向迭代器特性的 容器 对应的 迭代器的 类型</strong>（如 forward_list&lt;&gt; ，其底层原理是单向链表，支持单向前进顺序访问，不支持反向后退顺序访问，不支持随机访问，是 符合前向迭代器特性的 容器，其对应的 迭代器的 类型 是前向迭代器）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="comment">// #include &lt;iterator&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::forward_list;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    forward_list&lt;<span class="type">int</span>&gt; for_list&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前向迭代器</span></span><br><span class="line">    forward_list&lt;<span class="type">int</span>&gt;::const_iterator it_beg = for_list.<span class="built_in">begin</span>(); <span class="comment">// 数据“0”的“位置”</span></span><br><span class="line">    forward_list&lt;<span class="type">int</span>&gt;::const_iterator it_end = for_list.<span class="built_in">end</span>();   <span class="comment">// 数据“2”的后一个“位置”</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (forward_list&lt;<span class="type">int</span>&gt;::const_iterator it = it_beg; it != it_end; ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：0 1 2</span></span><br></pre></td></tr></table></figure><p>双向迭代器</p><ul><li><p>支持<strong>逐个前进</strong>，支持<strong>逐个后退</strong></p></li><li><p>支持多次遍历</p></li><li><p><strong>没有特定的类模板， 是 符合双向迭代器特性的 容器 对应的 迭代器的 类型</strong>（如 list&lt;&gt; ，其底层原理是双向链表，支持单向前进顺序访问，支持反向后退顺序访问，不支持随机访问，是 符合双向迭代器特性的 容器，其对应的 迭代器的 类型 是双向迭代器）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="comment">// #include &lt;iterator&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::list;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; li = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双向迭代器</span></span><br><span class="line">    list&lt;<span class="type">int</span>&gt;::const_iterator it_beg = li.<span class="built_in">begin</span>(); <span class="comment">// 数据“0”的“位置”</span></span><br><span class="line">    list&lt;<span class="type">int</span>&gt;::const_iterator it_end = li.<span class="built_in">end</span>();   <span class="comment">// 数据“2”的后一个“位置”</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (list&lt;<span class="type">int</span>&gt;::const_iterator it = it_beg; it != it_end; ++it) <span class="comment">// 前进遍历</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    list&lt;<span class="type">int</span>&gt;::const_reverse_iterator it_rbeg = li.<span class="built_in">rbegin</span>(); <span class="comment">// 数据“2”的“位置”</span></span><br><span class="line">    list&lt;<span class="type">int</span>&gt;::const_reverse_iterator it_rend = li.<span class="built_in">rend</span>();   <span class="comment">// 数据“0”的前一个“位置”</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (list&lt;<span class="type">int</span>&gt;::const_reverse_iterator it = it_rbeg; it != it_rend; ++it) <span class="comment">// 后退遍历</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：0 1 2</span></span><br><span class="line"><span class="comment">// 输出：2 1 0</span></span><br></pre></td></tr></table></figure><p>随机访问迭代器</p></li><li><p>支持<strong>任意前进和后退</strong></p></li><li><p>支持多次遍历</p></li><li><p><strong>没有特定的类模板， 是 符合随机访问迭代器特性的 容器 对应的 迭代器的 类型</strong>（如 vector&lt;&gt; ，其底层原理是动态数组，支持随机访问，是 符合随机访问迭代器特性的 容器，其对应的 迭代器的 类型 是随机访问迭代器）</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="comment">// #include &lt;iterator&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机访问迭代器</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::const_iterator it_beg = vec.<span class="built_in">begin</span>(); <span class="comment">// 数据“0”的“位置”</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; *(it_beg + <span class="number">2</span>) &lt;&lt; endl; <span class="comment">// 数据“2”的“位置”   随机访问</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：2</span></span><br></pre></td></tr></table></figure><p>连续迭代器</p><ul><li>C++17 标准引入</li><li>支持<strong>任意前进和后退</strong></li><li>支持多次遍历</li><li>与随机访问迭代器不同，连续迭代器保证数据在内存中是连续存储的，可以提供更高效的内存访问</li><li><strong>没有特定的类模板， 是 符合连续迭代器特性的 容器 对应的 迭代器的 类型</strong>（如 vector&lt;&gt; ，其底层原理是动态数组，支持随机访问，数据连续存储，是 符合连续迭代器特性的 容器，其对应的 迭代器的 类型 是连续迭代器）<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="comment">// #include &lt;iterator&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连续迭代器</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::const_iterator it_beg = vec.<span class="built_in">begin</span>(); <span class="comment">// 数据“0”的“位置”</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; *(it_beg + <span class="number">2</span>) &lt;&lt; endl; <span class="comment">// 数据“2”的“位置”   随机访问</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：2</span></span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="容器对应的迭代器的类型"><a href="#容器对应的迭代器的类型" class="headerlink" title="容器对应的迭代器的类型"></a>容器对应的迭代器的类型</h2><p>数组&#x2F;向量</p><table><thead><tr><th>容器</th><th>对应的迭代器的类型</th></tr></thead><tbody><tr><td>array</td><td>随机访问迭代器</td></tr><tr><td>vector</td><td>随机访问迭代器</td></tr></tbody></table><p>链表</p><table><thead><tr><th>容器</th><th>对应的迭代器的类型</th></tr></thead><tbody><tr><td>list</td><td>双向迭代器</td></tr><tr><td>forward_list</td><td>前向迭代器</td></tr></tbody></table><p>栈</p><table><thead><tr><th>容器</th><th>对应的迭代器的类型</th></tr></thead><tbody><tr><td>stack</td><td>不支持迭代器</td></tr></tbody></table><p>队列</p><table><thead><tr><th>容器</th><th>对应的迭代器的类型</th></tr></thead><tbody><tr><td>deque</td><td>随机访问迭代器</td></tr><tr><td>queue</td><td>不支持迭代器</td></tr><tr><td>priority_queue</td><td>不支持迭代器</td></tr></tbody></table><p>图&#x2F;映射</p><table><thead><tr><th>容器</th><th>对应的迭代器的类型</th></tr></thead><tbody><tr><td>map</td><td>双向迭代器</td></tr><tr><td>multimap</td><td>双向迭代器</td></tr><tr><td>unordered_map</td><td>前向迭代器</td></tr><tr><td>unordered_multimap</td><td>前向迭代器</td></tr></tbody></table><p>集合</p><table><thead><tr><th>容器</th><th>对应的迭代器的类型</th></tr></thead><tbody><tr><td>set</td><td>双向迭代器</td></tr><tr><td>multiset</td><td>双向迭代器</td></tr><tr><td>unordered_set</td><td>前向迭代器</td></tr><tr><td>unordered_multiset</td><td>前向迭代器</td></tr></tbody></table><p>对组</p><table><thead><tr><th>容器</th><th>对应的迭代器的类型</th></tr></thead><tbody><tr><td>pair</td><td>不支持迭代器</td></tr></tbody></table><p>元组</p><table><thead><tr><th>容器</th><th>对应的迭代器类型</th></tr></thead><tbody><tr><td>tuple</td><td>不支持迭代器</td></tr></tbody></table><p>总表</p><table><thead><tr><th>容器</th><th>对应的迭代器的类型</th></tr></thead><tbody><tr><td>array</td><td>随机访问迭代器</td></tr><tr><td>vector</td><td>随机访问迭代器</td></tr><tr><td>list</td><td>双向迭代器</td></tr><tr><td>forward_list</td><td>前向迭代器</td></tr><tr><td>stack</td><td>不支持迭代器</td></tr><tr><td>deque</td><td>随机访问迭代器</td></tr><tr><td>queue</td><td>不支持迭代器</td></tr><tr><td>priority_queue</td><td>不支持迭代器</td></tr><tr><td>map</td><td>双向迭代器</td></tr><tr><td>multimap</td><td>双向迭代器</td></tr><tr><td>unordered_map</td><td>前向迭代器</td></tr><tr><td>unordered_multimap</td><td>前向迭代器</td></tr><tr><td>set</td><td>双向迭代器</td></tr><tr><td>multiset</td><td>双向迭代器</td></tr><tr><td>unordered_set</td><td>前向迭代器</td></tr><tr><td>unordered_multiset</td><td>前向迭代器</td></tr><tr><td>pair</td><td>不支持迭代器</td></tr><tr><td>tuple</td><td>不支持迭代器</td></tr></tbody></table><hr><h2 id="作用（为什么需要）-2"><a href="#作用（为什么需要）-2" class="headerlink" title="作用（为什么需要）"></a>作用（为什么需要）</h2><ul><li><strong>连接</strong>容器和算法</li><li><strong>代表</strong>容器组织的数据：无需关心数据的内部实现细节，以统一的方式表示数据</li><li><strong>通过</strong>算法处理数据：操作数据时，以“逐一访问”&#x2F;遍历的表现形式</li><li>类比：容器 -&gt; 数组，算法 -&gt; 遍历，迭代器 -&gt;数组下标。为了实现遍历，需要通过数组下标获取数组的数据 -&gt; 为了实现算法，需要通过迭代器获取容器的数据</li></ul><hr><h1 id="容器，算法，迭代器代码示例"><a href="#容器，算法，迭代器代码示例" class="headerlink" title="容器，算法，迭代器代码示例"></a>容器，算法，迭代器代码示例</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>    <span class="comment">// vector&lt;&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span> <span class="comment">// find()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 容器</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;; <span class="comment">// 有“0、1和2”3个数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::const_iterator it_beg = vec.<span class="built_in">begin</span>(); <span class="comment">// 数据“0”的“位置”</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::const_iterator it_end = vec.<span class="built_in">end</span>();   <span class="comment">// 数据“2”的后一个“位置”</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::const_iterator it_res = vec.<span class="built_in">end</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 算法</span></span><br><span class="line">    it_res = std::<span class="built_in">find</span>(it_beg, it_end, <span class="number">1</span>); <span class="comment">// 查找数据“1”</span></span><br><span class="line">    <span class="keyword">if</span> (it_res != it_end)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;查找到数据&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;未查找到数据&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 输出：查找到数据</span></span><br></pre></td></tr></table></figure><hr><h1 id="适配器（adapter）"><a href="#适配器（adapter）" class="headerlink" title="适配器（adapter）"></a>适配器（adapter）</h1><h2 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h2><ul><li><strong>封装已有目标</strong>（容器、迭代器和函数）<strong>，提供不同形式的接口</strong>（特性和函数等）</li><li>类比：电源适配器将 220V 的交流电转换成 20V 的直流电提供给笔记本电脑；设计模式的适配器模式</li></ul><h2 id="类型和代码示例-1"><a href="#类型和代码示例-1" class="headerlink" title="类型和代码示例"></a>类型和代码示例</h2><p>类型</p><ul><li>容器适配器</li><li>迭代器适配器 <strong>（少用）</strong></li><li>函数适配器 <strong>（少用）</strong></li></ul><p>容器适配器</p><ul><li>stack&lt;&gt;</li><li>queue&lt;&gt;</li><li>priority_queue&lt;&gt;</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span> <span class="comment">// stack&lt;&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::stack;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 容器适配器</span></span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; st&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    st.<span class="built_in">push</span>(<span class="number">0</span>); <span class="comment">// 入栈</span></span><br><span class="line">    st.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; st.<span class="built_in">top</span>() &lt;&lt; endl; <span class="comment">// 获取栈顶数据</span></span><br><span class="line"></span><br><span class="line">    st.<span class="built_in">pop</span>(); <span class="comment">// 出栈</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; st.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：1</span></span><br><span class="line"><span class="comment">// 输出：0</span></span><br></pre></td></tr></table></figure><p>迭代器适配器</p><ul><li>反向迭代器：reverse_iterator&lt;&gt;</li><li>插入迭代器：back_insert_iterator&lt;&gt;，front_insert_iterator&lt;&gt;，insert_iterator&lt;&gt;</li><li>流迭代器：istream_iterator&lt;&gt;，ostream_iterator&lt;&gt;</li><li>流缓冲迭代器：istreambuf_iterator&lt;&gt;，ostreambuf_iterator&lt;&gt;</li><li>移动迭代器：move_iterator&lt;&gt;</li></ul><blockquote><p>注意：“迭代器”和“迭代器适配器”的类型中有重叠的类型。如：stream_iterator&lt;&gt;，从“输入”的角度， 是“迭代器”的“输入迭代器”类型；从“流”的角度，是“迭代器适配器”的“流迭代器”类型。</p></blockquote><blockquote><p>一般不区分容器和容器适配器，迭代器和迭代器适配器。</p></blockquote><blockquote><p>代码示例见“迭代器”内容。</p></blockquote><p><strong>函数（普通函数、类方法、 仿函数和 Lambda 表达式等）</strong> 适配器</p><blockquote><p>注意：很多函数适配器已不推荐&#x2F;过时&#x2F;弃用：bind1st()、std::bind2nd() 和 mem_fun() 等，请注意甄别</p></blockquote><ul><li>改变函数参数：bind()</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span> <span class="comment">// bind()，placeholders</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> <span class="comment">// add()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 函数适配器</span></span><br><span class="line">    <span class="keyword">auto</span> add_bind = std::<span class="built_in">bind</span>(add, <span class="number">1</span>, std::placeholders::_1); <span class="comment">// 绑定 add() 的第一个参数为数据“1”</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">add_bind</span>(<span class="number">2</span>); <span class="comment">// 调用 add_bind(x)，实际上是调用 add(1, x)</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：3</span></span><br></pre></td></tr></table></figure><ul><li>封装函数：function&lt;&gt;</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span> <span class="comment">// function&lt;&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> <span class="comment">// add()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 函数适配器</span></span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; add_func = add; <span class="comment">// 封装 add()</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">add_func</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 调用 add_func(x, y)，实际上是调用 add(x, y)</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：3</span></span><br></pre></td></tr></table></figure><hr><h2 id="作用（为什么需要）-3"><a href="#作用（为什么需要）-3" class="headerlink" title="作用（为什么需要）"></a>作用（为什么需要）</h2><p>适配器</p><ul><li>可以在<strong>已有目标</strong>（容器、迭代器和函数）的基础上<strong>提供不同形式的接口</strong>（特性和函数等），以满足特定场景需求</li><li>如：已有容器不满足栈数据结构的特性，封装双端队列 deque&lt;&gt; 容器形成 stack&lt;&gt; 容器适配器。直接使用 stack&lt;&gt; 存储数据，而无需自己编写“栈”数据结构</li><li>如：已有容器不满足队列数据结构的特性，封装双端队列 deque&lt;&gt; 容器形成 queue&lt;&gt; 容器适配器。直接使用 queue&lt;&gt; 存储数据，而无需自己编写“队列”数据结构</li></ul><hr><h1 id="仿函数（functor）"><a href="#仿函数（functor）" class="headerlink" title="仿函数（functor）"></a>仿函数（functor）</h1><h2 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h2><ul><li>重载调用运算符（小括号“()”）的<strong>类的对象</strong>。（所以又称：函数对象）</li><li>重载调用运算符（小括号“()”）的<strong>类的对象</strong> 使用调用运算符时，表现形式和普通函数调用一样（所以称作：仿造的函数 -&gt; 仿函数）</li><li>类比：函数指针；Lambda 表达式</li></ul><h2 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h2><p>一般使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仿函数类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Add_functor</span> <span class="comment">// add()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 + num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 仿函数（对象）</span></span><br><span class="line">    Add_functor add_functor;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">add_functor</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：3</span></span><br></pre></td></tr></table></figure><p>算法使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仿函数类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Comp</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;num1, <span class="type">const</span> <span class="type">int</span> &amp;num2)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 &gt; num2; <span class="comment">// 左数比右数大则返回 true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  仿函数（对象）</span></span><br><span class="line">    Comp comp;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), comp); <span class="comment">// std::sort() 默认从小到大排序，使用仿函数（对象）定制从大到小排序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> &amp;v : vec)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; v &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：2 1 0</span></span><br></pre></td></tr></table></figure><hr><h2 id="作用（为什么需要）-4"><a href="#作用（为什么需要）-4" class="headerlink" title="作用（为什么需要）"></a>作用（为什么需要）</h2><ul><li>可以代替<strong>函数指针</strong>（函数指针的签名复杂）</li></ul><blockquote><p>函数指针：指向函数的指针</p></blockquote><ul><li>可以通过类的特性封装更多信息，执行更多操作</li></ul><blockquote><p>参见：<a href="https://blog.csdn.net/u014386899/article/details/108590804">为什么要用仿函数？_为什么要把函数写成仿函数-CSDN博客</a></p></blockquote><hr><h1 id="分配器（allocator）"><a href="#分配器（allocator）" class="headerlink" title="分配器（allocator）"></a>分配器（allocator）</h1><h2 id="概念-6"><a href="#概念-6" class="headerlink" title="概念"></a>概念</h2><ul><li>为<strong>容器</strong>提供<strong>自定义的内存分配和释放，对象构造和析构</strong>功能（所以称作：分配空间的器具 -&gt; 分配器）</li></ul><blockquote><p>一般类型（内置类型和自定义类型等）内存分配（在堆上的动态内存分配）<strong>不推荐</strong>使用分配器（难用），容器分配内存<strong>可以</strong>使用分配器（<strong>少用</strong>，有需求才用）</p></blockquote><blockquote><p><strong>分配器本质：</strong> 将 1. 内存分配和对象构造 和 2. 对象析构和内存释放 两个过程 拆分成 1. 内存分配 2. 对象构造 3. 对象析构 4. 内存释放 四个过程，通过定制内存管理策略提高灵活性和效率</p></blockquote><ul><li>类比：malloc() - free()；构造函数 - 析构函数；new - delete</li></ul><hr><h2 id="代码示例-3"><a href="#代码示例-3" class="headerlink" title="代码示例"></a>代码示例</h2><p>一般类型（内置类型和自定义类型等）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span> <span class="comment">// allocator&lt;&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::allocator;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 分配器</span></span><br><span class="line">    allocator&lt;<span class="type">int</span>&gt; allo;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 内存分配</span></span><br><span class="line">    <span class="type">int</span> *int_ptr = allo.<span class="built_in">allocate</span>(<span class="number">1</span>); <span class="comment">// 分配1个原始的/未初始化的 int 类型数据的内存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 对象构造</span></span><br><span class="line">    allo.<span class="built_in">construct</span>(int_ptr, <span class="number">3</span>); <span class="comment">// 构造对象数据为“3”</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; *int_ptr &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 对象析构</span></span><br><span class="line">    allo.<span class="built_in">destroy</span>(int_ptr); <span class="comment">// 析构对象数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 内存释放</span></span><br><span class="line">    allo.<span class="built_in">deallocate</span>(int_ptr, <span class="number">1</span>); <span class="comment">// 释放1个原始的/未初始化的 int 类型数据的内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：3</span></span><br></pre></td></tr></table></figure><p>容器类型</p><ul><li><strong>大多数</strong>（vector&lt;&gt; 和 list&lt;&gt; 等）容器的实现中，形参有一个默认分配器，其设计得足够安全和高效，<strong>一般不需要定制，</strong> 容器自动调用该默认分配器管理空间</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vector&lt;&gt; 的声明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Allocator</span> = std::allocator&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> vector;</span><br></pre></td></tr></table></figure><ul><li><strong>有需求时需要自定义分配器</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="comment">// #include &lt;memory&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （自定义）分配器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomAllocator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 容器的设计要求：分配器必须提供一个“value_type”的类型别名，以便容器使用分配器时知道数据的类型</span></span><br><span class="line">    <span class="keyword">using</span> value_type = T;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造</span></span><br><span class="line">    <span class="built_in">CustomAllocator</span>() <span class="keyword">noexcept</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存分配</span></span><br><span class="line">    <span class="comment">// 可能失败，不声明为 noexcept</span></span><br><span class="line">    <span class="function">T *<span class="title">allocate</span><span class="params">(std::<span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Allocating memory for &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; objects.&quot;</span> &lt;&lt; std::endl; <span class="comment">// 定制化体现</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> std::allocator&lt;T&gt;&#123;&#125;.<span class="built_in">allocate</span>(n); <span class="comment">// 使用标准分配器分配内存</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存释放</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">(T *p, std::<span class="type">size_t</span> n)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Deallocating memory for &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; objects.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        std::allocator&lt;T&gt;&#123;&#125;.<span class="built_in">deallocate</span>(p, n); <span class="comment">// 使用标准分配器释放内存</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象构造</span></span><br><span class="line">    <span class="comment">// 可能失败，不声明为 noexcept</span></span><br><span class="line">    <span class="comment">// typename...：声名可变参数模板</span></span><br><span class="line">    <span class="comment">// Args：类型参数包的名称；包含零或多个类型参数；指的是类型</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// args：值参数包的名称；包含零或多个值参数；指的是值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Args：可变参数的类型</span></span><br><span class="line">    <span class="comment">// &amp;&amp;：（右值引用）保留传递给函数的 参数的 值的 特性（常量/引用左值/右值）</span></span><br><span class="line">    <span class="comment">// ...：折叠运算符（在参数左边）</span></span><br><span class="line">    <span class="comment">// args：可变参数的值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// new：new 运算符：1. 内存分配 2. 对象构造</span></span><br><span class="line">    <span class="comment">// new：placement new 运算符：对象构造</span></span><br><span class="line">    <span class="comment">// placement new 运算符需要一个 void* 参数，以指定在哪个内存地址上构造对象</span></span><br><span class="line">    <span class="comment">// forward&lt;&gt;()：完美转发：1. 类型（Args） 2. 值的特性（&amp;&amp;） 3. 值（args）</span></span><br><span class="line">    <span class="comment">// ...：展开运算符（在参数右边）</span></span><br><span class="line">    <span class="comment">// (args...)：展开所有参数并作为 forward&lt;&gt;() 的参数 ×</span></span><br><span class="line">    <span class="comment">// (args)...：分别展开所有参数并分别作为 forward&lt;&gt;() 的参数 √</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用搭配</span></span><br><span class="line">    <span class="comment">// malloc() - free()</span></span><br><span class="line">    <span class="comment">// 构造 - 析构</span></span><br><span class="line">    <span class="comment">// new - delete</span></span><br><span class="line">    <span class="comment">// 内存分配 - placement new - 析构 - delete</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">construct</span><span class="params">(U *p, Args &amp;&amp;...args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Constructing object.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> ((<span class="type">void</span> *)p) <span class="built_in">U</span>(std::forward&lt;Args&gt;(args)...); <span class="comment">// 使用对象的构造函数构造对象</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数，用于在分配的内存上销毁对象</span></span><br><span class="line">    <span class="comment">// 没有 placement detele 运算符</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">destroy</span><span class="params">(U *p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Destroying object.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        p-&gt;~<span class="built_in">U</span>(); <span class="comment">// 使用对象的析构函数析构对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// （自定义）分配器</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>, CustomAllocator&lt;<span class="type">int</span>&gt;&gt; vec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 内存分配</span></span><br><span class="line">    <span class="comment">// 2. 对象构造</span></span><br><span class="line">    <span class="comment">// 3. 对象析构</span></span><br><span class="line">    <span class="comment">// 4. 内存释放</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输出：</span></span><br><span class="line"><span class="comment">Allocating memory for 1 objects.</span></span><br><span class="line"><span class="comment">Constructing object.</span></span><br><span class="line"><span class="comment">Allocating memory for 2 objects.</span></span><br><span class="line"><span class="comment">Constructing object.</span></span><br><span class="line"><span class="comment">Constructing object.</span></span><br><span class="line"><span class="comment">Destroying object.</span></span><br><span class="line"><span class="comment">Deallocating memory for 1 objects.</span></span><br><span class="line"><span class="comment">Destroying object.</span></span><br><span class="line"><span class="comment">Destroying object.</span></span><br><span class="line"><span class="comment">Deallocating memory for 2 objects.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/* 逐行分析：</span></span><br><span class="line"><span class="comment">1.1 第一个容器内存分配</span></span><br><span class="line"><span class="comment">1.2 第一个容器第一个对象构造</span></span><br><span class="line"><span class="comment">2.1 第二个容器内存分配（容器扩容）</span></span><br><span class="line"><span class="comment">2.2 第二个容器第一个对象构造</span></span><br><span class="line"><span class="comment">2.2 第二个容器第二个对象构造</span></span><br><span class="line"><span class="comment">1.3 第一个容器第一个对象析构</span></span><br><span class="line"><span class="comment">1.4 第一个容器内存释放</span></span><br><span class="line"><span class="comment">2.3 第二个容器第二个对象析构</span></span><br><span class="line"><span class="comment">2.3 第二个容器第一个对象析构</span></span><br><span class="line"><span class="comment">2.4 第二个容器内存释放</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h2 id="作用（为什么需要）-5"><a href="#作用（为什么需要）-5" class="headerlink" title="作用（为什么需要）"></a>作用（为什么需要）</h2><ul><li>可以为<strong>容器</strong>提供<strong>自定义的内存分配和释放，对象构造和析构</strong>功能</li></ul><blockquote><p><strong>分配器本质：</strong> 将 1. 内存分配和对象构造 和 2. 对象析构和内存释放 两个过程 拆分成 1. 内存分配 2. 对象构造 3. 对象析构 4. 内存释放 四个过程，通过定制内存管理策略提高灵活性和效率</p></blockquote><ul><li>可以先进行内存分配（占位置），有数据时再进行对象构造，以避免对象构造（二次赋值&#x2F;拷贝）开销</li><li>可以先进行对象析构，不需要空间时再进行内存释放，以避免内存释放开销</li></ul><blockquote><p>参见：<a href="https://www.jianshu.com/p/bfcf95a2a204">C++:allocator 学习整理 - 简书 (jianshu.com)</a></p></blockquote><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>C++ STL 六组件介绍。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><p><a href="https://c.biancheng.net/view/6593.html">C++ STL基本组成（6大组件+13个头文件） (biancheng.net)</a></p></li><li><p><a href="https://blog.csdn.net/m0_62083249/article/details/128418167">C++的基于对象编程范式、常用STL容器和C++11标准_基于对象的编程范式_夜悊的博客-CSDN博客</a></p></li><li><p><a href="https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5">cppreference.com</a></p></li><li><p><a href="https://blog.csdn.net/junxuezheng/article/details/129804072#:~:text=1%203%E7%A7%8D%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8%EF%BC%9A%E5%88%86%E5%88%AB%E6%98%AF%20%E5%8F%8D%E5%90%91%E8%BF%AD%E4%BB%A3%E5%99%A8%20%E9%80%82%E9%85%8D%E5%99%A8%E3%80%81%20%E6%8F%92%E5%85%A5%E5%9E%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%20%E9%80%82%E9%85%8D%E5%99%A8%E3%80%81%20%E7%A7%BB%E5%8A%A8%E8%BF%AD%E4%BB%A3%E5%99%A8,%E9%80%82%E9%85%8D%E5%99%A8%E3%80%82%202%202%E7%A7%8D%E6%B5%81%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%9A%20%E6%B5%81%E8%BF%AD%E4%BB%A3%E5%99%A8%20%E3%80%81%20%E6%B5%81%E7%BC%93%E5%86%B2%E5%8C%BA%E8%BF%AD%E4%BB%A3%E5%99%A8%20%E3%80%81">【STL十三】适配器——迭代器适配器_郑同学的笔记的博客-CSDN博客</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/610255181">C++ STL：适配器 - 知乎 (zhihu.com)</a></p></li><li><p><a href="https://c.biancheng.net/stl/iterator_adaptor/">C++ STL迭代器适配器完全攻略 (biancheng.net)</a></p></li><li><p><a href="https://blog.csdn.net/u014386899/article/details/108590804">为什么要用仿函数？_为什么要把函数写成仿函数-CSDN博客</a></p></li><li><p><a href="https://www.jianshu.com/p/bfcf95a2a204">C++:allocator 学习整理 - 简书 (jianshu.com)</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/99427686#:~:text=%E5%AE%9A%E4%BD%8D%20%28placement%29%20new%20%E8%BF%90%E7%AE%97%E7%AC%A6%20%E5%85%81%E8%AE%B8%E6%88%91%E4%BB%AC%E5%B0%86%20object%20%E6%88%96%E8%80%85%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%88%9B%E5%BB%BA%E5%9C%A8%E5%B7%B2%E7%94%B3%E8%AF%B7%E7%9A%84%E5%86%85%E5%AD%98%E4%B8%AD%EF%BC%8C%E5%B9%B6%E4%B8%94%20%E5%AE%9A%E4%BD%8D,%E5%AE%9A%E4%BD%8D%20%28placement%29%20delete%20%EF%BC%8C%E5%9B%A0%E4%B8%BA%20%E5%AE%9A%E4%BD%8D%20new%20%E8%BF%90%E7%AE%97%E7%AC%A6%20%E6%B2%A1%E6%9C%89%E7%94%B3%E8%AF%B7%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4">C&#x2F;C++内存申请和释放(二) - 知乎 (zhihu.com)</a></p></li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>环境编程代码实例：“加/卸载” Zend Framework 2</title>
      <link href="/2023/10/25/%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%BB%A3%E7%A0%81%E5%AE%9E%E4%BE%8B%EF%BC%9A%E2%80%9C%E5%8A%A0_%E5%8D%B8%E8%BD%BD%E2%80%9D%20Zend%20Framework%202/"/>
      <url>/2023/10/25/%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%BB%A3%E7%A0%81%E5%AE%9E%E4%BE%8B%EF%BC%9A%E2%80%9C%E5%8A%A0_%E5%8D%B8%E8%BD%BD%E2%80%9D%20Zend%20Framework%202/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>环境编程代码实例：“加&#x2F;卸载” Zend Framework 2。</p><hr><h1 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h1><ul><li><a href="https://github.com/yezhening/Environment-and-network-programming-examples">yezhening&#x2F;Environment-and-network-programming-examples: 环境和网络编程实例 (github.com)</a></li><li><a href="https://gitee.com/yezhening/Environment-and-network-programming-examples">Environment-and-network-programming-examples: 环境和网络编程实例 (gitee.com)</a></li></ul><hr><h1 id="需求介绍"><a href="#需求介绍" class="headerlink" title="需求介绍"></a>需求介绍</h1><p>现状：已存在旧生产项目，系统使用 Zend Framework 2（基于 PHP 的 Web MVC 框架，简称 ZF2）</p><p>目标：简化 ZF2 的配置</p><p>内容：</p><ol><li>将 ZF2 的供应镜像可执行文件加载到内存，并<strong>映射&#x2F;解映射</strong>到虚拟设备的一个分区</li><li>将虚拟设备的文件系统<strong>挂&#x2F;卸载</strong>到目录</li></ol><p>实现：</p><ul><li>环境：FreeBSD（服务器）</li><li>语言：C&#x2F;C++（程序）</li><li>核心：执行 Shell 命令（程序使用 UNIX -&gt; FreeBSD 的系统调用）</li><li>要求：可靠（尽可能地考虑并处理错误情况）</li></ul><hr><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul><li>由于代码篇幅较多，在博客中直接粘贴并呈现会显得冗长，因此未在博客中放置<strong>完整</strong>代码，只展示<strong>核心片段</strong>代码。请前往”代码仓库”查看或获取相关代码</li><li>注释有详细解析</li></ul><hr><h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><ul><li>文件夹：load_ZF2</li><li>源文件：main.cpp</li><li>可执行文件：main</li><li>说明文件：readme.txt</li><li>配置文件：setupvendor.conf</li><li>ZF2 的供应镜像文件：ZF2VendorImage.bin（<strong>因为是生产项目，未将该文件开源在代码仓库</strong>）</li></ul><hr><h2 id="核心片段"><a href="#核心片段" class="headerlink" title="核心片段"></a>核心片段</h2><p>结构体和全局变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SystemFile</span> <span class="comment">// 系统文件</span></span><br><span class="line">&#123;</span><br><span class="line">    string file_name;   <span class="comment">// 文件名称</span></span><br><span class="line">    string virtual_dev; <span class="comment">// 挂载设备号</span></span><br><span class="line">    string mount_dir;   <span class="comment">// 挂载目录</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// const string g_config_file_path(&quot;./setupvendor.conf&quot;); // 配置文件路径</span></span><br><span class="line"><span class="function"><span class="type">const</span> string <span class="title">g_config_file_path</span><span class="params">(<span class="string">&quot;/usr/local/etc/setupvendor.conf&quot;</span>)</span></span>; <span class="comment">// 配置文件路径</span></span><br><span class="line"><span class="function"><span class="type">const</span> string <span class="title">g_file_num_key</span><span class="params">(<span class="string">&quot;file_num&quot;</span>)</span></span>;                            <span class="comment">// 配置文件中系统文件数量的键</span></span><br><span class="line"><span class="function">string <span class="title">g_file_num_value</span><span class="params">(<span class="string">&quot;&quot;</span>)</span></span>;                                        <span class="comment">// 配置文件中系统文件数量的值</span></span><br><span class="line"><span class="type">int</span> g_file_num_value2 = <span class="number">0</span>;                                          <span class="comment">// 配置文件中系统文件数量的值2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> string <span class="title">g_file_name_key</span><span class="params">(<span class="string">&quot;file_name&quot;</span>)</span></span>;     <span class="comment">// 配置文件中系统文件名称的键</span></span><br><span class="line"><span class="function"><span class="type">const</span> string <span class="title">g_virtual_dev_key</span><span class="params">(<span class="string">&quot;virtual_dev&quot;</span>)</span></span>; <span class="comment">// 配置文件中虚拟设备号的键</span></span><br><span class="line"><span class="function"><span class="type">const</span> string <span class="title">g_mount_dir_key</span><span class="params">(<span class="string">&quot;mount_dir&quot;</span>)</span></span>;     <span class="comment">// 配置文件中挂载目录的键</span></span><br><span class="line">vector&lt;<span class="keyword">struct</span> SystemFile&gt; g_system_file_vec&#123;&#125;; <span class="comment">// 系统文件向量</span></span><br></pre></td></tr></table></figure><p>函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在配置文件的一行字符串【键 = 值换行符】中，依据键获取值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_key_value</span><span class="params">(<span class="type">const</span> string &amp;line, <span class="type">const</span> string &amp;key, string &amp;value)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 获取系统文件数量</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_system_file_num</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 获取系统文件配置</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_system_file_config</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 执行命令</span></span></span><br><span class="line"><span class="function"><span class="comment">// 输入：命令，参数数组，参数数量</span></span></span><br><span class="line"><span class="function"><span class="comment">// 注意execv需要char*const*参数</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exec_cmd</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cmd, <span class="type">char</span> *<span class="type">const</span> arg[], <span class="type">const</span> <span class="type">int</span> arg_size)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 挂载文件系统</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mount_file_system</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 卸载文件系统</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">umount_file_system</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br></pre></td></tr></table></figure><p>执行命令函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行命令</span></span><br><span class="line"><span class="comment">// 输入：命令，参数数组，参数数量</span></span><br><span class="line"><span class="comment">// 注意execv需要char*const*参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exec_cmd</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cmd, <span class="type">char</span> *<span class="type">const</span> arg[], <span class="type">const</span> <span class="type">int</span> arg_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arg_size; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; arg[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid = fork(); <span class="comment">// 进程号</span></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;exec_cmd() fork() error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">execv</span>(cmd, arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pid != 0</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;                   <span class="comment">// 系统调用返回结果</span></span><br><span class="line">    <span class="type">int</span> status = <span class="number">0</span>;                 <span class="comment">// 进程结束状态</span></span><br><span class="line">    ret = <span class="built_in">waitpid</span>(pid, &amp;status, <span class="number">0</span>); <span class="comment">// 等待子进程，结束状态，阻塞等待</span></span><br><span class="line">    <span class="keyword">if</span> ((ret == <span class="number">-1</span>) || ((<span class="built_in">WIFEXITED</span>(status)) &amp;&amp; (<span class="built_in">WEXITSTATUS</span>(status) != <span class="number">0</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;exec_cmd() Execute command error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 依据参数判断挂载或卸载文件系统</span></span><br><span class="line">    <span class="keyword">if</span> (argc &gt;= <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;main() Argument number error&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((argc == <span class="number">2</span>) &amp;&amp; (((<span class="built_in">strncmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;umount&quot;</span>, <span class="number">6</span>)) != <span class="number">0</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;main() Invalid argument error&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">get_system_file_num</span>();    <span class="comment">// 获取系统文件数量</span></span><br><span class="line">    <span class="built_in">get_system_file_config</span>(); <span class="comment">// 获取系统文件配置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((argc == <span class="number">2</span>) &amp;&amp; (((<span class="built_in">strncmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;umount&quot;</span>, <span class="number">6</span>)) == <span class="number">0</span>))) <span class="comment">// 有2个参数且第二个是umount，则卸载文件系统</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">umount_file_system</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">mount_file_system</span>(); <span class="comment">// 默认1个参数挂载文件系统</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><ul><li>该份实例实际上是在 UNIX&#x2F;FreeBSD&#x2F;Linux 环境使用 C&#x2F;C++ 程序执行 Shell 命令的<strong>特例</strong>版本</li><li>看懂代码后，稍加修改，该份实例可以成为<strong>通用</strong>版本</li></ul><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>环境编程代码实例：“加&#x2F;卸载” Zend Framework 2。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《UNIX环境高级编程（第3版）》作者：W.Richard Stevens，Stephen A.Rago</li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 环境和网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境和网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++代码示例：进制数简单生成工具</title>
      <link href="/2023/10/02/C++%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%EF%BC%9A%E8%BF%9B%E5%88%B6%E6%95%B0%E7%AE%80%E5%8D%95%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7/"/>
      <url>/2023/10/02/C++%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%EF%BC%9A%E8%BF%9B%E5%88%B6%E6%95%B0%E7%AE%80%E5%8D%95%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>C++代码示例：进制数简单生成工具。</p><hr><h1 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h1><ul><li><a href="https://github.com/yezhening/Programming-examples">yezhening&#x2F;Programming-examples: 编程实例 (github.com)</a></li><li><a href="https://gitee.com/yezhening/Programming-examples">Programming-examples: 编程实例 (gitee.com)</a></li></ul><hr><h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><ul><li>简单地生成进制数</li><li><strong>有详细的步骤解析</strong></li></ul><hr><h1 id="代码（有详细注释）"><a href="#代码（有详细注释）" class="headerlink" title="代码（有详细注释）"></a>代码（有详细注释）</h1><p>cdigital.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CDigital</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CDigital</span>(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;bases) : <span class="built_in">bases</span>(bases), <span class="built_in">curDig</span>(<span class="number">0</span>), <span class="built_in">digCount</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">next</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 第一次进入初始化当前组合，如bases.size()=3，this-&gt;curDig为000，从000开始遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;curDig.<span class="built_in">empty</span>() == <span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;curDig.<span class="built_in">resize</span>(bases.<span class="built_in">size</span>(), <span class="number">0</span>); <span class="comment">// 初始化所有位置为0</span></span><br><span class="line"></span><br><span class="line">            ++<span class="keyword">this</span>-&gt;digCount;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 从后向前找到第一个不是该位置最大值的位置，</span></span><br><span class="line">        <span class="type">int</span> curPos = bases.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ((curPos &gt;= <span class="number">0</span>) &amp;&amp; (<span class="keyword">this</span>-&gt;curDig.<span class="built_in">at</span>(curPos) == <span class="keyword">this</span>-&gt;bases.<span class="built_in">at</span>(curPos) - <span class="number">1</span>)) <span class="comment">// 是最大值就移动位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            --curPos;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (curPos &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 都是最大位置，组合结束</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 然后把该位置数据加1</span></span><br><span class="line">        ++<span class="keyword">this</span>-&gt;curDig.<span class="built_in">at</span>(curPos);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 最后把后面的各个位置写对应的最小值</span></span><br><span class="line">        <span class="comment">// 一般进制的最小值都为0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> right = curPos + <span class="number">1</span>; right &lt; <span class="keyword">this</span>-&gt;bases.<span class="built_in">size</span>(); ++right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;curDig.<span class="built_in">at</span>(right) = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ++<span class="keyword">this</span>-&gt;digCount;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">printCurDig</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> d : <span class="keyword">this</span>-&gt;curDig)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; d &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">printDigCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="keyword">this</span>-&gt;digCount &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> vector&lt;<span class="type">int</span>&gt; bases; <span class="comment">// 各个位置的进制</span></span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; curDig; <span class="comment">// 当前数字“组合”</span></span><br><span class="line">    <span class="type">int</span> digCount;       <span class="comment">// 数字组合数的数量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> vector&lt;<span class="type">int</span>&gt; bases&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>&#125;; <span class="comment">// 不同位置的进制数/取值范围 4表示0~3</span></span><br><span class="line"></span><br><span class="line">    <span class="function">CDigital <span class="title">dig</span><span class="params">(bases)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (dig.<span class="built_in">next</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        dig.<span class="built_in">printCurDig</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    dig.<span class="built_in">printDigCount</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="编译和运行命令"><a href="#编译和运行命令" class="headerlink" title="编译和运行命令"></a>编译和运行命令</h1><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ <span class="literal">-o</span> cdigital cdigital.cpp</span><br><span class="line">./cdigital.exe</span><br></pre></td></tr></table></figure><hr><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p><img src="/../img/cdigital/one.png" alt="在这里插入图片描述"><br><img src="/../img/cdigital/two.png" alt="在这里插入图片描述"></p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>C++代码示例：进制数简单生成工具。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>学校《高级算法设计与分析》课程课件的算法思路</li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++代码示例：排列数简单生成工具</title>
      <link href="/2023/10/01/C++%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%EF%BC%9A%E6%8E%92%E5%88%97%E6%95%B0%E7%AE%80%E5%8D%95%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7/"/>
      <url>/2023/10/01/C++%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%EF%BC%9A%E6%8E%92%E5%88%97%E6%95%B0%E7%AE%80%E5%8D%95%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>C++代码示例：排列数简单生成工具。</p><hr><h1 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h1><ul><li><a href="https://github.com/yezhening/Programming-examples">yezhening&#x2F;Programming-examples: 编程实例 (github.com)</a></li><li><a href="https://gitee.com/yezhening/Programming-examples">Programming-examples: 编程实例 (gitee.com)</a></li></ul><hr><h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><ul><li>简单地生成排列数</li><li><strong>有详细的步骤解析</strong></li></ul><hr><h1 id="代码（有详细注释）"><a href="#代码（有详细注释）" class="headerlink" title="代码（有详细注释）"></a>代码（有详细注释）</h1><p>cpermutation.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::unordered_set;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPermutation</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CPermutation</span>(<span class="type">const</span> <span class="type">int</span> &amp;n, <span class="type">const</span> <span class="type">int</span> &amp;m) : <span class="built_in">n</span>(n), <span class="built_in">m</span>(m), <span class="built_in">flags</span>(<span class="number">0</span>), <span class="built_in">curPerm</span>(<span class="number">0</span>), <span class="built_in">permCount</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">next</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 第一次进入初始化当前排列，如m=3，this-&gt;curPerm为012，从012开始遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;curPerm.<span class="built_in">empty</span>() == <span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">this</span>-&gt;curPerm.<span class="built_in">push_back</span>(i);</span><br><span class="line">                <span class="keyword">this</span>-&gt;flags.<span class="built_in">insert</span>(i); <span class="comment">// 记录哈希</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ++<span class="keyword">this</span>-&gt;permCount;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 首先，确定某个位置是否已经达到了当前意义下的“最大值”—“当前” 的意义：前面的位置数值固定之后</span></span><br><span class="line">        <span class="comment">// 求当前位置应当的最大值</span></span><br><span class="line">        <span class="comment">// 注意理解：如014，索引2位置可取23，最大值为3；索引1位置可取234，最大值为4；索引0位置可取1234，最大值为4，左边位置的取值范围要包括右边的位置</span></span><br><span class="line">        <span class="comment">// 从后往前大到小遍历，如果这个数不在哈希表中就是应该的最大值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 然后，从后向前寻找第一个不是当前最大值的位置</span></span><br><span class="line">        <span class="comment">// 修正：小于当前应当最大值的位置</span></span><br><span class="line">        <span class="comment">// 如014，则求得的位置是索引1</span></span><br><span class="line">        <span class="type">int</span> curPos = <span class="keyword">this</span>-&gt;m - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> curMax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (curPos &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 1.</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="keyword">this</span>-&gt;n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (flags.<span class="built_in">find</span>(i) == flags.<span class="built_in">end</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    curMax = i;</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// 找到就退出for</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;curPerm.<span class="built_in">at</span>(curPos) &gt;= curMax) <span class="comment">// 未找到位置移动</span></span><br><span class="line">            &#123;</span><br><span class="line">                flags.<span class="built_in">erase</span>(<span class="keyword">this</span>-&gt;curPerm.<span class="built_in">at</span>(curPos)); <span class="comment">// 哈希表减少</span></span><br><span class="line">                --curPos;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 找到位置退出while</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (curPos &lt; <span class="number">0</span>) <span class="comment">// 没找到位置搜完排列</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.这个位置上的数值最小限度地增加—“最小限度”，前面的数值排除之后，取剩余的、大于该值的最小值</span></span><br><span class="line">        <span class="comment">// 从前往后小到大遍历，如果这个数不在哈希表中就是应该变换的值</span></span><br><span class="line">        <span class="comment">// 注意：此时可能处理左边的位置，哈希表还是删减状态以让左边位置可以取到右边的值</span></span><br><span class="line">        <span class="comment">// 如014，遍历012到2最小且不在哈希表，将索引1位置元素1换成2，该位置后续可以取到右边的值4，右边的值相应的会减小不再是4保证不重复</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="keyword">this</span>-&gt;curPerm.<span class="built_in">at</span>(curPos); i &lt; <span class="keyword">this</span>-&gt;n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (flags.<span class="built_in">find</span>(i) == flags.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">this</span>-&gt;flags.<span class="built_in">erase</span>(<span class="keyword">this</span>-&gt;curPerm.<span class="built_in">at</span>(curPos)); <span class="comment">// 哈希删除</span></span><br><span class="line">                <span class="keyword">this</span>-&gt;curPerm.<span class="built_in">at</span>(curPos) = i;</span><br><span class="line">                <span class="keyword">this</span>-&gt;flags.<span class="built_in">insert</span>(i); <span class="comment">// 哈希插入</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 归位哈希表。因为右边的数要填充了</span></span><br><span class="line">        <span class="comment">// 如034，位置1可以取到4，但此时哈希表是没有4的，将3变为4后，需要加入哈希表，右边的值填充时不能再是4，不是044而是041</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> p : <span class="keyword">this</span>-&gt;curPerm)</span><br><span class="line">        &#123;</span><br><span class="line">            flags.<span class="built_in">insert</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 该位置确定后，后面的位置依次取剩余数值的最小几个</span></span><br><span class="line">        <span class="comment">// 对右边的所有位置</span></span><br><span class="line">        <span class="comment">// 从前往后小到大遍历，如果这个数不在哈希表中就是应该变换的值</span></span><br><span class="line">        <span class="comment">// 如024，遍历01到1最小且不在哈希表，</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = curPos + <span class="number">1</span>; i &lt; <span class="keyword">this</span>-&gt;m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="keyword">this</span>-&gt;n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (flags.<span class="built_in">find</span>(j) == flags.<span class="built_in">end</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">this</span>-&gt;flags.<span class="built_in">erase</span>(<span class="keyword">this</span>-&gt;curPerm.<span class="built_in">at</span>(i)); <span class="comment">// 哈希删除</span></span><br><span class="line">                    <span class="keyword">this</span>-&gt;curPerm.<span class="built_in">at</span>(i) = j;</span><br><span class="line">                    <span class="keyword">this</span>-&gt;flags.<span class="built_in">insert</span>(j); <span class="comment">// 哈希插入</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ++<span class="keyword">this</span>-&gt;permCount;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">printCurPerm</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> p : <span class="keyword">this</span>-&gt;curPerm)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; p &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">printPermCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="keyword">this</span>-&gt;permCount &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> n; <span class="comment">// 从n个取m个</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> m;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; curPerm;      <span class="comment">// 当前排列，存储排列的索引</span></span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; flags; <span class="comment">// 哈希标志，标记已在排列中的索引</span></span><br><span class="line">    <span class="type">int</span> permCount;            <span class="comment">// 排列数的数量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> n = <span class="number">5</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> m = <span class="number">3</span>;</span><br><span class="line">    <span class="function">CPermutation <span class="title">perm</span><span class="params">(n, m)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (perm.<span class="built_in">next</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        perm.<span class="built_in">printCurPerm</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    perm.<span class="built_in">printPermCount</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="编译和运行命令"><a href="#编译和运行命令" class="headerlink" title="编译和运行命令"></a>编译和运行命令</h1><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ <span class="literal">-o</span> cpermutation cpermutation.cpp</span><br><span class="line">./cpermutation.exe</span><br></pre></td></tr></table></figure><hr><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p><img src="/../img/cpermutation/one.png" alt="在这里插入图片描述"></p><p><img src="/../img/cpermutation/two.png" alt="在这里插入图片描述"></p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>C++代码示例：排列数简单生成工具。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>学校《高级算法设计与分析》课程课件的算法思路</li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++代码示例：组合数简单生成工具</title>
      <link href="/2023/09/28/C++%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%EF%BC%9A%E7%BB%84%E5%90%88%E6%95%B0%E7%AE%80%E5%8D%95%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7/"/>
      <url>/2023/09/28/C++%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%EF%BC%9A%E7%BB%84%E5%90%88%E6%95%B0%E7%AE%80%E5%8D%95%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>C++代码示例：组合数简单生成工具。</p><hr><h1 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h1><ul><li><a href="https://github.com/yezhening/Programming-examples">yezhening&#x2F;Programming-examples: 编程实例 (github.com)</a></li><li><a href="https://gitee.com/yezhening/Programming-examples">Programming-examples: 编程实例 (gitee.com)</a></li></ul><hr><h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><ul><li>简单地生成组合数</li><li><strong>有详细的步骤解析</strong></li></ul><hr><h1 id="代码（有详细注释）"><a href="#代码（有详细注释）" class="headerlink" title="代码（有详细注释）"></a>代码（有详细注释）</h1><p>ccombination.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CCombination</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CCombination</span>(<span class="type">const</span> <span class="type">int</span> &amp;n, <span class="type">const</span> <span class="type">int</span> &amp;m) : <span class="built_in">n</span>(n), <span class="built_in">m</span>(m), <span class="built_in">curComb</span>(<span class="number">0</span>), <span class="built_in">combCount</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">next</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 第一次进入初始化当前组合，如m=3，this-&gt;curComb为012，从012开始遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;curComb.<span class="built_in">empty</span>() == <span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">this</span>-&gt;curComb.<span class="built_in">push_back</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ++<span class="keyword">this</span>-&gt;combCount;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 从右向左，找到第一个不存有自己最终内容的位置</span></span><br><span class="line">        <span class="comment">// 如n=5，m=3，curPos为索引为3-1=2的位置，从该位置的数开始递增，即先从右边的数开始递增，递增完再到左边的数</span></span><br><span class="line">        <span class="comment">// curPos &gt;= 0：防止越界</span></span><br><span class="line">        <span class="comment">// this-&gt;curComb.at(curPos) == this-&gt;n - this-&gt;m + curPos：因为是组合数，无序，不存有自己最终内容指的是在索引2，只能取到5-3+2=4，索引1取到5-3+1=3，索引0取到5-3+0=2</span></span><br><span class="line">        <span class="comment">// 继续理解：比如012，前面占了01两个位置，最后的位置能取到最大值4，第二个位置因为右边的位置占位，为了保证不重复，最大值取到3，以此类推</span></span><br><span class="line">        <span class="comment">// 即为了保证不重复，索引0位置取值范围0~2，1位置0~3，2位置0~4，位置达到这个数说明到了最终位置，位置应该减一，用其左边的数递增</span></span><br><span class="line">        <span class="type">int</span> curPos = <span class="keyword">this</span>-&gt;m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ((curPos &gt;= <span class="number">0</span>) &amp;&amp; (<span class="keyword">this</span>-&gt;curComb.<span class="built_in">at</span>(curPos) == <span class="keyword">this</span>-&gt;n - <span class="keyword">this</span>-&gt;m + curPos))</span><br><span class="line">        &#123;</span><br><span class="line">            --curPos;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (curPos &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 已经遍历所有组合</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.把这个位置上的数值加1</span></span><br><span class="line">        ++<span class="keyword">this</span>-&gt;curComb.<span class="built_in">at</span>(curPos);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 后面的数值递增</span></span><br><span class="line">        <span class="comment">// 指的是当前位置+1后，其右边的数“归位”，只能从比它大1的数开始，否则会重复，如 014 -&gt; 023， 034 -&gt; 123</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> right = curPos + <span class="number">1</span>; right &lt; <span class="keyword">this</span>-&gt;m; ++right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;curComb.<span class="built_in">at</span>(right) = <span class="keyword">this</span>-&gt;curComb.<span class="built_in">at</span>(right - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ++<span class="keyword">this</span>-&gt;combCount;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">printCurComb</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> c : <span class="keyword">this</span>-&gt;curComb)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; c &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">printCombCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="keyword">this</span>-&gt;combCount &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> n; <span class="comment">// 从n个取m个</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> m;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; curComb; <span class="comment">// 当前组合，存储组合的索引</span></span><br><span class="line">    <span class="type">int</span> combCount;       <span class="comment">// 组合数的数量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> n = <span class="number">5</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> m = <span class="number">3</span>;</span><br><span class="line">    <span class="function">CCombination <span class="title">comb</span><span class="params">(n, m)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (comb.<span class="built_in">next</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        comb.<span class="built_in">printCurComb</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    comb.<span class="built_in">printCombCount</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="编译和运行命令"><a href="#编译和运行命令" class="headerlink" title="编译和运行命令"></a>编译和运行命令</h1><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ <span class="literal">-o</span> ccombination ccombination.cpp</span><br><span class="line">./ccombination.exe</span><br></pre></td></tr></table></figure><hr><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p><img src="/../img/ccombination/one.png" alt="在这里插入图片描述"></p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>C++代码示例：组合数简单生成工具。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>学校《高级算法设计与分析》课程课件的算法思路</li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>环境编程代码实例：进程间通信（IPC）</title>
      <link href="/2023/05/16/%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%BB%A3%E7%A0%81%E5%AE%9E%E4%BE%8B%EF%BC%9A%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%88IPC%EF%BC%89/"/>
      <url>/2023/05/16/%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E4%BB%A3%E7%A0%81%E5%AE%9E%E4%BE%8B%EF%BC%9A%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%88IPC%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>环境编程代码实例：进程间通信（IPC）。</p><hr><h1 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h1><ul><li><a href="https://github.com/yezhening/Environment-and-network-programming-examples">yezhening&#x2F;Environment-and-network-programming-examples: 环境和网络编程实例 (github.com)</a></li><li><a href="https://gitee.com/yezhening/Environment-and-network-programming-examples">Environment-and-network-programming-examples: 环境和网络编程实例 (gitee.com)</a></li></ul><hr><h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><p>低级：3种</p><ul><li>全局变量&#x2F;glov：类似管道、命名管道、消息队列、共享内存：头文件&#x2F;库文件全局变量，源文件全局变量</li><li>文件&#x2F;file：类似管道、命名管道、消息队列、共享内存</li><li>PV操作&#x2F;pv：类似信号量</li></ul><p>第三方：2种</p><ul><li>数据库&#x2F;db：类似管道、命名管道、消息队列、共享内存</li><li>缓存&#x2F;cache：类似管道、命名管道、消息队列、共享内存</li></ul><p>一般：7种</p><ul><li>管道&#x2F;无名管道&#x2F;pipe</li><li>命名管道&#x2F;有名管道&#x2F;FIFO</li><li>信号&#x2F;signal</li><li>信号量&#x2F;semaphore：XSI信号量，POSIX信号量</li><li>消息队列&#x2F;mq</li><li>共享内存&#x2F;shm</li><li>套接字&#x2F;socket</li></ul><p>高级：1种</p><ul><li>内存映射&#x2F;mmap：类似共享内存</li></ul><hr><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><h3 id="头文件全局变量"><a href="#头文件全局变量" class="headerlink" title="头文件全局变量"></a>头文件全局变量</h3><p>缺点：</p><ul><li>只读，不可写</li><li>同步互斥问题：无法解决。需要引入其他进程间通信机制才能解决</li><li>扩展问题：无法解决。需要引入其他进程间通信机制才能解决</li></ul><p>相关语句：</p><ul><li>extern</li><li>#include</li><li>…</li></ul><hr><h3 id="源文件全局变量"><a href="#源文件全局变量" class="headerlink" title="源文件全局变量"></a>源文件全局变量</h3><p>缺点：</p><ul><li>只读，不可写</li><li>只能用于具有公共祖先的进程间</li><li>同步互斥问题：无法解决。需要引入其他进程间通信机制才能解决</li><li>扩展问题：无法解决。需要引入其他进程间通信机制才能解决</li></ul><hr><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p>缺点：</p><ul><li>性能问题：访问文件效率低</li><li>同步互斥问题：无法解决。需要引入其他进程间通信机制才能解决</li><li>扩展问题：无法解决。需要引入其他进程间通信机制才能解决</li></ul><p>相关函数：</p><ul><li>open()</li><li>…</li><li>fopen()</li><li>…</li></ul><hr><h2 id="PV操作"><a href="#PV操作" class="headerlink" title="PV操作"></a>PV操作</h2><p>缺点：</p><ul><li>同步互斥问题：无法解决。需要引入其他进程间通信机制才能解决</li><li>扩展问题：无法解决。需要引入其他进程间通信机制才能解决</li></ul><hr><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>优点：</p><ul><li>相对于文件，由相关机制优化同步互斥、性能和扩展问题。</li></ul><p>相关数据库：</p><ul><li>MySQL</li><li>SQL Server</li><li>…</li></ul><hr><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>优点：</p><ul><li>相对于文件，由相关机制优化同步互斥、性能和扩展问题。</li></ul><p>相关缓存：</p><ul><li>Memcached</li><li>Redis</li><li>…</li></ul><hr><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>缺点：</p><ul><li>半双工</li><li>只能用于具有公共祖先的进程间</li></ul><p>相关函数：</p><ul><li>pipe()：创建管道</li><li>popen()：打开管道</li><li>pclose()：关闭管道</li></ul><hr><h2 id="命名管道"><a href="#命名管道" class="headerlink" title="命名管道"></a>命名管道</h2><p>相关函数：</p><ul><li>mkfifo()：创建命名管道</li><li>mkfifoat()：创建命名管道</li></ul><hr><h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>相关函数：</p><ul><li>signal()</li><li>kill()</li><li>…</li></ul><hr><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><h3 id="XSI信号量"><a href="#XSI信号量" class="headerlink" title="XSI信号量"></a>XSI信号量</h3><p>缺点：</p><ul><li>在系统范围内起作用，没有引用计数。不能隐式删除，需要显式删除</li><li>在文件系统中没有名字。不能使用文件相关函数操作，需要使用特定的系统调用或命令</li><li>不使用文件描述符。不能使用多路复用函数操作，一般一次只使用一个而不是多个（消息队列）</li></ul><p>相关函数：</p><ul><li>semget()：获取信号量</li><li>semctl()：控制信号量</li><li>semop()：操作信号量</li></ul><hr><h3 id="POSIX信号量"><a href="#POSIX信号量" class="headerlink" title="POSIX信号量"></a>POSIX信号量</h3><p>相关函数：</p><ul><li>sem_open()：打开有名信号量</li><li>sem_close()：关闭信号量</li><li>sem_unlink()：销毁有名信号量</li><li>sem_trywait()：尝试等待信号量</li><li>sem_wait()：等待信号量</li><li>sem_timewait()：定时等待信号量</li><li>sem_post()：提交信号量</li><li>sem_init()：初始化无名信号量</li><li>sem_destroy()：销毁无名信号量</li><li>sem_getvalue()：获取信号量值</li></ul><hr><h2 id="消息队列-mq"><a href="#消息队列-mq" class="headerlink" title="消息队列&#x2F;mq"></a>消息队列&#x2F;mq</h2><p>缺点：</p><ul><li>在系统范围内起作用，没有引用计数。不能隐式删除，需要显式删除</li><li>在文件系统中没有名字。不能使用文件相关函数操作，需要使用特定的系统调用或命令</li><li>不使用文件描述符。不能使用多路复用函数操作，一般一次只使用一个而不是多个（消息队列）</li></ul><p>相关函数：</p><ul><li>ftok()：创建键</li><li>msgget()：获取消息队列</li><li>msgctl()：控制消息队列</li><li>msgsnd()：发送消息到消息队列</li><li>msgrcv()：接收消息从消息队列</li></ul><hr><h2 id="共享内存-shm"><a href="#共享内存-shm" class="headerlink" title="共享内存&#x2F;shm"></a>共享内存&#x2F;shm</h2><p>缺点：</p><ul><li>在系统范围内起作用，没有引用计数。不能隐式删除，需要显式删除</li><li>在文件系统中没有名字。不能使用文件相关函数操作，需要使用特定的系统调用或命令</li><li>不使用文件描述符。不能使用多路复用函数操作，一般一次只使用一个而不是多个（消息队列）</li></ul><p>相关函数：</p><ul><li>shmget()：获取共享内存</li><li>shmctl()：控制共享内存</li><li>shmat()：连接共享内存</li><li>shmdt()：分离共享内存</li></ul><hr><h2 id="套接字-sock"><a href="#套接字-sock" class="headerlink" title="套接字&#x2F;sock"></a>套接字&#x2F;sock</h2><p>优点：</p><ul><li>可用于不同主机进程间的通信</li></ul><p>相关函数：</p><ul><li>socket()</li><li>bind()</li><li>…</li></ul><hr><h2 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h2><p>相关函数：</p><ul><li>mmap()</li><li>munmap()</li></ul><hr><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul><li>由于代码篇幅较多，在博客中直接粘贴并呈现会显得冗长，因此未在博客中放置代码。请前往”代码仓库”查看或获取相关代码</li><li>对大部分总结的进程间通信机制提供简单实现</li><li>有详细步骤解析</li><li>只简单演示基础的操作，未考虑深层次的问题</li><li>对相关函数获取返回值进行错误处理，不相关函数不进行错误处理</li></ul><hr><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><ul><li>头文件全局变量：glov_h</li><li>源文件全局变量：glov_s</li><li>文件，PV操作：file_pv</li><li>管道：pipe</li><li>命名管道：fifo</li><li>信号：sig</li><li>XSI信号量：sem_XSI</li><li>POSIX信号量：sem_POSIX</li><li>消息队列：mq</li><li>共享内存：shm</li><li>套接字：socket（使用代码仓库中，“传输控制协议（TCP）简单版：TCP_simple”）</li><li>内存映射：mmap</li></ul><hr><h1 id="持续更新"><a href="#持续更新" class="headerlink" title="持续更新"></a>持续更新</h1><ul><li>当前内容总结于博主和《UNIX环境高级编程（第3版）》的一部分</li><li>在《UNIX网络编程（第3版）卷2：进程间通信》中，还有其他的进程间通信机制，在后面有时间阅读后，持续更新代码仓库和博客</li></ul><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>环境编程代码实例：进程间通信（IPC）。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《UNIX环境高级编程（第3版）》作者：W.Richard Stevens，Stephen A.Rago</li><li>《UNIX网络编程（第3版）》作者：W.Richard Stevens，Bill Fenner，Andrew M.Rudoff</li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 环境和网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境和网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络编程代码实例：守护进程版</title>
      <link href="/2023/05/12/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%BB%A3%E7%A0%81%E5%AE%9E%E4%BE%8B%EF%BC%9A%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E7%89%88/"/>
      <url>/2023/05/12/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%BB%A3%E7%A0%81%E5%AE%9E%E4%BE%8B%EF%BC%9A%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E7%89%88/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>网络编程代码实例：守护进程版。</p><hr><h1 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h1><ul><li><a href="https://github.com/yezhening/Environment-and-network-programming-examples">yezhening&#x2F;Environment-and-network-programming-examples: 环境和网络编程实例 (github.com)</a></li><li><a href="https://gitee.com/yezhening/Environment-and-network-programming-examples">Environment-and-network-programming-examples: 环境和网络编程实例 (gitee.com)</a></li></ul><hr><h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><ul><li>使用传输控制协议（TCP）</li><li>检测recv()返回值，遇到信号或网络中断会重启</li><li>为保证代码简洁，部分输入输出和字符串处理函数未获取返回值进行错误检测</li><li>服务端作为守护进程启动，设置无缓冲IO，标准输入、输出和错误重定向并实时记录到日志文本文件。在main()开头注释不调用create_daemon()，可不作为守护进程启动——增加</li><li>服务端使用signal()注册SIGCHLD信号处理函数（signal()函数对信号处理一次后，信号恢复默认行为，需要在信号处理函数中重新注册）。信号处理函数中使用可重入函数和保存并恢复旧errno方案，避免重入错误。父进程接收SIGCHLD信号后调用循环非阻塞waitpid()可处理同时终止的多个子进程，避免子进程成为僵尸进程——增加</li><li>服务端检测accept()慢系统调用的返回值，遇到信号中断会重启。在三次握手后且accept()返回前的时序，收到客户端RST重新连接，依据POSIX标准重启——增加</li><li>服务端设置套接字选项：SO_KEEPLIVE。客户端不发送数据也可以检测到服务端主机崩溃、主机崩溃后重启或网络不可达——增加</li><li>服务端设置套接字选项：SO_REUSEADDR。服务端Ctrl+C或意外中止后，不会经过TIME_WAIT状态，bind()不会报错：Address already in use，可立即重启服务端。连接套接字子进程正常运行，监听套接字父进程可立即重启。允许多个IP地址绑定同一个端口——增加</li><li>服务端多进程，一个服务端可并发连接多个客户端</li><li>服务端使用getpeername()而不是传递客户端sockaddr_in{}参数获取客户端地址——修改</li><li>用户在客户端终端输入，可多次手动通信</li><li>3个客户端代码实例分别使用IO复用的select、poll和epoll技术，同时监听用户输入和网络接收，可即时检测到服务端进程终止和服务端主机关机</li><li>Makefile文件增加注释和生成.o目标文件逻辑——增加</li></ul><hr><h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><p>daemon_process&#x2F;：</p><ul><li>bin&#x2F;</li><li>obj&#x2F;</li><li>src&#x2F;</li><li>log.txt：以守护进程方式（未注释main()中的creat_daemon()），运行daemon_process&#x2F;bin&#x2F;server生成</li><li>Makefile</li></ul><p>daemon_process&#x2F;bin&#x2F;：运行Makefile生成</p><ul><li>client_epoll</li><li>client_poll</li><li>client_select</li><li>server</li></ul><p>daemon_process&#x2F;obj&#x2F;：运行Makefile生成</p><ul><li>client_epoll.o</li><li>client_poll.o</li><li>client_select.o</li><li>server.o</li></ul><p>daemon_process&#x2F;src&#x2F;：</p><ul><li>client_epoll.c</li><li>client_poll.c</li><li>client_select.c</li><li>server.c</li></ul><hr><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>由于代码篇幅较多，在博客中直接粘贴并呈现会显得冗长，因此未在博客中放置代码。请前往”代码仓库”查看或获取相关代码。</p><hr><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p>操作时序：</p><ol><li>make clean：清理文件</li><li>make all：生成文件</li><li>cd bin：切换到二进制文件目录</li><li>.&#x2F;server： 启动服务端</li><li>ps -ef | grep -w “.&#x2F;server” | grep -v grep：查看服务端进程（服务端父进程9949作为后台守护进程启动；此时无客户端连接，所以无服务端子进程）</li><li>.&#x2F;client_select：启动客户端client_select，发送消息”client_select”</li><li>.&#x2F;client_client_poll：启动客户端client_poll，发送消息”client_poll”</li><li>.&#x2F;client_epoll：启动client_epoll，发送消息”client_epoll”</li><li>Ctrl+C：使客户端client_select异常终止</li><li>Ctrl+D：使客户端client_poll正常终止</li><li>kill 9949：终止服务端父进程9949</li><li>ps -ef | grep -w “.&#x2F;server” | grep -v grep：查看服务端进程（服务端父进程9949终止；服务端子进程10241仍与客户端client_epoll连接）</li><li>客户端client_epoll，发送消息”client_epoll2”，能够正常通信</li><li>kill 10241：终止服务端子进程10241，客户端client_epoll被迫终止</li></ol><p>server：</p><p><img src="/../img/daemon_process/server.png" alt="在这里插入图片描述"><br>client_select：</p><p><img src="/../img/daemon_process/client_select.png" alt="在这里插入图片描述"></p><p>client_poll：</p><p><img src="/../img/daemon_process/client_poll.png" alt="在这里插入图片描述"></p><p>client_epoll：</p><p><img src="/../img/daemon_process/client_epoll.png" alt="在这里插入图片描述"></p><p>log.txt：</p><p><img src="/../img/daemon_process/logtxt.png" alt="在这里插入图片描述"></p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>网络编程代码实例：守护进程版。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《UNIX环境高级编程（第3版）》作者：W.Richard Stevens，Stephen A.Rago</li><li>《UNIX网络编程（第3版）》作者：W.Richard Stevens，Bill Fenner，Andrew M.Rudoff</li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 环境和网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境和网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络编程代码实例：IO复用版</title>
      <link href="/2023/05/01/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%BB%A3%E7%A0%81%E5%AE%9E%E4%BE%8B%EF%BC%9AIO%E5%A4%8D%E7%94%A8%E7%89%88/"/>
      <url>/2023/05/01/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%BB%A3%E7%A0%81%E5%AE%9E%E4%BE%8B%EF%BC%9AIO%E5%A4%8D%E7%94%A8%E7%89%88/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>网络编程代码实例：IO复用版。</p><hr><h1 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h1><ul><li><a href="https://github.com/yezhening/Environment-and-network-programming-examples">yezhening&#x2F;Environment-and-network-programming-examples: 环境和网络编程实例 (github.com)</a></li><li><a href="https://gitee.com/yezhening/Environment-and-network-programming-examples">Environment-and-network-programming-examples: 环境和网络编程实例 (gitee.com)</a></li></ul><hr><h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><ul><li>使用传输控制协议（TCP）</li><li>服务端多进程，一个服务端可连接多个客户端</li><li>用户在客户端终端输入，可多次手动通信</li><li>在上一份代码实例：多进程版的基础上，服务端增加获取客户端地址的逻辑；更新部分函数使用、错误处理、注释和Makefile文件；为保证代码简洁，部分输入输出和字符串处理函数未进行错误检测</li><li>3个客户端代码实例分别使用IO复用的select、poll和epoll技术，同时监听用户输入和网络接收，可即时接收服务端进程终止和服务端主机关机消息</li><li>客户端使用shutdown()而不是close()关闭连接，当客户端主动关闭写半部连接后，服务端仍能够接收而不是丢弃批量输入的缓冲区数据</li></ul><hr><h1 id="代码（有详细注释）"><a href="#代码（有详细注释）" class="headerlink" title="代码（有详细注释）"></a>代码（有详细注释）</h1><h2 id="server-c"><a href="#server-c" class="headerlink" title="server.c"></a>server.c</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件————————————————————</span></span><br><span class="line"><span class="comment">// #include &lt;sys/socket.h&gt; // socket()、sockaddr&#123;&#125;、bind()、listen()、accept()、recv()、send()</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  <span class="comment">// perror()、printf()、sprintf()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> <span class="comment">// exit()</span></span></span><br><span class="line"><span class="comment">// #include &lt;netinet/in.h&gt; // sockaddr_in&#123;&#125;、htons()、ntohs()</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>    <span class="comment">// memset()、strcpy()、strcat()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span> <span class="comment">// inet_pton()、inet_ntop()</span></span></span><br><span class="line"><span class="comment">// #include &lt;unistd.h&gt;  // close()、fork()</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span> <span class="comment">// errno</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局常量————————————————————</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> g_serv_listen_ip[INET_ADDRSTRLEN] = <span class="string">&quot;0.0.0.0&quot;</span>; <span class="comment">// 服务端监听的IP地址</span></span><br><span class="line"><span class="type">const</span> <span class="type">uint16_t</span> g_serv_listen_port = <span class="number">6000</span>;                 <span class="comment">// 服务端监听的端口号</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> g_listen_max_count = <span class="number">5</span>;                         <span class="comment">// 监听的最大连接数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> g_buff_size = <span class="number">32</span>;                               <span class="comment">// 消息缓冲区的大小。单位：字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明————————————————————</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handle_request</span><span class="params">(<span class="type">int</span>, <span class="keyword">struct</span> sockaddr_in)</span>; <span class="comment">// 处理请求</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数————————————————————</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> arg, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 网络连接————————————————————</span></span><br><span class="line">    <span class="type">int</span> listen_fd; <span class="comment">// 监听套接字文件描述符</span></span><br><span class="line">    <span class="comment">//  创建套接字并获取套接字文件描述符</span></span><br><span class="line">    <span class="keyword">if</span> ((listen_fd = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span> <span class="comment">// 服务端网络信息结构体</span></span><br><span class="line">    <span class="comment">// 初始化服务端网络信息结构体</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = htons(g_serv_listen_port);</span><br><span class="line">    <span class="keyword">if</span> ((inet_pton(AF_INET, g_serv_listen_ip, &amp;serv_addr.sin_addr)) != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;inet_pton() error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定套接字与网络信息</span></span><br><span class="line">    <span class="keyword">if</span> ((bind(listen_fd, (<span class="keyword">struct</span> sockaddr *)(&amp;serv_addr), <span class="keyword">sizeof</span>(serv_addr))) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((close(listen_fd)) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;bind() close() error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        perror(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 套接字设置被动监听状态</span></span><br><span class="line">    <span class="keyword">if</span> ((listen(listen_fd, g_listen_max_count)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((close(listen_fd)) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;listen() close() error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        perror(<span class="string">&quot;listen() error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clie_addr</span>;</span> <span class="comment">// 客户端网络信息结构体</span></span><br><span class="line">    <span class="type">int</span> clie_addr_size;           <span class="comment">// 客户端网络信息结构体大小</span></span><br><span class="line">    <span class="type">int</span> connect_fd;               <span class="comment">// 连接套接字文件描述符</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;clie_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(clie_addr));</span><br><span class="line">    clie_addr_size = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr);</span><br><span class="line">    <span class="type">pid_t</span> pid; <span class="comment">// 进程标识符</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 循环监听客户端请求</span></span><br><span class="line">    <span class="comment">// 原则：父进程不能退出，子进程可以退出</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 与客户端建立连接</span></span><br><span class="line">        <span class="keyword">if</span> ((connect_fd = accept(listen_fd, (<span class="keyword">struct</span> sockaddr *)(&amp;clie_addr), &amp;clie_addr_size)) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;accept() error&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// 继续监听</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建子进程处理请求</span></span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">-1</span>) <span class="comment">// 错误</span></span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;fork() error&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// 继续监听</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) <span class="comment">// 子进程</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((close(listen_fd)) == <span class="number">-1</span>) <span class="comment">// 1.关闭监听套接字文件描述符</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> ((close(connect_fd)) == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    perror(<span class="string">&quot;fork() close() connect_fd child_process error&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(EXIT_FAILURE); <span class="comment">// 子进程退出</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                perror(<span class="string">&quot;fork() close() listen_fd child_process error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE); <span class="comment">// 子进程退出</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            handle_request(connect_fd, clie_addr); <span class="comment">// 2.处理请求</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((close(connect_fd)) == <span class="number">-1</span>) <span class="comment">// 3.关闭连接套接字文件描述符</span></span><br><span class="line">            &#123;</span><br><span class="line">                perror(<span class="string">&quot;fork() close() connect_fd2 child_process error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE); <span class="comment">// 子进程退出</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) <span class="comment">// 父进程</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((close(connect_fd)) == <span class="number">-1</span>) <span class="comment">// 关闭连接套接字文件描述符</span></span><br><span class="line">            &#123;</span><br><span class="line">                perror(<span class="string">&quot;fork() close() connect_fd parent_process error&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 继续监听</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((close(listen_fd)) == <span class="number">-1</span>) <span class="comment">// 父进程关闭监听套接字文件描述符。实际不会执行</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;close() listen_fd error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义————————————————————</span></span><br><span class="line"><span class="comment">// 处理请求</span></span><br><span class="line"><span class="comment">// 参数：连接套接字文件描述符，客户端网络信息结构体</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handle_request</span><span class="params">(<span class="type">int</span> connect_fd, <span class="keyword">struct</span> sockaddr_in clie_addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取客户端的IP地址和端口————————————————————</span></span><br><span class="line">    <span class="type">char</span> clie_ip[INET_ADDRSTRLEN];          <span class="comment">// 客户端的IP地址    如：127.0.0.1</span></span><br><span class="line">    <span class="type">uint16_t</span> clie_port;                     <span class="comment">// 客户端的端口  如：42534</span></span><br><span class="line">    <span class="type">char</span> clie_port_str[<span class="number">5</span>];                  <span class="comment">// 客户端的端口，char[]类型  如：42534</span></span><br><span class="line">    <span class="type">char</span> clie_ip_port[INET_ADDRSTRLEN + <span class="number">5</span>]; <span class="comment">// 客户端的IP地址和端口  如：127.0.0.1:42534</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((inet_ntop(AF_INET, &amp;clie_addr.sin_addr, clie_ip, <span class="keyword">sizeof</span>(clie_ip))) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;inet_ntop() error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 函数返回后，关闭连接套接字文件描述符，结束子进程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意：返回值和第3个参数值相同，区别为一个是常量一个是变量</span></span><br><span class="line">    clie_port = ntohs(clie_addr.sin_port);</span><br><span class="line">    <span class="built_in">sprintf</span>(clie_port_str, <span class="string">&quot;%d&quot;</span>, clie_port);</span><br><span class="line">    <span class="built_in">strcpy</span>(clie_ip_port, clie_ip);</span><br><span class="line">    <span class="built_in">strcat</span>(clie_ip_port, <span class="string">&quot;:&quot;</span>);</span><br><span class="line">    <span class="built_in">strcat</span>(clie_ip_port, clie_port_str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Client connection: %s\n&quot;</span>, clie_ip_port);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传输消息————————————————————</span></span><br><span class="line">    <span class="type">char</span> msg_recv[g_buff_size]; <span class="comment">// 从客户端接收的消息缓冲区</span></span><br><span class="line">    <span class="type">char</span> msg_send[g_buff_size]; <span class="comment">// 发送到客户端的消息缓冲区</span></span><br><span class="line">    <span class="type">int</span> recv_byte;              <span class="comment">// 接收的消息字节数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) <span class="comment">// 循环接收和发送消息</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;msg_recv, <span class="number">0</span>, <span class="keyword">sizeof</span>(*msg_recv));</span><br><span class="line">        <span class="built_in">memset</span>(&amp;msg_send, <span class="number">0</span>, <span class="keyword">sizeof</span>(*msg_send));</span><br><span class="line"></span><br><span class="line">        recv_byte = recv(connect_fd, msg_recv, g_buff_size, <span class="number">0</span>); <span class="comment">// 接收消息</span></span><br><span class="line">        <span class="keyword">if</span> (recv_byte &gt; <span class="number">0</span>)                                      <span class="comment">// 有消息</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;From %s received message: %s&quot;</span>, clie_ip_port, msg_recv); <span class="comment">// 接收的消息</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">strcpy</span>(msg_send, msg_recv);                             <span class="comment">// 发送的消息</span></span><br><span class="line">            <span class="keyword">if</span> ((send(connect_fd, msg_send, g_buff_size, <span class="number">0</span>)) == <span class="number">-1</span>) <span class="comment">// 发送消息</span></span><br><span class="line">            &#123;</span><br><span class="line">                perror(<span class="string">&quot;send() error&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// 函数返回后，关闭连接套接字文件描述符，结束子进程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (recv_byte == <span class="number">0</span>) <span class="comment">// 文件末尾EOF：在客户端标准输入Ctrl+D或Ctrl+C</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;From %s received the end of file\n&quot;</span>, clie_ip_port);</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 函数返回后，关闭连接套接字文件描述符，结束子进程</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((recv_byte == <span class="number">-1</span>) &amp;&amp; (errno == EINTR)) <span class="comment">// 信号或网络中断recv()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// 继续接收消息</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (recv_byte == <span class="number">-1</span>) <span class="comment">// 错误</span></span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;recv() error&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 函数返回后，关闭连接套接字文件描述符，结束子进程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="client-select-c"><a href="#client-select-c" class="headerlink" title="client_select.c"></a>client_select.c</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件————————————————————</span></span><br><span class="line"><span class="comment">// #include &lt;sys/socket.h&gt; // socket()、sockaddr&#123;&#125;、connect()、send()、recv()、shutdown()</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  <span class="comment">// perror()、printf()、gets()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> <span class="comment">// exit()</span></span></span><br><span class="line"><span class="comment">// #include &lt;netinet/in.h&gt; // sockaddr_in&#123;&#125;、htons()</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>     <span class="comment">// memset()、strcat()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span>  <span class="comment">// inet_pton()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>     <span class="comment">// close()、STDIN_FILENO</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span>      <span class="comment">// errno</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span> <span class="comment">// select()</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局常量————————————————————</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> g_connect_serv_ip[INET_ADDRSTRLEN] = <span class="string">&quot;127.0.0.1&quot;</span>; <span class="comment">// 连接服务端的IP地址</span></span><br><span class="line"><span class="type">const</span> <span class="type">uint16_t</span> g_connect_serv_port = <span class="number">6000</span>;                   <span class="comment">// 连接服务端的端口号</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> g_buff_size = <span class="number">32</span>;                                  <span class="comment">// 消息缓冲区大小。单位：字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明————————————————————</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handle</span><span class="params">(<span class="type">int</span>)</span>; <span class="comment">// 处理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数————————————————————</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 网络连接————————————————————</span></span><br><span class="line">    <span class="type">int</span> sock_fd; <span class="comment">// 套接字文件描述符</span></span><br><span class="line">    <span class="comment">// 创建套接字并获取套接字文件描述符</span></span><br><span class="line">    <span class="keyword">if</span> ((sock_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span> <span class="comment">// 服务端网络信息结构体</span></span><br><span class="line">    <span class="comment">// 初始化服务端网络信息结构体</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = htons(g_connect_serv_port);</span><br><span class="line">    <span class="keyword">if</span> ((inet_pton(AF_INET, g_connect_serv_ip, &amp;serv_addr.sin_addr)) != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;inet_pton() error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 与服务端建立连接</span></span><br><span class="line">    <span class="keyword">if</span> ((connect(sock_fd, (<span class="keyword">struct</span> sockaddr *)(&amp;serv_addr), <span class="keyword">sizeof</span>(serv_addr))) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((close(sock_fd)) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;connect() close() error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        perror(<span class="string">&quot;connect() error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handle(sock_fd); <span class="comment">// 处理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭套接字文件描述符</span></span><br><span class="line">    <span class="keyword">if</span> ((close(sock_fd)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;close() error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义————————————————————</span></span><br><span class="line"><span class="comment">// 处理</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handle</span><span class="params">(<span class="type">int</span> sock_fd)</span> <span class="comment">// 参数：套接字文件描述符</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// select()准备————————————————————</span></span><br><span class="line">    <span class="comment">// 监听标准输入文件描述符和套接字文件描述符的可读条件</span></span><br><span class="line">    <span class="type">int</span> maxfdp1;        <span class="comment">// 要监听描述符的最大值+1</span></span><br><span class="line">    fd_set read_fd_set; <span class="comment">// 可读文件描述符集合</span></span><br><span class="line">    <span class="keyword">if</span> (STDIN_FILENO &gt;= sock_fd)</span><br><span class="line">    &#123;</span><br><span class="line">        maxfdp1 = STDIN_FILENO + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        maxfdp1 = sock_fd + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    FD_ZERO(&amp;read_fd_set);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传输消息————————————————————</span></span><br><span class="line">    <span class="type">char</span> msg_send[g_buff_size]; <span class="comment">// 发送到服务端的消息缓冲区</span></span><br><span class="line">    <span class="type">char</span> msg_recv[g_buff_size]; <span class="comment">// 从服务端接收的消息缓冲区</span></span><br><span class="line">    <span class="type">int</span> recv_byte;              <span class="comment">// 接收的消息字节数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> stdin_eof = <span class="number">0</span>; <span class="comment">// 标准输入文件描述符读到文件末尾的标志：0未读到EOF，1读到EOF</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please input the message to be sent directly below:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) <span class="comment">// 循环发送和接收消息</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 1.select()调用</span></span><br><span class="line">        <span class="comment">// 因为select()返回会修改fd_set，所以每循环都要重新设置监听的fd_set</span></span><br><span class="line">        <span class="comment">// 当stdin_eof == 1时，写半部关闭，不需要再设置监听标准输入文件描述符</span></span><br><span class="line">        <span class="keyword">if</span> (stdin_eof == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            FD_SET(STDIN_FILENO, &amp;read_fd_set);</span><br><span class="line">        &#125;</span><br><span class="line">        FD_SET(sock_fd, &amp;read_fd_set);</span><br><span class="line">        <span class="keyword">if</span> ((select(maxfdp1, &amp;read_fd_set, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>)) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;select() error&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// 若有错误在下个循环继续调用</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(&amp;msg_send, <span class="number">0</span>, <span class="keyword">sizeof</span>(*msg_send));</span><br><span class="line">        <span class="built_in">memset</span>(&amp;msg_recv, <span class="number">0</span>, <span class="keyword">sizeof</span>(*msg_recv));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.select()检测</span></span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(STDIN_FILENO, &amp;read_fd_set)) <span class="comment">// 标准输入文件描述符可读</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((fgets(msg_send, g_buff_size, <span class="built_in">stdin</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="comment">// 从标准输入获取消息。错误或遇到文件结尾(EOF)：在客户端标准输入Ctrl+D或Ctrl+C，相当于关闭连接</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;End of connection\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">                stdin_eof = <span class="number">1</span>;                          <span class="comment">// 设置标志</span></span><br><span class="line">                FD_CLR(STDIN_FILENO, &amp;read_fd_set);     <span class="comment">// 清理fd_set</span></span><br><span class="line">                <span class="keyword">if</span> ((shutdown(sock_fd, SHUT_WR)) == <span class="number">-1</span>) <span class="comment">// 写半部关闭</span></span><br><span class="line">                &#123;</span><br><span class="line">                    perror(<span class="string">&quot;shutdown() error&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span>; <span class="comment">// 函数返回后，关闭连接套接字文件描述符，结束进程</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// 不是return，因为可能还需要从网络套接字文件描述符读</span></span><br><span class="line">                <span class="comment">// 不需要进入下面的send()，服务端会recv()接收EOF</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((send(sock_fd, msg_send, g_buff_size, <span class="number">0</span>)) == <span class="number">-1</span>) <span class="comment">// 发送消息</span></span><br><span class="line">            &#123;</span><br><span class="line">                perror(<span class="string">&quot;send() error&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// 函数返回后，关闭连接套接字文件描述符，结束进程</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Send message: %s&quot;</span>, msg_send);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (FD_ISSET(sock_fd, &amp;read_fd_set)) <span class="comment">// 套接字文件描述符可读</span></span><br><span class="line">        &#123;</span><br><span class="line">            recv_byte = recv(sock_fd, msg_recv, g_buff_size, <span class="number">0</span>); <span class="comment">// 接收消息</span></span><br><span class="line">            <span class="keyword">if</span> (recv_byte &gt; <span class="number">0</span>)                                   <span class="comment">// 有数据</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Received message: %s&quot;</span>, msg_recv); <span class="comment">// 接收的消息</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (recv_byte == <span class="number">0</span>) <span class="comment">// 服务端进程提前终止，在服务端标准输入Ctrl+C中断进程</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果已经调用shutdown()写半部关闭，当服务端recv()EOF后调用close()时，是正常的结束连接</span></span><br><span class="line">                <span class="comment">// 否则，是服务端ctrl+c提前关闭连接</span></span><br><span class="line">                <span class="keyword">if</span> (stdin_eof == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span>; <span class="comment">// 函数返回后，关闭套接字文件描述符，结束进程</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Server terminated prematurely\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// 函数返回后，关闭套接字文件描述符，结束进程</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((recv_byte == <span class="number">-1</span>) &amp;&amp; (errno == EINTR)) <span class="comment">// 信号或网络中断recv()</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 继续发送和接收数据</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (recv_byte == <span class="number">-1</span>) <span class="comment">// 错误</span></span><br><span class="line">            &#123;</span><br><span class="line">                perror(<span class="string">&quot;recv() error&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// 函数返回后，关闭套接字文件描述符，结束进程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="client-poll-c"><a href="#client-poll-c" class="headerlink" title="client_poll.c"></a>client_poll.c</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件————————————————————</span></span><br><span class="line"><span class="comment">// #include &lt;sys/socket.h&gt; // socket()、sockaddr&#123;&#125;、connect()、send()、recv()、shutdown()</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  <span class="comment">// perror()、printf()、gets()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> <span class="comment">// exit()</span></span></span><br><span class="line"><span class="comment">// #include &lt;netinet/in.h&gt; // sockaddr_in&#123;&#125;、htons()</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>    <span class="comment">// memset()、strcat()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span> <span class="comment">// inet_pton()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>    <span class="comment">// close()、STDIN_FILENO</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span>     <span class="comment">// errno</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span>      <span class="comment">// poll()</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局常量————————————————————</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> g_connect_serv_ip[INET_ADDRSTRLEN] = <span class="string">&quot;127.0.0.1&quot;</span>; <span class="comment">// 连接服务端的IP地址</span></span><br><span class="line"><span class="type">const</span> <span class="type">uint16_t</span> g_connect_serv_port = <span class="number">6000</span>;                   <span class="comment">// 连接服务端的端口号</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> g_buff_size = <span class="number">32</span>;                                  <span class="comment">// 消息缓冲区大小。单位：字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明————————————————————</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handle</span><span class="params">(<span class="type">int</span>)</span>; <span class="comment">// 处理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数————————————————————</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 网络连接————————————————————</span></span><br><span class="line">    <span class="type">int</span> sock_fd; <span class="comment">// 套接字文件描述符</span></span><br><span class="line">    <span class="comment">// 创建套接字并获取套接字文件描述符</span></span><br><span class="line">    <span class="keyword">if</span> ((sock_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span> <span class="comment">// 服务端网络信息结构体</span></span><br><span class="line">    <span class="comment">// 初始化服务端网络信息结构体</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = htons(g_connect_serv_port);</span><br><span class="line">    <span class="keyword">if</span> ((inet_pton(AF_INET, g_connect_serv_ip, &amp;serv_addr.sin_addr)) != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;inet_pton() error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 与服务端建立连接</span></span><br><span class="line">    <span class="keyword">if</span> ((connect(sock_fd, (<span class="keyword">struct</span> sockaddr *)(&amp;serv_addr), <span class="keyword">sizeof</span>(serv_addr))) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((close(sock_fd)) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;connect() close() error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        perror(<span class="string">&quot;connect() error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handle(sock_fd); <span class="comment">// 处理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭套接字文件描述符</span></span><br><span class="line">    <span class="keyword">if</span> ((close(sock_fd)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;close() error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义————————————————————</span></span><br><span class="line"><span class="comment">// 处理</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handle</span><span class="params">(<span class="type">int</span> sock_fd)</span> <span class="comment">// 参数：套接字文件描述符</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// poll()准备————————————————————</span></span><br><span class="line">    <span class="comment">// 监听标准输入文件描述符和套接字文件描述符的可读条件</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd_array</span>[2];</span> <span class="comment">// pollfd&#123;&#125;结构数组</span></span><br><span class="line">    pollfd_array[<span class="number">0</span>].fd = STDIN_FILENO;</span><br><span class="line">    pollfd_array[<span class="number">0</span>].events = POLLIN;</span><br><span class="line">    pollfd_array[<span class="number">1</span>].fd = sock_fd;</span><br><span class="line">    pollfd_array[<span class="number">1</span>].events = POLLIN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传输消息————————————————————</span></span><br><span class="line">    <span class="type">char</span> msg_send[g_buff_size]; <span class="comment">// 发送到服务端的消息缓冲区</span></span><br><span class="line">    <span class="type">char</span> msg_recv[g_buff_size]; <span class="comment">// 从服务端接收的消息缓冲区</span></span><br><span class="line">    <span class="type">int</span> recv_byte;              <span class="comment">// 接收的消息字节数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> stdin_eof = <span class="number">0</span>; <span class="comment">// 标准输入文件描述符读到文件末尾的标志：0未读到EOF，1读到EOF</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please input the message to be sent directly below:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) <span class="comment">// 循环发送和接收消息</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 1.poll()调用</span></span><br><span class="line">        <span class="comment">// 当stdin_eof == 1时，写半部关闭，不需要再设置监听标准输入文件描述符</span></span><br><span class="line">        <span class="comment">// 不监听的成员fd设置为-1，会忽略成员events，返回时将成员revents置0</span></span><br><span class="line">        <span class="keyword">if</span> (stdin_eof == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pollfd_array[<span class="number">0</span>].fd = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((poll(pollfd_array, <span class="number">2</span>, <span class="number">-1</span>)) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;poll() error&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// 若有错误在下个循环继续调用</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(&amp;msg_send, <span class="number">0</span>, <span class="keyword">sizeof</span>(*msg_send));</span><br><span class="line">        <span class="built_in">memset</span>(&amp;msg_recv, <span class="number">0</span>, <span class="keyword">sizeof</span>(*msg_recv));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.poll()检测</span></span><br><span class="line">        <span class="keyword">if</span> (pollfd_array[<span class="number">0</span>].revents &amp; (POLLIN | POLLERR)) <span class="comment">// 标准输入文件描述符可读</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((fgets(msg_send, g_buff_size, <span class="built_in">stdin</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="comment">// 从标准输入获取消息。错误或遇到文件结尾(EOF)：在客户端标准输入Ctrl+D或Ctrl+C，相当于关闭连接</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;End of connection\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">                stdin_eof = <span class="number">1</span>;                          <span class="comment">// 设置标志</span></span><br><span class="line">                <span class="keyword">if</span> ((shutdown(sock_fd, SHUT_WR)) == <span class="number">-1</span>) <span class="comment">// 写半部关闭</span></span><br><span class="line">                &#123;</span><br><span class="line">                    perror(<span class="string">&quot;shutdown() error&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span>; <span class="comment">// 函数返回后，关闭连接套接字文件描述符，结束进程</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// 不是return，因为可能还需要从网络套接字文件描述符读</span></span><br><span class="line">                <span class="comment">// 不需要进入下面的send()，服务端会recv()接收EOF</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((send(sock_fd, msg_send, g_buff_size, <span class="number">0</span>)) == <span class="number">-1</span>) <span class="comment">// 发送消息</span></span><br><span class="line">            &#123;</span><br><span class="line">                perror(<span class="string">&quot;send() error&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// 函数返回后，关闭连接套接字文件描述符，结束进程</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Send message: %s&quot;</span>, msg_send);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pollfd_array[<span class="number">1</span>].revents &amp; (POLLIN | POLLERR)) <span class="comment">// 套接字文件描述符可读</span></span><br><span class="line">        &#123;</span><br><span class="line">            recv_byte = recv(sock_fd, msg_recv, g_buff_size, <span class="number">0</span>); <span class="comment">// 接收消息</span></span><br><span class="line">            <span class="keyword">if</span> (recv_byte &gt; <span class="number">0</span>)                                   <span class="comment">// 有数据</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Received message: %s&quot;</span>, msg_recv); <span class="comment">// 接收的消息</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (recv_byte == <span class="number">0</span>) <span class="comment">// 服务端进程提前终止，在服务端标准输入Ctrl+C中断进程</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果已经调用shutdown()写半部关闭，当服务端recv()EOF后调用close()时，是正常的结束连接</span></span><br><span class="line">                <span class="comment">// 否则，是服务端ctrl+c提前关闭连接</span></span><br><span class="line">                <span class="keyword">if</span> (stdin_eof == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span>; <span class="comment">// 函数返回后，关闭套接字文件描述符，结束进程</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Server terminated prematurely\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// 函数返回后，关闭套接字文件描述符，结束进程</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((recv_byte == <span class="number">-1</span>) &amp;&amp; (errno == EINTR)) <span class="comment">// 信号或网络中断recv()</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 继续发送和接收数据</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (recv_byte == <span class="number">-1</span>) <span class="comment">// 错误</span></span><br><span class="line">            &#123;</span><br><span class="line">                perror(<span class="string">&quot;recv() error&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// 函数返回后，关闭套接字文件描述符，结束进程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="client-epoll-c"><a href="#client-epoll-c" class="headerlink" title="client_epoll.c"></a>client_epoll.c</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件————————————————————</span></span><br><span class="line"><span class="comment">// #include &lt;sys/socket.h&gt; // socket()、sockaddr&#123;&#125;、connect()、send()、recv()、shutdown()</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  <span class="comment">// perror()、printf()、gets()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> <span class="comment">// exit()</span></span></span><br><span class="line"><span class="comment">// #include &lt;netinet/in.h&gt; // sockaddr_in&#123;&#125;、htons()</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>    <span class="comment">// memset()、strcat()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span> <span class="comment">// inet_pton()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>    <span class="comment">// close()、STDIN_FILENO</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span>     <span class="comment">// errno</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span> <span class="comment">// epoll()</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局常量————————————————————</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> g_connect_serv_ip[INET_ADDRSTRLEN] = <span class="string">&quot;127.0.0.1&quot;</span>; <span class="comment">// 连接服务端的IP地址</span></span><br><span class="line"><span class="type">const</span> <span class="type">uint16_t</span> g_connect_serv_port = <span class="number">6000</span>;                   <span class="comment">// 连接服务端的端口号</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> g_buff_size = <span class="number">32</span>;                                  <span class="comment">// 消息缓冲区大小。单位：字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明————————————————————</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handle</span><span class="params">(<span class="type">int</span>)</span>; <span class="comment">// 处理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数————————————————————</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 网络连接————————————————————</span></span><br><span class="line">    <span class="type">int</span> sock_fd; <span class="comment">// 套接字文件描述符</span></span><br><span class="line">    <span class="comment">// 创建套接字并获取套接字文件描述符</span></span><br><span class="line">    <span class="keyword">if</span> ((sock_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span> <span class="comment">// 服务端网络信息结构体</span></span><br><span class="line">    <span class="comment">// 初始化服务端网络信息结构体</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = htons(g_connect_serv_port);</span><br><span class="line">    <span class="keyword">if</span> ((inet_pton(AF_INET, g_connect_serv_ip, &amp;serv_addr.sin_addr)) != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;inet_pton() error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 与服务端建立连接</span></span><br><span class="line">    <span class="keyword">if</span> ((connect(sock_fd, (<span class="keyword">struct</span> sockaddr *)(&amp;serv_addr), <span class="keyword">sizeof</span>(serv_addr))) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((close(sock_fd)) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;connect() close() error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        perror(<span class="string">&quot;connect() error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handle(sock_fd); <span class="comment">// 处理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭套接字文件描述符</span></span><br><span class="line">    <span class="keyword">if</span> ((close(sock_fd)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;close() error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义————————————————————</span></span><br><span class="line"><span class="comment">// 处理</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handle</span><span class="params">(<span class="type">int</span> sock_fd)</span> <span class="comment">// 参数：套接字文件描述符</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// epoll()准备————————————————————</span></span><br><span class="line">    <span class="comment">// 监听标准输入文件描述符和套接字文件描述符的可读条件</span></span><br><span class="line">    <span class="type">int</span> epoll_fd;                           <span class="comment">// epoll用的文件描述符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epoll_listen_event</span>;</span>  <span class="comment">// epoll监听的事件</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epoll_wait_event</span>[2];</span> <span class="comment">// epoll等待的事件</span></span><br><span class="line">    <span class="type">int</span> epoll_wait_event_num;               <span class="comment">// epoll_wait()调用返回的就绪事件数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((epoll_fd = epoll_create(<span class="number">2</span>)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_create() error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 函数返回后，关闭连接套接字文件描述符，结束进程</span></span><br><span class="line">    &#125;</span><br><span class="line">    epoll_listen_event.data.fd = STDIN_FILENO;</span><br><span class="line">    epoll_listen_event.events = EPOLLIN; <span class="comment">// 默认水平触发，未设置边缘触发</span></span><br><span class="line">    <span class="keyword">if</span> ((epoll_ctl(epoll_fd, EPOLL_CTL_ADD, STDIN_FILENO, &amp;epoll_listen_event)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((close(epoll_fd)) == <span class="number">-1</span>) <span class="comment">// 注意关闭epoll用的文件描述符</span></span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;epoll_ctl() STDIN_FILENO EPOLL_CTL_ADD close() error&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        perror(<span class="string">&quot;epoll_ctl() STDIN_FILENO EPOLL_CTL_ADD error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    epoll_listen_event.data.fd = sock_fd; <span class="comment">// 同一个变量可重复使用，修改后注册到epoll_ctl()即可</span></span><br><span class="line">    epoll_listen_event.events = EPOLLIN;</span><br><span class="line">    <span class="keyword">if</span> ((epoll_ctl(epoll_fd, EPOLL_CTL_ADD, sock_fd, &amp;epoll_listen_event)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((close(epoll_fd)) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;epoll_ctl() sock_fd close() error&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        perror(<span class="string">&quot;epoll_ctl() sock_fd error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传输消息————————————————————</span></span><br><span class="line">    <span class="type">char</span> msg_send[g_buff_size]; <span class="comment">// 发送到服务端的消息缓冲区</span></span><br><span class="line">    <span class="type">char</span> msg_recv[g_buff_size]; <span class="comment">// 从服务端接收的消息缓冲区</span></span><br><span class="line">    <span class="type">int</span> recv_byte;              <span class="comment">// 接收的消息字节数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> stdin_eof = <span class="number">0</span>; <span class="comment">// 标准输入文件描述符读到文件末尾的标志：0未读到EOF，1读到EOF</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please input the message to be sent directly below:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) <span class="comment">// 循环发送和接收消息</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 1.epoll()调用</span></span><br><span class="line">        <span class="comment">// 当stdin_eof == 1时，写半部关闭，不需要再设置监听标准输入文件描述符</span></span><br><span class="line">        <span class="keyword">if</span> (stdin_eof == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((epoll_ctl(epoll_fd, EPOLL_CTL_DEL, STDIN_FILENO, <span class="literal">NULL</span>)) == <span class="number">-1</span>) <span class="comment">// 删除事件时，第4个参数设置为NULL</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> ((close(epoll_fd)) == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    perror(<span class="string">&quot;epoll_ctl() STDIN_FILENO EPOLL_CTL_DEL close() error&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                perror(<span class="string">&quot;epoll_ctl() STDIN_FILENO EPOLL_CTL_DEL error&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((epoll_wait_event_num = epoll_wait(epoll_fd, epoll_wait_event, <span class="number">2</span>, <span class="number">-1</span>)) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((close(epoll_fd)) == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                perror(<span class="string">&quot;epoll_wait() close() error&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            perror(<span class="string">&quot;epoll_wait() error&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// 若有错误在下个循环继续调用</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(&amp;msg_send, <span class="number">0</span>, <span class="keyword">sizeof</span>(*msg_send));</span><br><span class="line">        <span class="built_in">memset</span>(&amp;msg_recv, <span class="number">0</span>, <span class="keyword">sizeof</span>(*msg_recv));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.epoll()检测</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; epoll_wait_event_num; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((epoll_wait_event[i].data.fd == STDIN_FILENO) &amp;&amp; (epoll_wait_event[i].events &amp; (EPOLLIN | EPOLLERR))) <span class="comment">// 标准输入文件描述符可读</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> ((fgets(msg_send, g_buff_size, <span class="built_in">stdin</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="comment">// 从标准输入获取消息。错误或遇到文件结尾(EOF)：在客户端标准输入Ctrl+D或Ctrl+C，相当于关闭连接</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;End of connection\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    stdin_eof = <span class="number">1</span>;                          <span class="comment">// 设置标志</span></span><br><span class="line">                    <span class="keyword">if</span> ((shutdown(sock_fd, SHUT_WR)) == <span class="number">-1</span>) <span class="comment">// 写半部关闭</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        perror(<span class="string">&quot;shutdown() error&quot;</span>);</span><br><span class="line">                        <span class="keyword">return</span>; <span class="comment">// 函数返回后，关闭连接套接字文件描述符，结束进程</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="comment">// 不是return，因为可能还需要从网络套接字文件描述符读</span></span><br><span class="line">                    <span class="comment">// 不需要进入下面的send()，服务端会recv()接收EOF</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> ((send(sock_fd, msg_send, g_buff_size, <span class="number">0</span>)) == <span class="number">-1</span>) <span class="comment">// 发送消息</span></span><br><span class="line">                &#123;</span><br><span class="line">                    perror(<span class="string">&quot;send() error&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span>; <span class="comment">// 函数返回后，关闭连接套接字文件描述符，结束进程</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Send message: %s&quot;</span>, msg_send);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((epoll_wait_event[i].data.fd == sock_fd) &amp;&amp; (epoll_wait_event[i].events &amp; (EPOLLIN | EPOLLERR))) <span class="comment">// 套接字文件描述符可读</span></span><br><span class="line">            &#123;</span><br><span class="line">                recv_byte = recv(sock_fd, msg_recv, g_buff_size, <span class="number">0</span>); <span class="comment">// 接收消息</span></span><br><span class="line">                <span class="keyword">if</span> (recv_byte &gt; <span class="number">0</span>)                                   <span class="comment">// 有数据</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Received message: %s&quot;</span>, msg_recv); <span class="comment">// 接收的消息</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (recv_byte == <span class="number">0</span>) <span class="comment">// 服务端进程提前终止，在服务端标准输入Ctrl+C中断进程</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 如果已经调用shutdown()写半部关闭，当服务端recv()EOF后调用close()时，是正常的结束连接</span></span><br><span class="line">                    <span class="comment">// 否则，是服务端ctrl+c提前关闭连接</span></span><br><span class="line">                    <span class="keyword">if</span> (stdin_eof == <span class="number">1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">return</span>; <span class="comment">// 函数返回后，关闭套接字文件描述符，结束进程</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Server terminated prematurely\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span>; <span class="comment">// 函数返回后，关闭套接字文件描述符，结束进程</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((recv_byte == <span class="number">-1</span>) &amp;&amp; (errno == EINTR)) <span class="comment">// 信号或网络中断recv()</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>; <span class="comment">// 继续发送和接收数据</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (recv_byte == <span class="number">-1</span>) <span class="comment">// 错误</span></span><br><span class="line">                &#123;</span><br><span class="line">                    perror(<span class="string">&quot;recv() error&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span>; <span class="comment">// 函数返回后，关闭套接字文件描述符，结束进程</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((close(epoll_fd)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;close()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p>操作时序：</p><ol><li>启动服务端</li><li>启动client_select，发送消息”client_select”</li><li>启动client_poll，发送消息”client_poll”</li><li>启动client_epoll，发送消息”client_epoll”</li><li>客户端client_select，使用Ctrl+C异常终止</li><li>客户端client_poll，使用Ctrl+D正常终止</li><li>服务端，使用Ctrl+C异常终止</li><li>客户端client_epoll，被迫终止</li></ol><p>server：</p><p><img src="/../img/IO_multiplexing/server.png"></p><p>client_select：</p><p><img src="/../img/IO_multiplexing/client_select.png" alt="在这里插入图片描述"></p><p>client_poll：</p><p><img src="/../img/IO_multiplexing/client_poll.png" alt="在这里插入图片描述"></p><p>client_epoll：</p><p><img src="/../img/IO_multiplexing/client_epoll.png" alt="在这里插入图片描述"></p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>网络编程代码实例：IO复用版。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《UNIX环境高级编程（第3版）》作者：W.Richard Stevens，Stephen A.Rago</li><li>《UNIX网络编程（第3版）》作者：W.Richard Stevens，Bill Fenner，Andrew M.Rudoff</li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 环境和网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境和网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络编程代码实例：多进程版</title>
      <link href="/2023/04/26/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%BB%A3%E7%A0%81%E5%AE%9E%E4%BE%8B%EF%BC%9A%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%89%88/"/>
      <url>/2023/04/26/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%BB%A3%E7%A0%81%E5%AE%9E%E4%BE%8B%EF%BC%9A%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%89%88/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>网络编程代码实例：多进程版。</p><hr><h1 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h1><ul><li><a href="https://github.com/yezhening/Environment-and-network-programming-examples">yezhening&#x2F;Environment-and-network-programming-examples: 环境和网络编程实例 (github.com)</a></li><li><a href="https://gitee.com/yezhening/Environment-and-network-programming-examples">Environment-and-network-programming-examples: 环境和网络编程实例 (gitee.com)</a></li></ul><hr><h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><ul><li>使用传输控制协议（TCP）</li><li>一个服务端可连接多个客户端</li><li>多次手动通信</li></ul><hr><h1 id="代码（有详细注释）"><a href="#代码（有详细注释）" class="headerlink" title="代码（有详细注释）"></a>代码（有详细注释）</h1><h2 id="server-c"><a href="#server-c" class="headerlink" title="server.c"></a>server.c</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件————————————————————</span></span><br><span class="line"><span class="comment">// #include &lt;sys/socket.h&gt; // socket()、sockaddr、bind()、listen()、accept()、recv()、send()</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  <span class="comment">//(perror())、printf()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> <span class="comment">//exit()</span></span></span><br><span class="line"><span class="comment">// #include &lt;netinet/in.h&gt; //sockaddr_in、（htons()）</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>    <span class="comment">//bzero()、strncpy()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span> <span class="comment">//inet_pton()</span></span></span><br><span class="line"><span class="comment">// #include &lt;unistd.h&gt;     //close()、fork()</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span> <span class="comment">//errno</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局常量————————————————————</span></span><br><span class="line"><span class="type">const</span> g_serv_port = <span class="number">6666</span>;     <span class="comment">// 服务端的端口号</span></span><br><span class="line"><span class="type">const</span> g_listen_max_count = <span class="number">5</span>; <span class="comment">// 监听的最大连接数</span></span><br><span class="line"><span class="type">const</span> g_buff_size = <span class="number">64</span>;      <span class="comment">// 消息缓冲区的大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明————————————————————</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handle_request</span><span class="params">(<span class="type">int</span> connect_fd)</span>; <span class="comment">// 处理请求</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数————————————————————</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> arg, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 网络连接————————————————————</span></span><br><span class="line">    <span class="type">int</span> listen_fd; <span class="comment">// 监听套接字文件描述符</span></span><br><span class="line">    <span class="comment">// 创建套接字并获取套接字文件描述符</span></span><br><span class="line">    <span class="keyword">if</span> ((listen_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span> <span class="comment">// 服务端网络信息结构体</span></span><br><span class="line">    <span class="comment">// 初始化服务端网络信息结构体</span></span><br><span class="line">    bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = htons(g_serv_port);</span><br><span class="line">    <span class="keyword">if</span> ((inet_pton(AF_INET, <span class="string">&quot;0.0.0.0&quot;</span>, &amp;serv_addr.sin_addr)) != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;inet_pton() error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定套接字与网络信息</span></span><br><span class="line">    <span class="keyword">if</span> ((bind(listen_fd, (<span class="keyword">struct</span> sockaddr *)(&amp;serv_addr), <span class="keyword">sizeof</span>(serv_addr))) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((close(listen_fd)) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;bind() close() error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        perror(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 套接字设置被动监听状态</span></span><br><span class="line">    <span class="keyword">if</span> ((listen(listen_fd, g_listen_max_count)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((close(listen_fd)) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;listen() close() error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        perror(<span class="string">&quot;listen() error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clie_addr</span>;</span> <span class="comment">// 客户端网络信息结构体</span></span><br><span class="line">    <span class="type">int</span> clie_addr_size;           <span class="comment">// 客户端网络信息结构体大小</span></span><br><span class="line">    <span class="type">int</span> connect_fd;               <span class="comment">// 连接套接字文件描述符</span></span><br><span class="line">    bzero(&amp;clie_addr, <span class="keyword">sizeof</span>(clie_addr));</span><br><span class="line">    clie_addr_size = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr);</span><br><span class="line">    <span class="type">pid_t</span> pid; <span class="comment">// 进程号</span></span><br><span class="line">    <span class="comment">// 循环监听客户端请求</span></span><br><span class="line">    <span class="comment">// 原则：父进程不能退出，子进程可以退出</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 与客户端建立连接</span></span><br><span class="line">        <span class="keyword">if</span> ((connect_fd = accept(listen_fd, (<span class="keyword">struct</span> sockaddr *)(&amp;clie_addr), &amp;clie_addr_size)) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;accept() error&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// 继续监听</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建子进程处理请求</span></span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">-1</span>) <span class="comment">// 错误</span></span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;fork() error&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// 继续监听</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) <span class="comment">// 子进程</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((close(listen_fd)) == <span class="number">-1</span>) <span class="comment">// 1.关闭监听套接字文件描述符</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> ((close(connect_fd)) == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    perror(<span class="string">&quot;fork() close() connect_fd child_process error&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(EXIT_FAILURE); <span class="comment">// 子进程退出</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                perror(<span class="string">&quot;fork() close() listen_fd child_process error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE); <span class="comment">// 子进程退出</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            handle_request(connect_fd); <span class="comment">// 2.处理请求</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((close(connect_fd)) == <span class="number">-1</span>) <span class="comment">// 3.关闭连接套接字文件描述符</span></span><br><span class="line">            &#123;</span><br><span class="line">                perror(<span class="string">&quot;fork() close() connect_fd2 child_process error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE); <span class="comment">// 子进程退出</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) <span class="comment">// 父进程</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((close(connect_fd)) == <span class="number">-1</span>) <span class="comment">// 关闭连接套接字文件描述符</span></span><br><span class="line">            &#123;</span><br><span class="line">                perror(<span class="string">&quot;fork() close() connect_fd parent_process error&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 继续监听</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((close(listen_fd)) == <span class="number">-1</span>) <span class="comment">// 父进程关闭监听套接字文件描述符。实际不会执行</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;close() listen_fd error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义————————————————————</span></span><br><span class="line"><span class="comment">// 处理请求</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handle_request</span><span class="params">(<span class="type">int</span> connect_fd)</span> <span class="comment">// 参数：连接套接字文件描述符</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 传输消息————————————————————</span></span><br><span class="line">    <span class="type">char</span> msg_recv[g_buff_size]; <span class="comment">// 从客户端接收的消息缓冲区</span></span><br><span class="line">    <span class="type">char</span> msg_send[g_buff_size]; <span class="comment">// 发送到客户端的消息缓冲区</span></span><br><span class="line">    <span class="type">int</span> recv_bytes;             <span class="comment">// 接收的消息字节数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) <span class="comment">// 循环接收和发送消息</span></span><br><span class="line">    &#123;</span><br><span class="line">        bzero(&amp;msg_recv, <span class="keyword">sizeof</span>(*msg_recv));</span><br><span class="line">        bzero(&amp;msg_send, <span class="keyword">sizeof</span>(*msg_send));</span><br><span class="line"></span><br><span class="line">        recv_bytes = recv(connect_fd, msg_recv, g_buff_size, <span class="number">0</span>); <span class="comment">// 接收消息</span></span><br><span class="line">        <span class="keyword">if</span> (recv_bytes &gt; <span class="number">0</span>) <span class="comment">// 有消息</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Received message: %s&quot;</span>, msg_recv); <span class="comment">// 接收的消息</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">strncpy</span>(msg_send, msg_recv, g_buff_size);               <span class="comment">// 发送的消息</span></span><br><span class="line">            <span class="keyword">if</span> ((send(connect_fd, msg_send, g_buff_size, <span class="number">0</span>)) == <span class="number">-1</span>) <span class="comment">// 发送消息</span></span><br><span class="line">            &#123;</span><br><span class="line">                perror(<span class="string">&quot;send() error&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// 函数返回后，关闭连接套接字文件描述符，结束子进程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (recv_bytes == <span class="number">0</span>) <span class="comment">// 文件末尾EOF：在客户端标准输入Ctrl+D</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;The process %d received the end of file\n&quot;</span>, getpid());</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 函数返回后，关闭连接套接字文件描述符，结束子进程</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((recv_bytes == <span class="number">-1</span>) &amp;&amp; (errno == EINTR)) <span class="comment">// 信号或网络中断recv()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// 继续接收消息</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (recv_bytes == <span class="number">-1</span>) <span class="comment">// 错误</span></span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;recv() error&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 函数返回后，关闭连接套接字文件描述符，结束子进程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="client-c"><a href="#client-c" class="headerlink" title="client.c"></a>client.c</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件————————————————————</span></span><br><span class="line"><span class="comment">// #include &lt;sys/socket.h&gt; //socket()、sockaddr、connect()、send()、recv()</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  <span class="comment">//（perror()）、printf()、（fgets()）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> <span class="comment">//exit()</span></span></span><br><span class="line"><span class="comment">// #include &lt;netinet/in.h&gt; //sockaddr_in、（htons()）</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>    <span class="comment">//bzero()、strncpy()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span> <span class="comment">//inet_pton()</span></span></span><br><span class="line"><span class="comment">// #include &lt;unistd.h&gt;     //close()</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span> <span class="comment">//errno</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局常量————————————————————</span></span><br><span class="line"><span class="type">const</span> g_serv_port = <span class="number">6666</span>; <span class="comment">// 服务端端口号</span></span><br><span class="line"><span class="type">const</span> g_buff_size = <span class="number">64</span>;   <span class="comment">// 消息缓冲区大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明————————————————————</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handle</span><span class="params">(<span class="type">int</span> sock_fd)</span>; <span class="comment">// 处理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数————————————————————</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 网络连接————————————————————</span></span><br><span class="line">    <span class="type">int</span> sock_fd; <span class="comment">// 套接字文件描述符</span></span><br><span class="line">    <span class="comment">// 创建套接字并获取套接字文件描述符</span></span><br><span class="line">    <span class="keyword">if</span> ((sock_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span> <span class="comment">// 服务端网络信息结构体</span></span><br><span class="line">    <span class="comment">// 初始化服务端网络信息结构体</span></span><br><span class="line">    bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = htons(g_serv_port);</span><br><span class="line">    <span class="keyword">if</span> ((inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;serv_addr.sin_addr)) != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;inet_pton() error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 与服务端建立连接</span></span><br><span class="line">    <span class="keyword">if</span> ((connect(sock_fd, (<span class="keyword">struct</span> sockaddr *)(&amp;serv_addr), <span class="keyword">sizeof</span>(serv_addr))) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((close(sock_fd)) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;connect() close() error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        perror(<span class="string">&quot;connect() error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handle(sock_fd); <span class="comment">// 处理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭套接字文件描述符</span></span><br><span class="line">    <span class="keyword">if</span> ((close(sock_fd)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;close() error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义————————————————————</span></span><br><span class="line"><span class="comment">// 处理</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handle</span><span class="params">(<span class="type">int</span> sock_fd)</span> <span class="comment">// 参数：套接字文件描述符</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 传输消息————————————————————</span></span><br><span class="line">    <span class="type">char</span> msg_send[g_buff_size]; <span class="comment">// 发送到服务端的消息缓冲区</span></span><br><span class="line">    <span class="type">char</span> msg_recv[g_buff_size]; <span class="comment">// 从服务端接收的消息缓冲区</span></span><br><span class="line">    <span class="type">int</span> recv_bytes;             <span class="comment">// 接收的消息字节数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) <span class="comment">// 循环发送和接收消息</span></span><br><span class="line">    &#123;</span><br><span class="line">        bzero(&amp;msg_send, <span class="keyword">sizeof</span>(*msg_send));</span><br><span class="line">        bzero(&amp;msg_recv, <span class="keyword">sizeof</span>(*msg_recv));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Send message: &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> ((fgets(msg_send, g_buff_size, <span class="built_in">stdin</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="comment">// 从标准输入获取消息。错误或遇到文件结尾(EOF)：在客户端标准输入Ctrl+D，相当于关闭连接</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;End of connection\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 函数返回后，关闭套接字文件描述符，结束进程</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((send(sock_fd, msg_send, g_buff_size, <span class="number">0</span>)) == <span class="number">-1</span>) <span class="comment">// 发送消息</span></span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;send() error&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 函数返回后，关闭连接套接字文件描述符，结束进程</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        recv_bytes = recv(sock_fd, msg_recv, g_buff_size, <span class="number">0</span>); <span class="comment">// 接收消息</span></span><br><span class="line">        <span class="keyword">if</span> (recv_bytes &gt; <span class="number">0</span>)                                   <span class="comment">// 有数据</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Received message: %s&quot;</span>, msg_recv); <span class="comment">// 接收的消息</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (recv_bytes == <span class="number">0</span>) <span class="comment">// 服务端进程提前终止，在服务端标准输入Ctrl+C中断进程</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Server terminated prematurely\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 函数返回后，关闭套接字文件描述符，结束进程</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((recv_bytes == <span class="number">-1</span>) &amp;&amp; (errno == EINTR)) <span class="comment">// 信号或网络中断recv()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// 继续发送和接收数据</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (recv_bytes == <span class="number">-1</span>) <span class="comment">// 错误</span></span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;recv() error&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 函数返回后，关闭套接字文件描述符，结束进程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#变量</span></span><br><span class="line">targets = server client</span><br><span class="line"></span><br><span class="line"><span class="comment">#伪目标</span></span><br><span class="line">.PHONY : all</span><br><span class="line">all : $(targets) </span><br><span class="line"></span><br><span class="line"><span class="comment">#规则</span></span><br><span class="line">server : server.c</span><br><span class="line">gcc -o server server.c </span><br><span class="line"></span><br><span class="line">client : client.c</span><br><span class="line">gcc -o client client.c</span><br><span class="line"></span><br><span class="line"><span class="comment">#伪目标</span></span><br><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line"><span class="built_in">rm</span> $(targets)</span><br></pre></td></tr></table></figure><hr><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p>正常情况，服务端表现：</p><p><img src="/../img/multiprocess/one.png" alt="在这里插入图片描述"></p><p>正常情况，客户端1表现：</p><p><img src="/../img/multiprocess/two.png" alt="在这里插入图片描述"></p><p>正常情况，客户端2表现：</p><p><img src="/../img/multiprocess/three.png" alt="在这里插入图片描述"></p><p>正常情况，客户端3表现：</p><p><img src="/../img/multiprocess/four.png" alt="在这里插入图片描述"></p><p>服务端终止，服务端表现：</p><p><img src="/../img/multiprocess/five.png" alt="在这里插入图片描述"></p><p>服务端终止，客户端表现：</p><p><img src="/../img/multiprocess/six.png" alt="在这里插入图片描述"></p><p>客户端终止连接，服务端表现：</p><p><img src="/../img/multiprocess/seven.png" alt="在这里插入图片描述"></p><p>客户端终止连接，客户端表现：</p><p><img src="/../img/multiprocess/eight.png" alt="在这里插入图片描述"></p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>网络编程代码实例：多进程版。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《UNIX环境高级编程（第3版）》作者：W.Richard Stevens，Stephen A.Rago</li><li>《UNIX网络编程（第3版）》作者：W.Richard Stevens，Bill Fenner，Andrew M.Rudoff</li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 环境和网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境和网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络编程代码实例：用户数据报协议（UDP）简单版</title>
      <link href="/2023/04/25/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%BB%A3%E7%A0%81%E5%AE%9E%E4%BE%8B%EF%BC%9A%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE%EF%BC%88UDP%EF%BC%89%E7%AE%80%E5%8D%95%E7%89%88/"/>
      <url>/2023/04/25/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%BB%A3%E7%A0%81%E5%AE%9E%E4%BE%8B%EF%BC%9A%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE%EF%BC%88UDP%EF%BC%89%E7%AE%80%E5%8D%95%E7%89%88/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>网络编程代码实例：用户数据报协议（UDP）简单版。</p><hr><h1 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h1><ul><li><a href="https://github.com/yezhening/Environment-and-network-programming-examples">yezhening&#x2F;Environment-and-network-programming-examples: 环境和网络编程实例 (github.com)</a></li><li><a href="https://gitee.com/yezhening/Environment-and-network-programming-examples">Environment-and-network-programming-examples: 环境和网络编程实例 (gitee.com)</a></li></ul><hr><h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><ul><li><p>使用用户数据报协议（UDP）</p></li><li><p>一个服务端连接一个客户端</p></li><li><p>一次自动通信</p></li></ul><hr><h1 id="代码（有详细注释）"><a href="#代码（有详细注释）" class="headerlink" title="代码（有详细注释）"></a>代码（有详细注释）</h1><h2 id="server-c"><a href="#server-c" class="headerlink" title="server.c"></a>server.c</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件————————————————————</span></span><br><span class="line"><span class="comment">// #include &lt;sys/socket.h&gt; // socket()、sockaddr、bind()、recvfrom()、sendto()</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  <span class="comment">//(perror())、printf()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> <span class="comment">//exit()</span></span></span><br><span class="line"><span class="comment">// #include &lt;netinet/in.h&gt; //sockaddr_in、（htons()）</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>    <span class="comment">//bzero()、strncpy()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span> <span class="comment">//inet_pton()</span></span></span><br><span class="line"><span class="comment">// #include &lt;unistd.h&gt;     //close()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局常量————————————————————</span></span><br><span class="line"><span class="type">const</span> g_serv_port = <span class="number">3333</span>; <span class="comment">// 服务端的端口号</span></span><br><span class="line"><span class="type">const</span> g_buff_size = <span class="number">16</span>;   <span class="comment">// 消息缓冲区的大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数————————————————————</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> arg, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 网络连接————————————————————</span></span><br><span class="line">    <span class="type">int</span> sock_fd; <span class="comment">// 套接字文件描述符</span></span><br><span class="line">    <span class="comment">// 创建套接字并获取套接字文件描述符</span></span><br><span class="line">    <span class="keyword">if</span> ((sock_fd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span> <span class="comment">// 服务端网络信息结构体</span></span><br><span class="line">    <span class="comment">// 初始化服务端网络信息结构体</span></span><br><span class="line">    bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = htons(g_serv_port);</span><br><span class="line">    <span class="keyword">if</span> ((inet_pton(AF_INET, <span class="string">&quot;0.0.0.0&quot;</span>, &amp;serv_addr.sin_addr)) != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;inet_pton() error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定套接字与网络信息</span></span><br><span class="line">    <span class="keyword">if</span> ((bind(sock_fd, (<span class="keyword">struct</span> sockaddr *)(&amp;serv_addr), <span class="keyword">sizeof</span>(serv_addr))) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((close(sock_fd)) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;bind() close() error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        perror(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clie_addr</span>;</span> <span class="comment">// 客户端网络信息结构体</span></span><br><span class="line">    <span class="type">socklen_t</span> clie_addr_size;     <span class="comment">// 客户端网络信息结构体大小</span></span><br><span class="line">    bzero(&amp;clie_addr, <span class="keyword">sizeof</span>(clie_addr));</span><br><span class="line">    clie_addr_size = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传输数据————————————————————</span></span><br><span class="line">    <span class="type">char</span> msg_recv[g_buff_size]; <span class="comment">// 从客户端接收的消息缓冲区</span></span><br><span class="line">    <span class="type">char</span> msg_send[g_buff_size]; <span class="comment">// 发送到客户端的消息缓冲区</span></span><br><span class="line">    bzero(&amp;msg_recv, <span class="keyword">sizeof</span>(*msg_recv));</span><br><span class="line">    bzero(&amp;msg_send, <span class="keyword">sizeof</span>(*msg_send));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((recvfrom(sock_fd, msg_recv, g_buff_size, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)(&amp;clie_addr), &amp;clie_addr_size)) == <span class="number">-1</span>) <span class="comment">// 接收数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((close(sock_fd)) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;recvfrom() close() error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        perror(<span class="string">&quot;recvfrom() error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Received message: %s\n&quot;</span>, msg_recv); <span class="comment">// 接收的消息</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">strncpy</span>(msg_send, msg_recv, g_buff_size);                                                               <span class="comment">// 发送的消息</span></span><br><span class="line">    <span class="keyword">if</span> ((sendto(sock_fd, msg_send, g_buff_size, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)(&amp;clie_addr), clie_addr_size)) == <span class="number">-1</span>) <span class="comment">// 发送数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((close(sock_fd)) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;sendto() close() connect_fd error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        perror(<span class="string">&quot;sendto() error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭套接字文件描述符</span></span><br><span class="line">    <span class="keyword">if</span> ((close(sock_fd)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;close() error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="client-c"><a href="#client-c" class="headerlink" title="client.c"></a>client.c</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件————————————————————</span></span><br><span class="line"><span class="comment">// #include &lt;sys/socket.h&gt; //socket()、sockaddr、sendto()、recvfrom()</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  <span class="comment">//（perror()）、printf()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> <span class="comment">//exit()</span></span></span><br><span class="line"><span class="comment">// #include &lt;netinet/in.h&gt; //sockaddr_in、（htons()）</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>    <span class="comment">//bzero()、strncpy()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span> <span class="comment">//inet_pton()</span></span></span><br><span class="line"><span class="comment">// #include &lt;unistd.h&gt;     //close()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局常量————————————————————</span></span><br><span class="line"><span class="type">const</span> g_serv_port = <span class="number">3333</span>; <span class="comment">// 服务端端口号</span></span><br><span class="line"><span class="type">const</span> g_buff_size = <span class="number">16</span>;   <span class="comment">// 消息缓冲区大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数————————————————————</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 网络连接————————————————————</span></span><br><span class="line">    <span class="type">int</span> sock_fd; <span class="comment">// 套接字文件描述符</span></span><br><span class="line">    <span class="comment">// 创建套接字并获取套接字文件描述符</span></span><br><span class="line">    <span class="keyword">if</span> ((sock_fd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span> <span class="comment">// 服务端网络信息结构体</span></span><br><span class="line">    <span class="comment">// 初始化服务端网络信息结构体</span></span><br><span class="line">    bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = htons(g_serv_port);</span><br><span class="line">    <span class="keyword">if</span> ((inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;serv_addr.sin_addr)) != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;inet_pton() error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据传输</span></span><br><span class="line">    <span class="type">char</span> msg_send[g_buff_size]; <span class="comment">// 发送到服务端的消息缓冲区</span></span><br><span class="line">    <span class="type">char</span> msg_recv[g_buff_size]; <span class="comment">// 从服务端接收的消息缓冲区</span></span><br><span class="line">    bzero(&amp;msg_recv, <span class="keyword">sizeof</span>(*msg_recv));</span><br><span class="line">    bzero(&amp;msg_send, <span class="keyword">sizeof</span>(*msg_send));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strncpy</span>(msg_send, <span class="string">&quot;Hello&quot;</span>, <span class="number">6</span>);                                                                             <span class="comment">// 发送的消息</span></span><br><span class="line">    <span class="keyword">if</span> ((sendto(sock_fd, msg_send, g_buff_size, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)(&amp;serv_addr), <span class="keyword">sizeof</span>(serv_addr))) == <span class="number">-1</span>) <span class="comment">// 发送数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((close(sock_fd)) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;sendto() close() error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        perror(<span class="string">&quot;sendto() error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((recvfrom(sock_fd, msg_recv, g_buff_size, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>)) == <span class="number">-1</span>) <span class="comment">// 接收数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((close(sock_fd)) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;recvfrom() close() error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        perror(<span class="string">&quot;recvfrom() error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Received message: %s\n&quot;</span>, msg_recv); <span class="comment">// 接收的消息</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭套接字文件描述符</span></span><br><span class="line">    <span class="keyword">if</span> ((close(sock_fd)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;close() error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#变量</span></span><br><span class="line">targets = server client</span><br><span class="line"></span><br><span class="line"><span class="comment">#伪目标</span></span><br><span class="line">.PHONY : all</span><br><span class="line">all : $(targets) </span><br><span class="line"></span><br><span class="line"><span class="comment">#规则</span></span><br><span class="line">server : server.c</span><br><span class="line">gcc -o server server.c </span><br><span class="line"></span><br><span class="line">client : client.c</span><br><span class="line">gcc -o client client.c</span><br><span class="line"></span><br><span class="line"><span class="comment">#伪目标</span></span><br><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line"><span class="built_in">rm</span> $(targets)</span><br></pre></td></tr></table></figure><hr><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p>server：</p><p><img src="/../img/simple_udp/one.png" alt="在这里插入图片描述"></p><p>client：</p><p><img src="/../img/simple_udp/two.png" alt="在这里插入图片描述"></p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>网络编程代码实例：用户数据报协议（UDP）简单版。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《UNIX环境高级编程（第3版）》作者：W.Richard Stevens，Stephen A.Rago</li><li>《UNIX网络编程（第3版）》作者：W.Richard Stevens，Bill Fenner，Andrew M.Rudoff</li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 环境和网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境和网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络编程代码实例：传输控制协议（TCP）简单版</title>
      <link href="/2023/04/24/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%BB%A3%E7%A0%81%E5%AE%9E%E4%BE%8B%EF%BC%9A%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE%EF%BC%88TCP%EF%BC%89%E7%AE%80%E5%8D%95%E7%89%88/"/>
      <url>/2023/04/24/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%BB%A3%E7%A0%81%E5%AE%9E%E4%BE%8B%EF%BC%9A%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE%EF%BC%88TCP%EF%BC%89%E7%AE%80%E5%8D%95%E7%89%88/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>网络编程代码实例：传输控制协议（TCP）简单版。</p><hr><h1 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h1><ul><li><a href="https://github.com/yezhening/Environment-and-network-programming-examples">yezhening&#x2F;Environment-and-network-programming-examples: 环境和网络编程实例 (github.com)</a></li><li><a href="https://gitee.com/yezhening/Environment-and-network-programming-examples">Environment-and-network-programming-examples: 环境和网络编程实例 (gitee.com)</a></li></ul><hr><h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><ul><li>使用传输控制协议（TCP）</li><li>一个服务端连接一个客户端</li><li>一次自动通信</li></ul><hr><h1 id="代码（有详细注释）"><a href="#代码（有详细注释）" class="headerlink" title="代码（有详细注释）"></a>代码（有详细注释）</h1><h2 id="server-c"><a href="#server-c" class="headerlink" title="server.c"></a>server.c</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件————————————————————</span></span><br><span class="line"><span class="comment">// #include &lt;sys/socket.h&gt; // socket()、sockaddr、bind()、listen()、accept()、recv()、send()</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>      <span class="comment">//(perror())、printf()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>     <span class="comment">//exit()</span></span></span><br><span class="line"><span class="comment">// #include &lt;netinet/in.h&gt; //sockaddr_in、（htons()）</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>     <span class="comment">//bzero()、strncpy()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span>  <span class="comment">//inet_pton()</span></span></span><br><span class="line"><span class="comment">// #include &lt;unistd.h&gt;     //close()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局常量————————————————————</span></span><br><span class="line"><span class="type">const</span> g_serv_port = <span class="number">3333</span>;     <span class="comment">// 服务端的端口号</span></span><br><span class="line"><span class="type">const</span> g_listen_max_count = <span class="number">1</span>; <span class="comment">// 监听的最大连接数</span></span><br><span class="line"><span class="type">const</span> g_buff_size = <span class="number">16</span>;       <span class="comment">// 消息缓冲区的大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数————————————————————</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> arg, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 网络连接————————————————————</span></span><br><span class="line">    <span class="type">int</span> listen_fd; <span class="comment">// 监听套接字文件描述符</span></span><br><span class="line">    <span class="comment">// 创建套接字并获取套接字文件描述符</span></span><br><span class="line">    <span class="keyword">if</span> ((listen_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span> <span class="comment">// 服务端网络信息结构体</span></span><br><span class="line">    <span class="comment">// 初始化服务端网络信息结构体</span></span><br><span class="line">    bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = htons(g_serv_port);</span><br><span class="line">    <span class="keyword">if</span> ((inet_pton(AF_INET, <span class="string">&quot;0.0.0.0&quot;</span>, &amp;serv_addr.sin_addr)) != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;inet_pton() error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定套接字与网络信息</span></span><br><span class="line">    <span class="keyword">if</span> ((bind(listen_fd, (<span class="keyword">struct</span> sockaddr *)(&amp;serv_addr), <span class="keyword">sizeof</span>(serv_addr))) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((close(listen_fd)) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;bind() close() error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        perror(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 套接字设置被动监听状态</span></span><br><span class="line">    <span class="keyword">if</span> ((listen(listen_fd, g_listen_max_count)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((close(listen_fd)) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;listen() close() error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        perror(<span class="string">&quot;listen() error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clie_addr</span>;</span> <span class="comment">// 客户端网络信息结构体</span></span><br><span class="line">    <span class="type">int</span> clie_addr_size;           <span class="comment">// 客户端网络信息结构体大小</span></span><br><span class="line">    <span class="type">int</span> connect_fd;               <span class="comment">// 连接套接字文件描述符</span></span><br><span class="line">    bzero(&amp;clie_addr, <span class="keyword">sizeof</span>(clie_addr));</span><br><span class="line">    clie_addr_size = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr);</span><br><span class="line">    <span class="comment">// 与客户端建立连接</span></span><br><span class="line">    <span class="keyword">if</span> ((connect_fd = accept(listen_fd, (<span class="keyword">struct</span> sockaddr *)(&amp;clie_addr), &amp;clie_addr_size)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((close(listen_fd)) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;accept() error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        perror(<span class="string">&quot;accept() error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传输数据————————————————————</span></span><br><span class="line">    <span class="type">char</span> msg_recv[g_buff_size]; <span class="comment">// 从客户端接收的消息缓冲区</span></span><br><span class="line">    <span class="type">char</span> msg_send[g_buff_size]; <span class="comment">// 发送到客户端的消息缓冲区</span></span><br><span class="line">    bzero(&amp;msg_recv, <span class="keyword">sizeof</span>(*msg_recv));</span><br><span class="line">    bzero(&amp;msg_send, <span class="keyword">sizeof</span>(*msg_send));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((recv(connect_fd, msg_recv, g_buff_size, <span class="number">0</span>)) == <span class="number">-1</span>) <span class="comment">// 接收数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((close(connect_fd)) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;recv() close() connect_fd error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((close(listen_fd)) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;recv() close() listen_fd error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        perror(<span class="string">&quot;recv() error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, msg_recv); <span class="comment">// 接收的消息</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">strncpy</span>(msg_send, msg_recv, g_buff_size);               <span class="comment">// 发送的消息</span></span><br><span class="line">    <span class="keyword">if</span> ((send(connect_fd, msg_send, g_buff_size, <span class="number">0</span>)) == <span class="number">-1</span>) <span class="comment">// 发送数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((close(connect_fd)) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;send() close() connect_fd error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((close(listen_fd)) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;send() close() listen_fd error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        perror(<span class="string">&quot;send() error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭套接字文件描述符</span></span><br><span class="line">    <span class="keyword">if</span> ((close(connect_fd)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;close() connect_fd error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((close(listen_fd)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;close() listen_fd error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="client-c"><a href="#client-c" class="headerlink" title="client.c"></a>client.c</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件————————————————————</span></span><br><span class="line"><span class="comment">// #include &lt;sys/socket.h&gt; //socket()、sockaddr、connect()、send()、recv()</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  <span class="comment">//（perror()）、printf()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> <span class="comment">//exit()</span></span></span><br><span class="line"><span class="comment">// #include &lt;netinet/in.h&gt; //sockaddr_in、（htons()）</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>    <span class="comment">//bzero()、strncpy()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span> <span class="comment">//inet_pton()</span></span></span><br><span class="line"><span class="comment">// #include &lt;unistd.h&gt;     //close()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局常量————————————————————</span></span><br><span class="line"><span class="type">const</span> g_serv_port = <span class="number">3333</span>; <span class="comment">// 服务端端口号</span></span><br><span class="line"><span class="type">const</span> g_buff_size = <span class="number">16</span>;   <span class="comment">// 消息缓冲区大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数————————————————————</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 网络连接————————————————————</span></span><br><span class="line">    <span class="type">int</span> sock_fd; <span class="comment">// 套接字文件描述符</span></span><br><span class="line">    <span class="comment">// 创建套接字并获取套接字文件描述符</span></span><br><span class="line">    <span class="keyword">if</span> ((sock_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span> <span class="comment">// 服务端网络信息结构体</span></span><br><span class="line">    <span class="comment">// 初始化服务端网络信息结构体</span></span><br><span class="line">    bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = htons(g_serv_port);</span><br><span class="line">    <span class="keyword">if</span> ((inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;serv_addr.sin_addr)) != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;inet_pton() error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 与服务端建立连接</span></span><br><span class="line">    <span class="keyword">if</span> ((connect(sock_fd, (<span class="keyword">struct</span> sockaddr *)(&amp;serv_addr), <span class="keyword">sizeof</span>(serv_addr))) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((close(sock_fd)) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;connect() close() error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        perror(<span class="string">&quot;connect() error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据传输</span></span><br><span class="line">    <span class="type">char</span> msg_send[g_buff_size]; <span class="comment">// 发送到服务端的消息缓冲区</span></span><br><span class="line">    <span class="type">char</span> msg_recv[g_buff_size]; <span class="comment">// 从服务端接收的消息缓冲区</span></span><br><span class="line">    bzero(&amp;msg_recv, <span class="keyword">sizeof</span>(*msg_recv));</span><br><span class="line">    bzero(&amp;msg_send, <span class="keyword">sizeof</span>(*msg_send));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strncpy</span>(msg_send, <span class="string">&quot;Hello&quot;</span>, <span class="number">6</span>);                       <span class="comment">// 发送的消息</span></span><br><span class="line">    <span class="keyword">if</span> ((send(sock_fd, msg_send, g_buff_size, <span class="number">0</span>)) == <span class="number">-1</span>) <span class="comment">// 发送数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((close(sock_fd)) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;send() close() error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        perror(<span class="string">&quot;send() error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((recv(sock_fd, msg_recv, g_buff_size, <span class="number">0</span>)) == <span class="number">-1</span>) <span class="comment">// 接收数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((close(sock_fd)) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;recv() close() error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        perror(<span class="string">&quot;recv() error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, msg_recv); <span class="comment">// 接收的消息</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭套接字文件描述符</span></span><br><span class="line">    <span class="keyword">if</span> ((close(sock_fd)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;close() error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#变量</span></span><br><span class="line">targets = server client</span><br><span class="line"></span><br><span class="line"><span class="comment">#伪目标</span></span><br><span class="line">.PHONY : all</span><br><span class="line">all : $(targets) </span><br><span class="line"></span><br><span class="line"><span class="comment">#规则</span></span><br><span class="line">server : server.c</span><br><span class="line">gcc -o server server.c </span><br><span class="line"></span><br><span class="line">client : client.c</span><br><span class="line">gcc -o client client.c</span><br><span class="line"></span><br><span class="line"><span class="comment">#伪目标</span></span><br><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line"><span class="built_in">rm</span> $(targets)</span><br></pre></td></tr></table></figure><hr><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p>server：</p><p><img src="/../img/simple_tcp/one.png" alt="在这里插入图片描述"></p><p>client：</p><p><img src="/../img/simple_tcp/two.png" alt="在这里插入图片描述"></p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>网络编程代码实例：传输控制协议（TCP）简单版。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《UNIX环境高级编程（第3版）》作者：W.Richard Stevens，Stephen A.Rago</li><li>《UNIX网络编程（第3版）》作者：W.Richard Stevens，Bill Fenner，Andrew M.Rudoff</li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 环境和网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境和网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js代码实例：简单Web服务端</title>
      <link href="/2023/04/21/Node.js%E4%BB%A3%E7%A0%81%E5%AE%9E%E4%BE%8B%EF%BC%9A%E7%AE%80%E5%8D%95Web%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
      <url>/2023/04/21/Node.js%E4%BB%A3%E7%A0%81%E5%AE%9E%E4%BE%8B%EF%BC%9A%E7%AE%80%E5%8D%95Web%E6%9C%8D%E5%8A%A1%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Node.js代码实例：简单Web服务端。</p><hr><h1 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h1><ul><li><a href="https://github.com/yezhening/Programming-examples">yezhening&#x2F;Programming-examples: 编程实例 (github.com)</a></li><li><a href="https://gitee.com/yezhening/Programming-examples">Programming-examples: 编程实例 (gitee.com)</a></li></ul><hr><h1 id="为什么要写一份Node-js简单Web服务端的代码实例？"><a href="#为什么要写一份Node-js简单Web服务端的代码实例？" class="headerlink" title="为什么要写一份Node.js简单Web服务端的代码实例？"></a>为什么要写一份Node.js简单Web服务端的代码实例？</h1><ul><li>想多了解一些技术知识，所以简单学习了Node.js</li><li>写过C和C++的环境和网络编程，它们的处理很复杂。了解到Node.js底层使用Libuv网络异步I&#x2F;O库，以事件驱动+异步I&#x2F;O方式运行，适合处理网络I&#x2F;O高并发的场景，和Go语言相似，具有互相比对的学习价值</li><li>写过而且写的很多代码都是客户端&#x2F;服务端（C&#x2F;S）模型的网络传输，写一份关于Web服务端的传输，能够深入了解Web服务和HTTP原理</li></ul><hr><h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><ul><li>详细解析创建http服务端的流程、URL的组成、请求消息的结构和响应消息的结构</li><li>通过网络传输，浏览器客户端向该Web服务端发送“GET”请求，服务端依据URL响应本地相应的HTML、CSS和JavaScript文件，并在客户端渲染显示页面</li></ul><hr><h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><p>simple_Web_server目录：</p><ul><li>server.js文件</li><li>www目录</li></ul><p>www目录：</p><ul><li>index.html</li><li>index.css</li><li>index.js</li><li>value.html</li></ul><hr><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="server-js"><a href="#server-js" class="headerlink" title="server.js"></a>server.js</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一、导入http模块</span></span><br><span class="line"><span class="keyword">const</span> http_module = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)    <span class="comment">// HTTP相关</span></span><br><span class="line"><span class="keyword">const</span> path_module = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>) <span class="comment">// 字符串路径相关</span></span><br><span class="line"><span class="keyword">const</span> fs_module = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)    <span class="comment">// 文件系统相关</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二、创建服务端对象</span></span><br><span class="line"><span class="comment">// 参数：可选项服务端如timeout和keepalive等配置，自动添加到‘request’请求事件的回调函数：当有客户端发起请求时，调用这个回调函数</span></span><br><span class="line"><span class="comment">// 返回值：http.server对象</span></span><br><span class="line"><span class="keyword">const</span> server = http_module.<span class="title function_">createServer</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> host = <span class="string">&#x27;127.0.0.1&#x27;</span>    <span class="comment">// 主机</span></span><br><span class="line"><span class="keyword">const</span> port = <span class="number">8000</span>   <span class="comment">// 端口</span></span><br><span class="line"><span class="keyword">const</span> request_query_stringing_key = <span class="string">&#x27;key&#x27;</span>   <span class="comment">// 请求url中，查询字符串的键</span></span><br><span class="line"><span class="keyword">const</span> site_root_directory = <span class="string">&#x27;www&#x27;</span>   <span class="comment">// 网站根目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 三、服务端对象绑定‘request’请求事件，监听客户端请求</span></span><br><span class="line"><span class="comment">// emitter.on(eventName, listener)是node.js中的事件绑定方法</span></span><br><span class="line"><span class="comment">// 当有客户端发起请求时，调用这个回调函数：传入http.IncomingMessage请求对象和http.ServerResponse响应对象</span></span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;request&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 获取http请求信息</span></span><br><span class="line">    <span class="comment">// http请求有3部分：请求行，请求头和请求体</span></span><br><span class="line">    <span class="comment">// 请求行有3部分：方法，url，http版本</span></span><br><span class="line">    <span class="comment">// （1）获取方法：“GET”，这里不需要</span></span><br><span class="line">    <span class="comment">// const request_method = request.method</span></span><br><span class="line">    <span class="comment">// （1）获取url：“/index.html?key=value”</span></span><br><span class="line">    <span class="keyword">const</span> request_url = request.<span class="property">url</span></span><br><span class="line">    <span class="comment">// （1）获取版本：“1.1”，这里不需要</span></span><br><span class="line">    <span class="comment">// const request_version = request.httpVersion   </span></span><br><span class="line">    <span class="comment">// （2）获取请求头，返回键值对object，这里不需要</span></span><br><span class="line">    <span class="comment">// const request_headers = request.headers </span></span><br><span class="line">    <span class="comment">// （3）获取请求体，返回string。GET方法请求体一般为空，这里不需要</span></span><br><span class="line">    <span class="comment">// let request_body = &#x27;&#x27;</span></span><br><span class="line">    <span class="comment">// request.on(&#x27;data&#x27;, (chunk) =&gt; &#123; // 请求绑定‘data’事件，数据按流传输，有数据时读取chunk为Buffer对象，自动转换为string</span></span><br><span class="line">    <span class="comment">//     request_body += chunk</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// request.on(&#x27;end&#x27;, () =&gt; &#123; // 请求绑定‘end’事件，数据传输完成时触发</span></span><br><span class="line">    <span class="comment">//     console.log(request_body)</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  2. 处理url。如http://127.0.0.1:8000/index.html?key=value</span></span><br><span class="line">    <span class="comment">// url有4部分：协议“http://”，地址主机名和端口“127.0.0.1:8000”，路径“/index.html”，查询字符串“?key=value”</span></span><br><span class="line">    <span class="comment">// (1）获取协议http，这里不需要</span></span><br><span class="line">    <span class="comment">// (2) 获取地址，这里不需要</span></span><br><span class="line">    <span class="keyword">const</span> absolute_url = <span class="string">&#x27;http://&#x27;</span> + host + <span class="string">&#x27;:&#x27;</span> + port + request_url    <span class="comment">// 获取请求的绝对url。如http://127.0.0.1:8000/index.html?key=value</span></span><br><span class="line">    <span class="keyword">const</span> request_path_query_string = <span class="keyword">new</span> <span class="title function_">URL</span>(absolute_url)  <span class="comment">// 解析绝对url，获取路径和查询字符串。如：/index.html?key=value</span></span><br><span class="line">    <span class="comment">// （3）获取路径。如：/index.html</span></span><br><span class="line">    <span class="keyword">const</span> request_path = request_path_query_string.<span class="property">pathname</span></span><br><span class="line">    <span class="comment">// （4）获取查询字符串。返回object如：&#123;&#x27;key&#x27; =&gt; &#x27;value&#x27;&#125;</span></span><br><span class="line">    <span class="keyword">const</span> request_query_string = request_path_query_string.<span class="property">searchParams</span></span><br><span class="line">    <span class="keyword">const</span> request_query_string_value = request_query_string.<span class="title function_">get</span>(request_query_stringing_key)    <span class="comment">// 获取查询字符串的值。如：通过&#x27;key&#x27;获取&#x27;value&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 结合网络路径和查询字符串，映射为本地文件系统中的路径</span></span><br><span class="line">    <span class="keyword">let</span> fs_path = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> (request_path === <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        fs_path = path_module.<span class="title function_">join</span>(__dirname, site_root_directory, <span class="string">&quot;index.html&quot;</span>)</span><br><span class="line">        <span class="comment">// 对于url为&#x27;/&#x27;的网络路径，映射为服务端js文件所在当前目录下，网站根目录下的index.html文件路径</span></span><br><span class="line">        <span class="comment">// 如：C:\Users\DSHH\Desktop\simple_Web_server\www\index.html</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (request_path === <span class="string">&#x27;/index.html&#x27;</span> &amp;&amp; request_query_string_value === <span class="string">&#x27;value&#x27;</span>) &#123;</span><br><span class="line">        fs_path = path_module.<span class="title function_">join</span>(__dirname, site_root_directory, <span class="string">&quot;value.html&quot;</span>)</span><br><span class="line">        <span class="comment">// 对于url为&#x27;/index.html&#x27;的网络路径，查询字符串值为&#x27;value&#x27;，映射为服务端js文件所在当前目录下，网站根目录下的value.html文件路径</span></span><br><span class="line">        <span class="comment">// 如：C:\Users\DSHH\Desktop\simple_Web_server\www\value.html</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fs_path = path_module.<span class="title function_">join</span>(__dirname, site_root_directory, request_path)</span><br><span class="line">        <span class="comment">// 对于其他网络路径，映射为服务端js文件当前目录下，网站根目录下的资源文件路径</span></span><br><span class="line">        <span class="comment">// 如url为：&#x27;/other.html&#x27;，则本地路径为：如：C:\Users\DSHH\Desktop\simple_Web_server\www\other.html</span></span><br><span class="line">        <span class="comment">// 注意：对于其他资源如css、js、ico等请求，全都走这个分支</span></span><br><span class="line">        <span class="comment">// 如：C:\Users\DSHH\Desktop\simple_Web_server\www\index.css、C:\Users\DSHH\Desktop\simple_Web_server\www\favicon.ico</span></span><br><span class="line">        <span class="comment">// 注意：浏览器除了请求路径中的页面，可能会自动请求favicon.ico作为网页的图标，可不管</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 读取本地文件系统相应的文件，设置http响应信息</span></span><br><span class="line">    <span class="comment">// http响应有3部分：响应行，响应头和响应体</span></span><br><span class="line">    <span class="comment">// 响应行有3部分：http版本，状态码，状态描述</span></span><br><span class="line">    <span class="comment">//（1) http版本，无需设置</span></span><br><span class="line">    <span class="comment">// (2) 状态码在下面读取文件时设置</span></span><br><span class="line">    <span class="comment">// (3) 状态描述无需设置，一般与状态码匹配</span></span><br><span class="line">    <span class="comment">// response.statusMessage = &#x27;This is status message&#x27;</span></span><br><span class="line">    <span class="comment">// (4) 响应头</span></span><br><span class="line">    <span class="comment">// 注意：</span></span><br><span class="line">    <span class="comment">// 只需要依据文档类型设置mime类型让浏览器可以解析html、css和js文档</span></span><br><span class="line">    <span class="comment">// 否则当html、css、js分文件编写时，请求html会再次请求css和js文档，再次进入这个回调函数</span></span><br><span class="line">    <span class="comment">// 若mime类型为text/html，则无法解析css文档，css无法渲染</span></span><br><span class="line">    <span class="comment">// 设置编码为utf8支持中文显示不乱码</span></span><br><span class="line">    <span class="keyword">const</span> fs_path_ext_name = path_module.<span class="title function_">extname</span>(fs_path) <span class="comment">// 获取本地路径文件的扩展名，如：.css</span></span><br><span class="line">    <span class="keyword">const</span> fs_path_mime_type = fs_path_ext_name.<span class="title function_">slice</span>(<span class="number">1</span>)   <span class="comment">// 获取mime类型中，text类型下的子类型名，如：css</span></span><br><span class="line">    response.<span class="title function_">setHeader</span>(<span class="string">&#x27;content-type&#x27;</span>, <span class="string">`text/<span class="subst">$&#123;fs_path_mime_type&#125;</span>;charset=utf-8`</span>)   <span class="comment">// 拼接为：text/css;charset=utf-8</span></span><br><span class="line">    <span class="comment">// (5) 响应体，在下面读取文件时设置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数：文件路径和编码等可选项，回调函数</span></span><br><span class="line">    <span class="comment">// 当读取完成时，调用这个回调函数：传入错误Error和数据string对象</span></span><br><span class="line">    fs_module.<span class="title function_">readFile</span>(fs_path, <span class="string">&#x27;utf8&#x27;</span>, <span class="function">(<span class="params">error, data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 如果有错误，返回404资源不存在状态码和状态信息</span></span><br><span class="line">        <span class="comment">// 没有错误，返回读取的文件数据</span></span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            response.<span class="property">statusCode</span> = <span class="number">404</span>   <span class="comment">// （2）设置状态码</span></span><br><span class="line">            <span class="comment">// 参数：流数据，可选项编码和回调函数</span></span><br><span class="line">            <span class="comment">// 返回值：bool，不需要</span></span><br><span class="line">            response.<span class="title function_">write</span>(<span class="string">&#x27;&lt;h1&gt;404 未找到&lt;/h1&gt;&#x27;</span>)   <span class="comment">// （5）设置响应体</span></span><br><span class="line">            <span class="comment">// 参数：数据、编码和回调函数等可选项</span></span><br><span class="line">            <span class="comment">// 返回值：this，即end()的调用者response对象</span></span><br><span class="line">            <span class="comment">// 对每个响应可以调用多次write()写入数据，必须调用一次end()返回响应</span></span><br><span class="line">            response.<span class="title function_">end</span>()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            response.<span class="property">statusCode</span> = <span class="number">200</span>   <span class="comment">// （2）设置状态码</span></span><br><span class="line">            response.<span class="title function_">write</span>(data)    <span class="comment">// （5）设置响应体</span></span><br><span class="line">            response.<span class="title function_">end</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 四、启动服务端监听</span></span><br><span class="line"><span class="comment">// 参数：对于TCP，使用端口、地址、半连接和全连接队列和回调函数可选项</span></span><br><span class="line">server.<span class="title function_">listen</span>(port, host, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Wen服务端运行在: http://<span class="subst">$&#123;host&#125;</span>:<span class="subst">$&#123;port&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><hr><h2 id="index-html"><a href="#index-html" class="headerlink" title="index.html"></a>index.html</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;./index.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是index.html<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="index-css"><a href="#index-css" class="headerlink" title="index.css"></a>index.css</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a>index.js</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;这是index.js&#x27;</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="value-html"><a href="#value-html" class="headerlink" title="value.html"></a>value.html</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是value.html<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p>运行Web服务端：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\DSHH\Desktop\simple_Web_server&gt; node server.js</span><br><span class="line">Wen服务端运行在: http://<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">8000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>浏览器访问： <a href="http://127.0.0.1:8000/">http://127.0.0.1:8000/</a> 或 <a href="http://127.0.0.1:8000/index.html">http://127.0.0.1:8000/index.html</a></p><p><img src="/../img/nodejs_web/%E6%88%AA%E5%9B%BE20230421125634.png"></p><p><img src="/../img/nodejs_web/%E6%88%AA%E5%9B%BE20230421125701.png" alt="在这里插入图片描述"></p><p>浏览器访问： <a href="http://127.0.0.1:8000/index.html?key=value">http://127.0.0.1:8000/index.html?key=value</a></p><p><img src="/../img/nodejs_web/%E6%88%AA%E5%9B%BE20230421125803.png" alt="在这里插入图片描述"></p><p>浏览器访问： <a href="http://127.0.0.1:8000/other.html">http://127.0.0.1:8000/other.html</a></p><p><img src="/../img/nodejs_web/%E6%88%AA%E5%9B%BE20230421125848.png" alt="在这里插入图片描述"></p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Node.js代码实例：简单Web服务端。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://nodejs.org/en">Node.js (nodejs.org)</a></li><li><a href="https://nodejs.cn/">Node.js 中文网 (nodejs.cn)</a></li><li><a href="https://www.bilibili.com/video/BV1a34y167AZ/?spm_id_from=333.337.search-card.all.click&vd_source=9ac1c0a6d496218112b60d49bc768cd7">黑马程序员Node.js全套入门教程，nodejs新教程含es6模块化+npm+express+webpack+promise等_Nodejs实战案例详解_哔哩哔哩_bilibili</a></li><li><a href="https://www.bilibili.com/video/BV1gM411W7ex/?spm_id_from=333.337.search-card.all.click&vd_source=9ac1c0a6d496218112b60d49bc768cd7">尚硅谷2023版Node.js零基础视频教程，nodejs新手到高手_哔哩哔哩_bilibili</a></li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Node.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go网络编程的学习代码示例：网络文件传输</title>
      <link href="/2023/04/18/Go%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%EF%BC%9A%E7%BD%91%E7%BB%9C%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/"/>
      <url>/2023/04/18/Go%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%EF%BC%9A%E7%BD%91%E7%BB%9C%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Go网络编程的学习代码示例：网络文件传输。</p><hr><h1 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h1><ul><li><a href="https://github.com/yezhening/Programming-examples">yezhening&#x2F;Programming-examples: 编程实例 (github.com)</a></li><li><a href="https://gitee.com/yezhening/Programming-examples">Programming-examples: 编程实例 (gitee.com)</a></li></ul><hr><h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p>接续上一章“Go网络编程的学习代码示例：客户端&#x2F;服务端（C&#x2F;S）模型”内容，本章将传输的用户输入数据改为传输文件</p><blockquote><p>注意：关于网络编程的代码，上一章有详细的注释，本章不再过多注释，只注释新增的网络文件传输相关内容</p></blockquote><hr><h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><ul><li>使用服务端&#x2F;客户端（C&#x2F;S）模型</li><li>实现发送方（客户端）和接收方（服务端）的简单网络文件传输：发送方发送文件名，接收方回复响应，发送方再发送文件内容，接收方接收文件内容并保存在当前目录</li></ul><blockquote><p>网络传输文件的形式和本地传输文件类似，<strong>本质是写读文件</strong></p></blockquote><hr><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><p>发送方：客户端</p><ol><li>接收用户输入，获取完整文件路径并提取文件信息：fmt.Scan()、os.Stat()</li><li>发送连接请求：net.Dial()</li><li>发送文件名：net.Write()</li><li>接收，接收方接收到文件名后的响应信息：net.Read()</li><li>发送文件内容：os.Open()、os.Read()、net.Write()、os.Close()</li><li>关闭连接：net.Close()</li></ol><p>接收方：服务端</p><ol><li>监听连接请求：net.Listen(）</li><li>接受连接请求：net.Accept()</li><li>接收文件名：net.Read()</li><li>发送，接收到文件名后的响应信息：net.Write()</li><li>接收文件内容：os.Create()、net.Read()、os.Write()、os.Close()</li><li>关闭连接：net.Close()</li></ol><hr><h1 id="代码（有详细注释）"><a href="#代码（有详细注释）" class="headerlink" title="代码（有详细注释）"></a>代码（有详细注释）</h1><h2 id="recv-go"><a href="#recv-go" class="headerlink" title="recv.go"></a>recv.go</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span> <span class="comment">// 文件相关</span></span><br><span class="line"><span class="string">&quot;net&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span> <span class="comment">// 操作系统/文件相关</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 五、接收文件内容</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv_file</span><span class="params">(file_name <span class="type">string</span>, conn net.Conn)</span></span> &#123;</span><br><span class="line">file, create_error := os.Create(file_name) <span class="comment">// 在当前路径下创建文件</span></span><br><span class="line"><span class="comment">// 返回值：File结构体</span></span><br><span class="line"><span class="keyword">if</span> create_error != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;os.Create():&quot;</span>, create_error)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> file.Close() <span class="comment">// 延迟关闭文件</span></span><br><span class="line"></span><br><span class="line">buffer := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>)</span><br><span class="line"><span class="comment">// 循环处理</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">read_count, read_error := conn.Read(buffer) <span class="comment">// 网络读取文件，按字节</span></span><br><span class="line"><span class="keyword">if</span> read_error != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 注意：读取完成时，会读取到EOF文件结束标志，错误标志置位为“EOF”，需要进行额外判断</span></span><br><span class="line"><span class="keyword">if</span> read_error == io.EOF &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;接收完成:&quot;</span>, read_error)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;net.Read():&quot;</span>, read_error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="comment">// 注意：接收完成和出现错误两种情况，函数返回，其他情况持续向本地写入文件</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// if n == 0 &#123; //对端断开，出问题</span></span><br><span class="line"><span class="comment">// fmt.Println(&quot;接收完毕2&quot;)</span></span><br><span class="line"><span class="comment">// break</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">file.Write(buffer[:read_count]) <span class="comment">// 本地写入文件，按字节</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 一、监听连接请求</span></span><br><span class="line">listener, listen_error := net.Listen(<span class="string">&quot;tcp4&quot;</span>, <span class="string">&quot;127.0.0.1:8000&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> listen_error != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;net.Listen():&quot;</span>, listen_error)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 六、2.关闭连接</span></span><br><span class="line"><span class="keyword">defer</span> listener.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二、接受连接请求</span></span><br><span class="line">conn, accept_error := listener.Accept()</span><br><span class="line"><span class="keyword">if</span> accept_error != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;net.Accept():&quot;</span>, accept_error)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 六、1.关闭连接</span></span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三、接收文件名</span></span><br><span class="line">buffer := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>)</span><br><span class="line">read_count, read_error := conn.Read(buffer)</span><br><span class="line"><span class="keyword">if</span> read_error != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;net.Read():&quot;</span>, read_error)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">file_name := <span class="type">string</span>(buffer[:read_count]) <span class="comment">// 获取文件名</span></span><br><span class="line"><span class="comment">// 注意：网络字节转换为字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 四、发送，接收到文件名后的响应信息</span></span><br><span class="line">conn.Write([]<span class="type">byte</span>(<span class="string">&quot;ok&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 五、接收文件内容</span></span><br><span class="line">recv_file(file_name, conn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="send-go"><a href="#send-go" class="headerlink" title="send.go"></a>send.go</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span> <span class="comment">// 文件相关</span></span><br><span class="line"><span class="string">&quot;net&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span> <span class="comment">// 操作系统/文件相关</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 五、发送文件内容</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send_file</span><span class="params">(file_path <span class="type">string</span>, conn net.Conn)</span></span> &#123;</span><br><span class="line">file, open_error := os.Open(file_path) <span class="comment">// 打开文件</span></span><br><span class="line"><span class="comment">// 返回值：File结构体</span></span><br><span class="line"><span class="keyword">if</span> open_error != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;os.Open():&quot;</span>, open_error)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> file.Close() <span class="comment">// 延迟关闭文件</span></span><br><span class="line"></span><br><span class="line">buffer := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>)</span><br><span class="line"><span class="comment">// 循环处理</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">read_count, read_error := file.Read(buffer) <span class="comment">// 本地读取文件，按字节</span></span><br><span class="line"><span class="keyword">if</span> read_error != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 注意：读取完成时，会读取到EOF文件结束标志，错误标志置位为“EOF”，需要进行额外判断</span></span><br><span class="line"><span class="keyword">if</span> read_error == io.EOF &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;发送完成:&quot;</span>, read_error)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;os.Read()&quot;</span>, read_error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="comment">// 注意：发送完成和出现错误两种情况，函数返回，其他情况持续向网络写入文件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">conn.Write(buffer[:read_count]) <span class="comment">// 网络写入文件，按字节</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 一、1.接收用户输入，获取完整文件路径。如：C:\Users\DSHH\Desktop\temp.txt</span></span><br><span class="line">fmt.Print(<span class="string">&quot;请输入完整文件路径：&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> file_path <span class="type">string</span></span><br><span class="line">fmt.Scan(&amp;file_path)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一、2.提取文件信息</span></span><br><span class="line">file_info, stat_error := os.Stat(file_path)</span><br><span class="line"><span class="comment">// 返回值：FileInfo = fs.FileInfo接口类型</span></span><br><span class="line"><span class="keyword">if</span> stat_error != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;os.Stat():&quot;</span>, stat_error)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二、发送连接请求</span></span><br><span class="line">conn, dial_error := net.Dial(<span class="string">&quot;tcp4&quot;</span>, <span class="string">&quot;127.0.0.1:8000&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> dial_error != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;net.Dial():&quot;</span>, dial_error)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 六、关闭连接</span></span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">//  三、发送文件名</span></span><br><span class="line">_, write_error := conn.Write([]<span class="type">byte</span>(file_info.Name()))</span><br><span class="line"><span class="comment">// Name()返回string，如：temp.txt，转换为byte切片在网络中传输</span></span><br><span class="line"><span class="keyword">if</span> write_error != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;net.Write():&quot;</span>, write_error)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 四、接收，接收方接收到文件名后的响应信息</span></span><br><span class="line">buffer := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>)</span><br><span class="line">read_count, read_error := conn.Read(buffer)</span><br><span class="line"><span class="keyword">if</span> read_error != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;net.Read():&quot;</span>, read_error)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 五、发送文件内容</span></span><br><span class="line"><span class="keyword">if</span> <span class="type">string</span>(buffer[:read_count]) == <span class="string">&quot;ok&quot;</span> &#123; <span class="comment">// 注意：网络接收为byte字节序列，需要转换为string类型才能作比较</span></span><br><span class="line">send_file(file_path, conn)</span><br><span class="line"><span class="comment">// 注意，参数使用完整文件路径而不是文件名，因为后续需要在指定路径打开文件</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p>send.go：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\DSHH\Desktop\go_test&gt; go run send.go</span><br><span class="line">请输入完整文件路径：C:\Users\DSHH\Desktop\temp.txt</span><br><span class="line">发送完成: EOF</span><br><span class="line"><span class="built_in">PS</span> C:\Users\DSHH\Desktop\go_test&gt;</span><br></pre></td></tr></table></figure><p>recv.go：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\DSHH\Desktop\go_test&gt; go run recv.go</span><br><span class="line">接收完成: EOF</span><br><span class="line"><span class="built_in">PS</span> C:\Users\DSHH\Desktop\go_test&gt;</span><br></pre></td></tr></table></figure><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Go网络编程的学习代码示例：网络文件传输。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.bilibili.com/video/BV17W411W7hm/?spm_id_from=333.337.search-card.all.click&vd_source=9ac1c0a6d496218112b60d49bc768cd7">黑马程序员20个小时快速入门go语言（下）_哔哩哔哩_bilibili</a></li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go网络编程的学习代码示例：客户端/服务端（C/S）模型</title>
      <link href="/2023/04/17/Go%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%AE%A2%E6%88%B7%E7%AB%AF_%E6%9C%8D%E5%8A%A1%E7%AB%AF%EF%BC%88C_S%EF%BC%89%E6%A8%A1%E5%9E%8B/"/>
      <url>/2023/04/17/Go%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%AE%A2%E6%88%B7%E7%AB%AF_%E6%9C%8D%E5%8A%A1%E7%AB%AF%EF%BC%88C_S%EF%BC%89%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Go网络编程的学习代码示例：客户端&#x2F;服务端（C&#x2F;S）模型。</p><hr><h1 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h1><ul><li><a href="https://github.com/yezhening/Programming-examples">yezhening&#x2F;Programming-examples: 编程实例 (github.com)</a></li><li><a href="https://gitee.com/yezhening/Programming-examples">Programming-examples: 编程实例 (gitee.com)</a></li></ul><hr><h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h1><p>包名：net</p><p>服务端的网络通信流程：</p><ol><li>监听连接请求：Listen()</li><li>接受连接请求：Accept()</li><li>发送和接收数据：Write()、Read()</li><li>关闭连接：Close()</li></ol><p>客户端的网络通信流程：</p><ol><li>发送连接请求：Dial()</li><li>发送和接收数据：Write()、Read()</li><li>关闭连接：Close()</li></ol><blockquote><p>相比于C、C++和其他语言，使用Go实现网络编程的逻辑很简单</p></blockquote><hr><h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><ul><li><p>实现服务端和客户端的简单通信：服务端接收，并原样发送所接收的数据给客户端</p></li><li><p>服务端使用多协程处理与多客户端的连接</p></li><li><p>客户端使用多协程处理终端用户输入和接收服务端数据</p></li></ul><hr><h1 id="代码示例（有详细注释）"><a href="#代码示例（有详细注释）" class="headerlink" title="代码示例（有详细注释）"></a>代码示例（有详细注释）</h1><h2 id="server-go"><a href="#server-go" class="headerlink" title="server.go"></a>server.go</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;net&quot;</span> <span class="comment">// 网络处理</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理连接请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(conn net.Conn)</span></span> &#123; <span class="comment">// 注意：conn的类型Conn是net包中的接口，需要引用</span></span><br><span class="line"><span class="comment">// 四、1关闭连接</span></span><br><span class="line"><span class="keyword">defer</span> conn.Close() <span class="comment">// handle()结束前关闭连接。注意：Close()有返回值为error接口，使用defer后这里不再处理错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取连接请求的地址</span></span><br><span class="line">addr := conn.RemoteAddr().String()</span><br><span class="line"><span class="comment">// RemoteAddr()返回值为Addr接口，Addr接口实现了String()，String()返回值为string类型</span></span><br><span class="line">fmt.Println(<span class="string">&quot;RemoteAddr:&quot;</span>, addr)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三、接收和发送数据</span></span><br><span class="line">data_buffer := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">16</span>)</span><br><span class="line"><span class="comment">// 数据缓冲区，切片类型，网络中以二进制/字节传输，后面Read()和Write()参数也是字节类型，16字节大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收并原封不动发送回所接收的数据</span></span><br><span class="line"><span class="comment">// 循环处理，只有在接收“quit”时，才退出handle()协程</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// 读取数据</span></span><br><span class="line">read_count, read_error := conn.Read(data_buffer)</span><br><span class="line"><span class="comment">// 返回值：接收的字节数量int，error接口</span></span><br><span class="line"><span class="keyword">if</span> read_error != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Read() error:&quot;</span>, read_error)</span><br><span class="line"><span class="keyword">return</span> <span class="comment">// 注意：异常退出handle(）协程</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;Read:&quot;</span>, <span class="type">string</span>(data_buffer[:read_count]))</span><br><span class="line"><span class="comment">// 输出读取的数据，从[0,read_count-2)的切片数据，byte需要转换为string类型</span></span><br><span class="line"><span class="comment">// 注意：Windows会多传输\r\n两个字符，所以要-2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是“quit”，退出handle()协程</span></span><br><span class="line"><span class="keyword">if</span> <span class="type">string</span>(data_buffer[:read_count]) == <span class="string">&quot;quit&quot;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="comment">// 注意：正常退出handle(）协程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入数据，直接写字节数组</span></span><br><span class="line">_, write_error := conn.Write(data_buffer[:read_count])</span><br><span class="line"><span class="comment">// 返回值：写入的字节数量不需要，error接口</span></span><br><span class="line"><span class="keyword">if</span> write_error != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Write() error:&quot;</span>, write_error)</span><br><span class="line"><span class="keyword">return</span> <span class="comment">// 注意：异常退出handle(）协程</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;Write:&quot;</span>, <span class="type">string</span>(data_buffer[:read_count])) <span class="comment">// 同理输出写入数据</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 一、监听连接请求</span></span><br><span class="line">listener, listen_error := net.Listen(<span class="string">&quot;tcp4&quot;</span>, <span class="string">&quot;127.0.0.1:8000&quot;</span>)</span><br><span class="line"><span class="comment">// 参数：使用TCP，IPv4，本机IP地址127.0.0.1，端口号8000</span></span><br><span class="line"><span class="comment">// 返回值：Listener接口（类似监听套接字文件描述符），error接口</span></span><br><span class="line"><span class="keyword">if</span> listen_error != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Listen() error:&quot;</span>, listen_error) <span class="comment">// Println()有返回值，不再处理</span></span><br><span class="line"><span class="keyword">return</span>                                       <span class="comment">// 注意：退出main()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 四、2关闭连接</span></span><br><span class="line"><span class="keyword">defer</span> listener.Close() <span class="comment">// main()结束前关闭连接。注意：Close()有返回值为error接口，使用defer后这里不再处理错误</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// 二、循环接受连接请求</span></span><br><span class="line">conn, accept_error := listener.Accept()</span><br><span class="line"><span class="comment">// 返回值：Conn接口（类似连接套接字文件描述符），error接口</span></span><br><span class="line"><span class="keyword">if</span> accept_error != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Accept() error:&quot;</span>, accept_error)</span><br><span class="line"><span class="keyword">continue</span> <span class="comment">// 注意：继续for&#123;&#125;循环接受连接请求，而不是return退出main()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启goroutine并发处理多客户端请求，一个conn代表一个客户端</span></span><br><span class="line"><span class="keyword">go</span> handle(conn)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="client-go"><a href="#client-go" class="headerlink" title="client.go"></a>client.go</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;net&quot;</span> <span class="comment">// 网络处理</span></span><br><span class="line"><span class="string">&quot;os&quot;</span>  <span class="comment">// 操作系统相关，这里用于接收用户输入</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 一、发送连接请求</span></span><br><span class="line">conn, dial_error := net.Dial(<span class="string">&quot;tcp4&quot;</span>, <span class="string">&quot;127.0.0.1:8000&quot;</span>)</span><br><span class="line"><span class="comment">// 参数：连接TCP，IPv4，本机IP地址127.0.0.1，端口号8000</span></span><br><span class="line"><span class="comment">// 返回值：Conn接口（类似套接字文件描述符），error接口</span></span><br><span class="line"><span class="keyword">if</span> dial_error != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Dial() error:&quot;</span>, dial_error)</span><br><span class="line"><span class="keyword">return</span> <span class="comment">// 注意：退出main()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三、关闭连接</span></span><br><span class="line"><span class="keyword">defer</span> conn.Close() <span class="comment">// main()结束前关闭连接。注意：Close()有返回值为error接口，使用defer后这里不再处理错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二、发送和接收数据</span></span><br><span class="line"><span class="comment">// 开启goroutine并发处理用户终端输入数据，发送数据</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">data_buffer := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">16</span>)</span><br><span class="line"><span class="comment">// 数据缓冲区，切片类型，网络中以二进制/字节传输，后面Read()和Write()参数也是字节类型，16字节大小</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">read_count, read_error := os.Stdin.Read(data_buffer) <span class="comment">//从标准输入读取用户输入</span></span><br><span class="line"><span class="comment">// 返回值：接收的字节数量int，error接口</span></span><br><span class="line"><span class="keyword">if</span> read_error != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Stdin.Read() error:&quot;</span>, read_error)</span><br><span class="line"><span class="keyword">return</span> <span class="comment">// 注意：退出协程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">conn.Write(data_buffer[:read_count<span class="number">-2</span>]) <span class="comment">//写入数据</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Write:&quot;</span>, <span class="type">string</span>(data_buffer[:read_count<span class="number">-2</span>]))</span><br><span class="line"><span class="comment">// Windows会将\r\n写入，先-2再写入</span></span><br><span class="line"><span class="comment">// 输出写入的数据，从[0,scan_count-2)的切片数据，byte需要转换为string类型</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主协程处理接收的数据</span></span><br><span class="line">data_buffer := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">16</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">read_count, read_error := conn.Read(data_buffer)</span><br><span class="line"><span class="keyword">if</span> read_error != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Read() error:&quot;</span>, read_error)</span><br><span class="line"><span class="keyword">return</span> <span class="comment">// 注意：退出main()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;Read:&quot;</span>, <span class="type">string</span>(data_buffer[:read_count])) <span class="comment">// 同理输出读取的数据</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p>server.go：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\DSHH\Desktop\go_test&gt; go run server.go</span><br><span class="line">RemoteAddr: <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">61915</span></span><br><span class="line">Read: aaa</span><br><span class="line"><span class="built_in">Write</span>: aaa</span><br><span class="line">RemoteAddr: <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">61939</span></span><br><span class="line">Read: bbb</span><br><span class="line"><span class="built_in">Write</span>: bbb</span><br><span class="line">Read: quit</span><br><span class="line">Read: quit</span><br><span class="line"><span class="keyword">exit</span> status <span class="number">0</span>xc000013a</span><br><span class="line"><span class="built_in">PS</span> C:\Users\DSHH\Desktop\go_test&gt; </span><br></pre></td></tr></table></figure><p>client.go：先连接先退出</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\DSHH\Desktop\go_test&gt; go run client.go</span><br><span class="line">aaa</span><br><span class="line"><span class="built_in">Write</span>: aaa</span><br><span class="line">Read: aaa</span><br><span class="line">quit</span><br><span class="line"><span class="built_in">Write</span>: quit</span><br><span class="line">Read() error: EOF</span><br><span class="line"><span class="built_in">PS</span> C:\Users\DSHH\Desktop\go_test&gt;</span><br></pre></td></tr></table></figure><p>client.go：后连接后退出</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\DSHH\Desktop\go_test&gt; go run client.go</span><br><span class="line">bbb</span><br><span class="line"><span class="built_in">Write</span>: bbb</span><br><span class="line">Read: bbb</span><br><span class="line">quit</span><br><span class="line"><span class="built_in">Write</span>: quit</span><br><span class="line">Read() error: EOF</span><br><span class="line"><span class="built_in">PS</span> C:\Users\DSHH\Desktop\go_test&gt;</span><br></pre></td></tr></table></figure><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Go网络编程的学习代码示例：客户端&#x2F;服务端（C&#x2F;S）模型。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.bilibili.com/video/BV17W411W7hm/?spm_id_from=333.337.search-card.all.click&vd_source=9ac1c0a6d496218112b60d49bc768cd7">黑马程序员20个小时快速入门go语言（下）_哔哩哔哩_bilibili</a></li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go并发编程学习的简单代码示例：生产者消费者模型</title>
      <link href="/2023/04/16/Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%EF%BC%9A%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/"/>
      <url>/2023/04/16/Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%EF%BC%9A%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Go并发编程学习的简单代码示例：生产者消费者模型。</p><hr><h1 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h1><ul><li><a href="https://github.com/yezhening/Programming-examples">yezhening&#x2F;Programming-examples: 编程实例 (github.com)</a></li><li><a href="https://gitee.com/yezhening/Programming-examples">Programming-examples: 编程实例 (gitee.com)</a></li></ul><hr><h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h1><p>并行和并发：</p><ul><li>并行：同时运行多个任务。依赖硬件中央处理器（CPU）的数量或CPU的核心数量，CPU或CPU核心的数量越多，能够同时运行的程序&#x2F;进程越多</li><li>并发：宏观上是“同时运行”，微观&#x2F;实际上是在极短的时间内顺序运行多个程序&#x2F;进程</li></ul><p>进程、线程、协程和Go协程（goroutine）：</p><ul><li>进程：资源分配的基本单位</li><li>线程：<strong>内核态线程；</strong> CPU调度的基本单位</li><li>协程：<strong>用户态线程；轻量级线程</strong></li><li>一个进程可以有多个线程</li><li>线程和协程对应关系可以是一对一、一对多和多对多</li><li>goroutine：Go的协程概念，使用<strong>G（Goroutine）-P（Processor）-M（Machine）模型</strong></li></ul><p>Go的并发编程：</p><ul><li><p>使用go关键字开启多协程goroutine，而不是多进程和多线程，实现并发</p></li><li><p>使用管道channal，而不是锁，实现同步互斥和数据通信</p></li></ul><blockquote><p>可联想进程间通信（IPC）中的管道pipe()、共享内存等方式</p></blockquote><ul><li>使用select{}语句，实现监听输入&#x2F;输出（I&#x2F;O）操作</li></ul><blockquote><p>可联想网络编程中的监听文件描述符select()函数</p></blockquote><blockquote><p>相比于C、C++和其他语言，使用Go实现并发编程的逻辑很简单</p></blockquote><hr><h1 id="main-go（有详细注释）"><a href="#main-go（有详细注释）" class="headerlink" title="main.go（有详细注释）"></a>main.go（有详细注释）</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main <span class="comment">// 一个工程只有一个main包</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入路径</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span> <span class="comment">// 用于输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者</span></span><br><span class="line"><span class="comment">// 参数：数据管道，单向只写；标志管道，单向只读</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">producer</span><span class="params">(data_channel <span class="keyword">chan</span>&lt;- <span class="type">int</span>, flag_channel &lt;-<span class="keyword">chan</span> <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 循环处理，接收到消费者标志后才退出循环和函数</span></span><br><span class="line">data := <span class="number">0</span> <span class="comment">//生产者生产的数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// select&#123;&#125;语句监听输入/输出（I/O）操作</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> data_channel &lt;- data: <span class="comment">//有数据写</span></span><br><span class="line">data++</span><br><span class="line"><span class="keyword">case</span> flag := &lt;-flag_channel: <span class="comment">//有标志读</span></span><br><span class="line">fmt.Println(<span class="string">&quot;生产者读标志：&quot;</span>, flag, <span class="string">&quot;结束生产&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line"><span class="comment">// 参数：数据管道，单向只读；标志管道，单向只写</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consumer</span><span class="params">(data_channel &lt;-<span class="keyword">chan</span> <span class="type">int</span>, flag_channel <span class="keyword">chan</span>&lt;- <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 约定循环5次后，消费者停止消费，向生产者发送停止生产标志</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">data := &lt;-data_channel <span class="comment">//读数据</span></span><br><span class="line">fmt.Println(<span class="string">&quot;消费者读数据：&quot;</span>, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">flag_channel &lt;- <span class="literal">true</span> <span class="comment">//写标志</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个工程只有一个main()函数，是程序的唯一入口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">data_channel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// 数据管道，生产者向消费者传输数据</span></span><br><span class="line"><span class="comment">// 传输int类型数据，0：无缓冲，双向</span></span><br><span class="line">flag_channel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// 标志管道，消费者向生产者传输标志，消费者不再消费，让生产者停止生产</span></span><br><span class="line"><span class="comment">// 传输bool类型数据，0：无缓冲，双向</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> consumer(data_channel, flag_channel) <span class="comment">//go关键字开启goroutine处理消费者任务</span></span><br><span class="line"></span><br><span class="line">producer(data_channel, flag_channel) <span class="comment">// main()中是主goroutine，处理生产者任务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\DSHH\Desktop\go_test&gt; go run main.go</span><br><span class="line">消费者读数据： <span class="number">0</span></span><br><span class="line">消费者读数据： <span class="number">1</span></span><br><span class="line">消费者读数据： <span class="number">2</span></span><br><span class="line">消费者读数据： <span class="number">3</span></span><br><span class="line">消费者读数据： <span class="number">4</span></span><br><span class="line">生产者读标志： true 结束生产</span><br><span class="line"><span class="built_in">PS</span> C:\Users\DSHH\Desktop\go_test&gt; </span><br></pre></td></tr></table></figure><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Go并发编程的学习代码示例：生产者消费者模型。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.bilibili.com/video/BV1UW411x7Ve/?spm_id_from=333.337.search-card.all.click">20个小时快速入门go语言（中）_哔哩哔哩_bilibili</a></li><li><a href="https://juejin.cn/post/7044741465930465311">一文看懂Go语言协程的设计与原理 - 掘金 (juejin.cn)</a></li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go的工程管理</title>
      <link href="/2023/04/14/Go%E7%9A%84%E5%B7%A5%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
      <url>/2023/04/14/Go%E7%9A%84%E5%B7%A5%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Go的工程管理。</p><hr><h1 id="一、问题"><a href="#一、问题" class="headerlink" title="一、问题"></a>一、问题</h1><ul><li>不知道如何同时编译并运行多个Go文件</li><li>因为Go的语法规范，模块、目录、文件、包、导入包和导入函数不知道怎样命名和书写</li><li>因为Go的改进，不用传统配置GOPATH方式而是使用Go mod进行工程管理，但不知道怎样使用Go mod</li><li>目前关于Go工程管理的网上资料较少，使用GOPATH方式的多，总结Go mod方式的少</li></ul><hr><h1 id="二、测试环境"><a href="#二、测试环境" class="headerlink" title="二、测试环境"></a>二、测试环境</h1><ul><li>Windows</li></ul><blockquote><p>注意：Windows下的cmd和PowerShell命令行无法识别部分字符，所以不能执行部分Linux下可以执行的命令</p></blockquote><ul><li><p>VS Code</p></li><li><p>开启Go mod机制，命令行执行：</p></li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">go env <span class="literal">-w</span> GO111MODULE=on</span><br><span class="line"><span class="comment"># 开启Go mod机制</span></span><br><span class="line"></span><br><span class="line">go env</span><br><span class="line"><span class="comment"># 查看GO111MODULE变量是否开启</span></span><br></pre></td></tr></table></figure><hr><h1 id="三、同模块同目录同包"><a href="#三、同模块同目录同包" class="headerlink" title="三、同模块同目录同包"></a>三、同模块同目录同包</h1><h2 id="1-目录结构"><a href="#1-目录结构" class="headerlink" title="1.目录结构"></a>1.目录结构</h2><p>目录dir：</p><ul><li>文件a.go</li><li>文件b.go</li></ul><hr><h2 id="2-操作"><a href="#2-操作" class="headerlink" title="2.操作"></a>2.操作</h2><p>（1）编写文件b.go：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同包中，函数名首字母无需大写指定公有访问权限</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="number">10</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）编写文件a.go：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同包中，无需导入路径</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">test()</span><br><span class="line"><span class="comment">// 同包中，可直接调用相应函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）命令行执行：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="built_in">dir</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式一</span></span><br><span class="line">go run a.go b.go</span><br><span class="line"><span class="comment"># VS Code会在a.go报错找不到test()函数，但能够成功运行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式二</span></span><br><span class="line">go run .</span><br><span class="line"><span class="comment"># 报错：go: go.mod file not found in current directory or any parent directory; see &#x27;go help modules&#x27;</span></span><br><span class="line"></span><br><span class="line">go mod init modu</span><br><span class="line"><span class="comment"># 通过创建mod文件，使得a.go能够找到依赖项b.go，所以能够运行</span></span><br><span class="line"><span class="comment"># VS Code不再报错，因为通过.mod文件让a.go找到其依赖项b.go</span></span><br><span class="line">go run .</span><br></pre></td></tr></table></figure><blockquote><p>在生成mod文件后，若在文件go.mod报错：gopls was not able to find modules in your workspace…，参见：<a href="https://www.jianshu.com/p/fde21b198795">关于VS code报错 gopls requires a module at the root of your workspace - 简书 (jianshu.com)</a></p></blockquote><hr><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><ul><li>同模块：使用“go mod init”初始化一个模块，<strong>模块名为modu</strong></li><li>同目录：多go文件在同一目录下，<strong>目录名为dir</strong></li><li>同包：多go文件在同包，<strong>包名为main</strong></li><li>文件名为a.go，b.go，<strong>没有特别命名</strong></li><li><strong>函数名为test，同包中，函数名首字母无需大写指定公有访问权限，无需导入路径，可直接调用相应函数</strong></li></ul><hr><h1 id="四、同模块不同目录不同包"><a href="#四、同模块不同目录不同包" class="headerlink" title="四、同模块不同目录不同包"></a>四、同模块不同目录不同包</h1><h2 id="1-目录结构-1"><a href="#1-目录结构-1" class="headerlink" title="1.目录结构"></a>1.目录结构</h2><p>目录dir：</p><ul><li>文件a.go</li><li>目录dir_b</li></ul><p>目录dir_b：</p><ul><li>文件b.go</li></ul><hr><h2 id="2-操作-1"><a href="#2-操作-1" class="headerlink" title="2.操作"></a>2.操作</h2><p>（1）编写文件b.go：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pkg_b</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不同包中，函数名首字母需大写指定公有访问权限</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="number">10</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）命令行执行：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="built_in">dir</span></span><br><span class="line"></span><br><span class="line">go mod init modu</span><br></pre></td></tr></table></figure><p>（3）编写文件a.go：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;modu/dir_b&quot;</span></span><br><span class="line"><span class="comment">// 格式：当前模块名/目录名</span></span><br><span class="line"><span class="comment">// 实际上，import是导入路径，而不是导入包名。所以是dir_b而不是pkg_b</span></span><br><span class="line"><span class="comment">// 奇怪的引用方式，应该把包名命名为目录名才能统一，不过一般同一目录下是同一个包，命名相同。这里为了突显导入格式，目录名和包名命名不同</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">pkg_b.Test()</span><br><span class="line"><span class="comment">// 使用函数需要用包名引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）命令行执行：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="built_in">dir</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式一</span></span><br><span class="line">go run .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式二</span></span><br><span class="line">go run a.go</span><br></pre></td></tr></table></figure><hr><h2 id="3-总结-1"><a href="#3-总结-1" class="headerlink" title="3.总结"></a>3.总结</h2><ul><li>同模块：使用“go mod init”初始化一个模块，<strong>模块名为modu</strong></li><li>不同目录：多go文件在不同一目录下，<strong>目录名为dir和dir_b</strong></li><li>不同包：多go文件在不同包，<strong>包名为main和pkg_b</strong></li><li>文件名为a.go，b.go，<strong>没有特别命名</strong></li><li><strong>函数名为Test，不同包中，函数名首字母需大写指定公有访问权限</strong></li><li>导入依赖<strong>包-&gt;路径</strong>的形式：<strong>import 当前模块名&#x2F;目录名</strong></li><li>使用依赖函数的形式：<strong>包名.函数名()</strong></li></ul><hr><h1 id="五、不同模块不同目录不同包1"><a href="#五、不同模块不同目录不同包1" class="headerlink" title="五、不同模块不同目录不同包1"></a>五、不同模块不同目录不同包1</h1><h2 id="1-目录结构-2"><a href="#1-目录结构-2" class="headerlink" title="1.目录结构"></a>1.目录结构</h2><p>目录dir：</p><ul><li>文件a.go</li><li>目录dir_b</li></ul><p>目录dir_b：</p><ul><li>文件b.go</li></ul><hr><h2 id="2-操作："><a href="#2-操作：" class="headerlink" title="2.操作："></a>2.操作：</h2><p>（1）编写文件b.go：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pkg_b</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不同包中，函数名首字母需大写指定公有访问权限</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="number">10</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）命令行执行：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> dir_b</span><br><span class="line"></span><br><span class="line">go mod init modu_b</span><br></pre></td></tr></table></figure><p>（3）编写a.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;modu_b&quot;</span></span><br><span class="line"><span class="comment">// 需要用的模块名</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">pkg_b.Test()</span><br><span class="line"><span class="comment">// 使用函数需要用包名引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）命令行执行：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="built_in">dir</span></span><br><span class="line"></span><br><span class="line">go mod init modu</span><br></pre></td></tr></table></figure><p>（5）修改dir下的go.mod文件：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">module modu</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.20</span></span><br><span class="line"></span><br><span class="line">require modu_b v0<span class="number">.0</span><span class="number">.0</span></span><br><span class="line"><span class="comment">// 需要用的模块名，版本</span></span><br><span class="line"></span><br><span class="line">replace modu_b =&gt; C:\Users\DSHH\Desktop\go_test\dir\dir_b</span><br><span class="line"><span class="comment">// 指定查找路径</span></span><br><span class="line"><span class="comment">// 导入该模块实际上是导入该路径</span></span><br></pre></td></tr></table></figure><h2 id="（5）命令行执行："><a href="#（5）命令行执行：" class="headerlink" title="（5）命令行执行："></a>（5）命令行执行：<br><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="built_in">dir</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式一</span></span><br><span class="line">go run .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式二</span></span><br><span class="line">go run a.go</span><br></pre></td></tr></table></figure></h2><h2 id="3-总结-2"><a href="#3-总结-2" class="headerlink" title="3.总结"></a>3.总结</h2><ul><li>不同模块：使用“go mod init”初始化多个模块，<strong>模块名为modu和modu_b</strong></li><li>不同目录：多go文件在不同一目录下，<strong>目录名为dir和dir_b</strong></li><li>不同包：多go文件在不同包，<strong>包名为main和pkg_b</strong></li><li>文件名为a.go，b.go，<strong>没有特别命名</strong></li><li><strong>函数名为Test，不同包中，函数名首字母需大写指定公有访问权限，使用函数需要用包名引用</strong></li><li>导入依赖<strong>模块-&gt;路径</strong>的形式：<strong>import 模块名</strong></li><li>使用依赖函数的形式：<strong>包名.函数名()</strong></li></ul><hr><h1 id="六、不同模块不同目录不同包2"><a href="#六、不同模块不同目录不同包2" class="headerlink" title="六、不同模块不同目录不同包2"></a>六、不同模块不同目录不同包2</h1><h2 id="1-目录结构-3"><a href="#1-目录结构-3" class="headerlink" title="1.目录结构"></a>1.目录结构</h2><p>目录dir：</p><ul><li>目录dir_a</li><li>目录dir_b</li></ul><p>目录dir_a：</p><ul><li>文件a.go</li></ul><p>目录dir_b：</p><ul><li>文件b.go</li></ul><hr><h2 id="2-操作：-1"><a href="#2-操作：-1" class="headerlink" title="2.操作："></a>2.操作：</h2><p>（1）编写文件b.go：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pkg_b</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不同包中，函数名首字母需大写指定公有访问权限</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="number">10</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）命令行执行：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> dir_b</span><br><span class="line"></span><br><span class="line">go mod init modu_b</span><br></pre></td></tr></table></figure><p>（3）编写a.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;modu_b&quot;</span></span><br><span class="line"><span class="comment">// 需要用的模块名</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">pkg_b.Test()</span><br><span class="line"><span class="comment">// 使用函数需要用包名引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）命令行执行：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> dir_a</span><br><span class="line"></span><br><span class="line">go mod init modu_a</span><br></pre></td></tr></table></figure><p>（5）修改dir_a下的go.mod文件：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">module modu_a</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.20</span></span><br><span class="line"></span><br><span class="line">require modu_b v0<span class="number">.0</span><span class="number">.0</span></span><br><span class="line"><span class="comment">// 需要用的模块名，版本</span></span><br><span class="line"></span><br><span class="line">replace modu_b =&gt; C:\Users\DSHH\Desktop\go_test\dir\dir_b</span><br><span class="line"><span class="comment">// 指定查找路径</span></span><br><span class="line"><span class="comment">// 导入该模块实际上是导入该路径</span></span><br></pre></td></tr></table></figure><h2 id="（5）命令行执行：-1"><a href="#（5）命令行执行：-1" class="headerlink" title="（5）命令行执行："></a>（5）命令行执行：<br><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> dir_a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式一</span></span><br><span class="line">go run .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式二</span></span><br><span class="line">go run a.go</span><br></pre></td></tr></table></figure></h2><h2 id="3-总结-3"><a href="#3-总结-3" class="headerlink" title="3.总结"></a>3.总结</h2><ul><li>不同模块：使用“go mod init”初始化多个模块，<strong>模块名为modu_a和modu_b</strong></li><li>不同目录：多go文件在不同一目录下，<strong>目录名为dir_a和dir_b</strong></li><li>不同包：多go文件在不同包，<strong>包名为main和pkg_b</strong></li><li>文件名为a.go，b.go，<strong>没有特别命名</strong></li><li><strong>函数名为Test，不同包中，函数名首字母需大写指定公有访问权限，使用函数需要用包名引用</strong></li><li>导入依赖<strong>模块-&gt;路径</strong>的形式：<strong>import 模块名</strong></li><li>使用依赖函数的形式：<strong>包名.函数名()</strong></li></ul><hr><h1 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h1><p>方式的选择：</p><ul><li><p>不使用旧的设置GOPATH变量方式，多文件编程不一定放在src目录下</p></li><li><p>原因：应该是引入新的Go mod模块机制替代了</p></li><li><p>建议使用新的方式，无需每次工程都要配置修改环境变量</p></li></ul><p>使用Go mod方式的建议：</p><ul><li>一个目录下的所有go文件都是同一个包，目录名和包名相同</li><li>运行同一个目录下的多个go文件（同个包），使用方式三</li><li>由第一点：“一个目录下的所有go文件都是同一个包”，方式四的使用并不常见，也容易混乱</li><li>运行不同目录下，目录有嵌套关系的多个go文件，使用方式五</li><li>运行不同目录下，目录是并列关系的多个go文件，使用方式六</li></ul><blockquote><p>实际上方式五和六的操作一样</p></blockquote><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Go的工程管理。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/482014524">go mod使用 | 全网最详细 - 知乎 (zhihu.com)</a></li><li><a href="https://segmentfault.com/q/1010000020590559">go mod怎么引用同一个项目下面的子目录 - SegmentFault 思否</a></li><li><a href="https://blog.csdn.net/qq_43442524/article/details/105216529?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-105216529-blog-118687783.235%5Ev28%5Epc_relevant_recovery_v2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-105216529-blog-118687783.235%5Ev28%5Epc_relevant_recovery_v2&utm_relevant_index=2">Golang1.14 go modules 怎么导入本地其它项目的包? 看完这篇文章, 终于搞懂了_golang 本地引用其它项目包_普通Gopher的博客-CSDN博客</a></li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯（backtrack）描述</title>
      <link href="/2023/02/13/%E5%9B%9E%E6%BA%AF%EF%BC%88backtrack%EF%BC%89%E6%8F%8F%E8%BF%B0/"/>
      <url>/2023/02/13/%E5%9B%9E%E6%BA%AF%EF%BC%88backtrack%EF%BC%89%E6%8F%8F%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>回溯描述。</p><hr><h1 id="一、核心概念"><a href="#一、核心概念" class="headerlink" title="一、核心概念"></a>一、核心概念</h1><ul><li>在深度优先搜索（DFS）的递归过程中回溯：回溯问题可抽象为树形结构，递归向下<strong>处理和获取</strong>结果，回溯向上<strong>撤销</strong>结果</li><li>相对于暴力算法，是一种间接&#x2F;有技巧（使用递归代替多重循环）的暴力搜索&#x2F;穷举，不高效</li></ul><hr><h1 id="二、典型问题"><a href="#二、典型问题" class="headerlink" title="二、典型问题"></a>二、典型问题</h1><blockquote><p>分类依据：<a href="https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">代码随想录 (programmercarl.com)</a>和力扣</p></blockquote><ul><li>组合问题：N个数里面按一定规则找出k个数的集合</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个N个数的集合里有多少符合条件的子集</li><li>排列问题：N个数按一定规则<strong>全排列</strong>，有几种排列方式</li><li>图问题：图中使用深度优先遍历</li><li>棋盘问题：N皇后，解数独等等</li></ul><hr><h1 id="三、算法步骤"><a href="#三、算法步骤" class="headerlink" title="三、算法步骤"></a>三、算法步骤</h1><ol start="0"><li>将回溯问题抽象为树形结构</li></ol><ul><li>问题规模为树的宽度</li><li>递归深度为树的深度</li></ul><ol><li>确定回溯函数的参数和返回值</li></ol><ul><li>可依据逻辑需要后补充参数</li></ul><blockquote><p><strong>可能</strong>的参数：<br>候选集合<br>问题规模为树的宽度width<br>递归深度为树的深度depth<br>当前结点问题规模的起始索引start_index<br>标记集合中元素是否已选取的数组<br>结果集合res和results</p></blockquote><ul><li>返回值一般为空（void）</li></ul><ol start="2"><li>确定回溯函数的终止条件和获取结果逻辑</li></ol><ul><li>在树的<strong>叶子</strong>结点<strong>获取</strong>结果</li><li>在树的叶子结点结束当前层递归，并回溯<strong>撤销</strong>结果</li></ul><blockquote><p>注意：子集问题，在树的<strong>每</strong>结点获取结果</p></blockquote><ol start="3"><li>确定回溯函数的遍历和处理结果逻辑</li></ol><ul><li>横向遍历当前树层各结点的问题规模</li><li>纵向递归<strong>处理</strong>结果</li></ul><hr><h1 id="四、模板"><a href="#四、模板" class="headerlink" title="四、模板"></a>四、模板</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0. 将回溯问题抽象为树形结构</span></span><br><span class="line"><span class="comment">// 1. 确定回溯函数的参数和返回值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(参数)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 2. 确定回溯函数的终止条件和获取结果逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (终止条件) </span><br><span class="line">    &#123;</span><br><span class="line">        获取结果;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 确定回溯函数的遍历和处理结果逻辑</span></span><br><span class="line">    <span class="keyword">for</span> (当前树层，各结点的问题规模) </span><br><span class="line">    &#123;</span><br><span class="line">        处理结果;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">backtrack</span>(参数); <span class="comment">// 递归</span></span><br><span class="line">        </span><br><span class="line">        撤销结果; <span class="comment">// 回溯</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="五、模板示例"><a href="#五、模板示例" class="headerlink" title="五、模板示例"></a>五、模板示例</h1><p>77.组合 - 力扣（LeetCode）——中等的题解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 0. 将回溯问题抽象为树形结构</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; results;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 确定回溯函数的参数和返回值</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> depth, <span class="type">int</span> start_index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 2. 确定回溯函数的终止条件和获取结果逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (res.<span class="built_in">size</span>() == depth)</span><br><span class="line">        &#123;</span><br><span class="line">            results.<span class="built_in">push_back</span>(res);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 确定回溯函数的遍历和处理结果逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start_index; i &lt;= width; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(i);       <span class="comment">// 处理结果</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">backtrack</span>(width, depth, i + <span class="number">1</span>); <span class="comment">// 递归</span></span><br><span class="line"></span><br><span class="line">            res.<span class="built_in">pop_back</span>(); <span class="comment">// 撤销结果  回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">backtrack</span>(n, k, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="六、性能分析"><a href="#六、性能分析" class="headerlink" title="六、性能分析"></a>六、性能分析</h1><blockquote><p>时间复杂度：指数级</p></blockquote><p>组合问题：</p><ul><li>时间复杂度：<strong>一般</strong>为：组合规模 × 每组合判断并加入结果集的时间</li></ul><blockquote><p>如：$O(\complement^n_m × n)$。从m规模中取n规模，有$\complement^n_m$种组合；每组合判断并加入结果集的时间需要O(n)</p></blockquote><blockquote><p>如：$O(2^n × n)$。从n规模中取或不取，有$2^n$种组合；每组合判断并加入结果集的时间需要O(n)</p></blockquote><ul><li>空间复杂度：<strong>一般</strong>为：递归栈规模 + 结果集规模：$O(n)$。n为数据规模</li></ul><p>切割和子集问题：类似组合问题</p><p>排列问题：<strong>全排列</strong></p><ul><li>时间复杂度：<strong>一般</strong>为：全排列规模 × 每排列判断并加入结果集的时间：$O(n!×n)$。n为数据规模</li></ul><blockquote><p>参见：<br><a href="https://leetcode.cn/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/">回溯算法入门级详解 + 练习（持续更新） - 全排列 - 力扣（LeetCode）</a><br><a href="https://programmercarl.com/%E5%91%A8%E6%80%BB%E7%BB%93/20201112%E5%9B%9E%E6%BA%AF%E5%91%A8%E6%9C%AB%E6%80%BB%E7%BB%93.html#%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90">本周小结！（回溯算法系列三） | 代码随想录 (programmercarl.com)</a></p></blockquote><ul><li>空间复杂度：类似组合问题</li></ul><p>图和棋盘问题：具体问题具体分析</p><hr><h1 id="七、优化方法"><a href="#七、优化方法" class="headerlink" title="七、优化方法"></a>七、优化方法</h1><h2 id="1-剪枝"><a href="#1-剪枝" class="headerlink" title="1. 剪枝"></a>1. 剪枝</h2><p>作用：降低时间复杂度</p><p>描述：</p><ul><li>不符合条件的问题</li><li>不再继续处理并获取结果</li></ul><p>形式：</p><ul><li><p>横向剪枝：缩小当前树层各结点的问题规模：修改for()循环</p></li><li><p>纵向剪枝：增加终止条件</p></li></ul><p>模板示例：216.组合总和 III - 力扣（LeetCode）——中等的题解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 0. 将回溯问题抽象为树形结构</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; results;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 确定回溯函数的参数和返回值</span></span><br><span class="line">    <span class="comment">// width：[1,9]</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span> depth, <span class="type">int</span> target_sum, <span class="type">int</span> start_index, <span class="type">int</span> sum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 2. 确定回溯函数的终止条件和获取结果逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (sum &gt; target_sum) <span class="comment">// 纵向剪枝</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (res.<span class="built_in">size</span>() == depth)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum == target_sum)</span><br><span class="line">            &#123;</span><br><span class="line">                results.<span class="built_in">push_back</span>(res);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 确定回溯函数的遍历和处理结果逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start_index; i &lt;= <span class="number">9</span> - (depth - res.<span class="built_in">size</span>()) + <span class="number">1</span>; ++i) <span class="comment">// 横向剪枝</span></span><br><span class="line">        &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">            res.<span class="built_in">push_back</span>(i); <span class="comment">// 处理结果</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">backtrack</span>(depth, target_sum, i + <span class="number">1</span>, sum); <span class="comment">// 递归</span></span><br><span class="line"></span><br><span class="line">            sum -= i;</span><br><span class="line">            res.<span class="built_in">pop_back</span>(); <span class="comment">// 撤销结果  回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="type">int</span> k, <span class="type">int</span> n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">backtrack</span>(k, n, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="八、其他技巧"><a href="#八、其他技巧" class="headerlink" title="八、其他技巧"></a>八、其他技巧</h1><h2 id="1-元素不可以和可以重复选取"><a href="#1-元素不可以和可以重复选取" class="headerlink" title="1. 元素不可以和可以重复选取"></a>1. 元素不可以和可以重复选取</h2><ul><li>在同一集合中，若元素不可以重复选取，则在递归时，修改当前结点问题规模的起始索引start_index</li></ul><blockquote><p>如：77.组合 - 力扣（LeetCode）——中等</p></blockquote><ul><li>在同一集合中，若元素可以重复选取，则在递归时，不修改当前结点问题规模的起始索引start_index</li></ul><blockquote><p>如：39.组合总和 - 力扣（LeetCode）——中等</p></blockquote><hr><h2 id="2-从同一集合中取和从不同集合间取元素"><a href="#2-从同一集合中取和从不同集合间取元素" class="headerlink" title="2. 从同一集合中取和从不同集合间取元素"></a>2. 从同一集合中取和从不同集合间取元素</h2><ul><li>从同一集合中取元素，需要参数：当前结点问题规模的起始索引start_index</li></ul><blockquote><p>如：77.组合 - 力扣（LeetCode）——中等</p></blockquote><ul><li>从不同集合间取元素，<strong>可能</strong>不需要参数：当前结点问题规模的起始索引start_index</li></ul><blockquote><p>如：17.电话号码的字母组合 - 力扣（LeetCode）——中等</p></blockquote><hr><h2 id="3-求和问题"><a href="#3-求和问题" class="headerlink" title="3. 求和问题"></a>3. 求和问题</h2><ul><li>在求和问题中，<strong>可能</strong>需要先排序后剪枝</li></ul><blockquote><p>如：39.组合总和 - 力扣（LeetCode）——中等</p></blockquote><hr><h2 id="4-先排序后去重"><a href="#4-先排序后去重" class="headerlink" title="4. 先排序后去重"></a>4. 先排序后去重</h2><blockquote><p>排序后才可以，通过相邻元素判断是否重复选取</p></blockquote><ul><li><strong>树层去重</strong></li></ul><blockquote><p>参见：<a href="https://programmercarl.com/0040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII.html">代码随想录 (programmercarl.com)</a></p></blockquote><blockquote><p>如：40.组合总和 II - 力扣（LeetCode）——中等</p></blockquote><blockquote><p>如：47.全排列 II - 力扣（LeetCode）——中等</p></blockquote><ul><li><strong>树枝去重</strong></li></ul><blockquote><p>如：47.全排列 II - 力扣（LeetCode）——中等</p></blockquote><blockquote><p>排列问题可以在树层去重，也可以在树枝去重；但在树层去重效率更高。参见：<a href="https://programmercarl.com/0047.%E5%85%A8%E6%8E%92%E5%88%97II.html">代码随想录 (programmercarl.com)</a></p></blockquote><hr><h2 id="5-去重的方式"><a href="#5-去重的方式" class="headerlink" title="5. 去重的方式"></a>5. 去重的方式</h2><blockquote><p>去重：即标记集合中元素是否已选取</p></blockquote><ul><li>数组</li><li>编程语言内置的哈希表数据结构（有频繁的插入、映射、查找和删除操作，时间和空间复杂度高）。如：C++的unordered_set</li><li>哈希数组（已知数据规模）</li></ul><blockquote><p>参见：<a href="https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E5%8E%BB%E9%87%8D%E9%97%AE%E9%A2%98%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%86%99%E6%B3%95.html#_90-%E5%AD%90%E9%9B%86ii">代码随想录 (programmercarl.com)</a></p></blockquote><hr><h2 id="6-组合、切割、排列和子集问题的区别"><a href="#6-组合、切割、排列和子集问题的区别" class="headerlink" title="6. 组合、切割、排列和子集问题的区别"></a>6. 组合、切割、排列和子集问题的区别</h2><ul><li><p>组合、切割和排列问题，树的叶子结点为结果（遍历符合条件的树枝）</p></li><li><p>子集问题，树的每个结点为结果（遍历树）；所以可以不需要确定回溯函数的终止条件，不存在剪枝的优化方法</p></li></ul><hr><h2 id="7-组合、切割、子集和排列问题的区别"><a href="#7-组合、切割、子集和排列问题的区别" class="headerlink" title="7. 组合、切割、子集和排列问题的区别"></a>7. 组合、切割、子集和排列问题的区别</h2><ul><li><p>组合问题、切割和子集问题，集合是无序的，for()循环从当前结点问题规模的起始索引start_index开始；<strong>可能</strong>需要去重</p></li><li><p>排列问题，集合是有序的，for()循环从0开始，<strong>必需</strong>去重</p></li></ul><hr><h2 id="8-二维横向遍历"><a href="#8-二维横向遍历" class="headerlink" title="8. 二维横向遍历"></a>8. 二维横向遍历</h2><ul><li>在二维横向遍历中</li><li>进行递归和回溯</li></ul><blockquote><p>如：37.解数独 II - 力扣（LeetCode）——困难</p></blockquote><hr><h1 id="九、力扣例题"><a href="#九、力扣例题" class="headerlink" title="九、力扣例题"></a>九、力扣例题</h1><p>组合问题：</p><ul><li>77.组合——中等</li><li>216.组合总和 III——中等</li><li>17.电话号码的字母组合——中等</li><li>39.组合总和——中等</li><li>40.组合总和 II——中等</li></ul><p>切割问题：</p><ul><li>131.分割回文串——中等</li><li>93.复原 IP 地址——中等</li></ul><p>子集问题：</p><ul><li>78.子集——中等</li><li>90.子集 II——中等</li><li>491.递增子序列——中等</li></ul><p>排列问题：</p><ul><li>46.全排列——中等</li><li>47.全排列 II——中等</li></ul><p>其他问题：</p><ul><li>332.重新安排行程——困难</li></ul><p>图问题：</p><ul><li>51.N 皇后——困难</li><li>37.解数独——困难</li></ul><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>回溯描述。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://programmercarl.com/">代码随想录 (programmercarl.com)</a></li><li>《代码随想录》作者：孙秀洋</li><li><a href="https://leetcode.cn/">力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台</a></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划（Dynamic Programming）（dp）描述</title>
      <link href="/2023/02/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88Dynamic%20Programming%EF%BC%89%EF%BC%88dp%EF%BC%89%E6%8F%8F%E8%BF%B0/"/>
      <url>/2023/02/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88Dynamic%20Programming%EF%BC%89%EF%BC%88dp%EF%BC%89%E6%8F%8F%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>动态规划（Dynamic Programming）（dp）描述。</p><hr><h1 id="一、核心概念"><a href="#一、核心概念" class="headerlink" title="一、核心概念"></a>一、核心概念</h1><ul><li>重叠局部问题 -&gt; 全局问题</li><li>状态推导</li></ul><hr><h1 id="二、典型问题"><a href="#二、典型问题" class="headerlink" title="二、典型问题"></a>二、典型问题</h1><p>类型1：</p><ul><li>统计数量&#x2F;方案类</li><li>求最优解类：背包问题</li></ul><p>类型2：依据力扣分类</p><ul><li>基础问题</li><li>背包问题</li><li>打家劫舍问题</li><li>股票问题</li><li>子序列问题</li></ul><p>类型3：</p><ul><li>线性</li><li>非线性</li></ul><blockquote><p>非线性树型如：337.打家劫舍 III - 力扣（LeetCode）——中等</p></blockquote><hr><h1 id="三、算法步骤"><a href="#三、算法步骤" class="headerlink" title="三、算法步骤"></a>三、算法步骤</h1><ol><li>确定dp数组中下标和值的含义 -&gt; 确定dp数组的维度、规模和所求结果&#x2F;返回值</li><li>确定dp数组的状态转移方程&#x2F;递推公式</li><li>确定dp数组的初始化值</li><li>确定dp数组的遍历顺序和临界条件</li><li>模拟&#x2F;举例推导dp数组以验证</li></ol><blockquote><p>算法往往为多重循环而不容易模拟&#x2F;举例推导dp数组以验证。可在调试时再验证。</p></blockquote><hr><h1 id="四、模板示例"><a href="#四、模板示例" class="headerlink" title="四、模板示例"></a>四、模板示例</h1><p> 509.斐波那契数 - 力扣（LeetCode）——简单的题解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 确定dp数组中下标和值的含义 -&gt; 确定dp数组的维度、规模和所求结果/返回值</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 3. 确定dp数组的初始化值</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 确定dp数组的遍历顺序和临界条件</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 2. 确定dp数组的状态转移方程/递推公式</span></span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 确定dp数组中下标和值的含义 -&gt; 确定dp数组的维度、规模和所求结果/返回值</span></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5. 模拟/举例推导dp数组以验证</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="五、调试方法"><a href="#五、调试方法" class="headerlink" title="五、调试方法"></a>五、调试方法</h1><ul><li>输出dp数组</li><li>判断是否和模拟&#x2F;举例推导的dp数组一致</li><li>若不一致，则可能是算法步骤问题</li><li>若一致，则可能是细节问题</li></ul><hr><h1 id="六、性能分析"><a href="#六、性能分析" class="headerlink" title="六、性能分析"></a>六、性能分析</h1><ul><li>时间复杂度：一般为多重循环的性能</li><li>空间复杂度：一般为dp数组的规模</li></ul><hr><h1 id="七、优化方法"><a href="#七、优化方法" class="headerlink" title="七、优化方法"></a>七、优化方法</h1><h2 id="1-记忆化搜索"><a href="#1-记忆化搜索" class="headerlink" title="1. 记忆化搜索"></a>1. 记忆化搜索</h2><p>作用：降低时间复杂度，增加空间复杂度</p><p>描述：</p><ul><li>使用数据结构存储已计算的状态</li><li>不再重复计算状态</li><li>从数据结构获取已计算的状态</li></ul><p>可能的优化：O(n²) -&gt; O(n)。n为数据规模</p><hr><h2 id="2-滚动数组"><a href="#2-滚动数组" class="headerlink" title="2. 滚动数组"></a>2. 滚动数组</h2><p>作用：优化空间复杂度</p><p>描述：</p><ul><li>状态推导时</li><li>若后一个状态<strong>只依赖固定的</strong>前一个或多个状态</li><li>则无需定义<strong>相应数据规模</strong>的dp数组</li><li>只需定义<strong>状态依赖规模</strong>的dp数组或变量</li><li>在递推中不断更新该dp数组或变量为前一个或多个<strong>所求解</strong>的状态，再用于求解后一个状态</li></ul><p>可能的优化：O(n) -&gt; O(1)；O(m × n) -&gt; O(n)</p><hr><h1 id="八、背包问题"><a href="#八、背包问题" class="headerlink" title="八、背包问题"></a>八、背包问题</h1><h2 id="1-类型"><a href="#1-类型" class="headerlink" title="1. 类型"></a>1. 类型</h2><p>混合背包：</p><ul><li>0-1背包 （基础）：各物品数量为一</li><li>完全背包：各物品数量不限</li><li>多重背包：各物品数量不同</li></ul><p>分组背包：依组装包，每组数量为一</p><hr><h2 id="2-算法步骤"><a href="#2-算法步骤" class="headerlink" title="2. 算法步骤"></a>2. 算法步骤</h2><ol start="0"><li>分析应用问题转换为背包问题 -&gt; 确定背包问题的参数</li></ol><blockquote><p>背包：容量<br>物品：体积，价值，数量</p></blockquote><ol><li>确定dp数组中下标和值的含义 -&gt; 确定dp数组的维度、规模和所求结果&#x2F;返回值</li><li>确定dp数组的状态转移方程&#x2F;递推公式</li><li>确定dp数组的初始化值</li><li>确定dp数组的遍历顺序和临界条件</li><li>确定dp数组的返回值</li><li>模拟&#x2F;举例推导dp数组以验证</li></ol><hr><h2 id="3-模板示例：0-1背包问题"><a href="#3-模板示例：0-1背包问题" class="headerlink" title="3. 模板示例：0-1背包问题"></a>3. 模板示例：0-1背包问题</h2><blockquote><p>详细解释参见：<a href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html">代码随想录 (programmercarl.com)</a></p></blockquote><p> 二维dp数组：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 0. 分析应用问题转换为背包问题 -&gt; 确定背包问题的参数</span></span><br><span class="line">    <span class="type">int</span> capacity = <span class="number">4</span>;                 <span class="comment">// 背包：容量</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; weight = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;   <span class="comment">// 物体：重量</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; value = &#123;<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>&#125;; <span class="comment">// 物体：价值</span></span><br><span class="line">    <span class="type">int</span> quantity = <span class="number">3</span>;                 <span class="comment">// 物体：数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 确定dp数组中下标和值的含义 -&gt; 确定dp数组的维度、规模和所求结果/返回值</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(quantity, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(capacity + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 确定dp数组的初始化值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; weight[<span class="number">0</span>]; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = weight[<span class="number">0</span>]; j &lt;= capacity; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = value[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 确定dp数组的遍历顺序和临界条件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; quantity; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">// 相关处理</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= capacity; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 2. 确定dp数组的状态转移方程/递推公式</span></span><br><span class="line">            <span class="keyword">if</span> (j &lt; weight[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = std::<span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 确定dp数组中下标和值的含义 -&gt; 确定dp数组的维度、规模和所求结果/返回值</span></span><br><span class="line">    cout &lt;&lt; dp[quantity - <span class="number">1</span>][capacity] &lt;&lt; endl; <span class="comment">// 35</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 5. 模拟/举例推导dp数组以验证</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二维dp数组可先遍历物品，后<strong>正序</strong>遍历背包：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4. 确定dp数组的遍历顺序和临界条件</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; quantity; ++i)</span><br><span class="line">   &#123;</span><br><span class="line">   <span class="comment">// 相关处理</span></span><br><span class="line">   </span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= capacity; ++j)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="comment">// 2. 确定dp数组的状态转移方程/递推公式</span></span><br><span class="line">           <span class="keyword">if</span> (j &lt; weight[i])</span><br><span class="line">           &#123;</span><br><span class="line">               dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">           &#123;</span><br><span class="line">               dp[i][j] = std::<span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>二维dp数组可先遍历背包，后<strong>正序</strong>遍历物品：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4. 确定dp数组的遍历顺序和临界条件</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= capacity; ++j)</span><br><span class="line">   &#123;</span><br><span class="line">   <span class="comment">// 相关处理</span></span><br><span class="line">   </span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i = q; i &lt;= quantity; ++i)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="comment">// 2. 确定dp数组的状态转移方程/递推公式</span></span><br><span class="line">           <span class="keyword">if</span> (j &lt; weight[i])</span><br><span class="line">           &#123;</span><br><span class="line">               dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">           &#123;</span><br><span class="line">               dp[i][j] = std::<span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p> 一维dp数组只能先遍历物品，后<strong>倒序</strong>遍历背包：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 0. 分析应用问题转换为背包问题 -&gt; 确定背包问题的参数</span></span><br><span class="line">    <span class="type">int</span> capacity = <span class="number">4</span>;                 <span class="comment">// 背包：容量</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; weight = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;   <span class="comment">// 物体：重量</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; value = &#123;<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>&#125;; <span class="comment">// 物体：价值</span></span><br><span class="line">    <span class="type">int</span> quantity = <span class="number">3</span>;                 <span class="comment">// 物体：数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 确定dp数组中下标和值的含义 -&gt; 确定dp数组的维度、规模和所求结果/返回值</span></span><br><span class="line">    <span class="comment">// 3. 确定dp数组的初始化值</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(capacity + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 确定dp数组的遍历顺序和临界条件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; quantity; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">// 相关处理</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = capacity; j &gt;= weight[i]; --j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 2. 确定dp数组的状态转移方程/递推公式</span></span><br><span class="line">            dp[j] = std::<span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 确定dp数组中下标和值的含义 -&gt; 确定dp数组的维度、规模和所求结果/返回值</span></span><br><span class="line">    cout &lt;&lt; dp[capacity] &lt;&lt; endl; <span class="comment">// 35</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 5. 模拟/举例推导dp数组以验证</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：还存在三维或更高维dp数组。如：474.一和零 - 力扣（LeetCode）——中等</p></blockquote><hr><h2 id="4-模板示例：完全背包问题"><a href="#4-模板示例：完全背包问题" class="headerlink" title="4. 模板示例：完全背包问题"></a>4. 模板示例：完全背包问题</h2><blockquote><p>详细解释参见：<a href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85.html">代码随想录 (programmercarl.com)</a></p></blockquote><p>一维dp数组：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 0. 分析应用问题转换为背包问题 -&gt; 确定背包问题的参数</span></span><br><span class="line">    <span class="type">int</span> capacity = <span class="number">4</span>;                 <span class="comment">// 背包：容量</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; weight = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;   <span class="comment">// 物体：重量</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; value = &#123;<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>&#125;; <span class="comment">// 物体：价值</span></span><br><span class="line">    <span class="type">int</span> quantity = <span class="number">3</span>;                 <span class="comment">// 物体：数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 确定dp数组中下标和值的含义 -&gt; 确定dp数组的维度、规模和所求结果/返回值</span></span><br><span class="line">    <span class="comment">// 3. 确定dp数组的初始化值</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(capacity + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 确定dp数组的遍历顺序和临界条件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; quantity; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 相关处理</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = weight[i]; j &lt;= capacity; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 2. 确定dp数组的状态转移方程/递推公式</span></span><br><span class="line">            dp[j] = std::<span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 确定dp数组中下标和值的含义 -&gt; 确定dp数组的维度、规模和所求结果/返回值</span></span><br><span class="line">    cout &lt;&lt; dp[capacity] &lt;&lt; endl; <span class="comment">// 60</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 5. 模拟/举例推导dp数组以验证</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一维dp数组可先遍历物品，后<strong>正序</strong>遍历背包：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4. 确定dp数组的遍历顺序和临界条件</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; quantity; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">// 相关处理</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = weight[i]; j &lt;= capacity; ++j)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">// 2. 确定dp数组的状态转移方程/递推公式</span></span><br><span class="line">          dp[j] = std::<span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>一维dp数组可先遍历背包，后<strong>正序</strong>遍历物品：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4. 确定dp数组的遍历顺序和临界条件</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= capacity; ++j)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 相关处理</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; quantity; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 2. 确定dp数组的状态转移方程/递推公式</span></span><br><span class="line">        <span class="keyword">if</span> (j - weight[i] &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[j] = std::<span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>若求排列数，则先遍历背包，后遍历物品<br>若求组合数，则先遍历物品，后遍历背包</p></blockquote><hr><h2 id="5-模板示例：多重背包"><a href="#5-模板示例：多重背包" class="headerlink" title="5. 模板示例：多重背包"></a>5. 模板示例：多重背包</h2><blockquote><p>详细解释参见：<a href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85.html#%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85">代码随想录 (programmercarl.com</a></p></blockquote><hr><h1 id="九、力扣例题"><a href="#九、力扣例题" class="headerlink" title="九、力扣例题"></a>九、力扣例题</h1><blockquote><p>题目组织依据：<a href="https://programmercarl.com/">代码随想录 (programmercarl.com)</a></p></blockquote><p>基础问题：</p><ul><li>509.斐波那契数——简单</li><li>70.爬楼梯——简单</li><li>746.使用最小花费爬楼梯——简单</li><li>62.不同路径——中等</li><li>63.不同路径 II——中等</li><li>343.整数拆分——中等</li><li>96.不同的二叉搜索树——中等</li></ul><p>背包问题：0-1背包问题</p><ul><li>416.分割等和子集——中等</li><li>1049.最后一块石头的重量 II——中等</li><li>494.目标和——中等</li><li>474.一和零——中等</li></ul><p>背包问题：完全背包问题</p><ul><li>518.零钱兑换 II——中等</li><li>377.组合总和 Ⅳ——中等</li><li>70.爬楼梯——简单</li><li>322.零钱兑换——中等</li><li>279.完全平方数——中等</li><li>139.单词拆分——中等</li></ul><p>打家劫舍问题：</p><ul><li>198.打家劫舍——中等</li><li>213.打家劫舍 II——中等</li><li>337.打家劫舍 III——中等</li></ul><p>股票问题：</p><ul><li>121.买卖股票的最佳时机——简单</li><li>122.买卖股票的最佳时机 II——中等</li><li>123.买卖股票的最佳时机 III——困难</li><li>188.买卖股票的最佳时机 IV——困难</li><li>309.最佳买卖股票时机含冷冻期——中等</li><li>714.买卖股票的最佳时机含手续费——中等</li></ul><p>子序列问题：非连续和连续子序列问题</p><ul><li>300.最长递增子序列——中等</li><li>674.最长连续递增序列——简单</li><li>718.最长重复子数组——中等</li><li>1143.最长公共子序列——中等</li><li>1035.不相交的线——中等</li><li>53.最大子数组和——中等</li></ul><p>子序列问题：编辑距离问题</p><ul><li>392.判断子序列——简单</li><li>115.不同的子序列——困难</li><li>583.两个字符串的删除操作——中等</li><li>72.编辑距离——困难</li></ul><p>子序列问题：回文问题</p><ul><li>647.回文子串——中等</li><li>516.最长回文子序列——中等</li></ul><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>动态规划（Dynamic Programming）（dp）描述。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://programmercarl.com/">代码随想录 (programmercarl.com)</a></li><li>《代码随想录》作者：孙秀洋</li><li><a href="https://leetcode.cn/">力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台</a></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《数据库原理及应用教程（第4版 | 微课版）》第3章：“关系数据库标准语言——SQL”和第7章：“SQL Server 2012高级应用”的学习提纲</title>
      <link href="/2023/01/16/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%E6%95%99%E7%A8%8B%EF%BC%88%E7%AC%AC4%E7%89%88%20_%20%E5%BE%AE%E8%AF%BE%E7%89%88%EF%BC%89%E3%80%8B%E7%AC%AC3%E7%AB%A0%EF%BC%9A%E2%80%9C%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A0%87%E5%87%86%E8%AF%AD%E8%A8%80%E2%80%94%E2%80%94SQL%E2%80%9D%E5%92%8C%E7%AC%AC7%E7%AB%A0%EF%BC%9A%E2%80%9CSQL%20Server%202012%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8%E2%80%9D%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%8F%90%E7%BA%B2/"/>
      <url>/2023/01/16/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%E6%95%99%E7%A8%8B%EF%BC%88%E7%AC%AC4%E7%89%88%20_%20%E5%BE%AE%E8%AF%BE%E7%89%88%EF%BC%89%E3%80%8B%E7%AC%AC3%E7%AB%A0%EF%BC%9A%E2%80%9C%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A0%87%E5%87%86%E8%AF%AD%E8%A8%80%E2%80%94%E2%80%94SQL%E2%80%9D%E5%92%8C%E7%AC%AC7%E7%AB%A0%EF%BC%9A%E2%80%9CSQL%20Server%202012%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8%E2%80%9D%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%8F%90%E7%BA%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>《数据库原理及应用教程（第4版 | 微课版）》第3章：“关系数据库标准语言——SQL”和第7章：“SQL Server 2012高级应用”的学习提纲。</p><hr><h1 id="3-1-SQL的基本概念与特点"><a href="#3-1-SQL的基本概念与特点" class="headerlink" title="3.1 SQL的基本概念与特点"></a>3.1 SQL的基本概念与特点</h1><p>概念：</p><ul><li>内模式——存储文件</li><li>模式——基本表</li><li>外模式——视图</li></ul><p>特点：</p><ul><li>类似自然语言：如英语</li><li>一体化的：功能集中</li><li>非过程化的：用户只关心“做什么”，无需关心“怎么做”</li><li>面向集合的：操作对象是关系，结果是关系</li><li>自含式的：可单独使用交互命令</li><li>嵌入式的：嵌入高级语言中使用</li><li><strong>有数据查询、数据定义、数据操纵和数据控制功能</strong></li></ul><hr><h1 id="3-2-SQL-Server-2012简介——略"><a href="#3-2-SQL-Server-2012简介——略" class="headerlink" title="3.2 SQL Server 2012简介——略"></a>3.2 SQL Server 2012简介——略</h1><hr><h1 id="3-3-数据库的创建和使用"><a href="#3-3-数据库的创建和使用" class="headerlink" title="3.3 数据库的创建和使用"></a>3.3 数据库的创建和使用</h1><p>数据库的文件：</p><ul><li>数据文件：主数据文件，次数据文件</li><li>日志文件</li></ul><blockquote><p>一个数据库至少有一个数据文件和一个日志文件。<br>一个数据库只有一个主数据文件，可有多个次数据文件。</p></blockquote><p>数据库的文件组：主要文件组，次要文件组</p><blockquote><p>数据文件有文件组，日志文件无文件组。<br>一个数据文件只能在一个文件组，一个文件组只能被一个数据库使用。</p></blockquote><p>SQL语句：</p><ul><li>增加数据库：create database</li><li>删除数据库：drop database</li><li>修改数据库：alter database</li></ul><p>数据库迁移的方式：</p><ul><li>分离和加载</li><li>生成脚本：常用</li></ul><hr><h1 id="3-4-数据表的创建和使用"><a href="#3-4-数据表的创建和使用" class="headerlink" title="3.4 数据表的创建和使用"></a>3.4 数据表的创建和使用</h1><p>数据定义：使用数据定义语言（DDL）。</p><p>数据类型：</p><ul><li>整数型：如int</li><li>数值型：如numeric</li><li>货币型：如money</li><li>日期型：如datetime</li><li>字符型：如char</li></ul><blockquote><p>“var”表示“变长的”，“n”表示“Unicode字符（ASCII字符）”：<br>char：定长的，非Unicode字符（ASCII字符）（1个字符1字节）<br>varchar：变长的，非Unicode字符（ASCII字符）（1个字符1字节）<br>nchar：定长的，Unicode字符（1个字符2字节）<br>nvarchar：变长的，Unicode字符（1个字符2字节）</p></blockquote><blockquote><p>若字符串有<strong>非ASCII字符</strong>（如中文），则使用nchar或nvarchar。</p></blockquote><ul><li>二进制数据型：如binary</li><li>特殊类型：如timestamp</li></ul><p>数据完整性的机制：</p><ul><li>约束</li><li>默认</li><li>规则</li><li>触发器</li><li>存储过程</li></ul><p>约束的类型1：</p><ul><li>列约束：约束1列</li><li>表约束：约束多列</li></ul><p>约束的类型2：</p><ul><li>空值约束：只用于列约束</li><li>主键约束</li><li>唯一约束</li></ul><blockquote><p>注意：主键约束和唯一约束不同</p></blockquote><ul><li>外键约束</li><li>检查约束</li></ul><p>SQL语句：</p><ul><li>增加数据表：create table</li><li>删除数据表：drop table</li><li>修改数据表：alter table</li></ul><hr><h1 id="3-5-单关系（表）的数据查询"><a href="#3-5-单关系（表）的数据查询" class="headerlink" title="3.5 单关系（表）的数据查询"></a>3.5 单关系（表）的数据查询</h1><p>无条件查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line"><span class="keyword">from</span></span><br></pre></td></tr></table></figure><p>条件查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line"><span class="keyword">from</span></span><br><span class="line"><span class="keyword">where</span></span><br></pre></td></tr></table></figure><p>常用的库函数：</p><ul><li>AVG()</li><li>SUM()</li><li>MAX()</li><li>MIN()</li><li>COUNT()</li></ul><p>分组查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line"><span class="keyword">from</span></span><br><span class="line"><span class="keyword">where</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line"><span class="keyword">having</span></span><br></pre></td></tr></table></figure><p>排序查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line"><span class="keyword">from</span></span><br><span class="line"><span class="keyword">where</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line"><span class="keyword">having</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span></span><br></pre></td></tr></table></figure><p>select语句语义层的执行顺序：</p><ol><li>from</li><li>where</li><li>group by</li><li>having</li><li>select</li><li>order by</li></ol><blockquote><p>详细内容参见：参考资料</p></blockquote><hr><h1 id="3-6-多关系（表）的连接查询"><a href="#3-6-多关系（表）的连接查询" class="headerlink" title="3.6 多关系（表）的连接查询"></a>3.6 多关系（表）的连接查询</h1><p>连接的方法：</p><ul><li>from子句指明连接的表名，where子句指明连接的列名和连接条件：常用</li><li>join子句指明连接的表名，on子句指明连接的列名和连接条件</li></ul><p> join子句指明连接的表名，on子句指明连接的列名和连接条件的方法：</p><ul><li>内连接：inner join：输出符合条件的结果</li><li>左（外）连接：left （outer） join：输出符合条件的结果和左边表不符合条件的结果</li><li>右（外）连接：right （outer） join：输出符合条件的结果和右边表不符合条件的结果</li><li>全（外）连接）：full （outer） join：输出符合条件的结果、左边表不符合条件的结果和右边表不符合条件的结果</li><li>交叉连接：cross join：类似广义笛卡尔积</li></ul><blockquote><p>另外，还有一种自连接查询。</p></blockquote><hr><h1 id="3-7-子查询"><a href="#3-7-子查询" class="headerlink" title="3.7 子查询"></a>3.7 子查询</h1><p>类型：</p><ul><li>普通子查询：先执行子查询，后执行父查询</li><li>相关子查询：对父查询的每一行，执行子查询判断是否满足条件</li></ul><hr><h1 id="3-8-其他类型查询"><a href="#3-8-其他类型查询" class="headerlink" title="3.8 其他类型查询"></a>3.8 其他类型查询</h1><p>类型：</p><ul><li>集合运算查询：如union</li><li>存储结果集到表：如select into</li></ul><hr><h1 id="3-9-数据表中数据的操纵"><a href="#3-9-数据表中数据的操纵" class="headerlink" title="3.9 数据表中数据的操纵"></a>3.9 数据表中数据的操纵</h1><p>数据操纵：使用数据操纵语言（DML）。</p><p>SQL语句：</p><ul><li>增加数据：insert into … values</li><li>删除数据：<strong>delete</strong> from</li><li>修改数据：<strong>update</strong> … set</li></ul><hr><h1 id="3-10-视图"><a href="#3-10-视图" class="headerlink" title="3.10 视图"></a>3.10 视图</h1><p>SQL语句：</p><ul><li>增加视图：create view</li><li>删除视图：drop view</li><li>修改视图：alter view</li><li>增加数据：insert into … values</li><li>删除数据：<strong>delete</strong> from</li><li>修改数据：<strong>update</strong> … set</li><li>查询数据：select</li></ul><hr><h1 id="3-11-创建与使用索引"><a href="#3-11-创建与使用索引" class="headerlink" title="3.11 创建与使用索引"></a>3.11 创建与使用索引</h1><p>索引的类型：</p><ul><li>聚集索引</li><li>非聚集索引</li><li>唯一索引</li><li>视图索引</li><li>全文索引</li><li>XML索引</li></ul><p>SQL语句：</p><ul><li>增加索引：create</li><li>删除索引：drop</li><li>修改索引：alter</li></ul><hr><h1 id="SQL功能的总结"><a href="#SQL功能的总结" class="headerlink" title="SQL功能的总结"></a>SQL功能的总结</h1><ul><li>数据定义（DDL）：create，drop，alter</li><li>数据操纵（DML）：insert，delete，update</li><li>数据查询（DQL）：select</li><li>数据控制（DCL）：grant，revoke</li></ul><hr><h1 id="7-1-Transact-SQL程序设计——略"><a href="#7-1-Transact-SQL程序设计——略" class="headerlink" title="7.1 Transact-SQL程序设计——略"></a>7.1 Transact-SQL程序设计——略</h1><hr><h1 id="7-2-存储过程"><a href="#7-2-存储过程" class="headerlink" title="7.2 存储过程"></a>7.2 存储过程</h1><p>概念：依据时序&#x2F;流程，封装多条SQL语句后方便一次调用&#x2F;执行。类似函数</p><p>优点：</p><ul><li>模块化的程序设计</li><li>高效率地执行</li><li>减少网络流量</li><li>可以作为安全机制使用</li></ul><p>类型：</p><ul><li>系统存储过程</li><li>用户自定义存储过程：常用</li><li>扩展存储过程</li></ul><p>SQL语句：</p><ul><li>创建存储过程：create procedure</li><li>删除存储过程：drop procedure</li><li>修改存储过程：alter procedure</li><li>执行存储过程：exec procedure</li></ul><hr><h1 id="7-3-触发器"><a href="#7-3-触发器" class="headerlink" title="7.3 触发器"></a>7.3 触发器</h1><p>概念：依据时序&#x2F;流程，封装多条SQL语句后方便一次调用&#x2F;执行。类似回调函数</p><p>本质：特殊的存储过程</p><p>类型：</p><ul><li>登录触发器</li><li>DDL触发器</li><li>DML触发器：instead of触发器（语句执行前触发），after触发器（语句执行后触发）</li></ul><p>SQL语句：</p><ul><li>增加触发器：create trigger</li><li>删除触发器：drop trigger</li><li>修改触发器：alter trigger</li></ul><hr><h1 id="7-4-备份和还原"><a href="#7-4-备份和还原" class="headerlink" title="7.4 备份和还原"></a>7.4 备份和还原</h1><p>备份的类型：</p><ul><li>数据库完整备份</li><li>数据库差异备份：还必须用数据库完整备份</li><li>事务日志备份：还必须用数据库完整备份</li><li>文件及文件组备份：还必须用事务日志备份</li></ul><p>备份并还原的方式：</p><ul><li>数据库完整备份——简单还原</li><li>数据库完整备份 + 数据库差异备份——简单还原</li><li>数据库完整备份 + 数据库差异备份 + 事务日志备份——完全还原，批日志还原（性能更好）</li><li>文件及文件组备份 + 事务日志备份</li></ul><blockquote><p>数据库完整备份：还原完整数据<br>数据库差异备份：还原差异数据<br>事务日志备份：还原到<strong>失败点</strong><br>失败前处于运行状态事务的备份：还原到<strong>失败时刻</strong></p></blockquote><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>《数据库原理及应用教程（第4版 | 微课版）》第3章：“关系数据库标准语言——SQL”和第7章：“SQL Server 2012高级应用”的学习提纲。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《数据库原理及应用教程（第4版 | 微课版）》主编：陈志泊；副主编：许福，韩慧；编著：崔晓晖，路贺俊，阮豫红</li><li><a href="https://blog.csdn.net/weixin_39703170/article/details/79056533">SQL Select语句完整的执行顺序_20120623的博客-CSDN博客</a></li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《数据库原理及应用教程（第4版 | 微课版）》第4章：“关系数据库理论”的学习提纲</title>
      <link href="/2023/01/15/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%E6%95%99%E7%A8%8B%EF%BC%88%E7%AC%AC4%E7%89%88%20_%20%E5%BE%AE%E8%AF%BE%E7%89%88%EF%BC%89%E3%80%8B%E7%AC%AC4%E7%AB%A0%EF%BC%9A%E2%80%9C%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%90%86%E8%AE%BA%E2%80%9D%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%8F%90%E7%BA%B2/"/>
      <url>/2023/01/15/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%E6%95%99%E7%A8%8B%EF%BC%88%E7%AC%AC4%E7%89%88%20_%20%E5%BE%AE%E8%AF%BE%E7%89%88%EF%BC%89%E3%80%8B%E7%AC%AC4%E7%AB%A0%EF%BC%9A%E2%80%9C%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%90%86%E8%AE%BA%E2%80%9D%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%8F%90%E7%BA%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>《数据库原理及应用教程（第4版 | 微课版）》第4章：“关系数据库理论”的学习提纲。</p><hr><h1 id="4-1-规范化问题的提出"><a href="#4-1-规范化问题的提出" class="headerlink" title="4.1 规范化问题的提出"></a>4.1 规范化问题的提出</h1><h2 id="4-1-1-规范化理论的主要内容"><a href="#4-1-1-规范化理论的主要内容" class="headerlink" title="4.1.1 规范化理论的主要内容"></a>4.1.1 规范化理论的主要内容</h2><blockquote><p>关系型数据库系统设计的关键：<strong>关系模式</strong>设计</p></blockquote><ul><li>函数依赖：核心</li><li>范式</li><li>关系模式设计</li></ul><hr><h2 id="4-1-2-不合理的关系模式存在的异常问题"><a href="#4-1-2-不合理的关系模式存在的异常问题" class="headerlink" title="4.1.2 不合理的关系模式存在的异常问题"></a>4.1.2 不合理的关系模式存在的异常问题</h2><ul><li>数据冗余</li><li>增加异常</li><li>删除异常</li><li>修改异常</li></ul><p>规范关系模式应具备的条件：</p><ul><li><strong>尽可能少的</strong>数据冗余</li><li>无增加异常</li><li>无删除异常</li><li>无修改异常</li></ul><hr><h1 id="4-2-函数依赖"><a href="#4-2-函数依赖" class="headerlink" title="4.2 函数依赖"></a>4.2 函数依赖</h1><h2 id="4-2-1-函数依赖的定义"><a href="#4-2-1-函数依赖的定义" class="headerlink" title="4.2.1 函数依赖的定义"></a>4.2.1 函数依赖的定义</h2><p>数据依赖的类型：</p><ul><li>函数依赖：重要</li><li>多值依赖</li></ul><p>函数依赖的类型1：</p><ul><li>平凡的函数依赖：无实际意义</li><li>非平凡的函数依赖</li></ul><blockquote><p>可以分析属性的联系以确定函数依赖。</p></blockquote><p>函数依赖的类型2：</p><ul><li>完全函数依赖</li><li>部分函数依赖</li><li>传递函数依赖</li></ul><hr><h2 id="省略内容"><a href="#省略内容" class="headerlink" title="省略内容"></a>省略内容</h2><ul><li>4.2.2 函数依赖的逻辑蕴含定义</li><li>4.2.3 函数依赖的推理规则及正确性</li><li>4.2.4 完全函数依赖与部分函数依赖</li><li>4.2.5 传递函数依赖</li><li>4.2.6 属性集的闭包及其算法</li><li>4.2.7 候选码的求解理论和算法</li><li>4.2.8 函数依赖推理规则的完备性</li><li>4.2.9 函数依赖集的等价、覆盖和最小函数依赖集</li></ul><hr><h1 id="4-3-关系模式的分解——略"><a href="#4-3-关系模式的分解——略" class="headerlink" title="4.3 关系模式的分解——略"></a>4.3 关系模式的分解——略</h1><ul><li>4.3.1 模式分解问题</li><li>4.3.2 无损连接分解</li><li>4.3.3 无损分解的测试算法</li><li>4.3.4 保持函数依赖的分解</li></ul><hr><h1 id="4-4-关系模式的范式"><a href="#4-4-关系模式的范式" class="headerlink" title="4.4 关系模式的范式"></a>4.4 关系模式的范式</h1><p>关系模式范式：衡量关系模式好坏的标准</p><p>关系模式规范化：设计<strong>更好的</strong>关系模式</p><p>范式的类型：</p><ul><li>第一范式（1NF）</li><li>第二范式（2NF）</li><li>第三范式（3NF）</li><li>BC范式（BCNF）</li><li>第四范式（4NF）</li><li>第五范式（5NF）</li></ul><p>范式的关系（依据概念的宽窄）：1NF 包含 2NF 包含 3NF 包含 BCNF 包含 4NF 包含 5NF</p><hr><h2 id="4-4-1-第一范式"><a href="#4-4-1-第一范式" class="headerlink" title="4.4.1 第一范式"></a>4.4.1 第一范式</h2><p>内容：属性不可再分（原子性）</p><p>规范化方式：属性分解，消除非原子性</p><hr><h2 id="4-4-2-第二范式"><a href="#4-4-2-第二范式" class="headerlink" title="4.4.2 第二范式"></a>4.4.2 第二范式</h2><p>内容：在第一范式的基础上，非主属性不部分函数依赖于主码</p><p>规范化方式：关系模式分解，消除非主属性对主码的部分函数依赖</p><hr><h2 id="4-4-3-第三范式"><a href="#4-4-3-第三范式" class="headerlink" title="4.4.3 第三范式"></a>4.4.3 第三范式</h2><p>内容：在第二范式的基础上，非主属性不传递函数依赖于主码</p><p>规范化方式：关系模式分解，消除非主属性对主码的传递函数依赖</p><hr><h2 id="4-4-4-BC范式"><a href="#4-4-4-BC范式" class="headerlink" title="4.4.4 BC范式"></a>4.4.4 BC范式</h2><p>内容：在<strong>第一范式</strong>的基础上，<strong>属性（非主属性和主属性）</strong> 不部分函数依赖和不传递函数依赖于主码</p><p>规范化方式：关系模式分解，消除属性（非主属性和主属性）对主码的部分函数依赖和传递函数依赖</p><hr><h2 id="4-4-5-多值依赖与第四范式"><a href="#4-4-5-多值依赖与第四范式" class="headerlink" title="4.4.5 多值依赖与第四范式"></a>4.4.5 多值依赖与第四范式</h2><p>函数依赖和多值依赖的区别：</p><ul><li>函数依赖：表示关系模式中属性间的一对一或一对多联系</li><li>多值依赖：表示关系模式中属性间的多对多联系</li></ul><p>第四范式：</p><ul><li><p>内容：在第BC范式的基础上，不存在<strong>非平凡的多值依赖</strong></p></li><li><p>规范化方式：关系模式分解，消除非平凡的多值依赖</p></li></ul><hr><h2 id="第五范式"><a href="#第五范式" class="headerlink" title="第五范式"></a>第五范式</h2><p>内容：在第BC范式的基础上，不存在<strong>连接依赖</strong></p><p>规范化方式：关系模式分解，消除连接依赖</p><hr><h1 id="4-5-关系模式的规范化"><a href="#4-5-关系模式的规范化" class="headerlink" title="4.5 关系模式的规范化"></a>4.5 关系模式的规范化</h1><h2 id="4-5-1-关系模式规范化的目的和原则"><a href="#4-5-1-关系模式规范化的目的和原则" class="headerlink" title="4.5.1 关系模式规范化的目的和原则"></a>4.5.1 关系模式规范化的目的和原则</h2><p>概念：设计<strong>更好的</strong>关系模式</p><p>本质1：一个关系模式只表示一个（而不是多个）实体或联系（概念单一化）</p><p>本质2：消除决定属性不是候选码的任何函数依赖</p><hr><h2 id="4-5-2-关系模式规范化的步骤"><a href="#4-5-2-关系模式规范化的步骤" class="headerlink" title="4.5.2 关系模式规范化的步骤"></a>4.5.2 关系模式规范化的步骤</h2><ol><li>属性分解，消除非原子性，为第一范式</li><li>关系模式分解，消除非主属性对主码的部分函数依赖，为第二范式</li><li>关系模式分解，消除非主属性对主码的传递函数依赖，为第三范式</li><li>关系模式分解，消除<strong>主属性</strong>对主码的部分函数依赖和传递函数依赖，为BC范式</li><li>关系模式分解，消除非平凡的多值依赖，为第四范式</li><li>关系模式分解，消除连接依赖，为第五范式</li></ol><blockquote><p>一般要求关系模式为第三范式或BC范式。</p></blockquote><hr><h2 id="4-5-3-关系模式规范化的要求"><a href="#4-5-3-关系模式规范化的要求" class="headerlink" title="4.5.3 关系模式规范化的要求"></a>4.5.3 关系模式规范化的要求</h2><p>要求：分解的关系模式与原关系模式等价</p><p>判断分解的关系模式与原关系模式是否等价的标准：</p><ul><li>分解具有无损连接性</li><li>分解具有函数依赖保持性</li><li>分解具有无损连接性和函数依赖保持性</li></ul><blockquote><p>无损连接性：保证数据不丢失<br>函数依赖保持性：减轻或解决异常情况</p></blockquote><blockquote><p>第三范式要求分解具有具有无损连接性和函数依赖保持性。</p></blockquote><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>《数据库原理及应用教程（第4版 | 微课版）》第4章：“关系数据库理论”的学习提纲。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《数据库原理及应用教程（第4版 | 微课版）》主编：陈志泊；副主编：许福，韩慧；编著：崔晓晖，路贺俊，阮豫红</li><li><a href="https://www.cnblogs.com/xiaxianfei/p/5454707.html">数据库设计五大范式 - 金木杂谈 - 博客园 (cnblogs.com)</a></li><li><a href="https://baike.baidu.com/item/%E7%AC%AC%E4%BA%94%E8%8C%83%E5%BC%8F/5025271">第五范式_百度百科 (baidu.com)</a></li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《数据库原理及应用教程（第4版 | 微课版）》第5章：“数据库安全保护”的学习提纲</title>
      <link href="/2023/01/14/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%E6%95%99%E7%A8%8B%EF%BC%88%E7%AC%AC4%E7%89%88%20_%20%E5%BE%AE%E8%AF%BE%E7%89%88%EF%BC%89%E3%80%8B%E7%AC%AC5%E7%AB%A0%EF%BC%9A%E2%80%9C%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E4%BF%9D%E6%8A%A4%E2%80%9D%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%8F%90%E7%BA%B2/"/>
      <url>/2023/01/14/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%E6%95%99%E7%A8%8B%EF%BC%88%E7%AC%AC4%E7%89%88%20_%20%E5%BE%AE%E8%AF%BE%E7%89%88%EF%BC%89%E3%80%8B%E7%AC%AC5%E7%AB%A0%EF%BC%9A%E2%80%9C%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E4%BF%9D%E6%8A%A4%E2%80%9D%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%8F%90%E7%BA%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>《数据库原理及应用教程（第4版 | 微课版）》第5章：“数据库安全保护”的学习提纲。</p><hr><h1 id="数据库安全保护的内容"><a href="#数据库安全保护的内容" class="headerlink" title="数据库安全保护的内容"></a>数据库安全保护的内容</h1><ul><li>安全性控制</li><li>完整性控制</li><li>并发性控制</li><li>数据库恢复</li></ul><hr><h1 id="5-1-数据库的安全性"><a href="#5-1-数据库的安全性" class="headerlink" title="5.1 数据库的安全性"></a>5.1 数据库的安全性</h1><p>安全性措施：</p><ul><li>用户标识和鉴定</li><li>用户存取权限控制</li><li>定义视图</li><li>数据加密</li><li>审计</li></ul><p>SQL Server 2012的安全模型1：</p><ul><li>第一层：服务器安全管理（服务器级别）</li><li>第二层：数据库安全管理（数据库级别）</li><li>第三层：<strong>数据库对象</strong>安全管理（数据库对象级别）</li></ul><p>SQL Server 2012的安全模型2：</p><ul><li>用户：用户账号（服务器级别），数据库账号（数据库级别）</li><li>角色：服务器角色（服务器级别），数据库角色（数据库级别）</li><li>权限：系统权限（数据库级别），对象权限（数据库对象级别）</li></ul><hr><h1 id="5-2-完整性控制"><a href="#5-2-完整性控制" class="headerlink" title="5.2 完整性控制"></a>5.2 完整性控制</h1><h2 id="5-2-1-数据库完整性的含义"><a href="#5-2-1-数据库完整性的含义" class="headerlink" title="5.2.1 数据库完整性的含义"></a>5.2.1 数据库完整性的含义</h2><ul><li>正确性：数据的值和型对应合法。如年龄是数字型，只能用数字值表示</li><li>有效性：数据在定义的有效范围。如月份只能用正整数1-12表示</li><li>相容性：表示同一对象的多个数据相同。如一般一个人只有一个性别</li></ul><hr><h2 id="5-2-2-完整性规则的组成"><a href="#5-2-2-完整性规则的组成" class="headerlink" title="5.2.2 完整性规则的组成"></a>5.2.2 完整性规则的组成</h2><p>完整性规则的组成：</p><ul><li>触发条件</li><li>约束条件</li><li>违约响应</li></ul><p>完整性规则的表示：五元组（D，O，A，C，P）</p><ul><li>D（Data）：约束作用的数据对象：二维表，行，列</li><li>O（Operation）：触发完整性检查的数据库操作：立即执行（针对一条语句），延迟执行（针对一个事务）</li><li>A（Assertion）：数据对象必须满足的语义约束，即规则描述</li><li>C（Condition）：<strong>选择A作用的数据对象值的谓词</strong></li><li>P（Procedure）：违反完整性规则时触发执行的操作过程</li></ul><p>完整性规则表示的示例：</p><ul><li>D：学号</li><li>O：增加或修改D（学号）时执行检查</li><li>A：D（学号）不能为空</li><li>C：选择A（D（学号）不能为空）作用于学生表&#x2F;所有行</li><li>P：拒绝执行O（增加或修改）操作</li></ul><hr><h2 id="5-2-3-完整性约束条件的分类"><a href="#5-2-3-完整性约束条件的分类" class="headerlink" title="5.2.3 完整性约束条件的分类"></a>5.2.3 完整性约束条件的分类</h2><p>依据对象：</p><ul><li>值（数据内）约束：数据类型约束，数据格式约束，取值范围约束，空值约束</li><li>结构（数据间）约束：函数依赖约束，实体完整性约束，参照完整性约束，<strong>统计约束</strong></li></ul><blockquote><p>统计约束：规定某个属性值与一个关系多个元组的统计值之间必须满足某种约束条件。如部门主管的奖金不能低于部门奖金的平均值</p></blockquote><p>依据对象的状态：</p><ul><li>静态约束：值（数据内）约束，结构（数据间）约束</li><li>动态约束：如年份只能增加</li></ul><hr><h2 id="5-2-4-数据完整性的实施"><a href="#5-2-4-数据完整性的实施" class="headerlink" title="5.2.4 数据完整性的实施"></a>5.2.4 数据完整性的实施</h2><p>SQL Server 2012的实施形式：</p><ul><li>声明式：定义时确定数据完整性</li><li>程序式：编写程序确定数据完整性</li></ul><p>方法：</p><ul><li>约束</li><li>默认值</li><li>规则</li><li>存储过程</li><li>触发器</li></ul><hr><h1 id="5-3-并发控制与封锁"><a href="#5-3-并发控制与封锁" class="headerlink" title="5.3 并发控制与封锁"></a>5.3 并发控制与封锁</h1><h2 id="5-3-1-数据库并发性的含义"><a href="#5-3-1-数据库并发性的含义" class="headerlink" title="5.3.1 数据库并发性的含义"></a>5.3.1 数据库并发性的含义</h2><p>保持数据的一致性。</p><hr><h2 id="5-3-2-事务"><a href="#5-3-2-事务" class="headerlink" title="5.3.2 事务"></a>5.3.2 事务</h2><p>特征：ACID</p><ul><li>原子性（Atomicity）</li><li>一致性（Consistency）</li><li>隔离性（Isolation）</li><li>持久性（Durability）</li></ul><hr><h2 id="5-3-3-并发操作与数据的不一致性"><a href="#5-3-3-并发操作与数据的不一致性" class="headerlink" title="5.3.3 并发操作与数据的不一致性"></a>5.3.3 并发操作与数据的不一致性</h2><p>类型：</p><ul><li>丢失更新：多事务读同数据，先后写数据，后事务数据覆盖前事务数据（先写后写）</li><li>污读：先事务写数据，后事务读数据，先事务撤销写数据操作，后事务读到过期&#x2F;错误数据（先写后读）</li><li>不可重读：先事务读数据，后事务写数据，先事务读到过期&#x2F;错误数据（先读后写）</li></ul><hr><h2 id="5-3-4-封锁"><a href="#5-3-4-封锁" class="headerlink" title="5.3.4 封锁"></a>5.3.4 封锁</h2><p>类型：</p><ul><li>排他型&#x2F;写&#x2F;X型：加X锁后，不能再加其他锁</li><li>共享型&#x2F;读&#x2F;S型：加S锁后，只能加S锁</li></ul><p>封锁协议：</p><ul><li>一级封锁协议：事务在修改数据对象之前必须对其加X锁，直到事务结束。可以解决丢失更新问题</li><li>二级封锁协议：<strong>在一级封锁协议的基础上</strong>，另外加上事务在读取数据之前必须先对其加S锁，读完后释放S锁。可以解决丢失更新和污读问题</li><li>三级封锁协议：<strong>在一级封锁协议的基础上</strong>，另外加上事务在读取数据之前必须先对其加S锁，读完后并不释放S锁，而直到事务结束才释放。可以解决丢失更新、污读和不可重读<br>问题</li></ul><p>封锁协议总结：</p><ul><li>一级封锁协议：加X锁后，不能再加X锁</li><li>二级封锁协议：加X锁后，不能再加X锁；加X锁后，不能再加S锁</li><li>三级封锁协议：加X锁后，不能再加X锁；加X锁后，不能再加S锁；加S锁后，只能加S锁</li></ul><p>活锁：</p><ul><li>概念：当某个事物请求对某一数据进行排他性封锁时，由于其他事务对该数据的操作而使这个事务处于永久等待状态</li><li>示例：事务1封锁并处理数据，事务2和3请求封锁数据，事务1解锁数据后由事务3封锁并处理数据，则事务2一直处于请求封锁数据的等待状态</li><li>解决方式：先来先服务策略</li></ul><p>死锁：</p><ul><li>概念：在同时处于等待状态的两个或多个事务中，其中的每一个在它能够进行之前，都等待着某个数据，而这个数据已被它们中的某个事务所封锁</li><li>示例：事务1封锁并处理数据a，事务2封锁并处理数据b。事务1请求封锁数据b，因为事务2未解封锁数据b而一直处于请求封锁数据的等待状态；事务2请求封锁数据a，因为事务1未解封锁数据a而一直处于请求封锁数据的等待状态</li></ul><p>死锁产生的条件：</p><ul><li>互斥</li><li>不可剥夺</li><li>请求保持</li><li>循环等待</li></ul><p>死锁预防的方法：</p><ul><li>一次加锁法</li><li>顺序加锁法</li></ul><blockquote><p>对于数据库，死锁预防的开销大，不太适合。</p></blockquote><p>死锁诊断的方法：<strong>事务信&#x2F;依赖图</strong></p><p>死锁解除的方法：撤销死锁的某个或某些事务</p><blockquote><p>关于“死锁”的详细内容可参见：“操作系统”专栏的“‘进程与线程’学习提纲”博客。</p></blockquote><hr><h1 id="5-4-数据库恢复"><a href="#5-4-数据库恢复" class="headerlink" title="5.4 数据库恢复"></a>5.4 数据库恢复</h1><h2 id="5-4-1-数据库恢复的含义"><a href="#5-4-1-数据库恢复的含义" class="headerlink" title="5.4.1 数据库恢复的含义"></a>5.4.1 数据库恢复的含义</h2><p>恢复损失的数据。</p><hr><h2 id="5-4-2-数据库恢复的原理及其实现技术"><a href="#5-4-2-数据库恢复的原理及其实现技术" class="headerlink" title="5.4.2 数据库恢复的原理及其实现技术"></a>5.4.2 数据库恢复的原理及其实现技术</h2><p>数据库恢复的原理：数据冗余</p><p>恢复系统功能的类型：</p><ul><li>生成冗余数据：预防故障</li><li>冗余重建：解决故障</li></ul><p>生成冗余数据功能的技术：</p><ul><li>登记日志文件</li></ul><blockquote><p>日志的先写原则：先写日志后操作数据</p></blockquote><ul><li>数据转储</li></ul><blockquote><p>数据转储的类型：<br>依据方式：海量转储，增量转储<br>依据状态：静态转储，动态转储</p></blockquote><hr><h2 id="5-4-3-数据库的故障和恢复策略"><a href="#5-4-3-数据库的故障和恢复策略" class="headerlink" title="5.4.3 数据库的故障和恢复策略"></a>5.4.3 数据库的故障和恢复策略</h2><p>故障的类型和恢复的策略：</p><ul><li>事务故障：事务撤销</li><li>系统故障：未提交的事务进行事务撤销，已提交的事务进行事务重做</li><li>介质故障：数据转储和登记日志文件恢复</li></ul><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>《数据库原理及应用教程（第4版 | 微课版）》第5章：“数据库安全保护”的学习提纲。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《数据库原理及应用教程（第4版 | 微课版）》主编：陈志泊；副主编：许福，韩慧；编著：崔晓晖，路贺俊，阮豫红</li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《数据库原理及应用教程（第4版 | 微课版）》第6章：“数据库设计”的学习提纲</title>
      <link href="/2023/01/13/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%E6%95%99%E7%A8%8B%EF%BC%88%E7%AC%AC4%E7%89%88%20_%20%E5%BE%AE%E8%AF%BE%E7%89%88%EF%BC%89%E3%80%8B%E7%AC%AC6%E7%AB%A0%EF%BC%9A%E2%80%9C%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E2%80%9D%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%8F%90%E7%BA%B2/"/>
      <url>/2023/01/13/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%E6%95%99%E7%A8%8B%EF%BC%88%E7%AC%AC4%E7%89%88%20_%20%E5%BE%AE%E8%AF%BE%E7%89%88%EF%BC%89%E3%80%8B%E7%AC%AC6%E7%AB%A0%EF%BC%9A%E2%80%9C%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E2%80%9D%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%8F%90%E7%BA%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>《数据库原理及应用教程（第4版 | 微课版）》第6章：“数据库设计”的学习提纲。</p><hr><h1 id="6-1-数据库设计概述"><a href="#6-1-数据库设计概述" class="headerlink" title="6.1 数据库设计概述"></a>6.1 数据库设计概述</h1><h2 id="6-1-1-数据库设计的任务、内容和特点"><a href="#6-1-1-数据库设计的任务、内容和特点" class="headerlink" title="6.1.1 数据库设计的任务、内容和特点"></a>6.1.1 数据库设计的任务、内容和特点</h2><p>数据库设计的内容：</p><ul><li>结构&#x2F;静态模型设计：概念设计，逻辑设计，物理设计</li><li>行为&#x2F;动态模型设计</li></ul><hr><h2 id="6-1-2-数据库设计方法简述"><a href="#6-1-2-数据库设计方法简述" class="headerlink" title="6.1.2 数据库设计方法简述"></a>6.1.2 数据库设计方法简述</h2><ul><li>直观设计&#x2F;手工试凑法</li><li>规范设计&#x2F;新奥尔良法</li><li>计算机辅助设计法</li><li>自动化设计法</li></ul><p>规范设计&#x2F;新奥尔良法：</p><ul><li>基于实体-联系（E-R）模型法</li><li>基于第三范式（3NF）法</li><li>基于视图法</li><li>实体分析法</li><li>属性分析法</li><li>基于抽象语义法</li><li>…</li></ul><hr><h2 id="6-1-3-数据库设计的步骤"><a href="#6-1-3-数据库设计的步骤" class="headerlink" title="6.1.3 数据库设计的步骤"></a>6.1.3 数据库设计的步骤</h2><ol><li>系统需求分析</li><li>概念结构设计：<strong>独立于软件（数据库管理系统）和硬件</strong>；需求 -&gt; <strong>概念模型</strong>——<strong>概念模式</strong></li></ol><blockquote><p>概念模式示例：实体-联系（E-R）图</p></blockquote><ol start="3"><li>逻辑结构设计：<strong>与软件（数据库管理系统）耦合</strong>；概念模型 -&gt; <strong>数据模型</strong>——<strong>关系模式</strong></li></ol><blockquote><p>关系模式示例：学生（学号（主码），姓名）</p></blockquote><ol start="4"><li>物理结构设计：<strong>与硬件耦合</strong></li><li>数据库实施</li><li>数据库运行与维护</li></ol><blockquote><p>第1和2步面向需求<br>第3和4步面向数据库管理系统<br>第5和6步面向实现</p></blockquote><hr><h1 id="6-2-系统需求分析"><a href="#6-2-系统需求分析" class="headerlink" title="6.2 系统需求分析"></a>6.2 系统需求分析</h1><h2 id="6-2-1-需求分析的任务"><a href="#6-2-1-需求分析的任务" class="headerlink" title="6.2.1 需求分析的任务"></a>6.2.1 需求分析的任务</h2><ol><li>调查分析用户活动</li><li>收集和分析需求数据，确定<strong>系统边界</strong></li><li>编写系统分析报告&#x2F;需求规范&#x2F;格说明书</li></ol><blockquote><p>系统边界：判断哪些对象由人工完成，哪些对象由计算机自动完成</p></blockquote><hr><h2 id="6-2-2-需求分析的方法"><a href="#6-2-2-需求分析的方法" class="headerlink" title="6.2.2 需求分析的方法"></a>6.2.2 需求分析的方法</h2><ul><li>自顶向下&#x2F;结构化分析（SA）：最简单实用</li><li>自底向上</li></ul><p>自顶向下&#x2F;结构化分析（SA）方法使用的工具：</p><ul><li>数据流图（DFD）</li><li>数据字典（DD）</li></ul><blockquote><p>数据表示：数据字典（DD）<br>数据处理：判定表，判定树</p></blockquote><hr><h1 id="6-3-概念结构设计"><a href="#6-3-概念结构设计" class="headerlink" title="6.3 概念结构设计"></a>6.3 概念结构设计</h1><h2 id="6-3-1-概念结构设计的必要性"><a href="#6-3-1-概念结构设计的必要性" class="headerlink" title="6.3.1 概念结构设计的必要性"></a>6.3.1 概念结构设计的必要性</h2><p>需求 -&gt; <strong>概念模型</strong>——<strong>概念模式</strong></p><hr><h2 id="6-3-2-概念模型的特点"><a href="#6-3-2-概念模型的特点" class="headerlink" title="6.3.2 概念模型的特点"></a>6.3.2 概念模型的特点</h2><ul><li>语义表达能力丰富</li><li>易于交流和理解</li><li>易于修改和扩充</li><li>易于向各种<strong>数据模型</strong>转换</li></ul><hr><h2 id="6-3-3-概念模型的E-R表示方法"><a href="#6-3-3-概念模型的E-R表示方法" class="headerlink" title="6.3.3 概念模型的E-R表示方法"></a>6.3.3 概念模型的E-R表示方法</h2><p>实体-联系（E-R）模型是概念模型。</p><p>E-R模型&#x2F;<strong>图&#x2F;方法</strong>的组成：</p><ul><li>实体：矩形框</li><li>属性：椭圆形框</li><li>联系：菱形框</li><li>关系：无向边</li><li>其他：标注，联系的类型</li></ul><p>联系的类型：</p><ul><li>实体内&#x2F;实体与属性的联系：一对一，一对多，多对多</li><li>实体间&#x2F;实体与实体的联系：一对一，一对多，多对多</li></ul><hr><h2 id="6-3-4-概念结构设计的方法与步骤"><a href="#6-3-4-概念结构设计的方法与步骤" class="headerlink" title="6.3.4 概念结构设计的方法与步骤"></a>6.3.4 概念结构设计的方法与步骤</h2><p>方法：</p><ul><li>自顶向下：先全局，后局部</li><li>自底向上：先局部，后全局；<strong>最常用</strong></li><li>逐步扩张：先核心，后全局</li><li>混合策略：先自顶向下，后自底向上</li></ul><p>步骤：</p><ol><li>数据抽象：设计局部E-R模型&#x2F;用户视图</li><li>视图集成：集成各局部E-R模型为全局E-R模型</li></ol><p>数据抽象的方法：</p><ul><li>分类：抽象实体</li><li>聚集：抽象属性</li></ul><p>数据抽象的步骤：</p><ol><li>分类</li><li>聚集</li><li>设计局部E-R模型</li></ol><p>视图集成的方法：</p><ul><li>多元集成法：一次集成各局部E-R模型为全局E-R模型</li><li>二元集成法：分多次，每次集成两个局部E-R模型为全局E-R模型；<strong>最常用</strong></li></ul><p>视图集成的步骤：</p><ol><li>合并：合并各局部E-R模型，消除<strong>冲突</strong>，生成<strong>初步E-R模型</strong></li></ol><blockquote><p>冲突：属性冲突，命名冲突，结构冲突<br>属性冲突：属性值域冲突，属性取值单位冲突<br>命名冲突：同名异义，异名同义<br>结构冲突：同一对象在不同应用中抽象不同：可能为实体或属性，同一实体在不同应用中属性组成不同：可能数量或次序不同，同一联系在不同应用中类型不同：可能为一对一、一对多或多对多</p></blockquote><ol start="2"><li>优化：由初步E-R模型，消除<strong>冗余</strong>，生成<strong>基本E-R模型</strong></li></ol><hr><h1 id="6-4-逻辑结构设计"><a href="#6-4-逻辑结构设计" class="headerlink" title="6.4 逻辑结构设计"></a>6.4 逻辑结构设计</h1><h2 id="6-4-1-逻辑结构设计的任务和步骤"><a href="#6-4-1-逻辑结构设计的任务和步骤" class="headerlink" title="6.4.1 逻辑结构设计的任务和步骤"></a>6.4.1 逻辑结构设计的任务和步骤</h2><p>任务：概念模型 -&gt; <strong>数据模型</strong>——<strong>关系模式</strong></p><blockquote><p>关系模式示例：学生（学号（主码），姓名）</p></blockquote><p>步骤：</p><ol><li>初始关系模式设计</li><li>关系模式规范化</li><li>模式的评价与改进</li></ol><hr><h2 id="6-4-2-初始关系模式设计"><a href="#6-4-2-初始关系模式设计" class="headerlink" title="6.4.2 初始关系模式设计"></a>6.4.2 初始关系模式设计</h2><p>转换原则：</p><ul><li>实体 -&gt; 关系模式</li><li>联系 -&gt; 关系模式</li><li>属性 -&gt; 属性</li></ul><p>步骤：</p><ol><li>实体转换为关系模式，转换属性</li><li>联系转换为关系模式，转换属性</li><li>处理特殊情况</li></ol><hr><h2 id="6-4-3-关系模式规范化"><a href="#6-4-3-关系模式规范化" class="headerlink" title="6.4.3 关系模式规范化"></a>6.4.3 关系模式规范化</h2><p>步骤：</p><ol><li>确定范式级别</li><li>实施规范化处理：至少为第三范式（3NF）</li></ol><hr><h2 id="6-4-4-模式评价与改进"><a href="#6-4-4-模式评价与改进" class="headerlink" title="6.4.4 模式评价与改进"></a>6.4.4 模式评价与改进</h2><p>模式评价：</p><ul><li>功能评价</li><li>性能评价</li></ul><p>模式改进的方法：</p><ul><li>合并：合并关系模式以减少连接操作</li><li>分解</li></ul><p>分解的类型：</p><ul><li>水平分解：分解元组以减少操作的记录数</li><li>垂直分解：分解属性以减少操作的字段数</li></ul><hr><h1 id="6-5-物理结构设计"><a href="#6-5-物理结构设计" class="headerlink" title="6.5 物理结构设计"></a>6.5 物理结构设计</h1><p>步骤：</p><ol><li>确定物理结构：存储结构，存取方法</li><li>评价物理结构：时间效率，空间效率</li></ol><hr><h2 id="6-5-1-确定物理结构"><a href="#6-5-1-确定物理结构" class="headerlink" title="6.5.1 确定物理结构"></a>6.5.1 确定物理结构</h2><p>步骤：</p><ol><li>设计存储记录的结构：如<strong>字段的类型和长度</strong></li><li>设计数据访问的方法：如索引</li><li>设计数据存储的位置：如存储的磁盘</li><li>设计系统的配置：如数据库的大小</li></ol><hr><h2 id="6-5-2-评价物理结构"><a href="#6-5-2-评价物理结构" class="headerlink" title="6.5.2 评价物理结构"></a>6.5.2 评价物理结构</h2><hr><h1 id="6-6-数据库实施"><a href="#6-6-数据库实施" class="headerlink" title="6.6 数据库实施"></a>6.6 数据库实施</h1><p>步骤：</p><ol><li>建立实际数据库结构</li><li>装入数据</li><li>应用程序编码与调试</li><li>数据库试运行</li><li>整理文档</li></ol><hr><h2 id="6-6-1-建立实际数据库结构"><a href="#6-6-1-建立实际数据库结构" class="headerlink" title="6.6.1 建立实际数据库结构"></a>6.6.1 建立实际数据库结构</h2><p>使用数据定义语言（DDL）</p><hr><h2 id="6-6-2-装入数据——略"><a href="#6-6-2-装入数据——略" class="headerlink" title="6.6.2 装入数据——略"></a>6.6.2 装入数据——略</h2><hr><h2 id="6-6-3-应用程序编码与调试——略"><a href="#6-6-3-应用程序编码与调试——略" class="headerlink" title="6.6.3 应用程序编码与调试——略"></a>6.6.3 应用程序编码与调试——略</h2><hr><h2 id="6-6-4-数据库试运行"><a href="#6-6-4-数据库试运行" class="headerlink" title="6.6.4 数据库试运行"></a>6.6.4 数据库试运行</h2><p>内容：</p><ul><li>功能测试</li><li>性能测试</li></ul><hr><h1 id="6-7-数据库运行和维护"><a href="#6-7-数据库运行和维护" class="headerlink" title="6.7 数据库运行和维护"></a>6.7 数据库运行和维护</h1><p>内容：</p><ul><li>维护数据库的安全性与完整性</li><li>监测并改善数据库性能</li><li>重新组织和构造数据库</li></ul><hr><h1 id="数据库设计步骤的总结"><a href="#数据库设计步骤的总结" class="headerlink" title="数据库设计步骤的总结"></a>数据库设计步骤的总结</h1><blockquote><p>方法：规范设计&#x2F;新奥尔良法</p></blockquote><p>1.系统需求分析</p><blockquote><p>方法：自顶向下&#x2F;结构化分析（SA）<br>工具：数据流图，数据字典，判定表&#x2F;树</p></blockquote><p>（1）调查分析用户活动</p><p>（2）收集和分析需求数据，确定<strong>系统边界</strong></p><p>（3）编写系统分析报告&#x2F;需求规范&#x2F;格说明书</p><p>2.概念结构设计</p><blockquote><p>方法：自底向上<br>工具：实体-联系（E-R）图</p></blockquote><p>（1）数据抽象</p><blockquote><p>方法：分类，聚集</p></blockquote><p>①分类</p><p>②聚集</p><p>③设计局部E-R图</p><p>（2）视图集成</p><blockquote><p>方法：二元集成法</p></blockquote><p>①合并</p><p>②优化</p><ol start="3"><li>逻辑结构设计</li></ol><p>（1）初始关系模式设计</p><p>①实体转换为关系模式，转换属性</p><p>②联系转换为关系模式，转换属性</p><p>③处理特殊情况</p><p>（2）关系模式规范化</p><p>①确定范式级别</p><p>②实施规范化处理</p><p>（3）模式的评价与改进</p><ul><li><p>模式评价：功能评价，性能评价</p></li><li><p>模式改进：合并，分解：水平分解，垂直分解</p></li></ul><p>4.物理结构设计</p><p>（1）确定物理结构</p><p>①设计存储记录的结构</p><p>②设计数据访问的方法</p><p>③设计数据存储的位置</p><p>④设计系统的配置</p><p>（2）评价物理结构</p><ul><li>时间效率</li><li>空间效率</li></ul><p>5.数据库实施</p><p>（1）建立实际数据库结构</p><p>（2）装入数据</p><p>（3）应用程序编码与调试</p><p>（4）数据库试运行</p><ul><li>功能测试</li><li>性能测试</li></ul><p>（5）整理文档</p><p>6.数据库运行和维护</p><ul><li>维护数据库的安全性与完整性</li><li>监测并改善数据库性能</li><li>重新组织和构造数据库</li></ul><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>《数据库原理及应用教程（第4版 | 微课版）》第6章：“数据库设计”的学习提纲。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《数据库原理及应用教程（第4版 | 微课版）》主编：陈志泊；副主编：许福，韩慧；编著：崔晓晖，路贺俊，阮豫红</li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《数据库原理及应用教程（第4版 | 微课版）》第2章：“关系数据库”的学习提纲</title>
      <link href="/2023/01/12/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%E6%95%99%E7%A8%8B%EF%BC%88%E7%AC%AC4%E7%89%88%20_%20%E5%BE%AE%E8%AF%BE%E7%89%88%EF%BC%89%E3%80%8B%E7%AC%AC2%E7%AB%A0%EF%BC%9A%E2%80%9C%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%9D%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%8F%90%E7%BA%B2/"/>
      <url>/2023/01/12/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%E6%95%99%E7%A8%8B%EF%BC%88%E7%AC%AC4%E7%89%88%20_%20%E5%BE%AE%E8%AF%BE%E7%89%88%EF%BC%89%E3%80%8B%E7%AC%AC2%E7%AB%A0%EF%BC%9A%E2%80%9C%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%9D%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%8F%90%E7%BA%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>《数据库原理及应用教程（第4版 | 微课版）》第2章：“关系数据库”的学习提纲。</p><hr><h1 id="关系模型的组成"><a href="#关系模型的组成" class="headerlink" title="关系模型的组成"></a>关系模型的组成</h1><ul><li>关系数据结构</li><li>关系操作集合</li><li>关系完整性约束</li></ul><hr><h1 id="2-1-关系模型的数据结构及其形式化定义"><a href="#2-1-关系模型的数据结构及其形式化定义" class="headerlink" title="2.1 关系模型的数据结构及其形式化定义"></a>2.1 关系模型的数据结构及其形式化定义</h1><h2 id="2-1-1-关系的形式化定义及其有关概念"><a href="#2-1-1-关系的形式化定义及其有关概念" class="headerlink" title="2.1.1 关系的形式化定义及其有关概念"></a>2.1.1 关系的形式化定义及其有关概念</h2><ul><li>域&#x2F;值域</li><li>笛卡尔积</li><li>关系</li><li>关系头和关系体</li></ul><h2 id="2-1-2-关系的性质"><a href="#2-1-2-关系的性质" class="headerlink" title="2.1.2 关系的性质"></a>2.1.2 关系的性质</h2><ul><li>列是同质的，即每一列中的分量必须来自同一个域，必须是同一类型的数据</li><li>不同的属性可来自同一个域，但不同的属性必须有不同的名字</li><li>列的顺序可以任意交换</li><li>关系中元组的顺序（即行序）可任意，在一个关系中可以任意交换两行的次序</li><li>关系中不允许出现相同的元组</li><li>关系中每一分量必须是不可分的数据项</li></ul><hr><h2 id="2-1-3-关系模式"><a href="#2-1-3-关系模式" class="headerlink" title="2.1.3 关系模式"></a>2.1.3 关系模式</h2><p>五元组：R（U，D，DOM，F）</p><ul><li>R：关系名</li><li>U：组成该关系的属性名集合</li><li>D：属性组U中属性来自的域</li><li>DOM：属性向域的<strong>映像集合</strong></li><li>F：属性间数据的<strong>依赖关系集合</strong></li></ul><blockquote><p>R（U） &#x3D; R（A1，A2，…，An）。A1，A2，…，An为各属性名</p></blockquote><p>区分：</p><ul><li>关系模式&#x2F;关系头：型</li><li>关系实例&#x2F;关系&#x2F;关系体：值</li></ul><blockquote><p>一般将关系模式和关系实例统称为关系</p></blockquote><hr><h2 id="2-1-4-关系数据库与关系数据库模式"><a href="#2-1-4-关系数据库与关系数据库模式" class="headerlink" title="2.1.4 关系数据库与关系数据库模式"></a>2.1.4 关系数据库与关系数据库模式</h2><ul><li>关系数据库模式：型</li><li>关系数据库实例&#x2F;关系数据库：值</li></ul><hr><h1 id="2-2-关系的码与关系的完整性"><a href="#2-2-关系的码与关系的完整性" class="headerlink" title="2.2 关系的码与关系的完整性"></a>2.2 关系的码与关系的完整性</h1><h2 id="2-2-1-候选码（键）与主码（键）"><a href="#2-2-1-候选码（键）与主码（键）" class="headerlink" title="2.2.1 候选码（键）与主码（键）"></a>2.2.1 候选码（键）与主码（键）</h2><ul><li>候选码&#x2F;候选关键字&#x2F;候选键（全码）</li><li>主码&#x2F;主关系键&#x2F;主键&#x2F;关系键&#x2F;关键字</li><li>主属性</li><li>非主属性&#x2F;非码属性</li></ul><hr><h2 id="2-2-2-外码（外部关系键）"><a href="#2-2-2-外码（外部关系键）" class="headerlink" title="2.2.2 外码（外部关系键）"></a>2.2.2 外码（外部关系键）</h2><ul><li>外码（外部关系键）</li></ul><blockquote><p>注意：外码的关系为<strong>参照关系</strong>，外码所对应主码的关系为<strong>被参照关系</strong></p></blockquote><hr><h2 id="2-2-3-关系的完整性"><a href="#2-2-3-关系的完整性" class="headerlink" title="2.2.3 关系的完整性"></a>2.2.3 关系的完整性</h2><ul><li>实体完整性</li><li>参照完整性</li><li>用户自定义完整性</li></ul><blockquote><p>关系数据库系统必须支持关系的两个不变性：实体完整性 + 参照完整性</p></blockquote><hr><h1 id="2-3-关系代数"><a href="#2-3-关系代数" class="headerlink" title="2.3 关系代数"></a>2.3 关系代数</h1><h2 id="2-3-1-关系代数的分类及其运算符"><a href="#2-3-1-关系代数的分类及其运算符" class="headerlink" title="2.3.1 关系代数的分类及其运算符"></a>2.3.1 关系代数的分类及其运算符</h2><p>关系代数：<strong>由关系的运算表达查询</strong>，是<strong>过程化语言</strong></p><p>关系代数运算的组成：</p><ul><li>运算对象：关系</li><li>运算符</li><li>运算结果：关系</li></ul><p>运算符的类型：</p><ul><li><strong>传统的</strong>集合运算符：并，差，交，广义笛卡尔积</li><li><strong>专门的</strong>关系运算符：选取，投影，θ连接，自然连接，除法</li><li>算术比较运算符：大于，大于等于，小于，小于等于，等于</li><li>逻辑运算符：与，或，非</li></ul><p>依据运算符的类型，关系代数的类型：</p><ul><li>传统的集合运算：行运算（水平方向）</li><li>专门的关系运算：行运算（水平方向）和列运算（垂直方向）</li></ul><blockquote><p>基本操作：并、差、积、选取和投影，构成关系代数<strong>完备的</strong>操作集。可由基本操作构成其他所有非基本操作。</p></blockquote><hr><h2 id="2-3-2-传统的集合运算"><a href="#2-3-2-传统的集合运算" class="headerlink" title="2.3.2 传统的集合运算"></a>2.3.2 传统的集合运算</h2><ul><li>并：增加</li><li>差：删除</li><li>交</li><li>广义笛卡尔积</li></ul><hr><h2 id="2-3-3-专门的关系运算"><a href="#2-3-3-专门的关系运算" class="headerlink" title="2.3.3 专门的关系运算"></a>2.3.3 专门的关系运算</h2><ul><li>选取</li><li>投影</li><li>θ连接：由多个关系的<strong>属性域</strong>，依据<strong>等于、小于或大于</strong>条件进行连接</li><li>自然连接：由多个关系的<strong>同名属性</strong>，依据<strong>等于</strong>条件进行连接，且<strong>删除重复的同名属性</strong></li><li>除法</li></ul><hr><h1 id="2-4-关系演算"><a href="#2-4-关系演算" class="headerlink" title="2.4 关系演算"></a>2.4 关系演算</h1><p>关系演算：由<strong>谓词表达查询</strong>，是<strong>非过程化语言</strong></p><p>依据谓词变元的类型，关系演算的类型：</p><ul><li>元组关系演算</li><li>域关系演算</li></ul><hr><h2 id="2-4-1-元组关系演算语言"><a href="#2-4-1-元组关系演算语言" class="headerlink" title="2.4.1 元组关系演算语言"></a>2.4.1 元组关系演算语言</h2><ul><li>ALPHA语言</li><li>QUEL语言</li></ul><hr><h2 id="2-4-2-域关系演算语言QBE"><a href="#2-4-2-域关系演算语言QBE" class="headerlink" title="2.4.2 域关系演算语言QBE"></a>2.4.2 域关系演算语言QBE</h2><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>《数据库原理及应用教程（第4版 | 微课版）》第2章：“关系数据库”的学习提纲。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《数据库原理及应用教程（第4版 | 微课版）》主编：陈志泊；副主编：许福，韩慧；编著：崔晓晖，路贺俊，阮豫红</li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《数据库原理及应用教程（第4版 | 微课版）》第1章：“数据库系统概述”的学习提纲</title>
      <link href="/2023/01/11/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%E6%95%99%E7%A8%8B%EF%BC%88%E7%AC%AC4%E7%89%88%20_%20%E5%BE%AE%E8%AF%BE%E7%89%88%EF%BC%89%E3%80%8B%E7%AC%AC1%E7%AB%A0%EF%BC%9A%E2%80%9C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0%E2%80%9D%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%8F%90%E7%BA%B2/"/>
      <url>/2023/01/11/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%E6%95%99%E7%A8%8B%EF%BC%88%E7%AC%AC4%E7%89%88%20_%20%E5%BE%AE%E8%AF%BE%E7%89%88%EF%BC%89%E3%80%8B%E7%AC%AC1%E7%AB%A0%EF%BC%9A%E2%80%9C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0%E2%80%9D%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%8F%90%E7%BA%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>《数据库原理及应用教程（第4版 | 微课版）》第1章：“数据库系统概述”的学习提纲。</p><hr><h1 id="计算机的主要应用领域"><a href="#计算机的主要应用领域" class="headerlink" title="计算机的主要应用领域"></a>计算机的主要应用领域</h1><ul><li>科学计算（早期的重点）</li><li>过程控制</li><li>数据处理（现代的重点）</li></ul><hr><h1 id="1-1-信息、数据、数据处理与数据管理"><a href="#1-1-信息、数据、数据处理与数据管理" class="headerlink" title="1.1 信息、数据、数据处理与数据管理"></a>1.1 信息、数据、数据处理与数据管理</h1><ul><li>信息 &#x3D; 数据 + 语义</li><li>数据处理包括数据管理；数据管理是数据处理的重点</li></ul><hr><h1 id="1-2-数据库技术的产生、发展"><a href="#1-2-数据库技术的产生、发展" class="headerlink" title="1.2 数据库技术的产生、发展"></a>1.2 数据库技术的产生、发展</h1><ol><li>人工管理阶段</li><li>文件系统阶段</li><li>数据库系统阶段</li></ol><p>人工管理阶段中，数据管理的特点：</p><ul><li>无专门的存取设备</li><li>无专门的管理软件</li><li>数据无<strong>共享性</strong>：不同程序使用相同数据时，各自使用 -&gt; 存在冗余数据</li><li>数据无<strong>独立性</strong>：数据与程序紧耦合，数据变化 -&gt; 程序变化</li></ul><blockquote><p>程序和数据的对应关系： 一个程序——一个数据集</p></blockquote><p>文件系统阶段中，数据管理的特点：</p><ul><li>有专门的存取设备，数据以文件形式保存，文件的形式多样化</li><li>有专门的管理软件：文件系统</li><li>数据有一定的共享性</li><li>数据有一定的独立性</li></ul><blockquote><p>程序和数据的对应关系： 一个程序——一个文件；多个程序——一个文件系统——多个文件</p></blockquote><p>数据库系统阶段中，数据管理的特点：</p><ul><li>数据是结构化的</li><li>有专门的管理软件：数据库管理系统（DBMS），有统一的数据管理功能</li><li>数据有共享性</li><li>数据有独立性：<strong>物理独立性，逻辑独立性</strong></li></ul><blockquote><p>程序和数据的对应关系： 多个程序——一个数据库管理系统——一个数据库</p></blockquote><p>数据库管理系统的数据控制功能：</p><ul><li>数据的<strong>安全性</strong>控制：如身份认证和权限访问控制</li><li>数据的<strong>完整性</strong>控制：<strong>正确性，有效性，相容性</strong></li><li>并发控制</li><li>数据恢复控制</li></ul><blockquote><p>正确性：数据合法。如数值型数据中无字符型数据<br>有效性：数据在定义的有效范围。如月份只能用1~12的正整数表示<br>相容性：同一实体的多个数据相同。如一个人只有一个性别</p></blockquote><hr><h1 id="1-3-数据库系统的组成"><a href="#1-3-数据库系统的组成" class="headerlink" title="1.3 数据库系统的组成"></a>1.3 数据库系统的组成</h1><p>由低到高层：</p><p>数据库（DB）：</p><ul><li>集成性</li><li>共享性</li></ul><p>硬件系统：</p><ul><li>设备</li></ul><p>软件系统：</p><ul><li>操作系统（OS）</li><li>数据库管理系统（DBMS）</li><li>应用系统</li></ul><p>用户：</p><ul><li>第三类用户：数据库管理员（DBA）</li><li>第二类用户：应用程序员（AP）</li><li>第一类用户：最终用户（EU）</li></ul><hr><h1 id="1-4-数据库系统的内部体系结构"><a href="#1-4-数据库系统的内部体系结构" class="headerlink" title="1.4 数据库系统的内部体系结构"></a>1.4 数据库系统的内部体系结构</h1><blockquote><p>三级模式的内部体系结构的别名：ANSI&#x2F;SPARC体系结构</p></blockquote><p>由低到高层：</p><p>3模式：</p><ul><li>内模式&#x2F;物理模式&#x2F;存储模式（唯一）</li><li>模式&#x2F;概念模式（唯一）</li><li>外模式&#x2F;用户模式&#x2F;子模式（不唯一）</li></ul><p>2映像：</p><ul><li>内模式&#x2F;模式映像（唯一）</li><li>模式&#x2F;外模式映像（不唯一）</li></ul><hr><h1 id="1-5-数据库系统的外部体系结构"><a href="#1-5-数据库系统的外部体系结构" class="headerlink" title="1.5 数据库系统的外部体系结构"></a>1.5 数据库系统的外部体系结构</h1><p>从最终用户的角度：</p><ul><li>单用户结构（桌面型数据库系统）：计算机有数据库、数据库管理系统和应用</li><li>多用户&#x2F;主从式结构：主机有数据库、数据库管理系统和应用，从机只作为主机的输入&#x2F;输出设备</li><li>分布式结构</li><li>客户机&#x2F;服务器（C&#x2F;S）结构（富客户机模式；两层结构）：客户机有应用，服务器有数据库和数据库管理系统</li><li>浏览器&#x2F;服务器（B&#x2F;S）结构（瘦客户机模式；三层结构）：客户机有浏览器，应用服务器有应用，数据库服务器有数据库和数据库管理系统</li></ul><hr><h1 id="1-6-数据库管理系统"><a href="#1-6-数据库管理系统" class="headerlink" title="1.6 数据库管理系统"></a>1.6 数据库管理系统</h1><h2 id="1-6-1-DBMS的主要功能："><a href="#1-6-1-DBMS的主要功能：" class="headerlink" title="1.6.1 DBMS的主要功能："></a>1.6.1 DBMS的主要功能：</h2><ul><li>数据定义</li><li>数据操作</li><li>数据库运行管理</li><li>数据库的建立和维护</li><li>数据通信接口</li><li>数据组织、存储和管理</li></ul><p>数据定义：数据定义语言（DDL）</p><ul><li>CREATE</li><li>DROP</li><li>ALTER</li></ul><p>数据操纵：数据操纵语言（DML）</p><ul><li>INSERT</li><li>DELETE</li><li>UPDATE</li><li>SELECT：数据查询语言（DQL）</li></ul><p>数据库运行管理：数据控制语言（DCL）</p><ul><li>数据的安全性控制</li><li>数据的完整性控制</li><li>数据的并发性控制</li><li>数据的恢复控制</li></ul><hr><h2 id="1-6-2-DBMS的组成"><a href="#1-6-2-DBMS的组成" class="headerlink" title="1.6.2 DBMS的组成"></a>1.6.2 DBMS的组成</h2><ul><li>语言编译处理程序</li><li>系统运行控制程序</li><li>系统建立、维护程序</li><li>数据字典</li></ul><hr><h2 id="1-6-2-DBMS的数据存取的过程"><a href="#1-6-2-DBMS的数据存取的过程" class="headerlink" title="1.6.2 DBMS的数据存取的过程"></a>1.6.2 DBMS的数据存取的过程</h2><p>数据流向：应用 &lt;-&gt; 数据库管理系统 &lt;-&gt; 数据库</p><hr><h1 id="1-7-数据模型"><a href="#1-7-数据模型" class="headerlink" title="1.7 数据模型"></a>1.7 数据模型</h1><h2 id="1-7-1-数据模型的概念及分类"><a href="#1-7-1-数据模型的概念及分类" class="headerlink" title="1.7.1 数据模型的概念及分类"></a>1.7.1 数据模型的概念及分类</h2><p>模型的转换：三个世界、两级抽象、四种模型和四种数据模型</p><ol><li>现实世界的实际模型 -&gt; </li><li>信息世界的概念&#x2F;信息&#x2F;实体模型 -&gt; </li><li>计算机世界的数据&#x2F;逻辑模型+物理模型</li></ol><p>数据模型的类型：</p><ul><li>层次模型</li><li>网状模型</li><li>关系模型</li><li>面向对象模型</li></ul><hr><h2 id="1-7-2-数据模型的组成要素"><a href="#1-7-2-数据模型的组成要素" class="headerlink" title="1.7.2 数据模型的组成要素"></a>1.7.2 数据模型的组成要素</h2><ul><li>数据结构：描述实体和<strong>联系</strong>，表现静态特性</li><li>数据操作：描述<strong>操作规则</strong>和操作，表现动态特性</li><li>数据的完整性约束：描述<strong>定义约束的机制</strong>和约束</li></ul><hr><h1 id="1-8-三个世界及其有关概念"><a href="#1-8-三个世界及其有关概念" class="headerlink" title="1.8 三个世界及其有关概念"></a>1.8 三个世界及其有关概念</h1><p>现实世界</p><p>信息世界：</p><ul><li>实体</li><li>属性：<strong>型 + 值</strong></li><li>实体<strong>型</strong></li><li>实体<strong>集</strong></li><li>码&#x2F;键</li><li>域</li><li>联系：实体型内的联系 + 实体型间的联系</li></ul><blockquote><p>实体型内的联系：<br>一对一<br>一对多<br>多对多</p></blockquote><blockquote><p>实体型间的联系：<br>一对一<br>一对多<br>多对多</p></blockquote><p>计算机世界：</p><ul><li>字段&#x2F;数据项：描述属性</li><li>记录：描述实体</li><li>文件：描述实体集</li><li>关键字&#x2F;键</li></ul><p>总结：</p><table><thead><tr><th>现实世界</th><th>信息世界</th><th>计算机世界</th></tr></thead><tbody><tr><td>事物总体</td><td>实体集</td><td>文件</td></tr><tr><td>事物个体</td><td>实体</td><td>记录</td></tr><tr><td>特征</td><td>属性</td><td>字段</td></tr><tr><td>事物联系&#x2F;实际模型</td><td>概念&#x2F;信息&#x2F;实体模型</td><td>数据模型</td></tr></tbody></table><hr><h1 id="1-9-四种数据模型"><a href="#1-9-四种数据模型" class="headerlink" title="1.9 四种数据模型"></a>1.9 四种数据模型</h1><ul><li>层次模型：数据结构是树</li><li>网状模型：数据结构是图</li><li>关系模型：数据结构是二维表&#x2F;关系；数据操作满足实体完整性、参照完整性和用户定义的完整性</li><li>面向对象模型</li></ul><blockquote><p>非关系模型：层次模型 + 网状模型</p></blockquote><p>二维表的组成：</p><ul><li>表名</li><li>表头：型</li><li>表体：值</li></ul><p>关系模型的相关概念：</p><ul><li>关系</li><li>元组</li><li>属性</li><li>域</li><li><strong>分量</strong>：具体一行一列的值</li><li>候选码</li><li>主码</li><li>关系模式：型</li><li>关系实例：值</li></ul><hr><h1 id="1-10-数据库领域的新技术"><a href="#1-10-数据库领域的新技术" class="headerlink" title="1.10 数据库领域的新技术"></a>1.10 数据库领域的新技术</h1><ul><li>分布式数据库</li><li>数据仓库与数据挖掘技术</li><li>多媒体数据库</li><li>大数据技术</li></ul><p>大数据的特性：4V</p><ul><li>数据量大（Volume）</li><li>数据类型繁多（Variety）</li><li>数据处理速度快（Velocity）</li><li>数据价值密度低（Value）</li></ul><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>《数据库原理及应用教程（第4版 | 微课版）》第1章：“数据库系统概述”的学习提纲。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《数据库原理及应用教程（第4版 | 微课版）》主编：陈志泊；副主编：许福，韩慧；编著：崔晓晖，路贺俊，阮豫红</li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《数据库系统概念（第6版）》第1章：“引言”的学习提纲</title>
      <link href="/2023/01/02/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5%EF%BC%88%E7%AC%AC6%E7%89%88%EF%BC%89%E3%80%8B%E7%AC%AC1%E7%AB%A0%EF%BC%9A%E2%80%9C%E5%BC%95%E8%A8%80%E2%80%9D%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%8F%90%E7%BA%B2/"/>
      <url>/2023/01/02/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5%EF%BC%88%E7%AC%AC6%E7%89%88%EF%BC%89%E3%80%8B%E7%AC%AC1%E7%AB%A0%EF%BC%9A%E2%80%9C%E5%BC%95%E8%A8%80%E2%80%9D%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%8F%90%E7%BA%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>《数据库系统概念（第6版）》第1章：“引言”的学习提纲。</p><hr><blockquote><p>数据库管理系统（DBMS）包括数据库（DB）</p></blockquote><hr><h1 id="1-1-数据库系统的应用"><a href="#1-1-数据库系统的应用" class="headerlink" title="1.1 数据库系统的应用"></a>1.1 数据库系统的应用</h1><ul><li>直接或间接地应用</li><li>应用广泛</li></ul><hr><h1 id="1-2-数据库系统的目标"><a href="#1-2-数据库系统的目标" class="headerlink" title="1.2 数据库系统的目标"></a>1.2 数据库系统的目标</h1><p>文件处理系统的缺点：</p><ul><li>数据的冗余和不一致</li><li>数据访问困难</li><li>数据孤立</li><li>完整性问题</li><li>原子性问题</li><li>并发访问异常</li><li>安全性问题</li><li>…</li></ul><p>数据库系统需要改进上述缺点</p><hr><h1 id="1-3-数据视图"><a href="#1-3-数据视图" class="headerlink" title="1.3 数据视图"></a>1.3 数据视图</h1><h2 id="1-3-1-数据抽象"><a href="#1-3-1-数据抽象" class="headerlink" title="1.3.1 数据抽象"></a>1.3.1 数据抽象</h2><p>从低到高层：</p><ul><li>物理层</li><li>逻辑层</li><li>视图层</li></ul><hr><h2 id="1-3-2-实例和模式"><a href="#1-3-2-实例和模式" class="headerlink" title="1.3.2 实例和模式"></a>1.3.2 实例和模式</h2><p>从低到高层：</p><ul><li>物理模式（唯一）</li><li>逻辑模式（唯一）（体现物理数据独立性）（最重要）</li><li>子模式（不唯一）</li></ul><hr><h2 id="1-3-3-数据模型"><a href="#1-3-3-数据模型" class="headerlink" title="1.3.3 数据模型"></a>1.3.3 数据模型</h2><ul><li>关系模型</li><li>实体-联系（E-R）模型</li><li>基于对象的数据模型</li><li>半结构化数据模型</li><li>网状数据模型（少用）</li><li>层次数据模型（少用）</li></ul><hr><h1 id="1-4-数据库语言"><a href="#1-4-数据库语言" class="headerlink" title="1.4 数据库语言"></a>1.4 数据库语言</h1><h2 id="1-4-1-数据操纵语言（DML）"><a href="#1-4-1-数据操纵语言（DML）" class="headerlink" title="1.4.1 数据操纵语言（DML）"></a>1.4.1 数据操纵语言（DML）</h2><p>访问类型：</p><ul><li>查询</li><li>插入</li><li>删除</li><li>修改</li></ul><p>类型：</p><ul><li>过程化数据操纵语言</li><li>非过程化数据操纵语言&#x2F;声明式数据操纵语言（相对更简单）</li></ul><hr><h2 id="1-4-2-数据定义语言（DDL）"><a href="#1-4-2-数据定义语言（DDL）" class="headerlink" title="1.4.2 数据定义语言（DDL）"></a>1.4.2 数据定义语言（DDL）</h2><p>定义的约束类型：</p><ul><li><strong>域约束</strong></li><li>参照完整性</li><li><strong>断言</strong></li><li>授权</li></ul><hr><h1 id="1-5-关系数据库"><a href="#1-5-关系数据库" class="headerlink" title="1.5 关系数据库"></a>1.5 关系数据库</h1><blockquote><p>“关系数据库基于关系模型，使用一系列表来表达数据以及这些数据之间的联系。关系数据库也包括DML和DDL。”</p></blockquote><hr><h2 id="1-5-1-表"><a href="#1-5-1-表" class="headerlink" title="1.5.1 表"></a>1.5.1 表</h2><p>内容：</p><ul><li>行&#x2F;记录</li><li>列&#x2F;字段&#x2F;属性</li></ul><hr><h2 id="1-5-2-数据操纵语言"><a href="#1-5-2-数据操纵语言" class="headerlink" title="1.5.2 数据操纵语言"></a>1.5.2 数据操纵语言</h2><blockquote><p>“SQL查询语言是非过程化的。”</p></blockquote><p>格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段名</span><br><span class="line"><span class="keyword">from</span> 表名</span><br><span class="line"><span class="keyword">where</span> 条件;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> instructor.ID, dapartment.dept_name</span><br><span class="line"><span class="keyword">from</span> instructor, dapartment</span><br><span class="line"><span class="keyword">where</span> instructor.dept_name <span class="operator">=</span> department.dept_name <span class="keyword">and</span> department.budget <span class="operator">&gt;</span> <span class="number">95000</span>;</span><br></pre></td></tr></table></figure><hr><h2 id="1-5-3-数据定义语言"><a href="#1-5-3-数据定义语言" class="headerlink" title="1.5.3 数据定义语言"></a>1.5.3 数据定义语言</h2><p>格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名</span><br><span class="line">(</span><br><span class="line">(字段名 字段类型)，</span><br><span class="line">(字段名 字段类型)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> department</span><br><span class="line">(</span><br><span class="line">dept_name <span class="type">char</span>(<span class="number">20</span>),</span><br><span class="line">building <span class="type">char</span>(<span class="number">15</span>),</span><br><span class="line">budget <span class="type">numeric</span>(<span class="number">12</span>,<span class="number">2</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><blockquote><p>“另外，DDL语句还更新了<strong>数据字典</strong>，它包含<strong>元数据</strong>(见1.4.2节)。表的模式就是元数据的一个例子。”</p></blockquote><hr><h2 id="1-5-4-来自应用程序的数据库访问"><a href="#1-5-4-来自应用程序的数据库访问" class="headerlink" title="1.5.4 来自应用程序的数据库访问"></a>1.5.4 来自应用程序的数据库访问</h2><blockquote><p>“SQL不像一个通用的图灵机那么强大；即，有一些计算可以用通用的程序设计语言来表达，但无<br>法通过SQL来表达。SQL还不支持诸如从用户那儿输入、输出到显示器，或者通过网络通信这样的动作。这样的计算和动作必须用一种<strong>宿主语言</strong>来写，比如C、C++或Java,在其中使用<strong>嵌入式的SQL</strong>查询来访问数据库中的数据。<strong>应用程序(application program)</strong> 在这里是指以这种方式与数据库进行交互的程序。”</p></blockquote><blockquote><p>“为了访问数据库，DML语句需要由宿主语言来执行。有两种途径可以做到这一点：<br>●一种是通过提供<strong>应用程序接口(过程集)</strong>,它可以用来将DML和DDL的语句发送给数据库，再取回结果。<br>与C语言一起使用的<strong>开放数据库连接(ODBC)标准</strong>，是一种常用的应用程序接口标准。<strong>Java数据库连接(JDBC)标准</strong>为Java语言提供了相应的特性。<br>●另一种是通过扩展宿主语言的语法，在宿主语言的程序中嵌入DML调用。通常用一个特殊字符作为DML调用的开始，并且通过预处理器，称为<strong>DML预编译器(DML precompiler)</strong>,来将DML语句转变成宿主语言中的过程调用。”</p></blockquote><hr><h1 id="1-6-数据库设计"><a href="#1-6-数据库设计" class="headerlink" title="1.6 数据库设计"></a>1.6 数据库设计</h1><blockquote><p>“数据库设计的主要内容是数据库模式的设计。”</p></blockquote><hr><h2 id="1-6-1-设计过程"><a href="#1-6-1-设计过程" class="headerlink" title="1.6.1 设计过程"></a>1.6.1 设计过程</h2><ol><li>需求分析</li><li>概念设计</li><li>逻辑设计</li><li>物理设计</li></ol><hr><h2 id="1-6-2-大学机构的数据库设计——略"><a href="#1-6-2-大学机构的数据库设计——略" class="headerlink" title="1.6.2 大学机构的数据库设计——略"></a>1.6.2 大学机构的数据库设计——略</h2><hr><h2 id="1-6-3-实体-联系模型"><a href="#1-6-3-实体-联系模型" class="headerlink" title="1.6.3 实体-联系模型"></a>1.6.3 实体-联系模型</h2><p>内容：</p><ul><li>实体</li><li>联系</li></ul><blockquote><p>“数据库的总体逻辑结构(模式)可以用<strong>实体-联系图(entity-relationship diagram,E-R图)</strong> 进行图形化表示。有几种方法来画这样的图。最常用的方法之一是采用**统一建模语言(Unified Modeling Language,UML)**。</p></blockquote><hr><h2 id="1-6-4-规范化"><a href="#1-6-4-规范化" class="headerlink" title="1.6.4 规范化"></a>1.6.4 规范化</h2><blockquote><p>“设计关系数据库所用到的另外一种方法是通常被称为<strong>规范化</strong>的过程。它的目标是生成一个关系模式集合，使我们存储信息时没有不必要的冗余，同时又能很轻易地检索数据。”</p></blockquote><blockquote><p>“空值很难处理，所以最好不要用它。”</p></blockquote><blockquote><p>“规范化的详尽理论已经研究形成，它有助于形式化地定义什么样的数据库设计是不好的，以及如<br> 何得到我们想要的设计。”</p></blockquote><hr><h1 id="1-7-数据存储和查询"><a href="#1-7-数据存储和查询" class="headerlink" title="1.7 数据存储和查询"></a>1.7 数据存储和查询</h1><blockquote><p>“数据库系统的功能部件大致可分为存储管理器和查询处理部件。”</p></blockquote><hr><h2 id="1-7-1-存储管理器"><a href="#1-7-1-存储管理器" class="headerlink" title="1.7.1 存储管理器"></a>1.7.1 存储管理器</h2><p> 包括：</p><ul><li>权限及完整性管理器</li><li>事务管理器</li><li>文件管理器</li><li>缓冲区管理器</li></ul><p>实现的数据结构：</p><ul><li>数据文件</li><li>数据字典</li><li>索引</li></ul><hr><h2 id="1-7-2-查询处理器"><a href="#1-7-2-查询处理器" class="headerlink" title="1.7.2 查询处理器"></a>1.7.2 查询处理器</h2><p>包括：</p><ul><li>数据定义语言解释器</li><li>数据操纵语言编译器</li><li>查询执行引擎</li></ul><hr><h1 id="1-8-事务管理"><a href="#1-8-事务管理" class="headerlink" title="1.8 事务管理"></a>1.8 事务管理</h1><p>事务的4个特性（ACID）：</p><ul><li>原子性</li><li>一致性</li><li>隔离性</li><li>持久性</li></ul><p>事务管理器包括：</p><ul><li>（故障）恢复管理器</li><li>并发控制管理器</li></ul><hr><h1 id="1-9-数据库体系结构"><a href="#1-9-数据库体系结构" class="headerlink" title="1.9 数据库体系结构"></a>1.9 数据库体系结构</h1><p>类型：</p><ul><li>集中式</li><li>客户&#x2F;服务端式</li><li>并行式</li><li>分布式</li></ul><p>2层：</p><ul><li>客户端（包含应用程序）</li><li>服务端（包含数据库系统）</li></ul><p>3层：</p><ul><li>客户端</li><li>服务端（包含应用程序，不包含数据库系统）</li><li>数据库系统</li></ul><hr><h1 id="1-10-数据挖掘与信息检索"><a href="#1-10-数据挖掘与信息检索" class="headerlink" title="1.10 数据挖掘与信息检索"></a>1.10 数据挖掘与信息检索</h1><blockquote><p>“<strong>数据挖掘(data mining)</strong> 这个术语指半自动地分析大型数据库并从中找出有用的模式的过程。”</p></blockquote><blockquote><p>“查询非结构化的文本数据被称为<strong>信息检索(information retrieval）。</strong>”</p></blockquote><hr><h1 id="1-11-特种数据库"><a href="#1-11-特种数据库" class="headerlink" title="1.11 特种数据库"></a>1.11 特种数据库</h1><h2 id="1-11-1-基于对象的数据模型"><a href="#1-11-1-基于对象的数据模型" class="headerlink" title="1.11.1 基于对象的数据模型"></a>1.11.1 基于对象的数据模型</h2><blockquote><p>“现在主要的数据库厂商都支持<strong>对象-关系数据模型(object-relational data model),</strong> 这是一个将面向对象数据模型和关系数据模型的特点结合在一起的数据模型。它扩展了传统的关系模型，增加了新的特征如结构和集合类型，以及面向对象特性。”</p></blockquote><hr><h2 id="1-11-2-半结构化数据模型"><a href="#1-11-2-半结构化数据模型" class="headerlink" title="1.11.2 半结构化数据模型"></a>1.11.2 半结构化数据模型</h2><blockquote><p>“半结构化数据模型允许那些相同类型的数据项有不同的属性集的数据说明。这和早先提到的数据模型形成了对比：在那些数据模型中所有某种特定类型的数据项必须有相同的属性集。”</p></blockquote><hr><h1 id="1-12-数据库用户和管理员"><a href="#1-12-数据库用户和管理员" class="headerlink" title="1.12 数据库用户和管理员"></a>1.12 数据库用户和管理员</h1><h2 id="1-12-1-数据库用户和用户界面"><a href="#1-12-1-数据库用户和用户界面" class="headerlink" title="1.12.1 数据库用户和用户界面"></a>1.12.1 数据库用户和用户界面</h2><p>用户类型：</p><ul><li>无经验的用户</li><li>应用程序员</li><li>老练的用户</li><li>专门的用户</li></ul><hr><h2 id="1-12-2-数据库管理员"><a href="#1-12-2-数据库管理员" class="headerlink" title="1.12.2 数据库管理员"></a>1.12.2 数据库管理员</h2><p>作用：</p><ul><li>模式定义</li><li>存储结构及存取方法定义</li><li>模式及物理组织的修改</li><li>数据访问授权</li><li>日常维护</li></ul><hr><h1 id="1-13-数据库系统的历史——略"><a href="#1-13-数据库系统的历史——略" class="headerlink" title="1.13 数据库系统的历史——略"></a>1.13 数据库系统的历史——略</h1><hr><h1 id="1-14-总结——略"><a href="#1-14-总结——略" class="headerlink" title="1.14 总结——略"></a>1.14 总结——略</h1><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>《数据库系统概念（第6版）》第1章：“引言”的学习提纲。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《数据库系统概念（第6版）》作者：Abraham Silberschatz，Henry E.Korth，S.Sudarshan</li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++的基于对象编程范式、常用STL容器和C++11标准</title>
      <link href="/2022/12/23/C++%E7%9A%84%E5%9F%BA%E4%BA%8E%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%E3%80%81%E5%B8%B8%E7%94%A8STL%E5%AE%B9%E5%99%A8%E5%92%8CC++11%E6%A0%87%E5%87%86/"/>
      <url>/2022/12/23/C++%E7%9A%84%E5%9F%BA%E4%BA%8E%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%E3%80%81%E5%B8%B8%E7%94%A8STL%E5%AE%B9%E5%99%A8%E5%92%8CC++11%E6%A0%87%E5%87%86/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>C++的基于对象编程范式、常用STL容器和C++11标准。</p><hr><h1 id="基于对象编程范式"><a href="#基于对象编程范式" class="headerlink" title="基于对象编程范式"></a>基于对象编程范式</h1><h2 id="面向过程编程范式的例子"><a href="#面向过程编程范式的例子" class="headerlink" title="面向过程编程范式的例子"></a>面向过程编程范式的例子</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> num1 = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> num2 = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> sum = num1 + num2;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="基于对象编程范式的例子"><a href="#基于对象编程范式的例子" class="headerlink" title="基于对象编程范式的例子"></a>基于对象编程范式的例子</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GetSum</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calculation</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;num1, <span class="type">const</span> <span class="type">int</span> &amp;num2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = num1 + num2;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> num1 = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> num2 = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">GetSum</span> get_sum;</span><br><span class="line">    <span class="type">int</span> sum = get_sum.<span class="built_in">calculation</span>(num1,num2);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="基于对象和面向对象编程范式的区别"><a href="#基于对象和面向对象编程范式的区别" class="headerlink" title="基于对象和面向对象编程范式的区别"></a>基于对象和面向对象编程范式的区别</h2><p>基于对象编程范式：</p><ul><li>具有“封装”特性</li><li>常用于中小项目</li></ul><p>面向对象编程范式：</p><ul><li>具有“封装”、“继承”和“多态”特性</li><li>使用虚函数、重写和设计模式等技术</li><li>常用于大项目</li></ul><hr><h1 id="常用STL容器"><a href="#常用STL容器" class="headerlink" title="常用STL容器"></a>常用STL容器</h1><p>顺序容器：</p><ul><li>数组&#x2F;向量</li><li>链表</li><li>队列</li><li>栈</li></ul><p>关联容器：</p><ul><li>图&#x2F;映射</li><li>集合</li><li>对组</li><li>元组</li></ul><hr><h2 id="数组-向量"><a href="#数组-向量" class="headerlink" title="数组&#x2F;向量"></a>数组&#x2F;向量</h2><table><thead><tr><th>名称</th><th>底层原理</th><th>说明</th></tr></thead><tbody><tr><td>array</td><td>静态数组</td><td>C++11标准</td></tr><tr><td>vector</td><td>动态数组</td><td></td></tr></tbody></table><hr><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><table><thead><tr><th>名称</th><th>底层原理</th><th>说明</th></tr></thead><tbody><tr><td>list</td><td>双向链表</td><td></td></tr><tr><td>forward_list</td><td>单向链表</td><td>C++11标准</td></tr></tbody></table><hr><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><table><thead><tr><th>名称</th><th>底层原理</th><th>说明</th></tr></thead><tbody><tr><td>deque</td><td>管理数组+多个被管理数组</td><td></td></tr><tr><td>queue</td><td>deque</td><td>容器适配器</td></tr><tr><td>priority_queue</td><td>堆（完全二叉树）</td><td></td></tr></tbody></table><hr><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><table><thead><tr><th>名称</th><th>底层原理</th><th>说明</th></tr></thead><tbody><tr><td>stack</td><td>deque</td><td>容器适配器</td></tr></tbody></table><hr><h2 id="图-映射"><a href="#图-映射" class="headerlink" title="图&#x2F;映射"></a>图&#x2F;映射</h2><table><thead><tr><th>名称</th><th>底层原理</th><th>说明</th></tr></thead><tbody><tr><td>map</td><td>红黑树</td><td></td></tr><tr><td>multimap</td><td>红黑树</td><td></td></tr><tr><td>unordered_map</td><td>哈希表</td><td>C++11标准</td></tr><tr><td>unordered_multimap</td><td>哈希表</td><td>C++11标准</td></tr></tbody></table><hr><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><table><thead><tr><th>名称</th><th>底层原理</th><th>说明</th></tr></thead><tbody><tr><td>set</td><td>红黑树</td><td></td></tr><tr><td>multiset</td><td>红黑树</td><td></td></tr><tr><td>unordered_set</td><td>哈希表</td><td>C++11标准</td></tr><tr><td>unordered_multiset</td><td>哈希表</td><td>C++11标准</td></tr></tbody></table><hr><h2 id="对组"><a href="#对组" class="headerlink" title="对组"></a>对组</h2><table><thead><tr><th>名称</th><th>底层原理</th><th>说明</th></tr></thead><tbody><tr><td>pair</td><td>结构体struct</td><td></td></tr></tbody></table><hr><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><table><thead><tr><th>名称</th><th>底层原理</th><th>说明</th></tr></thead><tbody><tr><td>tuple</td><td>递归继承类</td><td>C++11标准</td></tr></tbody></table><hr><h2 id="总表"><a href="#总表" class="headerlink" title="总表"></a>总表</h2><table><thead><tr><th>名称</th><th>底层原理</th><th>说明</th></tr></thead><tbody><tr><td>array</td><td>静态数组</td><td>C++11标准</td></tr><tr><td>vector</td><td>动态数组</td><td></td></tr><tr><td>list</td><td>双向链表</td><td></td></tr><tr><td>forward_list</td><td>单向链表</td><td>C++11标准</td></tr><tr><td>deque</td><td>管理数组+多个被管理数组</td><td></td></tr><tr><td>queue</td><td>deque</td><td>容器适配器</td></tr><tr><td>priority_queue</td><td>堆（完全二叉树）</td><td></td></tr><tr><td>stack</td><td>deque</td><td>容器适配器</td></tr><tr><td>map</td><td>红黑树</td><td></td></tr><tr><td>multimap</td><td>红黑树</td><td></td></tr><tr><td>unordered_map</td><td>哈希表</td><td>C++11标准</td></tr><tr><td>unordered_multimap</td><td>哈希表</td><td>C++11标准</td></tr><tr><td>set</td><td>红黑树</td><td></td></tr><tr><td>multiset</td><td>红黑树</td><td></td></tr><tr><td>unordered_set</td><td>哈希表</td><td>C++11标准</td></tr><tr><td>unordered_multiset</td><td>哈希表</td><td>C++11标准</td></tr><tr><td>pair</td><td>结构体struct</td><td></td></tr><tr><td>tuple</td><td>递归继承类</td><td>C++11标准</td></tr></tbody></table><hr><h1 id="C-11标准"><a href="#C-11标准" class="headerlink" title="C++11标准"></a>C++11标准</h1><blockquote><p>依据《C++ Primer中文版（第5版）》XXV页的“C++11的新特性”栏所列顺序</p></blockquote><blockquote><p>可能常用的用粗体标示</p></blockquote><ul><li>long long 类型</li><li><strong>列表初始化</strong></li><li><strong>nullptr 常量</strong></li><li><strong>constexpr 变量</strong></li><li>类型别名声明</li><li><strong>auto 类型指示符</strong></li><li>decltype 类型指示符</li><li>类内初始化</li><li>使用 auto 或 decltype 缩写类型</li><li><strong>范围 for 语句</strong></li><li></li><li><strong>定义 vector 对象的 vector （向量的向量）</strong></li><li><strong>vector 对象的列表初始化</strong></li><li><strong>容器的 cbegin 和 cend 函数</strong></li><li>标准库函数 begin 和 end 函数</li><li>使用 auto 和 decltype 简化声明</li><li><strong>除法的舍入规则</strong></li><li><strong>用大括号包围的值列表赋值</strong> </li><li>将 sizeof 用于类成员</li><li><strong>范围 for 语句</strong> </li><li>标准库 initializer_list 类</li><li></li><li><strong>列表初始化返回值</strong></li><li>定义尾置返回类型</li><li>使用 decltype 简化返回类型定义</li><li>constexpr 函数</li><li><strong>使用&#x3D;default 生成默认构造函数</strong></li><li>类对象成员的类内初始化</li><li>委托构造函数</li><li>constexpr 构造函数</li><li><strong>用 string 对象处理文件名</strong></li><li><strong>array 和 forward_list 容器</strong></li><li></li><li><strong>容器的 cbegin 和 cend 函数</strong></li><li><strong>容器的列表初始化</strong></li><li><strong>容器的非成员函数 swap</strong></li><li><strong>容器 insert 成员的返回类型</strong></li><li>容器的 emplace 成员</li><li>shrink_to_fit</li><li><strong>string 的数值转换函数</strong></li><li><strong>lambda 表达式</strong></li><li><strong>lambda 表达式中的尾置返回类型</strong></li><li>标准库 bind 函数</li><li></li><li><strong>关联容器的列表初始化</strong></li><li><strong>列表初始化 pair 的返回类型</strong></li><li><strong>pair 的列表初始化</strong></li><li><strong>无序容器</strong></li><li><strong>智能指针</strong></li><li><strong>shared_ptr 类</strong></li><li><strong>动态分配对象的列表初始化</strong></li><li>auto 和动态分配</li><li><strong>unique_ptr 类</strong></li><li><strong>weak_ptr 类</strong></li><li></li><li><strong>范围 for 语句不能应用于动态分配数组</strong></li><li><strong>动态分配数组的列表初始化</strong></li><li>auto 不能用于分配数组</li><li>allocator::construct 可使用任意构造函数</li><li>将&#x3D;default 用于拷贝控制成员</li><li>使用&#x3D;delete 阻止拷贝类对象</li><li>用移动类对象代替拷贝类对象</li><li>右值引用</li><li>标准库 move 函数</li><li>移动构造函数和移动赋值</li><li></li><li>移动构造函数通常应该是noexcept</li><li>移动迭代器</li><li>引用限定成员函数</li><li>function 类模板</li><li><strong>explicit 类型转换运算符</strong></li><li>虚函数的 override 指示符</li><li>通过定义类为 final 来组阻止继承</li><li>虚函数的 override  和 final 指示符</li><li>删除的拷贝控制和继承</li><li>继承的构造函数</li><li></li><li>声明模板类型形参为友元</li><li>模板类型别名</li><li>模板函数的默认模板参数</li><li>实例化的显式控制</li><li>模板函数与尾置返回类型</li><li>引用折叠规则</li><li>用 static_cast 将左值转换为右值</li><li>标准库 forward 函数</li><li>可变参数模板</li><li>sizeof…运算符</li><li></li><li>可变参数模板与转发</li><li><strong>标准库 tuple 类模板</strong></li><li>新的 bitset 运算</li><li>正则表达式库</li><li>随机数库</li><li>浮点数格式控制</li><li>noexcept 异常指示符</li><li>noexcept 运算符</li><li>内联命名空间</li><li>继承的构造函数与多重继承</li><li></li><li>有作用域的 enum</li><li>说明类型用于保存 enum 对象</li><li>enum 的前置声明</li><li>标准库mem_fn 类模板</li><li>类类型的 union 成员</li></ul><hr><h2 id="大致分类"><a href="#大致分类" class="headerlink" title="大致分类"></a>大致分类</h2><p>改进：</p><ul><li>nullptr 常量</li><li>constexpr 变量</li><li>定义 vector 对象的 vector （向量的向量）</li></ul><p>语法糖：</p><ul><li>auto 类型推导</li><li>列表初始化</li><li>范围 for 语句</li><li>lambda 表达式</li></ul><p>智能指针：</p><ul><li>shared_ptr</li><li>unique_ptr</li><li>weak_ptr</li></ul><p>扩充容器：</p><ul><li>array</li><li>forward_list</li><li>unordered_map</li><li>unordered_multimap</li><li>unordered_set</li><li>unordered_multiset</li><li>tuple</li></ul><p>扩充库：</p><ul><li>bitset</li><li>正则表达式</li><li>随机数</li></ul><p>移动语义：</p><ul><li>&amp;&amp;右值引用</li><li>std::move()</li><li>移动构造函数和移动赋值运算符</li></ul><p>面向对象编程范式相关：</p><ul><li>explicit</li><li>&#x3D;default</li><li>&#x3D;delete</li><li>override</li><li>final</li></ul><p>面向泛型编程范式相关：</p><ul><li>模板函数的默认模板参数</li><li>可变参数模板</li></ul><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>C++的基于对象编程范式、常用STL容器和C++11标准。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《C++ Primer中文版（第5版）》作者：Stanley B.Lippman</li><li><a href="https://zhuanlan.zhihu.com/p/542115773">C++ STL 十六大容器 —— 底层原理与特性分析 - 知乎 (zhihu.com)</a></li><li><a href="https://blog.csdn.net/lanzhihui_10086/article/details/41383017">C++标准库—pair用法及实现_lanzhihui_的博客-CSDN博客_pair底层实现</a></li><li><a href="https://zhuanlan.zhihu.com/p/356954012">走近std::tuple，揭秘C++元组的底层实现原理 - 知乎 (zhihu.com)</a></li><li><a href="https://www.zhihu.com/question/65209863/answer/230185590">当面试官问我C++ 11新特性的时候，应该怎样回答？ - 知乎 (zhihu.com)</a></li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git的精简使用</title>
      <link href="/2022/12/06/Git%E7%9A%84%E7%B2%BE%E7%AE%80%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/12/06/Git%E7%9A%84%E7%B2%BE%E7%AE%80%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Git的精简使用。</p><hr><h1 id="配置流程"><a href="#配置流程" class="headerlink" title="配置流程"></a>配置流程</h1><ol><li>下载（相应操作系统的安装包）</li><li>安装</li><li>配置（环境变量、用户名和邮箱等）</li><li>转到本地工作流程；关联远程工作流程</li></ol><hr><h1 id="本地工作流程"><a href="#本地工作流程" class="headerlink" title="本地工作流程"></a>本地工作流程</h1><h2 id="创建流程"><a href="#创建流程" class="headerlink" title="创建流程"></a>创建流程</h2><ol><li>创建目录</li><li>（在目录中）创建本地仓库</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><ol start="3"><li>转到基本工作流程；分支使用流程</li></ol><hr><h2 id="基本工作流程"><a href="#基本工作流程" class="headerlink" title="基本工作流程"></a>基本工作流程</h2><ol><li>创建、删除或修改文件</li><li>从工作区添加文件到暂存区</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add *</span><br></pre></td></tr></table></figure><ol start="2"><li>从暂存区恢复文件到工作区</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git restore --staged *</span><br></pre></td></tr></table></figure><ol start="3"><li>从暂存区提交文件到本地仓库</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &lt;说明信息&gt; </span><br></pre></td></tr></table></figure><ol start="3"><li>从本地仓库还原文件到暂存区</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --soft HEAD^</span><br></pre></td></tr></table></figure><ol start="4"><li>可转到分支使用流程</li></ol><hr><h2 id="分支使用流程"><a href="#分支使用流程" class="headerlink" title="分支使用流程"></a>分支使用流程</h2><ol><li>创建分支</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch &lt;分支名&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>切换分支</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git switch &lt;分支名&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>转到基本工作流程</li><li>转到分支合并流程</li></ol><hr><h2 id="分支合并流程"><a href="#分支合并流程" class="headerlink" title="分支合并流程"></a>分支合并流程</h2><ol><li>被合并分支提交；合并分支提交</li><li>切换到合并分支</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git switch &lt;合并分支名&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>合并分支合并被合并分支</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;被合并分支名&gt;</span><br></pre></td></tr></table></figure><ol start="4"><li>打开文件，查看冲突内容</li><li>修改文件，解决冲突内容</li><li>保存冲突解决的内容</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add *</span><br></pre></td></tr></table></figure><ol start="7"><li>提交冲突解决的内容</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &lt;说明信息&gt; </span><br></pre></td></tr></table></figure><ol start="8"><li>删除被合并分支</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d &lt;被合并分支名&gt;</span><br></pre></td></tr></table></figure><hr><h1 id="关联远程工作流程"><a href="#关联远程工作流程" class="headerlink" title="关联远程工作流程"></a>关联远程工作流程</h1><h2 id="克隆流程"><a href="#克隆流程" class="headerlink" title="克隆流程"></a>克隆流程</h2><ol><li>（在代码托管平台上）创建远程仓库</li><li>（在本地上）创建目录</li><li>（在目录中）从远程仓库克隆文件到工作区</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -o &lt;本地对远程仓库的别名：一般为origin&gt; &lt;远程仓库的地址&gt;</span><br></pre></td></tr></table></figure><ol start="4"><li>转到基本工作流程；分支关联流程；分支使用流程</li></ol><hr><h2 id="基本工作流程-1"><a href="#基本工作流程-1" class="headerlink" title="基本工作流程"></a>基本工作流程</h2><ol><li>从远程仓库的远程分支拉取文件到本地仓库的<strong>跟踪分支</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch &lt;远程仓库名&gt; &lt;远程分支名&gt;</span><br></pre></td></tr></table></figure><ol><li>工作区的<strong>当前本地分支</strong>合并本地仓库的跟踪分支</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;远程仓库名&gt;/&lt;远程分支名&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>创建、删除或修改文件</li><li>从工作区添加文件到暂存区</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add *</span><br></pre></td></tr></table></figure><ol start="3"><li>从暂存区恢复文件到工作区</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git restore --staged *</span><br></pre></td></tr></table></figure><ol start="4"><li>从暂存区提交文件到本地仓库</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &lt;说明信息&gt; </span><br></pre></td></tr></table></figure><ol start="4"><li>从本地仓库还原文件到暂存区</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --soft HEAD^</span><br></pre></td></tr></table></figure><ol start="5"><li>从本地仓库的<strong>当前本地分支</strong>推送文件到远程仓库的远程分支</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;远程仓库名&gt; &lt;远程分支名&gt;</span><br></pre></td></tr></table></figure><ol start="6"><li>可转到分支关联流程；分支使用流程</li></ol><hr><h2 id="分支关联流程"><a href="#分支关联流程" class="headerlink" title="分支关联流程"></a>分支关联流程</h2><ol><li>（在代码托管平台上）创建远程分支</li><li>（在本地上）创建本地分支</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch &lt;本地分支名&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>切换本地分支</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git switch &lt;本地分支名&gt;</span><br></pre></td></tr></table></figure><ol start="4"><li>从远程仓库的远程分支拉取文件到本地仓库的<strong>跟踪分支</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch &lt;远程主机名&gt; &lt;远程分支名&gt;</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>当前本地分支</strong> 关联<strong>跟踪分支和远程分支</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -u &lt;远程主机名&gt;/&lt;远程分支名&gt;</span><br></pre></td></tr></table></figure><ol start="6"><li>转到基本工作流程</li><li>转到分支合并流程</li></ol><hr><h2 id="分支使用流程-1"><a href="#分支使用流程-1" class="headerlink" title="分支使用流程"></a>分支使用流程</h2><ol><li>创建分支</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch &lt;分支名&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>切换分支</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git switch &lt;分支名&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>转到基本工作流程</li><li>转到分支合并流程</li></ol><hr><h2 id="分支合并流程-1"><a href="#分支合并流程-1" class="headerlink" title="分支合并流程"></a>分支合并流程</h2><ol><li>被合并分支提交；合并分支提交</li><li>切换到合并分支</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git switch &lt;合并分支名&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>合并分支合并被合并分支</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;被合并分支名&gt;</span><br></pre></td></tr></table></figure><ol start="4"><li>打开文件，查看冲突内容</li><li>修改文件，解决冲突内容</li><li>保存冲突解决的内容</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add *</span><br></pre></td></tr></table></figure><ol start="7"><li>提交冲突解决的内容</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &lt;说明信息&gt; </span><br></pre></td></tr></table></figure><ol start="8"><li>删除被合并分支</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d &lt;被合并分支名&gt;</span><br></pre></td></tr></table></figure><hr><h1 id="实用命令"><a href="#实用命令" class="headerlink" title="实用命令"></a>实用命令</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git status<span class="comment">#查看状态</span></span><br><span class="line">git status -s<span class="comment">#查看精简的状态</span></span><br><span class="line"></span><br><span class="line">git branch<span class="comment">#查看分支</span></span><br><span class="line">git branch -vv<span class="comment">#查看有本地分支、跟踪分支和远程分支关联信息的分支</span></span><br><span class="line">git branch -a<span class="comment">#查看所有的分支</span></span><br><span class="line"></span><br><span class="line">git <span class="built_in">log</span><span class="comment">#查看日志</span></span><br><span class="line">git <span class="built_in">log</span> --oneline<span class="comment">#查看一个提交为一行格式的日志</span></span><br></pre></td></tr></table></figure><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Git的精简使用。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《Pro Git》作者：Scott Chacom，Ben Straub</li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 开发和管理工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发和管理工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Diffie-Hellman的C++语言描述简单实现</title>
      <link href="/2022/11/16/Diffie-Hellman%E7%9A%84C++%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/"/>
      <url>/2022/11/16/Diffie-Hellman%E7%9A%84C++%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>网络安全中Diffie-Hellman的C++语言描述简单实现。</p><hr><h1 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h1><ul><li><a href="https://github.com/yezhening/Programming-examples">yezhening&#x2F;Programming-examples: 编程实例 (github.com)</a></li><li><a href="https://gitee.com/yezhening/Programming-examples">Programming-examples: 编程实例 (gitee.com)</a></li></ul><hr><h1 id="代码特点"><a href="#代码特点" class="headerlink" title="代码特点"></a>代码特点</h1><p>纯C++语言：</p><ul><li>相对规范和整洁</li><li>一定程度地面向对象</li><li>使用一部分高级特性</li><li>考虑优化性能</li></ul><p>详细注释：</p><ul><li>提示规范和整洁</li><li>提示面向对象</li><li>提示高级特性</li><li>提示优化性能</li><li>解析Diffie-Hellman步骤（<strong>网络上大部分实现代码的含义不明确，本代码相对明确</strong>）</li><li>注意易错点</li></ul><hr><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="dh-h"><a href="#dh-h" class="headerlink" title="dh.h"></a>dh.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DH_DH_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DH_DH_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> <span class="comment">//cout、endl</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Diffie-Hellman类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DH</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DH</span>();                         <span class="comment">// 构造</span></span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">GetPrivateKey</span><span class="params">()</span></span>; <span class="comment">// 获取私钥</span></span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">GetPublicKey</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> &amp;x)</span></span>; <span class="comment">// 获取公钥</span></span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">GetKey</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> &amp;y, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> &amp;x)</span></span>; <span class="comment">// 获取密钥</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 提示：算法未明确说是正数，但大多使用正数</span></span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">GetPrimeNum</span><span class="params">()</span></span>;                                                                    <span class="comment">// 获取素数</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">PrimalityTest</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> &amp;n, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> &amp;a)</span></span>;                              <span class="comment">// Miller-Rabin素性测试</span></span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">QuickPowMod</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> &amp;a, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> &amp;q, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> &amp;n)</span></span>; <span class="comment">// 蒙哥马利快速幂模运算</span></span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">QuickMulMod</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> &amp;a, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> &amp;b, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> &amp;c)</span></span>; <span class="comment">// 快速乘</span></span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">GetPrimitiveRoot</span><span class="params">()</span></span>;                                                               <span class="comment">// 获取本原根</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> p_arg_; <span class="comment">// 参数p</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> a_arg_; <span class="comment">// 参数a</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// DH_DH_H_</span></span></span><br></pre></td></tr></table></figure><hr><h2 id="dh-cpp"><a href="#dh-cpp" class="headerlink" title="dh.cpp"></a>dh.cpp</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span>   <span class="comment">//time()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span> <span class="comment">//srand()、rand()</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;dh.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造</span></span><br><span class="line">DH::<span class="built_in">DH</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 全局公开量：</span></span><br><span class="line">    <span class="comment">//  1. 选择p。p为素数</span></span><br><span class="line">    <span class="comment">//  注意：将随机种子提取放在循环外、相同函数外，以避免时间相近获取的随机数相同</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> seed = <span class="built_in">time</span>(<span class="literal">nullptr</span>); <span class="comment">// 随机种子</span></span><br><span class="line">    <span class="built_in">srand</span>(seed);                       <span class="comment">// 设置随机种子</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;p_arg_ = <span class="keyword">this</span>-&gt;<span class="built_in">GetPrimeNum</span>(); <span class="comment">// 获取素数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.计算a。a &lt; p且a是p的本原根</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;a_arg_ = <span class="keyword">this</span>-&gt;<span class="built_in">GetPrimitiveRoot</span>(); <span class="comment">// 获取本原根</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;全局公开量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;参数p：\t&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;p_arg_ &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;参数a：\t&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;a_arg_ &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取私钥</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">DH::GetPrivateKey</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 私钥要求：随机整数；简化为非负数；小于参数p</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> random = <span class="number">0</span>; <span class="comment">// 随机数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) <span class="comment">// 循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        random = <span class="built_in">rand</span>(); <span class="comment">// 随机数 一般是4~5位数，不超过unsigned int的表示范围</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (random &lt; <span class="keyword">this</span>-&gt;p_arg_)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> random;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取公钥</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">DH::GetPublicKey</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> &amp;x)</span> <span class="comment">// 参数：私钥</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 公钥Y = 参数a的私钥X次方 mod p（X是以a为底的模p离散对数）</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> y = <span class="keyword">this</span>-&gt;<span class="built_in">QuickPowMod</span>(<span class="keyword">this</span>-&gt;a_arg_, x, <span class="keyword">this</span>-&gt;p_arg_);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取密钥</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">DH::GetKey</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> &amp;y, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> &amp;x)</span> <span class="comment">// 参数：对方的公钥，本方的私钥</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 密钥K = 对方的公钥Y的本方的私钥X次方 mod p</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> k = <span class="keyword">this</span>-&gt;<span class="built_in">QuickPowMod</span>(y, x, <span class="keyword">this</span>-&gt;p_arg_);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取素数</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">DH::GetPrimeNum</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> random = <span class="number">0</span>;     <span class="comment">// 随机数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> random_odd = <span class="number">0</span>; <span class="comment">// 随机奇数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> n = <span class="number">0</span>;              <span class="comment">// 素性测试的参数n 循环中需要重新初始化</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> a = <span class="number">0</span>;              <span class="comment">// 素性测试的参数a</span></span><br><span class="line">    <span class="type">bool</span> primality_test_res = <span class="literal">false</span>; <span class="comment">// 一次素性测试结果    false不是素数true可能为素数</span></span><br><span class="line">    <span class="type">bool</span> prime_flag = <span class="literal">false</span>;         <span class="comment">// 素数标志，最终素性测试结果。false0不是素数，true1可能为素数</span></span><br><span class="line">    <span class="comment">// 提示：初始化在循环外的变量在循环中注意是否需要更新、重新初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) <span class="comment">// 循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 1.1随机取一个期望大小的奇数</span></span><br><span class="line">        <span class="comment">// 1.1.1取随机数</span></span><br><span class="line">        random = <span class="built_in">rand</span>(); <span class="comment">// 随机数 一般是4~5位数，不超过unsigned int的表示范围</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.1.2取奇数</span></span><br><span class="line">        <span class="keyword">if</span> (random % <span class="number">2</span> == <span class="number">0</span>) <span class="comment">// 如果是偶数，+1成为奇数</span></span><br><span class="line">        &#123;</span><br><span class="line">            random_odd = random + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 奇数不额外操作</span></span><br><span class="line">        &#123;</span><br><span class="line">            random_odd = random;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.2使用素性测试判断</span></span><br><span class="line">        n = random_odd;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">128</span>; ++i) <span class="comment">// 选取128个参数a，测试128次</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//  1.2.1随机选择相关参数a。满足a为整数，1 &lt; a &lt; n - 1</span></span><br><span class="line">            a = <span class="built_in">rand</span>() % (n - <span class="number">1</span>); <span class="comment">// 0 ~ n - 2</span></span><br><span class="line">            <span class="comment">// 注意：</span></span><br><span class="line">            <span class="comment">// 因为运行时间段相近，第一次a取的随机数可能和n相等</span></span><br><span class="line">            <span class="comment">// 则计算后结果必为1，而后1 + 1 = 2</span></span><br><span class="line">            <span class="comment">// 将设置随机种子代码提取出函数后，排除该错误</span></span><br><span class="line">            <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="comment">// 如果是0，令a = 2 &gt; 1</span></span><br><span class="line">            &#123;</span><br><span class="line">                a += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="number">1</span>) <span class="comment">// 如果是1，令a = 2 &gt; 1</span></span><br><span class="line">            &#123;</span><br><span class="line">                ++a;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            primality_test_res = <span class="built_in">PrimalityTest</span>(random_odd, a); <span class="comment">// 素性测试</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (primality_test_res == <span class="literal">true</span>) <span class="comment">// 一次测试结果可能为素数</span></span><br><span class="line">            &#123;</span><br><span class="line">                prime_flag = <span class="literal">true</span>; <span class="comment">// 标记可能为素数</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (primality_test_res == <span class="literal">false</span>) <span class="comment">// 只要有一次素性测试不是素数，则必不为素数</span></span><br><span class="line">            &#123;</span><br><span class="line">                prime_flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 不再用a测试，需要重新选取随机奇数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (prime_flag == <span class="literal">true</span>) <span class="comment">// 随机奇数可能为素数，</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 退出循环</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则随机奇数不是素数，进入循环，再重新进行1.1取随机奇数，1.2素性测试步骤</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> random_odd; <span class="comment">// 获得素数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Miller-Rabin素性测试</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DH::PrimalityTest</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> &amp;n, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> &amp;a)</span> <span class="comment">// 参数：随机奇数，参数a</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1.2.2找到相关参数k，q。满足n - 1 = 2 ^ k × q。k、q为整数，k &gt; 0，q为奇数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> q = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提示：</span></span><br><span class="line">    <span class="comment">// 很多算法都只说明要找到k、q，却不说怎么找</span></span><br><span class="line">    <span class="comment">// 找k，q的代码也含糊其辞的</span></span><br><span class="line">    <span class="keyword">while</span> ((q &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ++k;</span><br><span class="line">        q &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 理解：</span></span><br><span class="line">    <span class="comment">// q &amp; 1：即q的二进制表示与二进制位1与运算，取q二进制表示的最低位0或1</span></span><br><span class="line">    <span class="comment">// 如101 &amp; 1 = 101 &amp; 001 = 001 = 1</span></span><br><span class="line">    <span class="comment">// 如0010 &amp; 1 = 0010 &amp; 0001 = 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在最低位中，基数2 ^ 0 = 1，所以如果值是0，则1 × 0 = 0为偶数；值是1，则1 × 1 = 1为奇数</span></span><br><span class="line">    <span class="comment">// 所以，如果运算结果为0，则是偶数，可以提取一个因子2</span></span><br><span class="line">    <span class="comment">// while：连续提取因子2</span></span><br><span class="line">    <span class="comment">// 每提取一个因子2，则++k，k是因子2的计数</span></span><br><span class="line">    <span class="comment">// q &gt;&gt;= 1：将q的二进制表示右移缩小，继续对最低位判断提取因子2</span></span><br><span class="line">    <span class="comment">// 直到不能连续提取因子2，则q即为所求</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如十进制13 - 1 = 12 = 二进制1100，在第1、2位提取因子2为2 ^ 2 = 4</span></span><br><span class="line">    <span class="comment">// 所以12 = 2 ^ 2 × 3。k = 2，q = 3</span></span><br><span class="line">    <span class="comment">// 如十进制7 - 1 = 6 = 二进制110，在第1位提取1个因子2为2 ^ 1 = 2</span></span><br><span class="line">    <span class="comment">// 所以6 = 2 ^ 1 × 3。k = 1，q = 3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提示：注意k、q的取值条件</span></span><br><span class="line">    <span class="comment">// 对正整数素数，除了2为偶数，其他数必为奇数</span></span><br><span class="line">    <span class="comment">// 奇数-1必为偶数，必至少能提取1个公因子2，则k至少为1 &gt; 0满足</span></span><br><span class="line">    <span class="comment">// 由算法性质，知提取所有的公因子2，则结果q必为奇数满足</span></span><br><span class="line">    <span class="comment">// 一般q数很大，所以在接下来的步骤需要用蒙哥马利快速模幂算法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.2.3计算a ^ q % n</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> aq_mod_n = <span class="keyword">this</span>-&gt;<span class="built_in">QuickPowMod</span>(a, q, n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cout &lt;&lt; n &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; k &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; q &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; a &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; aq_mod_n &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.2.4运用二次探测定理的逆否命题判断</span></span><br><span class="line">    <span class="comment">// 正命题大概：探测，所有解只有1或n-1，则可能为素数</span></span><br><span class="line">    <span class="comment">// 逆否命题大概：探测，存在解不为1且不为n-1，则必定不是素数</span></span><br><span class="line">    <span class="comment">// 可以用正命题也可以用逆否命题判断。以下用正命题和逆否命题判断</span></span><br><span class="line">    <span class="comment">// 第一个判断条件：未探测时，a ^ q % n == 1，则可能为素数</span></span><br><span class="line">    <span class="keyword">if</span> (aq_mod_n == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二个判断条件：二次探测时，只要存在不为1且不为n-1，则必定不是素数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; k; ++j) <span class="comment">// 0 ~ k-1</span></span><br><span class="line">    &#123;</span><br><span class="line">        aq_mod_n = <span class="keyword">this</span>-&gt;<span class="built_in">QuickPowMod</span>(aq_mod_n, <span class="number">2</span>, n);</span><br><span class="line">        <span class="comment">// 对序列二次探测 计算a ^ (q × 2 ^ j) % n = aq_mod_n ^ (2 ^ j) % n。每次循环都幂2相当于(2 ^ j)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (aq_mod_n != <span class="number">1</span> &amp;&amp; aq_mod_n != n - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 第二个判断条件：二次探测时，若没有因判断为合数而返回，则可能为素数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 蒙哥马利快速幂模运算</span></span><br><span class="line"><span class="comment">// 参数：a ^ q % n</span></span><br><span class="line"><span class="comment">// 返回值：a ^ q % n</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">DH::QuickPowMod</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> &amp;a, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> &amp;q, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> &amp;n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 原理：</span></span><br><span class="line">    <span class="comment">//  幂运算性质：a ^ q = a ^ q1 × a ^ q2。q = q1 + q2</span></span><br><span class="line">    <span class="comment">//  模运算性质：(a × b) % n = [(a % n) × (b % n)] % n</span></span><br><span class="line">    <span class="comment">// 所以：a ^ q % n = (a ^ q1 × a ^ q2) % n = [(a ^ q1 % n) × (a ^ q2 % n)] % n</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> a_temp = a; <span class="comment">// 运算中会改变a的值，暂存</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> q_temp = q; <span class="comment">// 运算中会改变q的值，暂存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提示：很多算法代码含糊其辞的</span></span><br><span class="line">    <span class="keyword">while</span> (q_temp &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((q_temp &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res = <span class="keyword">this</span>-&gt;<span class="built_in">QuickMulMod</span>(res, a_temp, n);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        a_temp = <span class="keyword">this</span>-&gt;<span class="built_in">QuickMulMod</span>(a_temp, a_temp, n);</span><br><span class="line"></span><br><span class="line">        q_temp &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 理解：</span></span><br><span class="line">    <span class="comment">// 算法是针对十进制数的二进制表示进行运算的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// while (q_temp &gt; 0)：对比素性测试的内容：while ((q &amp; 1) == 0)</span></span><br><span class="line">    <span class="comment">// 这里是判断值，需要判断所有二进制位，所以只要q在后面的右移位中值不为0，就循环。而素性测试中是判断位</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// if ((q_temp &amp; 1) == 1)：最低位为1时，该位有效，需要计算并更新结果</span></span><br><span class="line">    <span class="comment">// 快速乘算法：res = (res × a_temp) % n</span></span><br><span class="line">    <span class="comment">// 该步骤相当于每次计算单个的(a ^ q2 % n)，然后和之前的(a ^ q1 % n)相乘作为新的结果</span></span><br><span class="line">    <span class="comment">// 其中第一个res是更新结果，第二个res是之前的结果，a_temp是当前的基数</span></span><br><span class="line">    <span class="comment">// 基数：在循环中对每一位都会更新基数（见后面步骤），在二进制表示为1时，该基数有效</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// a_temp = QuickMulMod(a_temp, a_temp, n);相当于a_temp = a_temp × a_temp % n</span></span><br><span class="line">    <span class="comment">// 如初始a_temp = 2，则不断更新为2 ^ 0 = 1，2 ^ 1 = 2</span></span><br><span class="line">    <span class="comment">// 再进行%保证基数不超过范围</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速乘</span></span><br><span class="line"><span class="comment">// 参数：a * b % c</span></span><br><span class="line"><span class="comment">// 返回值：a * b % c</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">DH::QuickMulMod</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> &amp;a, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> &amp;b, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> &amp;c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 原理：</span></span><br><span class="line">    <span class="comment">// 同快速幂模运算，将乘法转换为加法运算</span></span><br><span class="line">    <span class="comment">// a × b % c = [(a + a) % c] + [(a + a) % c] + ... [(a + a) % c]共b个a相加求模</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> a_temp = a;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> b_temp = b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (b_temp &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b_temp &amp; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res = (res + a_temp) % c;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        a_temp = (a_temp + a_temp) % c;</span><br><span class="line"></span><br><span class="line">        b_temp &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取本原根</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">DH::GetPrimitiveRoot</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 大致思路：对素数p，p的欧拉函数p - 1，底数a属于（1，p），指数m属于（1，p）</span></span><br><span class="line">    <span class="comment">// 正向判定本原根满足：</span></span><br><span class="line">    <span class="comment">// 1.当m = （1，p - 1）的数时，所有a^m % p 不等于 1</span></span><br><span class="line">    <span class="comment">// 2.当m = p - 1时，a^m % p = 1</span></span><br><span class="line">    <span class="comment">// 则a为本原根</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逆向否定本原根满足：由正向的1.逆否命题得</span></span><br><span class="line">    <span class="comment">// 1.当m = （1，p - 1）的数时，存在a^m % p = 1，则a不为本原根</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快速正向判定本原根满足：</span></span><br><span class="line">    <span class="comment">// 1.当m = （p - 1的素因子）的数时，所有a^m % p 不等于 1，则a为本原根</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 慢速正向判定本原根满足：由快速正向扩大搜索范围得</span></span><br><span class="line">    <span class="comment">// 1.当m = （1，p - 1）的数时，所有a^m % p 不等于 1，则a为本原根</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提示：</span></span><br><span class="line">    <span class="comment">// 可以证明暴力枚举求最小本原根的复杂度是可以接受的，采用正向逆向结合判定本原根的暴力枚举法</span></span><br><span class="line">    <span class="comment">// 参数p的欧拉函数为p -1</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> calcul_res = <span class="number">0</span>; <span class="comment">// 计算结果</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.1遍历（1，p）为底数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">2</span>; i &lt; <span class="keyword">this</span>-&gt;p_arg_; ++i) <span class="comment">// 范围：2 ~ p - 1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 2.2遍历（1，p）为指数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> j = <span class="number">2</span>; j &lt; <span class="keyword">this</span>-&gt;p_arg_; ++j) <span class="comment">// 范围：2 ~ p - 1</span></span><br><span class="line">        &#123;</span><br><span class="line">            calcul_res = <span class="keyword">this</span>-&gt;<span class="built_in">QuickPowMod</span>(i, j, <span class="keyword">this</span>-&gt;p_arg_); <span class="comment">// 计算结果 = i ^ j % p</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.2.1当m = （1，p - 1）的数时，所有a^m % p 不等于 1</span></span><br><span class="line">            <span class="comment">// 逆否命题为当m = （1，p - 1）的数时，存在a^m % p = 1，则a不为本原根</span></span><br><span class="line">            <span class="keyword">if</span> ((j != <span class="keyword">this</span>-&gt;p_arg_ - <span class="number">1</span>) &amp;&amp; (calcul_res == <span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 退出j循环，取下一个i</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.2.2在2.2.1没退出j循环，且当m = p - 1时，a ^ m % p = 1</span></span><br><span class="line">            <span class="keyword">if</span> ((j == <span class="keyword">this</span>-&gt;p_arg_ - <span class="number">1</span>) &amp;&amp; (calcul_res == <span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> i; <span class="comment">// i为（最小）本原根，返回本原根i</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提示：素数必存在本原根，存在i并返回。但代码逻辑需考虑不满足if()条件返回i的另外返回条件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 必不会执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a>main.cpp</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;dh.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DH *dh = <span class="keyword">new</span> <span class="built_in">DH</span>(); <span class="comment">// DH对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户A</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> xa = dh-&gt;<span class="built_in">GetPrivateKey</span>(); <span class="comment">// 1.获取私钥</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;用户A的密钥生成：\t&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;私钥xa：\t&quot;</span> &lt;&lt; xa &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ya = dh-&gt;<span class="built_in">GetPublicKey</span>(xa); <span class="comment">// 2.获取公钥</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;公钥ya：\t&quot;</span> &lt;&lt; ya &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户B</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> xb = dh-&gt;<span class="built_in">GetPrivateKey</span>(); <span class="comment">// 1.获取私钥</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;用户B的密钥生成：\t&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;私钥xb：\t&quot;</span> &lt;&lt; xb &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> yb = dh-&gt;<span class="built_in">GetPublicKey</span>(xb); <span class="comment">// 2.获取公钥</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;公钥yb：\t&quot;</span> &lt;&lt; yb &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户A</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ka = dh-&gt;<span class="built_in">GetKey</span>(yb, xa); <span class="comment">// 3.密钥生成</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;用户A计算产生密钥：\t&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;密钥ka：\t&quot;</span> &lt;&lt; ka &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户B</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> kb = dh-&gt;<span class="built_in">GetKey</span>(ya, xb); <span class="comment">// 3.密钥生成</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;用户B计算产生密钥：\t&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;密钥kb：\t&quot;</span> &lt;&lt; kb &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> dh;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p><img src="/../img/dh/5c8347e61c6242dca83763e0c30e95c8.png" alt="在这里插入图片描述"></p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>网络安全中Diffie-Hellman的C++语言描述简单实现。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《密码编码学与网络安全——原理与实践(第五版)》作者：William Stallings</li><li><a href="https://www.cnblogs.com/pam-sh/p/16491643.html">求本原根 - PamShao - 博客园 (cnblogs.com)</a></li><li><a href="https://www.cnblogs.com/Dance-Of-Faith/p/9905786.html">【科技】原根的快速判断方法以及对1求离散对数的另一种想法 - Dance_Of_Faith - 博客园 (cnblogs.com)</a></li><li><a href="https://oi-wiki.org/math/number-theory/primitive-root/">原根 - OI Wiki (oi-wiki.org</a></li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RSA的C++语言描述简单实现</title>
      <link href="/2022/11/09/RSA%E7%9A%84C++%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/"/>
      <url>/2022/11/09/RSA%E7%9A%84C++%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>网络安全中RSA的C++语言描述简单实现。</p><hr><h1 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h1><ul><li><a href="https://github.com/yezhening/Programming-examples">yezhening&#x2F;Programming-examples: 编程实例 (github.com)</a></li><li><a href="https://gitee.com/yezhening/Programming-examples">Programming-examples: 编程实例 (gitee.com)</a></li></ul><hr><h1 id="代码特点"><a href="#代码特点" class="headerlink" title="代码特点"></a>代码特点</h1><p>纯C++语言：</p><ul><li>相对规范和整洁</li><li>一定程度地面向对象</li><li>使用一部分高级特性</li><li>考虑优化性能</li></ul><p>详细注释：</p><ul><li>提示规范和整洁</li><li>提示面向对象</li><li>提示高级特性</li><li>提示优化性能</li><li>解析RSA步骤（<strong>网络上大部分实现代码的含义不明确，本代码相对明确</strong>）</li><li>注意易错点</li></ul><hr><h1 id="大（素）数讨论"><a href="#大（素）数讨论" class="headerlink" title="大（素）数讨论"></a>大（素）数讨论</h1><ul><li>实际的RSA需要操作大（素）数</li><li>因为大（素）数结合RSA的代码实现较复杂，所以本代码未实现大（素）数部分，（简单）实现RSA部分</li><li>网络上有很多大数实现的思路和代码资料，有兴趣可以参阅</li></ul><h2 id="部分资料"><a href="#部分资料" class="headerlink" title="部分资料"></a>部分资料</h2><ul><li><a href="https://ask.csdn.net/questions/7514078">生成1024比特随机数-编程语言-CSDN问答</a></li><li><a href="https://www.jianshu.com/p/1e139541c4eb">RSA 大数的处理 - 简书 (jianshu.com)</a></li><li><a href="https://www.cnblogs.com/billsedison/archive/2010/12/25/1916626.html">大整数类的实现 - 万户侯 - 博客园 (cnblogs.com)</a></li><li><a href="https://blog.kedixa.top/2017/cpp-bigint-overview/">C++大整数运算（一）：概述 – kedixa的博客</a></li><li><a href="https://blog.csdn.net/cmj198799/article/details/6883274">RSA与大数运算（C语言）_cmj198799的博客-CSDN博客</a></li><li><a href="https://www.cnblogs.com/shoule/p/15950488.html">RSA与大数运算 - 勇敢蘑菇 - 博客园 (cnblogs.com)</a></li><li><a href="https://www.geeksforgeeks.org/bigint-big-integers-in-c-with-example/">BigInt (BIG INTEGERS) in C++ with Example - GeeksforGeeks</a></li></ul><h2 id="作者理解"><a href="#作者理解" class="headerlink" title="作者理解"></a>作者理解</h2><blockquote><p>注意：理解中部分基于学校计算机网络安全课程的实验要求</p></blockquote><p>可能性：</p><ul><li>能够实现自定义大数数据结构&#x2F;类及其上的相关算法</li><li>但是，将其嵌入RSA算法的实现，无论是对于实验量、实验要求时长，都相对复杂些</li></ul><p>复杂性的体现：</p><ul><li>如果使用相对面向数学计算、大数据应用的语言，如Python，直接调现有的库，可能认为无所不能。需要学习使用库的成本，相对的，就没有对“自定义大数结构和运算”这一“造轮子、拧螺丝”的底层理解</li><li>如果使用面向底层原理的语言，如C和C++，可能也有库可以直接调用，但可能没有Python那么方便使用</li><li>如果想自定义大数结构和运算，就需要对底层如语言支持的数据类型有一定的规划和了解。设计的这个大数结构和运算必须能够在RSA算法中被应用，而RSA算法中稍复杂的数学算法更会限制这个大数类的设计。RSA算法中，对简单数的操作已经相对复杂，再进一步对大数操作，复杂度就提升了</li><li>搜索网上单纯对大数的自定义代码实现（C和C++语言），几百行快至千行还是有的，再针对RSA算法进行重构，代码量会更多</li></ul><p>可能的实现：</p><p>1.使用十进制数数组&#x2F;向量表示大数。大数的各个位是数组中的一个元素</p><ul><li>实验要求：1024位的参数p，1024位的参数q，可能为2048位的参数n</li><li>实验要求需要使用二进制进行运算，另外，相应数论中使用二进制相对十进制有更简便快捷的算法</li><li>1024位二进制约为309位十进制数，2048位不太清楚。也就是说，十进制数组初始化大小是不太确定的。就C++而言，向量最好初始化大小，否则在未定义大小的基础上不断添加元素，可能会造成预先分配的向量空间不够，出现越界、向量空间扩容重分配等未知不好定位问题</li><li>几百位十进制的大数运算，在加法进位、减法借位、乘法等运算中，需要对每位操作，嵌套循环、循环次数、记录借位标志等情况很复杂</li></ul><p>2.使用二进制数数组&#x2F;向量表示大数。大数的各个位是数组中的一个元素</p><ul><li>能够满足实验要求的1024位</li><li>但对于可能的2048位参数n，可能也不明确向量的初始化大小</li><li>千位二进制相对百位十进制，定义每位操作，嵌套循环、循环次数、记录借位标志等情况会更加复杂</li></ul><p>3.使用2^32进制数组&#x2F;向量表示大数。大数的各个位是数组中的一个元素</p><ul><li>是最可能实现的方案</li><li>要求1024位二进制</li><li>语言的内置类型范围最多为64位二进制，考虑到乘法运算会使位数扩大，如超过64位而表示不了，则折中选取32位二进制，可用int数据类型表示</li><li>再考虑到参数&gt;0，可用unsigned int数据类型表示</li><li>即：相对于1.使用十进制，2.使用二进制，该方案使用2^32进制。数组中一个0~9范围内的数字，它的基数为2^32</li><li>1024 ÷ 32 &#x3D; 32，则参数pq的数组&#x2F;向量长度缩减为32，大大简化各种运算时的操作</li><li>但是，基数为2^32，则在语言的表现层面，最小操作粒度是2^32。比如用unsigned int数据类型的数字0表示0 × 2^32的大数，用unsigned int数据类型的数字1表示1 × 2^32的大数。而数字0-1即大数0-2^32的间的各种数字，在宏观层面应该是操作不到、不好操作的</li><li>再考虑到RSA算法中，可以使用大数运算求得p、q、n参数。但是，对于后续细粒度的n - 1、n的欧拉函数 &#x3D; (p - 1)(q - 1) &#x3D; p × q + p + q - 1等对较小数1，应该是操作不到、不好操作的</li><li>更不用考虑后续RSA其他数学算法了</li></ul><p>总结：</p><ul><li>可能性：大数可以实现，但不好实现。可以调库也可以自定义</li><li>复杂度：纯大数相对简单，考虑编程语言、为了适应RSA算法，大数结构和运算的设计相对复杂</li><li>可能的实现：方案都可能可以实现，综合考虑实验目的、实验量和实验时长等问题，成本可能会很高</li></ul><hr><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="rsa-h"><a href="#rsa-h" class="headerlink" title="rsa.h"></a>rsa.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> RSA_RSA_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RSA_RSA_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> <span class="comment">//cout、endl、string</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>   <span class="comment">// vector</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RSA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RSA</span>();                                                                            <span class="comment">// 构造</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Encrypt</span><span class="params">(<span class="type">const</span> string &amp;plaintext_str, vector&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt; &amp;ciphertext_int)</span></span>;  <span class="comment">// 加密</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Decrypt</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt; &amp;ciphertext_int, string &amp;plaintext_str1)</span></span>; <span class="comment">// 解密</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">KeyGen</span><span class="params">()</span></span>; <span class="comment">// 密钥生成</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">GetPrimeNum</span><span class="params">()</span></span>;                                                                    <span class="comment">// 获取素数</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">PrimalityTest</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> &amp;n, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> &amp;a)</span></span>;                              <span class="comment">// Miller-Rabin素性测试</span></span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">QuickPowMod</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> &amp;a, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> &amp;q, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> &amp;n)</span></span>; <span class="comment">// 蒙哥马利快速幂模运算</span></span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">QuickMulMod</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> &amp;a, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> &amp;b, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> &amp;c)</span></span>; <span class="comment">// 快速乘模</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">ExGcd</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> &amp;a, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> &amp;b, <span class="type">unsigned</span> <span class="type">int</span> &amp;x, <span class="type">unsigned</span> <span class="type">int</span> &amp;y)</span></span>; <span class="comment">// 扩展欧几里得算法</span></span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">GetMulInverse</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> &amp;a, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> &amp;b)</span></span>;                           <span class="comment">// 求乘法逆元</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> p_arg_; <span class="comment">// p参数</span></span><br><span class="line">    <span class="comment">// 提示：参数&gt;=0，使用unsigned int更符合语义</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> q_arg_;            <span class="comment">// q参数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> n_arg_;            <span class="comment">// n参数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> n_Euler_func_arg_; <span class="comment">// n的欧拉函数参数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> e_arg_;            <span class="comment">// e参数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> d_arg_;            <span class="comment">// d参数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// RSA_RSA_H_</span></span></span><br></pre></td></tr></table></figure><hr><h2 id="rsa-cpp"><a href="#rsa-cpp" class="headerlink" title="rsa.cpp"></a>rsa.cpp</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span>   <span class="comment">//time()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span> <span class="comment">//srand()、rand()</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rsa.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cerr;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造</span></span><br><span class="line">RSA::<span class="built_in">RSA</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">KeyGen</span>(); <span class="comment">// 密钥生成</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;密钥生成: \t&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;参数p: \t&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;p_arg_ &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;参数q: \t&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;q_arg_ &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;参数n: \t&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;n_arg_ &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;参数n的欧拉函数: \t&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;n_Euler_func_arg_ &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;参数e: \t&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;e_arg_ &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;参数d: \t&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;d_arg_ &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加密</span></span><br><span class="line"><span class="comment">// 参数：字符串类型的明文，无符号整型的密文</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RSA::Encrypt</span><span class="params">(<span class="type">const</span> string &amp;plaintext_str, vector&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt; &amp;ciphertext_int)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;加密：\t&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;字符串类型的明文：\t&quot;</span> &lt;&lt; plaintext_str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.依据ASCII码将明文的字符串数据类型转换为无符号整数类型</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> p = <span class="number">0</span>; <span class="comment">// 明文分组   1个字符1个数字为1个明文分组</span></span><br><span class="line">    <span class="comment">// 提示：要求明文分组P &lt; 参数n，依据ASCII范围0~255必 &lt; n，不再处理</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt; <span class="title">plaintext_int</span><span class="params">(plaintext_str.size(), <span class="number">0</span>)</span></span>; <span class="comment">// 无符号整数类型的明文    1个字符为1个数字</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; plaintext_str.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        p = plaintext_str[i]; <span class="comment">// 注意：利用自动类型转换</span></span><br><span class="line">        plaintext_int[i] = (p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;无符号整数类型的明文：\t&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : plaintext_int)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.加密</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> c = <span class="number">0</span>; <span class="comment">// 密文分组   1个数字明文加密得1个数字密文，1个数字为1个密文分组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; plaintext_int.<span class="built_in">size</span>(); ++i) <span class="comment">// 对每个明文分组，蒙哥马利快速模幂加密</span></span><br><span class="line">    &#123;</span><br><span class="line">        c = <span class="keyword">this</span>-&gt;<span class="built_in">QuickPowMod</span>(plaintext_int[i], <span class="keyword">this</span>-&gt;e_arg_, <span class="keyword">this</span>-&gt;n_arg_);</span><br><span class="line">        ciphertext_int[i] = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;无符号整数类型的密文：\t&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : ciphertext_int)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解密</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RSA::Decrypt</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt; &amp;ciphertext_int, string &amp;plaintext_str1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;解密：\t&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;无符号整数类型的密文：\t&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : ciphertext_int)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.解密</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> p = <span class="number">0</span>;                                           <span class="comment">// 明文分组 1个数字密文解密得1个数字明文，1个数字为1个明文分组</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt; <span class="title">plaintext_int</span><span class="params">(ciphertext_int.size(), <span class="number">0</span>)</span></span>; <span class="comment">// 无符号整数类型的明文    1个字符为1个数字</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ciphertext_int.<span class="built_in">size</span>(); ++i) <span class="comment">// 对每个密文分组，蒙哥马利快速模幂解密</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = <span class="keyword">this</span>-&gt;<span class="built_in">QuickPowMod</span>(ciphertext_int[i], <span class="keyword">this</span>-&gt;d_arg_, <span class="keyword">this</span>-&gt;n_arg_);</span><br><span class="line">        plaintext_int[i] = p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;无符号整数类型的明文：\t&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : plaintext_int)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.依据ASCII码将明文的无符号整数类型转换为字符串数据类型</span></span><br><span class="line">    <span class="type">char</span> p_str = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 字符类型的明文分组    1个数字1个字符为1个明文分组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; plaintext_int.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        p_str = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(plaintext_int[i]); <span class="comment">// 注意：利用强制类型转换</span></span><br><span class="line">        plaintext_str1[i] = (p_str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;字符串类型的明文：\t&quot;</span> &lt;&lt; plaintext_str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 密钥生成</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RSA::KeyGen</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 选择p，q。p和q为素数，p不等于q</span></span><br><span class="line">    <span class="comment">// 注意：将随机种子提取放在循环外、相同函数外，以避免时间相近获取的随机数相同</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> seed = <span class="built_in">time</span>(<span class="literal">nullptr</span>); <span class="comment">// 随机种子</span></span><br><span class="line">    <span class="built_in">srand</span>(seed);                       <span class="comment">// 设置随机种子</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;p_arg_ = <span class="keyword">this</span>-&gt;<span class="built_in">GetPrimeNum</span>(); <span class="comment">// 获取p参数</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;q_arg_ = <span class="keyword">this</span>-&gt;<span class="built_in">GetPrimeNum</span>(); <span class="comment">// 获取q参数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 计算n = p × q</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;n_arg_ = <span class="keyword">this</span>-&gt;p_arg_ * <span class="keyword">this</span>-&gt;q_arg_;</span><br><span class="line">    <span class="comment">// 提示：第一次写习惯中文用了×号而不是*...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 计算n的欧拉函数 = (p - 1) × (q - 1)</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;n_Euler_func_arg_ = (<span class="keyword">this</span>-&gt;p_arg_ - <span class="number">1</span>) * (<span class="keyword">this</span>-&gt;q_arg_ - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 选择e。 e为整数，e和n的欧拉函数互素，1 &lt; e &lt; n的欧拉函数</span></span><br><span class="line">    <span class="comment">// 选择3或17或65537，e越大相对的d越小，两值比较平衡</span></span><br><span class="line">    <span class="comment">// 注意：e和n的欧拉函数互素，不能想当然的选取</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;n_Euler_func_arg_ % <span class="number">65537</span> != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;e_arg_ = <span class="number">65537</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;n_Euler_func_arg_ % <span class="number">17</span> != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;e_arg_ = <span class="number">17</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;n_Euler_func_arg_ % <span class="number">3</span> != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;e_arg_ = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 极端几乎不可能情况</span></span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;无法选取参数e&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE); <span class="comment">// 程序直接退出</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 计算d。d × e % n的欧拉函数 = 1，d &lt; n的欧拉函数</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;d_arg_ = <span class="built_in">GetMulInverse</span>(<span class="keyword">this</span>-&gt;e_arg_, <span class="keyword">this</span>-&gt;n_Euler_func_arg_);</span><br><span class="line">    <span class="comment">// 注意：对n的欧拉函数而不是参数n</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取素数</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">RSA::GetPrimeNum</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> random = <span class="number">0</span>;     <span class="comment">// 随机数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> random_odd = <span class="number">0</span>; <span class="comment">// 随机奇数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> n = <span class="number">0</span>;              <span class="comment">// 素性测试的参数n 循环中需要重新初始化</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> a = <span class="number">0</span>;              <span class="comment">// 素性测试的参数a</span></span><br><span class="line">    <span class="type">bool</span> primality_test_res = <span class="literal">false</span>; <span class="comment">// 一次素性测试结果    false不是素数true可能为素数</span></span><br><span class="line">    <span class="type">bool</span> prime_flag = <span class="literal">false</span>;         <span class="comment">// 素数标志，最终素性测试结果。false0不是素数，true1可能为素数</span></span><br><span class="line">    <span class="comment">// 提示：初始化在循环外的变量在循环中注意是否需要更新、重新初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) <span class="comment">// 循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 1.1随机取一个期望大小的奇数</span></span><br><span class="line">        <span class="comment">// 1.1.1取随机数</span></span><br><span class="line">        random = <span class="built_in">rand</span>(); <span class="comment">// 随机数 一般是4~5位数，不超过unsigned int的表示范围</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.1.2取奇数</span></span><br><span class="line">        <span class="keyword">if</span> (random % <span class="number">2</span> == <span class="number">0</span>) <span class="comment">// 如果是偶数，+1成为奇数</span></span><br><span class="line">        &#123;</span><br><span class="line">            random_odd = random + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 奇数不额外操作</span></span><br><span class="line">        &#123;</span><br><span class="line">            random_odd = random;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.2使用素性测试判断</span></span><br><span class="line">        n = random_odd;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">128</span>; ++i) <span class="comment">// 选取128个参数a，测试128次</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//  1.2.1随机选择相关参数a。满足a为整数，1 &lt; a &lt; n - 1</span></span><br><span class="line">            a = <span class="built_in">rand</span>() % (n - <span class="number">1</span>); <span class="comment">// 0 ~ n - 2</span></span><br><span class="line">            <span class="comment">// 注意：</span></span><br><span class="line">            <span class="comment">// 因为运行时间段相近，第一次a取的随机数可能和n相等</span></span><br><span class="line">            <span class="comment">// 则计算后结果必为1，而后1 + 1 = 2</span></span><br><span class="line">            <span class="comment">// 将设置随机种子代码提取出函数后，排除该错误</span></span><br><span class="line">            <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="comment">// 如果是0，令a = 2 &gt; 1</span></span><br><span class="line">            &#123;</span><br><span class="line">                a += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="number">1</span>) <span class="comment">// 如果是1，令a = 2 &gt; 1</span></span><br><span class="line">            &#123;</span><br><span class="line">                ++a;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            primality_test_res = <span class="built_in">PrimalityTest</span>(random_odd, a); <span class="comment">// 素性测试</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (primality_test_res == <span class="literal">true</span>) <span class="comment">// 一次测试结果可能为素数</span></span><br><span class="line">            &#123;</span><br><span class="line">                prime_flag = <span class="literal">true</span>; <span class="comment">// 标记可能为素数</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (primality_test_res == <span class="literal">false</span>) <span class="comment">// 只要有一次素性测试不是素数，则必不为素数</span></span><br><span class="line">            &#123;</span><br><span class="line">                prime_flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 不再用a测试，需要重新选取随机奇数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (prime_flag == <span class="literal">true</span>) <span class="comment">// 随机奇数可能为素数，</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 退出循环</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则随机奇数不是素数，进入循环，再重新进行1.1取随机奇数，1.2素性测试步骤</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> random_odd; <span class="comment">// 获得素数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Miller-Rabin素性测试</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">RSA::PrimalityTest</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> &amp;n, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> &amp;a)</span> <span class="comment">// 参数：随机奇数，参数a</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1.2.2找到相关参数k，q。满足n - 1 = 2 ^ k × q。k、q为整数，k &gt; 0，q为奇数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> q = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提示：</span></span><br><span class="line">    <span class="comment">// 很多算法都只说明要找到k、q，却不说怎么找</span></span><br><span class="line">    <span class="comment">// 找k，q的代码也含糊其辞的</span></span><br><span class="line">    <span class="keyword">while</span> ((q &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ++k;</span><br><span class="line">        q &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 理解：</span></span><br><span class="line">    <span class="comment">// q &amp; 1：即q的二进制表示与二进制位1与运算，取q二进制表示的最低位0或1</span></span><br><span class="line">    <span class="comment">// 如101 &amp; 1 = 101 &amp; 001 = 001 = 1</span></span><br><span class="line">    <span class="comment">// 如0010 &amp; 1 = 0010 &amp; 0001 = 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在最低位中，基数2 ^ 0 = 1，所以如果值是0，则1 × 0 = 0为偶数；值是1，则1 × 1 = 1为奇数</span></span><br><span class="line">    <span class="comment">// 所以，如果运算结果为0，则是偶数，可以提取一个因子2</span></span><br><span class="line">    <span class="comment">// while：连续提取因子2</span></span><br><span class="line">    <span class="comment">// 每提取一个因子2，则++k，k是因子2的计数</span></span><br><span class="line">    <span class="comment">// q &gt;&gt;= 1：将q的二进制表示右移缩小，继续对最低位判断提取因子2</span></span><br><span class="line">    <span class="comment">// 直到不能连续提取因子2，则q即为所求</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如十进制13 - 1 = 12 = 二进制1100，在第1、2位提取因子2为2 ^ 2 = 4</span></span><br><span class="line">    <span class="comment">// 所以12 = 2 ^ 2 × 3。k = 2，q = 3</span></span><br><span class="line">    <span class="comment">// 如十进制7 - 1 = 6 = 二进制110，在第1位提取1个因子2为2 ^ 1 = 2</span></span><br><span class="line">    <span class="comment">// 所以6 = 2 ^ 1 × 3。k = 1，q = 3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提示：注意k、q的取值条件</span></span><br><span class="line">    <span class="comment">// 对正整数素数，除了2为偶数，其他数必为奇数</span></span><br><span class="line">    <span class="comment">// 奇数-1必为偶数，必至少能提取1个公因子2，则k至少为1 &gt; 0满足</span></span><br><span class="line">    <span class="comment">// 由算法性质，知提取所有的公因子2，则结果q必为奇数满足</span></span><br><span class="line">    <span class="comment">// 一般q数很大，所以在接下来的步骤需要用蒙哥马利快速模幂算法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.2.3计算a ^ q % n</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> aq_mod_n = <span class="keyword">this</span>-&gt;<span class="built_in">QuickPowMod</span>(a, q, n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cout &lt;&lt; n &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; k &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; q &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; a &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; aq_mod_n &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.2.4运用二次探测定理的逆否命题判断</span></span><br><span class="line">    <span class="comment">// 正命题大概：探测，所有解只有1或n-1，则可能为素数</span></span><br><span class="line">    <span class="comment">// 逆否命题大概：探测，存在解不为1且不为n-1，则必定不是素数</span></span><br><span class="line">    <span class="comment">// 可以用正命题也可以用逆否命题判断。以下用正命题和逆否命题判断</span></span><br><span class="line">    <span class="comment">// 第一个判断条件：未探测时，a ^ q % n == 1，则可能为素数</span></span><br><span class="line">    <span class="keyword">if</span> (aq_mod_n == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二个判断条件：二次探测时，只要存在不为1且不为n-1，则必定不是素数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; k; ++j) <span class="comment">// 0 ~ k-1</span></span><br><span class="line">    &#123;</span><br><span class="line">        aq_mod_n = <span class="keyword">this</span>-&gt;<span class="built_in">QuickPowMod</span>(aq_mod_n, <span class="number">2</span>, n);</span><br><span class="line">        <span class="comment">// 对序列二次探测 计算a ^ (q × 2 ^ j) % n = aq_mod_n ^ (2 ^ j) % n。每次循环都幂2相当于(2 ^ j)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (aq_mod_n != <span class="number">1</span> &amp;&amp; aq_mod_n != n - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 第二个判断条件：二次探测时，若没有因判断为合数而返回，则可能为素数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 蒙哥马利快速幂模运算</span></span><br><span class="line"><span class="comment">// 参数：a ^ q % n</span></span><br><span class="line"><span class="comment">// 返回值：a ^ q % n</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">RSA::QuickPowMod</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> &amp;a, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> &amp;q, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> &amp;n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 原理：</span></span><br><span class="line">    <span class="comment">//  幂运算性质：a ^ q = a ^ q1 × a ^ q2。q = q1 + q2</span></span><br><span class="line">    <span class="comment">//  模运算性质：(a × b) % n = [(a % n) × (b % n)] % n</span></span><br><span class="line">    <span class="comment">// 所以：a ^ q % n = (a ^ q1 × a ^ q2) % n = [(a ^ q1 % n) × (a ^ q2 % n)] % n</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> a_temp = a; <span class="comment">// 运算中会改变a的值，暂存</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> q_temp = q; <span class="comment">// 运算中会改变q的值，暂存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提示：很多算法代码含糊其辞的</span></span><br><span class="line">    <span class="keyword">while</span> (q_temp &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((q_temp &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res = <span class="keyword">this</span>-&gt;<span class="built_in">QuickMulMod</span>(res, a_temp, n);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        a_temp = <span class="keyword">this</span>-&gt;<span class="built_in">QuickMulMod</span>(a_temp, a_temp, n);</span><br><span class="line"></span><br><span class="line">        q_temp &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 理解：</span></span><br><span class="line">    <span class="comment">// 算法是针对十进制数的二进制表示进行运算的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// while (q_temp &gt; 0)：对比素性测试的内容：while ((q &amp; 1) == 0)</span></span><br><span class="line">    <span class="comment">// 这里是判断值，需要判断所有二进制位，所以只要q在后面的右移位中值不为0，就循环。而素性测试中是判断位</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// if ((q_temp &amp; 1) == 1)：最低位为1时，该位有效，需要计算并更新结果</span></span><br><span class="line">    <span class="comment">// 快速乘算法：res = (res × a_temp) % n</span></span><br><span class="line">    <span class="comment">// 该步骤相当于每次计算单个的(a ^ q2 % n)，然后和之前的(a ^ q1 % n)相乘作为新的结果</span></span><br><span class="line">    <span class="comment">// 其中第一个res是更新结果，第二个res是之前的结果，a_temp是当前的基数</span></span><br><span class="line">    <span class="comment">// 基数：在循环中对每一位都会更新基数（见后面步骤），在二进制表示为1时，该基数有效</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// a_temp = QuickMulMod(a_temp, a_temp, n);相当于a_temp = a_temp × a_temp % n</span></span><br><span class="line">    <span class="comment">// 如初始a_temp = 2，则不断更新为2 ^ 0 = 1，2 ^ 1 = 2</span></span><br><span class="line">    <span class="comment">// 再进行%保证基数不超过范围</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速乘</span></span><br><span class="line"><span class="comment">// 参数：a * b % c</span></span><br><span class="line"><span class="comment">// 返回值：a * b % c</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">RSA::QuickMulMod</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> &amp;a, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> &amp;b, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> &amp;c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 原理：</span></span><br><span class="line">    <span class="comment">// 同快速幂模运算，将乘法转换为加法运算</span></span><br><span class="line">    <span class="comment">// a × b % c = [(a + a) % c] + [(a + a) % c] + ... [(a + a) % c]共b个a相加求模</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> a_temp = a;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> b_temp = b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (b_temp &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b_temp &amp; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res = (res + a_temp) % c;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        a_temp = (a_temp + a_temp) % c;</span><br><span class="line"></span><br><span class="line">        b_temp &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展欧几里得算法</span></span><br><span class="line"><span class="comment">// 参数和返回值：</span></span><br><span class="line"><span class="comment">// 由欧几里得算法，求两数a和b，a &gt;= b的最大公约数g</span></span><br><span class="line"><span class="comment">// 由贝祖定理，存在令a × x + b × y = g的解x和y</span></span><br><span class="line"><span class="comment">// 由扩展欧几里得算法，求令a × x + b × y = gcd的一组解x，y</span></span><br><span class="line"><span class="comment">// 该组解x和y随后用于求乘法逆元</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">RSA::ExGcd</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> &amp;a, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> &amp;b, <span class="type">unsigned</span> <span class="type">int</span> &amp;x, <span class="type">unsigned</span> <span class="type">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 大致思路：</span></span><br><span class="line">    <span class="comment">//  由欧几里得算法，求a和b的最大公约数：gcd(a，b) = gcd(b，a % b)</span></span><br><span class="line">    <span class="comment">//  所以是个递归过程，递归出口为右数b，即右数a % b = 0，此时左数a即为最大公约数返回</span></span><br><span class="line">    <span class="comment">//  此时即：gcd(g，0) = g = a × x + b × y = a × 1 + b × 0</span></span><br><span class="line">    <span class="comment">//  即在递归栈顶时，求得解x = 1，y = 0</span></span><br><span class="line">    <span class="comment">//  随后逐层返回退出递归栈，由扩展欧几里得算法推导，将x和y逐层更新，最后求得解x和y</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归出口</span></span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归逻辑</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> g = <span class="built_in">ExGcd</span>(b, a % b, x, y); <span class="comment">// g是当前递归的最大公约数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提示：</span></span><br><span class="line">    <span class="comment">// 将x和y从栈底到栈顶更新，即正向写代码逻辑递归</span></span><br><span class="line">    <span class="comment">// 则返回时从栈顶到栈底更新，最后求得解</span></span><br><span class="line">    <span class="type">int</span> temp = y;</span><br><span class="line">    y = x - (a / b) * y;</span><br><span class="line">    x = temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> g; <span class="comment">// 返回最大公约数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求乘法逆元</span></span><br><span class="line"><span class="comment">// 参数：a × x % b = 1的a和b</span></span><br><span class="line"><span class="comment">// 返回值：a模b的乘法逆元x</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">RSA::GetMulInverse</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> &amp;a, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 大致思路：</span></span><br><span class="line">    <span class="comment">// 若求a模b的乘法逆元x，即a × x % b = 1</span></span><br><span class="line">    <span class="comment">//  即同余式：ax ≡ 1(mod b)</span></span><br><span class="line">    <span class="comment">//  可转换为不定方程：a × x + b × y = 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对两个素数a，b，最大公约数为1，即gcd(a，b) = 1</span></span><br><span class="line">    <span class="comment">// 所以：a × x + b × y = 1 = gcd(a，b)</span></span><br><span class="line">    <span class="comment">// 由贝祖定理，存在令a × x + b × y = gcd(a，b)的解x和y</span></span><br><span class="line">    <span class="comment">// 即已知a和b，求解x</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所以：</span></span><br><span class="line">    <span class="comment">// 使用扩展欧几里得算法求a × x + b × y = 1的解x</span></span><br><span class="line">    <span class="comment">// 由同余式，逆元z=(x % b + b) % b</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> y = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> g = <span class="keyword">this</span>-&gt;<span class="built_in">ExGcd</span>(a, b, x, y); <span class="comment">// 使用扩展欧几里得算法求a × x + b × y = 1的解x</span></span><br><span class="line"></span><br><span class="line">    x = (x % b + b) % b;</span><br><span class="line">    <span class="comment">// 提示：</span></span><br><span class="line">    <span class="comment">// x是a模b的乘法逆元，但不能保证是正数，不能保证落在(a,b)内，所以需要更新</span></span><br><span class="line">    <span class="comment">// 这一步很多讲解都含糊其辞</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 思路：如果求得x为负数，则需要转换为正数，由模运算性质保证结果不变</span></span><br><span class="line">    <span class="comment">// 假设x = -9，b = 20</span></span><br><span class="line">    <span class="comment">// 由模运算性质：对负数-9 ≡ -9 % 20 ≡ 对正数x1 % 20</span></span><br><span class="line">    <span class="comment">// 想办法将负数-9转换为正数x1，且保证模后结果恒等</span></span><br><span class="line">    <span class="comment">// 将20转换为负数，再加上一个因子构造-9，即[20 × (-1) + 11] % 20 = -9</span></span><br><span class="line">    <span class="comment">// 由模运算性质：-9 = -9 % 20= [20 × (-1) + 11] % 20 = &#123;[(-20) % 20] + (11 % 20)&#125; % 20 = [0 + (11 % 20)] % 20  = 11 % 20 = 11</span></span><br><span class="line">    <span class="comment">// 所以新更新的x1为11</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// x % b：缩小负数在(-b，0]范围</span></span><br><span class="line">    <span class="comment">// 加上1个b能够一次性转换为正数，范围在[0，b]</span></span><br><span class="line">    <span class="comment">// 注意如果x % b = 0时，+b = b，还需要% b使范围落在[0，b)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a>main.cpp</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rsa.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RSA *rsa = <span class="keyword">new</span> RSA;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">plaintext_str</span><span class="params">(<span class="string">&quot;yezhening&quot;</span>)</span></span>;                            <span class="comment">// 字符串类型的明文</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt; <span class="title">ciphertext_int</span><span class="params">(plaintext_str.size(), <span class="number">0</span>)</span></span>; <span class="comment">// 无符号整数类型的密文</span></span><br><span class="line">    <span class="function">string <span class="title">plaintext_str1</span><span class="params">(plaintext_str.size(), <span class="string">&#x27;\0&#x27;</span>)</span></span>;            <span class="comment">// 字符串类型的明文   解密后的明文</span></span><br><span class="line"></span><br><span class="line">    rsa-&gt;<span class="built_in">Encrypt</span>(plaintext_str, ciphertext_int);  <span class="comment">// 加密得密文</span></span><br><span class="line">    rsa-&gt;<span class="built_in">Decrypt</span>(ciphertext_int, plaintext_str1); <span class="comment">// 解密得明文</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> rsa;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p><img src="/../img/rsa/0ecb9dc979534c7e95494cc65565a708.png" alt="请添加图片描述"></p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>网络安全中RSA的C++语言描述简单实现。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《密码编码学与网络安全——原理与实践(第五版)》作者：William Stallings</li><li><a href="https://www.cnblogs.com/kentle/p/14975056.html">Miller-Rabin 素性检测 - kentle - 博客园 (cnblogs.com)</a></li><li><a href="https://blog.csdn.net/forever_dreams/article/details/82314237">Miller-Rabin素数测试算法_forever_dreams的博客-CSDN博客_millerrabin素数测试算法</a></li><li><a href="https://blog.csdn.net/heshiip/article/details/95679397">素性测试的Miller-Rabin算法完全解析 （C语言实现、Python实现）_heshiip的博客-CSDN博客_millerrabin算法c代码</a></li><li><a href="https://zpf1900.blog.csdn.net/article/details/85197424?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-85197424-blog-51457540.pc_relevant_landingrelevant&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-85197424-blog-51457540.pc_relevant_landingrelevant&utm_relevant_index=2">米勒-拉宾素性检验(MillerRabbin)算法详解_1900_的博客-CSDN博客_米勒拉宾素性检验</a></li><li><a href="https://blog.csdn.net/lovecyr/article/details/105372427">扩展欧几里得算法（详细推导+代码实现+应用）_胡小涛的博客-CSDN博客_扩展欧几里得算法代码</a></li><li><a href="https://blog.csdn.net/weixin_43772166/article/details/104254604">求解乘法逆元的方法_默_silence的博客-CSDN博客_求乘法逆元</a></li><li><a href="https://zhuanlan.zhihu.com/p/370615983">计算乘法逆元 - 知乎 (zhihu.com)</a></li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据加密标准（DES）的C++语言描述实现</title>
      <link href="/2022/10/24/%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E6%A0%87%E5%87%86%EF%BC%88DES%EF%BC%89%E7%9A%84C++%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E5%AE%9E%E7%8E%B0/"/>
      <url>/2022/10/24/%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E6%A0%87%E5%87%86%EF%BC%88DES%EF%BC%89%E7%9A%84C++%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>网络安全中数据加密标准（DES）的C++语言描述实现。</p><hr><h1 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h1><ul><li><a href="https://github.com/yezhening/Programming-examples">yezhening&#x2F;Programming-examples: 编程实例 (github.com)</a></li><li><a href="https://gitee.com/yezhening/Programming-examples">Programming-examples: 编程实例 (gitee.com)</a></li></ul><hr><h1 id="代码特点"><a href="#代码特点" class="headerlink" title="代码特点"></a>代码特点</h1><p>纯C++语言：</p><ul><li>相对规范和整洁</li><li>一定程度地面向对象</li><li>使用一部分高级特性</li><li>考虑优化性能</li></ul><p>详细注释：</p><ul><li>提示规范和整洁</li><li>提示面向对象</li><li>提示高级特性</li><li>提示优化性能</li><li>解析数据加密标准（DES）步骤</li><li>注意易错点</li></ul><hr><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="des-h"><a href="#des-h" class="headerlink" title="des.h"></a>des.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//预处理指令——————————</span></span><br><span class="line"><span class="comment">//预定义宏</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DES_DES_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DES_DES_H_</span></span><br><span class="line"><span class="comment">//提示：防止头文件被重复包含</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//标准库头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> <span class="comment">//string，cout，endl</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>   <span class="comment">//vector</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//命名空间</span></span><br><span class="line"><span class="comment">//提示：</span></span><br><span class="line"><span class="comment">//使用using声明而不是using指示，以体现命名空间的作用</span></span><br><span class="line"><span class="comment">//本项目并未体现命名空间的作用，因为只使用一个命名空间std</span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型——————————</span></span><br><span class="line"><span class="comment">//类</span></span><br><span class="line"><span class="comment">//数据加密标准类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DES</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">encrypt</span><span class="params">(<span class="type">const</span> string &amp;plainText, <span class="type">const</span> string &amp;key, string &amp;cipherTextASCII)</span></span>;      <span class="comment">//加密</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">decrypt</span><span class="params">(<span class="type">const</span> string &amp;cipherTextASCII, <span class="type">const</span> string &amp;key, string &amp;plainTextASCII)</span></span>; <span class="comment">//解密</span></span><br><span class="line">    <span class="comment">//提示：</span></span><br><span class="line">    <span class="comment">//加密和解密过程相似，存在大量代码复用</span></span><br><span class="line">    <span class="comment">//但仍依据语义拆分成两函数，解耦合以能够单独调用</span></span><br><span class="line">    <span class="comment">//提示：返回值的数据类型为void而不是string，和其他函数形式统一，反正结果都会输出</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//提示：属性初始化，避免未显式定义的默认构造函数调用造成未知错误</span></span><br><span class="line">    <span class="comment">//提示：因为会修改属性，所以不使用const修饰</span></span><br><span class="line">    <span class="comment">//提示：记录二进制而不是字符是数据加密标准的原貌，更有实际意义</span></span><br><span class="line">    string plainTextASCII&#123;<span class="string">&quot;&quot;</span>&#125;;  <span class="comment">//明文的ASCII码  64位</span></span><br><span class="line">    string keyASCII&#123;<span class="string">&quot;&quot;</span>&#125;;        <span class="comment">//密钥的ASCII码  64位</span></span><br><span class="line">    string cipherTextASCII&#123;<span class="string">&quot;&quot;</span>&#125;; <span class="comment">//密文的ASCII码 64位</span></span><br><span class="line"></span><br><span class="line">    vector&lt;string&gt; wheelKeys&#123;</span><br><span class="line">        <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>&#125;; <span class="comment">//轮密钥   16个，每个56位</span></span><br><span class="line">    <span class="comment">//注意：</span></span><br><span class="line">    <span class="comment">// vector&lt;string&gt; wheelKeys(16,&quot;&quot;);报错</span></span><br><span class="line">    <span class="comment">// string默认为空字符串，可不初始化</span></span><br><span class="line">    <span class="comment">//可初始化，和其他属性初始化方式统一</span></span><br><span class="line">    <span class="comment">//提示：记录轮密钥，可将轮密钥生成过程和轮函数过程解耦合，可提前准备轮密钥</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//提示：将固有属性放在类中，而不是初始化为静态全局变量</span></span><br><span class="line">    <span class="comment">//提示：C++11新特性，可用大括号初始化任何类型</span></span><br><span class="line">    <span class="comment">//初始置换IP表</span></span><br><span class="line">    <span class="type">const</span> string ipTable&#123;</span><br><span class="line">        <span class="number">58</span>, <span class="number">50</span>, <span class="number">42</span>, <span class="number">34</span>, <span class="number">26</span>, <span class="number">18</span>, <span class="number">10</span>, <span class="number">2</span>,</span><br><span class="line">        <span class="number">60</span>, <span class="number">52</span>, <span class="number">44</span>, <span class="number">36</span>, <span class="number">28</span>, <span class="number">20</span>, <span class="number">12</span>, <span class="number">4</span>,</span><br><span class="line">        <span class="number">62</span>, <span class="number">54</span>, <span class="number">46</span>, <span class="number">38</span>, <span class="number">30</span>, <span class="number">22</span>, <span class="number">14</span>, <span class="number">6</span>,</span><br><span class="line">        <span class="number">64</span>, <span class="number">56</span>, <span class="number">48</span>, <span class="number">40</span>, <span class="number">32</span>, <span class="number">24</span>, <span class="number">16</span>, <span class="number">8</span>,</span><br><span class="line">        <span class="number">57</span>, <span class="number">49</span>, <span class="number">41</span>, <span class="number">33</span>, <span class="number">25</span>, <span class="number">17</span>, <span class="number">9</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">59</span>, <span class="number">51</span>, <span class="number">43</span>, <span class="number">35</span>, <span class="number">27</span>, <span class="number">19</span>, <span class="number">11</span>, <span class="number">3</span>,</span><br><span class="line">        <span class="number">61</span>, <span class="number">53</span>, <span class="number">45</span>, <span class="number">37</span>, <span class="number">29</span>, <span class="number">21</span>, <span class="number">13</span>, <span class="number">5</span>,</span><br><span class="line">        <span class="number">63</span>, <span class="number">55</span>, <span class="number">47</span>, <span class="number">39</span>, <span class="number">31</span>, <span class="number">23</span>, <span class="number">15</span>, <span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//密钥的选择置换表</span></span><br><span class="line">    <span class="type">const</span> string keySeRepTable&#123;</span><br><span class="line">        <span class="number">57</span>, <span class="number">49</span>, <span class="number">41</span>, <span class="number">33</span>, <span class="number">25</span>, <span class="number">17</span>, <span class="number">9</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">58</span>, <span class="number">50</span>, <span class="number">42</span>, <span class="number">34</span>, <span class="number">26</span>, <span class="number">18</span>,</span><br><span class="line">        <span class="number">10</span>, <span class="number">2</span>, <span class="number">59</span>, <span class="number">51</span>, <span class="number">43</span>, <span class="number">35</span>, <span class="number">27</span>,</span><br><span class="line">        <span class="number">9</span>, <span class="number">11</span>, <span class="number">3</span>, <span class="number">60</span>, <span class="number">52</span>, <span class="number">44</span>, <span class="number">36</span>,</span><br><span class="line">        <span class="number">63</span>, <span class="number">55</span>, <span class="number">47</span>, <span class="number">39</span>, <span class="number">31</span>, <span class="number">23</span>, <span class="number">15</span>,</span><br><span class="line">        <span class="number">7</span>, <span class="number">62</span>, <span class="number">54</span>, <span class="number">46</span>, <span class="number">38</span>, <span class="number">30</span>, <span class="number">22</span>,</span><br><span class="line">        <span class="number">14</span>, <span class="number">6</span>, <span class="number">61</span>, <span class="number">53</span>, <span class="number">45</span>, <span class="number">37</span>, <span class="number">29</span>,</span><br><span class="line">        <span class="number">21</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">28</span>, <span class="number">20</span>, <span class="number">12</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//密钥的左移位表</span></span><br><span class="line">    <span class="type">const</span> vector&lt;<span class="type">int</span>&gt; keyLeftMoveTable&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//密钥的压缩置换表</span></span><br><span class="line">    <span class="type">const</span> string keyComRepTable&#123;</span><br><span class="line">        <span class="number">14</span>, <span class="number">17</span>, <span class="number">11</span>, <span class="number">24</span>, <span class="number">1</span>, <span class="number">5</span>,</span><br><span class="line">        <span class="number">3</span>, <span class="number">28</span>, <span class="number">15</span>, <span class="number">6</span>, <span class="number">21</span>, <span class="number">10</span>,</span><br><span class="line">        <span class="number">23</span>, <span class="number">19</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">26</span>, <span class="number">8</span>,</span><br><span class="line">        <span class="number">16</span>, <span class="number">7</span>, <span class="number">27</span>, <span class="number">20</span>, <span class="number">13</span>, <span class="number">2</span>,</span><br><span class="line">        <span class="number">41</span>, <span class="number">52</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">47</span>, <span class="number">55</span>,</span><br><span class="line">        <span class="number">30</span>, <span class="number">40</span>, <span class="number">51</span>, <span class="number">45</span>, <span class="number">33</span>, <span class="number">48</span>,</span><br><span class="line">        <span class="number">44</span>, <span class="number">49</span>, <span class="number">39</span>, <span class="number">56</span>, <span class="number">34</span>, <span class="number">53</span>,</span><br><span class="line">        <span class="number">46</span>, <span class="number">42</span>, <span class="number">50</span>, <span class="number">36</span>, <span class="number">29</span>, <span class="number">32</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//扩展置换E表</span></span><br><span class="line">    <span class="type">const</span> string eRepTable&#123;</span><br><span class="line">        <span class="number">32</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>,</span><br><span class="line">        <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>,</span><br><span class="line">        <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>,</span><br><span class="line">        <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>,</span><br><span class="line">        <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">21</span>,</span><br><span class="line">        <span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>,</span><br><span class="line">        <span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>,</span><br><span class="line">        <span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// S盒选择代替表</span></span><br><span class="line">    <span class="type">const</span> vector&lt;string&gt; sBoxSeRepTable&#123;</span><br><span class="line">        <span class="comment">// S1</span></span><br><span class="line">        &#123;<span class="number">14</span>, <span class="number">4</span>, <span class="number">13</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">15</span>, <span class="number">11</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">7</span>,</span><br><span class="line">         <span class="number">0</span>, <span class="number">15</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">14</span>, <span class="number">2</span>, <span class="number">13</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">11</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>,</span><br><span class="line">         <span class="number">4</span>, <span class="number">1</span>, <span class="number">14</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">12</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">0</span>,</span><br><span class="line">         <span class="number">15</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">3</span>, <span class="number">14</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">13</span>&#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// S2</span></span><br><span class="line">        &#123;<span class="number">15</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">14</span>, <span class="number">6</span>, <span class="number">11</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">13</span>, <span class="number">12</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">10</span>,</span><br><span class="line">         <span class="number">3</span>, <span class="number">13</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">15</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">14</span>, <span class="number">12</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">5</span>,</span><br><span class="line">         <span class="number">0</span>, <span class="number">14</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">13</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">15</span>,</span><br><span class="line">         <span class="number">13</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">15</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">12</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">14</span>, <span class="number">9</span>&#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// S3</span></span><br><span class="line">        &#123;<span class="number">10</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">14</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">15</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">13</span>, <span class="number">12</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">8</span>,</span><br><span class="line">         <span class="number">13</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">14</span>, <span class="number">12</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">1</span>,</span><br><span class="line">         <span class="number">13</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">11</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">7</span>,</span><br><span class="line">         <span class="number">1</span>, <span class="number">10</span>, <span class="number">13</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">15</span>, <span class="number">14</span>, <span class="number">3</span>, <span class="number">11</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">12</span>&#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// S4</span></span><br><span class="line">        &#123;<span class="number">7</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">15</span>,</span><br><span class="line">         <span class="number">13</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">15</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">9</span>,</span><br><span class="line">         <span class="number">10</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">12</span>, <span class="number">11</span>, <span class="number">7</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">14</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">4</span>,</span><br><span class="line">         <span class="number">3</span>, <span class="number">15</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">13</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">14</span>&#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// S5</span></span><br><span class="line">        &#123;<span class="number">2</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">15</span>, <span class="number">13</span>, <span class="number">0</span>, <span class="number">14</span>, <span class="number">9</span>,</span><br><span class="line">         <span class="number">14</span>, <span class="number">11</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">13</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">15</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">6</span>,</span><br><span class="line">         <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">11</span>, <span class="number">10</span>, <span class="number">13</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">14</span>,</span><br><span class="line">         <span class="number">11</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">14</span>, <span class="number">2</span>, <span class="number">13</span>, <span class="number">6</span>, <span class="number">15</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>&#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// S6</span></span><br><span class="line">        &#123;<span class="number">12</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">13</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">14</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">11</span>,</span><br><span class="line">         <span class="number">10</span>, <span class="number">15</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">12</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">0</span>, <span class="number">11</span>, <span class="number">3</span>, <span class="number">8</span>,</span><br><span class="line">         <span class="number">9</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">13</span>, <span class="number">11</span>, <span class="number">6</span>,</span><br><span class="line">         <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">15</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">14</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">13</span>&#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// S7</span></span><br><span class="line">        &#123;<span class="number">4</span>, <span class="number">11</span>, <span class="number">2</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">3</span>, <span class="number">12</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">1</span>,</span><br><span class="line">         <span class="number">13</span>, <span class="number">0</span>, <span class="number">11</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">15</span>, <span class="number">8</span>, <span class="number">6</span>,</span><br><span class="line">         <span class="number">1</span>, <span class="number">4</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">12</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">14</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>,</span><br><span class="line">         <span class="number">6</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">15</span>, <span class="number">14</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">12</span>&#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// S8</span></span><br><span class="line">        &#123;<span class="number">13</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">15</span>, <span class="number">11</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">14</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">12</span>, <span class="number">7</span>,</span><br><span class="line">         <span class="number">1</span>, <span class="number">15</span>, <span class="number">13</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">11</span>, <span class="number">0</span>, <span class="number">14</span>, <span class="number">9</span>, <span class="number">2</span>,</span><br><span class="line">         <span class="number">7</span>, <span class="number">11</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>,</span><br><span class="line">         <span class="number">2</span>, <span class="number">1</span>, <span class="number">14</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">12</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">11</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 置换P表</span></span><br><span class="line">    <span class="type">const</span> string pRepTable&#123;</span><br><span class="line">        <span class="number">16</span>, <span class="number">7</span>, <span class="number">20</span>, <span class="number">21</span>,</span><br><span class="line">        <span class="number">29</span>, <span class="number">12</span>, <span class="number">28</span>, <span class="number">17</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">15</span>, <span class="number">23</span>, <span class="number">26</span>,</span><br><span class="line">        <span class="number">5</span>, <span class="number">18</span>, <span class="number">31</span>, <span class="number">10</span>,</span><br><span class="line">        <span class="number">2</span>, <span class="number">8</span>, <span class="number">24</span>, <span class="number">14</span>,</span><br><span class="line">        <span class="number">32</span>, <span class="number">27</span>, <span class="number">3</span>, <span class="number">9</span>,</span><br><span class="line">        <span class="number">19</span>, <span class="number">13</span>, <span class="number">30</span>, <span class="number">6</span>,</span><br><span class="line">        <span class="number">22</span>, <span class="number">11</span>, <span class="number">4</span>, <span class="number">25</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//逆初始置换IP-1表</span></span><br><span class="line">    <span class="type">const</span> string iIpTable&#123;</span><br><span class="line">        <span class="number">40</span>, <span class="number">8</span>, <span class="number">48</span>, <span class="number">16</span>, <span class="number">56</span>, <span class="number">24</span>, <span class="number">64</span>, <span class="number">32</span>,</span><br><span class="line">        <span class="number">39</span>, <span class="number">7</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">55</span>, <span class="number">23</span>, <span class="number">63</span>, <span class="number">31</span>,</span><br><span class="line">        <span class="number">38</span>, <span class="number">6</span>, <span class="number">46</span>, <span class="number">14</span>, <span class="number">54</span>, <span class="number">22</span>, <span class="number">62</span>, <span class="number">30</span>,</span><br><span class="line">        <span class="number">37</span>, <span class="number">5</span>, <span class="number">45</span>, <span class="number">13</span>, <span class="number">53</span>, <span class="number">21</span>, <span class="number">61</span>, <span class="number">29</span>,</span><br><span class="line">        <span class="number">36</span>, <span class="number">4</span>, <span class="number">44</span>, <span class="number">12</span>, <span class="number">52</span>, <span class="number">20</span>, <span class="number">60</span>, <span class="number">28</span>,</span><br><span class="line">        <span class="number">35</span>, <span class="number">3</span>, <span class="number">43</span>, <span class="number">11</span>, <span class="number">51</span>, <span class="number">19</span>, <span class="number">59</span>, <span class="number">27</span>,</span><br><span class="line">        <span class="number">34</span>, <span class="number">2</span>, <span class="number">42</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">18</span>, <span class="number">58</span>, <span class="number">26</span>,</span><br><span class="line">        <span class="number">33</span>, <span class="number">1</span>, <span class="number">41</span>, <span class="number">9</span>, <span class="number">49</span>, <span class="number">17</span>, <span class="number">57</span>, <span class="number">25</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提示：使用const表示只读；使用引用传地址而不是值，避免拷贝开销-&gt;搭配使用</span></span><br><span class="line">    <span class="comment">//提示：非常量引用实参可传递给常量引用形参</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">byteStrToBitStr</span><span class="params">(<span class="type">const</span> string &amp;str, string &amp;bitStr)</span></span>; <span class="comment">// 8字节字符串转64位字符串 依据ASCII码</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wheelKeyGener</span><span class="params">(<span class="type">const</span> string &amp;preKey, <span class="type">const</span> <span class="type">int</span> &amp;wheelCount, string &amp;nextKey, string &amp;wheelKey)</span></span>; <span class="comment">//轮密钥生成</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wheelFunc</span><span class="params">(<span class="type">const</span> string &amp;textIp, <span class="type">const</span> string &amp;keySeRep, string &amp;textWheelF)</span></span>;                   <span class="comment">//轮函数F</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// DES_DES_H_</span></span></span><br></pre></td></tr></table></figure><hr><h2 id="des-cpp"><a href="#des-cpp" class="headerlink" title="des.cpp"></a>des.cpp</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//预处理指令——————————</span></span><br><span class="line"><span class="comment">//标准库头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span>    <span class="comment">//&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span> <span class="comment">//reverse()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>    <span class="comment">//stoi()</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;des.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//命名空间</span></span><br><span class="line"><span class="comment">//提示：</span></span><br><span class="line"><span class="comment">//使用using声明而不是using指示，以体现命名空间的作用</span></span><br><span class="line"><span class="comment">//本项目并未体现命名空间的作用，因为只使用一个命名空间std</span></span><br><span class="line"><span class="keyword">using</span> std::bitset;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加密</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DES::encrypt</span><span class="params">(<span class="type">const</span> string &amp;plainText, <span class="type">const</span> string &amp;key, string &amp;cipherTextASCII)</span> <span class="comment">//参数：明文，密钥，密文的ASCII码</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;加密过程：————————————————————&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对明文和密钥：</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;明文：\t&quot;</span> &lt;&lt; plainText &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;密钥：\t&quot;</span> &lt;&lt; key &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0.初始化为二进制  8字节-&gt;64位</span></span><br><span class="line">    <span class="function">string <span class="title">plainTextASCII</span><span class="params">(<span class="string">&quot;&quot;</span>)</span></span>;                        <span class="comment">//明文的ASCII码   64位</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">byteStrToBitStr</span>(plainText, plainTextASCII); <span class="comment">// 8字节字符串转64位字符串 依据ASCII码</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;plainTextASCII = plainTextASCII;            <span class="comment">//记录明文的ASCII码</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;明文的ASCII码：\t&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;plainTextASCII &lt;&lt; endl;</span><br><span class="line">    <span class="function">string <span class="title">keyASCII</span><span class="params">(<span class="string">&quot;&quot;</span>)</span></span>;                  <span class="comment">//密钥的ASCII码   64位</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">byteStrToBitStr</span>(key, keyASCII); <span class="comment">// 8字节字符串转64位字符串 依据ASCII码</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;keyASCII = keyASCII;            <span class="comment">//记录密钥的ASCII码</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;密钥的ASCII码：\t&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;keyASCII &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对密钥：</span></span><br><span class="line">    <span class="comment">// 1.密钥的选择置换 64-&gt;56位</span></span><br><span class="line">    <span class="function">string <span class="title">keySeRep</span><span class="params">(<span class="number">56</span>, <span class="string">&#x27;-&#x27;</span>)</span></span>; <span class="comment">//密钥的选择置换   56位</span></span><br><span class="line">    <span class="comment">//注意：因为需要使用下标赋值，所以需要初始化大小以预分配空间</span></span><br><span class="line">    <span class="comment">//注意：初始化为不是0或1的字符，以验证是否成功</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;keySeRepTable.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//置换规则：依据置换表，输入的第57位是输出的第1位-&gt;输入的第56位是输出的第0位</span></span><br><span class="line">        <span class="comment">//注意：下标从0开始</span></span><br><span class="line">        keySeRep[i] = <span class="keyword">this</span>-&gt;keyASCII[<span class="keyword">this</span>-&gt;keySeRepTable[i] - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;密钥的选择置换：\t&quot;</span> &lt;&lt; keySeRep &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.轮密钥生成</span></span><br><span class="line">    <span class="comment">//提示：预先生成</span></span><br><span class="line">    <span class="function">string <span class="title">preKey</span><span class="params">(keySeRep)</span></span>;  <span class="comment">//上一轮密钥 56位</span></span><br><span class="line">    <span class="function">string <span class="title">nextKey</span><span class="params">(<span class="string">&quot;&quot;</span>)</span></span>;       <span class="comment">//下一轮密钥 56位</span></span><br><span class="line">    <span class="function">string <span class="title">wheelKey</span><span class="params">(<span class="number">48</span>, <span class="string">&#x27;-&#x27;</span>)</span></span>; <span class="comment">//轮密钥 48位</span></span><br><span class="line">    <span class="comment">//注意：因为需要使用下标赋值，所以需要初始化大小以预分配空间</span></span><br><span class="line">    <span class="comment">//注意：初始化为不是0或1的字符，以验证是否成功</span></span><br><span class="line">    <span class="comment">//提示：</span></span><br><span class="line">    <span class="comment">//在循环外而不是循环中声明并初始化/定义对象，避免重复进行对象的构造和析构，减少开销</span></span><br><span class="line">    <span class="comment">//但可读性差</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 16轮轮函数</span></span><br><span class="line">    <span class="comment">//注意：轮数从1开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> wheelCount = <span class="number">1</span>; wheelCount &lt;= <span class="number">16</span>; ++wheelCount) <span class="comment">//轮数计数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//轮密钥生成</span></span><br><span class="line">        <span class="comment">//参数：上一轮密钥（56位），轮数（从1开始），下一轮密钥（56位），轮密钥（48位）</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">wheelKeyGener</span>(preKey, wheelCount, nextKey, wheelKey);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>-&gt;wheelKeys[wheelCount - <span class="number">1</span>] = wheelKey; <span class="comment">//记录轮密钥</span></span><br><span class="line">        <span class="comment">//注意：轮数从1开始，轮密钥下标从0开始</span></span><br><span class="line">        <span class="comment">//注意：记录轮密钥（48位）而不是下一轮密钥（56位）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//注意：</span></span><br><span class="line">        <span class="comment">//循环外定义的变量可能需要更新</span></span><br><span class="line">        <span class="comment">//循环内定义的变量为局部变量，不需要更新，方便</span></span><br><span class="line">        preKey = nextKey; <span class="comment">//更新上一轮密钥 56位</span></span><br><span class="line">        nextKey = <span class="string">&quot;&quot;</span>;     <span class="comment">//更新下一轮密钥 56位</span></span><br><span class="line">        <span class="comment">//轮密钥每轮都通过下标填充，不需要更新</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对明文：</span></span><br><span class="line">    <span class="comment">// 1.初始置换IP 64-&gt;64位</span></span><br><span class="line">    <span class="function">string <span class="title">plainTextIp</span><span class="params">(<span class="number">64</span>, <span class="string">&#x27;-&#x27;</span>)</span></span>; <span class="comment">//明文的初始置换IP   64位</span></span><br><span class="line">    <span class="comment">//注意：因为需要使用下标赋值，所以需要初始化大小以预分配空间</span></span><br><span class="line">    <span class="comment">//注意：初始化为不是0或1的字符，以验证是否成功</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;ipTable.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//置换规则：依据置换表，输入的第58位是输出的第1位-&gt;输入的第57位是输出的第0位</span></span><br><span class="line">        <span class="comment">//注意：下标从0开始</span></span><br><span class="line">        plainTextIp[i] = <span class="keyword">this</span>-&gt;plainTextASCII[<span class="keyword">this</span>-&gt;ipTable[i] - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;明文的初始置换IP：\t&quot;</span> &lt;&lt; plainTextIp &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.轮函数F</span></span><br><span class="line">    <span class="function">string <span class="title">plainTextWheelF</span><span class="params">(<span class="string">&quot;&quot;</span>)</span></span>; <span class="comment">//明文的轮函数  64位</span></span><br><span class="line">    <span class="built_in">wheelFunc</span>(plainTextIp, keySeRep, plainTextWheelF);</span><br><span class="line">    <span class="comment">//参数：明文的初始置换IP，密钥的选择置换，明文的轮函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;明文的轮函数F：\t&quot;</span> &lt;&lt; plainTextWheelF &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.左右置换/轮函数F的第16轮不进行左右置换 64-&gt;64位</span></span><br><span class="line">    <span class="function">string <span class="title">left</span><span class="params">(plainTextWheelF.substr(<span class="number">0</span>, <span class="number">32</span>))</span></span>;   <span class="comment">//左 范围：0~31</span></span><br><span class="line">    <span class="function">string <span class="title">right</span><span class="params">(plainTextWheelF.substr(<span class="number">32</span>, <span class="number">32</span>))</span></span>; <span class="comment">//右 范围：32~63</span></span><br><span class="line">    string plainTextLeRiRep = right + left;       <span class="comment">//明文的左右置换</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;明文的左右置换：\t&quot;</span> &lt;&lt; plainTextLeRiRep &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.逆初始置换IP-1 64-&gt;64位</span></span><br><span class="line">    <span class="function">string <span class="title">plainTextIIp</span><span class="params">(<span class="number">64</span>, <span class="string">&#x27;-&#x27;</span>)</span></span>; <span class="comment">//明文的逆初始置换IP-1</span></span><br><span class="line">    <span class="comment">//注意：因为需要使用下标赋值，所以需要初始化大小以预分配空间</span></span><br><span class="line">    <span class="comment">//注意：初始化为不是0或1的字符，以验证是否成功</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;iIpTable.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//置换规则：依据置换表，输入的第40位是输出的第1位-&gt;输入的第39位是输出的第0位</span></span><br><span class="line">        <span class="comment">//注意：下标从0开始</span></span><br><span class="line">        plainTextIIp[i] = plainTextLeRiRep[<span class="keyword">this</span>-&gt;iIpTable[i] - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;明文的逆初始置换IP-1：\t&quot;</span> &lt;&lt; plainTextIIp &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;cipherTextASCII = plainTextIIp; <span class="comment">//记录密文的ASCII码   密文的ASCII码为明文的逆初始置换IP-1</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;密文的ASCII码：\t&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;cipherTextASCII &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cipherTextASCII = plainTextIIp; <span class="comment">//记录结果   密文的ASCII码为明文的逆初始置换IP-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8字节字符串转64位字符串 依据ASCII码</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DES::byteStrToBitStr</span><span class="params">(<span class="type">const</span> string &amp;str, string &amp;bitStr)</span> <span class="comment">//参数：8字节字符串，64位字符串</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="type">char</span> &amp;ch : str)</span><br><span class="line">    &#123;</span><br><span class="line">        bitStr += <span class="built_in">bitset</span>&lt;<span class="number">8</span>&gt;(ch).<span class="built_in">to_string</span>(); <span class="comment">// 1字节字符转8位字符串    字符-&gt;bitset对象-&gt;字符串</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//轮密钥生成</span></span><br><span class="line"><span class="comment">//参数：上一轮密钥（56位），轮数（从1开始），下一轮密钥（56位），轮密钥（48位）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DES::wheelKeyGener</span><span class="params">(<span class="type">const</span> string &amp;preKey, <span class="type">const</span> <span class="type">int</span> &amp;wheelCount, string &amp;nextKey, string &amp;wheelKey)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 2.1等分上一轮密钥为上一轮左右    56-&gt;28+28位</span></span><br><span class="line">    <span class="comment">//注意：substr()的参数：开始下标，子串大小</span></span><br><span class="line">    <span class="function">string <span class="title">preLeft</span><span class="params">(preKey.substr(<span class="number">0</span>, <span class="number">28</span>))</span></span>;   <span class="comment">//上一轮左  范围：0~27</span></span><br><span class="line">    <span class="function">string <span class="title">preRight</span><span class="params">(preKey.substr(<span class="number">28</span>, <span class="number">28</span>))</span></span>; <span class="comment">//上一轮右  范围：28~55</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.2上一轮左右各循环左移/旋转</span></span><br><span class="line">    <span class="comment">//上一轮左的左移</span></span><br><span class="line">    <span class="comment">//局部翻转</span></span><br><span class="line">    <span class="comment">//注意：轮数从1开始，下标从0开始</span></span><br><span class="line">    <span class="comment">//注意：reverse()是左闭右开区间[)</span></span><br><span class="line">    <span class="built_in">reverse</span>(preLeft.<span class="built_in">begin</span>(), preLeft.<span class="built_in">begin</span>() + <span class="keyword">this</span>-&gt;keyLeftMoveTable[wheelCount - <span class="number">1</span>]); <span class="comment">//翻转[0,1)或[0,2)</span></span><br><span class="line">    <span class="built_in">reverse</span>(preLeft.<span class="built_in">begin</span>() + <span class="keyword">this</span>-&gt;keyLeftMoveTable[wheelCount - <span class="number">1</span>], preLeft.<span class="built_in">end</span>());   <span class="comment">//翻转[1,n)或[2,n)</span></span><br><span class="line">    <span class="comment">//整体翻转</span></span><br><span class="line">    <span class="built_in">reverse</span>(preLeft.<span class="built_in">begin</span>(), preLeft.<span class="built_in">end</span>()); <span class="comment">//翻转[0,n)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//上一轮右的左移位</span></span><br><span class="line">    <span class="comment">//局部翻转</span></span><br><span class="line">    <span class="comment">//注意：轮数从1开始，下标从0开始</span></span><br><span class="line">    <span class="comment">//注意：reverse()是左闭右开区间[)</span></span><br><span class="line">    <span class="built_in">reverse</span>(preRight.<span class="built_in">begin</span>(), preRight.<span class="built_in">begin</span>() + <span class="keyword">this</span>-&gt;keyLeftMoveTable[wheelCount - <span class="number">1</span>]); <span class="comment">//翻转[0,1)或[0,2)</span></span><br><span class="line">    <span class="built_in">reverse</span>(preRight.<span class="built_in">begin</span>() + <span class="keyword">this</span>-&gt;keyLeftMoveTable[wheelCount - <span class="number">1</span>], preRight.<span class="built_in">end</span>());   <span class="comment">//翻转[1,n)或[2,n)</span></span><br><span class="line">    <span class="comment">//整体翻转</span></span><br><span class="line">    <span class="built_in">reverse</span>(preRight.<span class="built_in">begin</span>(), preRight.<span class="built_in">end</span>()); <span class="comment">//翻转[0,n)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.3拼接上一轮左右得下一轮密钥    28+28-&gt;56位</span></span><br><span class="line">    nextKey = preLeft + preRight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.4下一轮密钥的压缩置换得轮密钥    56-&gt;48位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;keyComRepTable.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//置换规则：依据置换表，输入的第14位是输出的第1位-&gt;输入的第13位是输出的第0位</span></span><br><span class="line">        <span class="comment">//注意：下标从0开始</span></span><br><span class="line">        wheelKey[i] = nextKey[<span class="keyword">this</span>-&gt;keyComRepTable[i] - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//轮函数F</span></span><br><span class="line"><span class="comment">//注意：忘记加类作用域...</span></span><br><span class="line"><span class="comment">//参数：文本的初始置换IP，密钥的选择置换，文本的轮函数F</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DES::wheelFunc</span><span class="params">(<span class="type">const</span> string &amp;textIp, <span class="type">const</span> string &amp;keySeRep, string &amp;textWheelF)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">string <span class="title">preText</span><span class="params">(textIp)</span></span>; <span class="comment">//上一轮文本    64位</span></span><br><span class="line">    <span class="comment">//提示：</span></span><br><span class="line">    <span class="comment">//在循环外而不是循环中声明并初始化/定义对象，避免重复进行对象的构造和析构，减少开销</span></span><br><span class="line">    <span class="comment">//但可读性差</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 16轮轮函数</span></span><br><span class="line">    <span class="comment">//注意：轮数从1开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> wheelCount = <span class="number">1</span>; wheelCount &lt;= <span class="number">16</span>; ++wheelCount) <span class="comment">//轮数计数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 2.1等分上一轮文本为上一轮左右    64-&gt;32+32位</span></span><br><span class="line">        <span class="comment">//注意：substr()的参数：开始下标，子串大小</span></span><br><span class="line">        <span class="function">string <span class="title">preLeft</span><span class="params">(preText.substr(<span class="number">0</span>, <span class="number">32</span>))</span></span>;   <span class="comment">//上一轮左   范围：0~31</span></span><br><span class="line">        <span class="function">string <span class="title">preRight</span><span class="params">(preText.substr(<span class="number">32</span>, <span class="number">32</span>))</span></span>; <span class="comment">//上一轮右 范围：32~63</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.2下一轮左为上一轮右    32-&gt;32位</span></span><br><span class="line">        <span class="function">string <span class="title">nextLeft</span><span class="params">(preRight)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.3.1下一轮右：上一轮右扩展置换E 32-&gt;48位</span></span><br><span class="line">        <span class="function">string <span class="title">preRightERep</span><span class="params">(<span class="number">48</span>, <span class="string">&#x27;-&#x27;</span>)</span></span>; <span class="comment">//上一轮右的扩展置换E</span></span><br><span class="line">        <span class="comment">//注意：因为需要使用下标赋值，所以需要初始化大小以预分配空间</span></span><br><span class="line">        <span class="comment">//注意：初始化为不是0或1的字符，以验证上一轮右的扩展置换E是否成功</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;eRepTable.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//置换规则：依据置换表，输入的第32位是输出的第1位-&gt;输入的第31位是输出的第0位</span></span><br><span class="line">            <span class="comment">//注意：下标从0开始</span></span><br><span class="line">            preRightERep[i] = preRight[<span class="keyword">this</span>-&gt;eRepTable[i] - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.3.2下一轮右：上一轮右的扩展置换E（48位）与轮密钥（48位）异或 48w-&gt;48位</span></span><br><span class="line">        <span class="function">string <span class="title">preRightXor</span><span class="params">(<span class="string">&quot;&quot;</span>)</span></span>; <span class="comment">//上一轮右的异或</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; preRightERep.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//注意：轮数计数从1开始，轮密钥的下标从0开始</span></span><br><span class="line">            <span class="keyword">if</span> (preRightERep[i] == <span class="keyword">this</span>-&gt;wheelKeys[wheelCount - <span class="number">1</span>][i]) <span class="comment">//相同为0</span></span><br><span class="line">            &#123;</span><br><span class="line">                preRightXor += <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//不同为&#x27;1&#x27;</span></span><br><span class="line">            &#123;</span><br><span class="line">                preRightXor += <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.3.4下一轮右：上一轮右的异或经S盒选择代替   48-&gt;32位</span></span><br><span class="line">        <span class="function">string <span class="title">preRightSBoxSeRep</span><span class="params">(<span class="string">&quot;&quot;</span>)</span></span>; <span class="comment">//上一轮右的S盒选择代替</span></span><br><span class="line">        <span class="type">int</span> sBoxCount = <span class="number">0</span>;            <span class="comment">// S盒计数</span></span><br><span class="line">        <span class="comment">//注意：S盒计数从0开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; preRightXor.<span class="built_in">size</span>();) <span class="comment">// i循环范围：0~47</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">string <span class="title">sBoxGroup</span><span class="params">(preRightXor.substr(i, <span class="number">6</span>))</span></span>; <span class="comment">// S盒组   一组从i开始取6位数</span></span><br><span class="line">            <span class="comment">//注意：substr()参数：开始下标，子串长度</span></span><br><span class="line"></span><br><span class="line">            string rowStr&#123;sBoxGroup[<span class="number">0</span>], sBoxGroup[<span class="number">5</span>]&#125;; <span class="comment">//行字符串：首尾2位</span></span><br><span class="line">            <span class="comment">//注意：初始化方式</span></span><br><span class="line">            <span class="type">int</span> rowNumber = <span class="built_in">stoi</span>(rowStr, <span class="number">0</span>, <span class="number">2</span>); <span class="comment">//行号</span></span><br><span class="line">            <span class="comment">//注意：stoi()参数：字符串，开始下标，字符串的基数</span></span><br><span class="line"></span><br><span class="line">            <span class="function">string <span class="title">colStr</span><span class="params">(sBoxGroup.substr(<span class="number">1</span>, <span class="number">4</span>))</span></span>; <span class="comment">//列字符串：中间4位</span></span><br><span class="line">            <span class="comment">//注意：初始化方式</span></span><br><span class="line">            <span class="type">int</span> colNumber = <span class="built_in">stoi</span>(colStr, <span class="number">0</span>, <span class="number">2</span>); <span class="comment">//列号</span></span><br><span class="line">            <span class="comment">//注意：stoi()参数：字符串，开始下标，字符串的基数</span></span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> pos = rowNumber * <span class="number">16</span> + colNumber; <span class="comment">//位置：第rowNumber行第colNumber列</span></span><br><span class="line">            <span class="comment">//注意：行数从0开始，列数从0开始</span></span><br><span class="line">            <span class="type">char</span> sBoxNumber = <span class="keyword">this</span>-&gt;sBoxSeRepTable[sBoxCount][pos]; <span class="comment">// S盒数</span></span><br><span class="line">            <span class="comment">//注意：</span></span><br><span class="line">            <span class="comment">// S盒计数从0开始   第0盒-&gt;S1</span></span><br><span class="line">            <span class="comment">// S盒数是char数据类型</span></span><br><span class="line"></span><br><span class="line">            preRightSBoxSeRep += <span class="built_in">bitset</span>&lt;<span class="number">4</span>&gt;(sBoxNumber).<span class="built_in">to_string</span>(); <span class="comment">// 1字节字符转4位字符串 字符-&gt;bitset对象-&gt;字符串</span></span><br><span class="line"></span><br><span class="line">            sBoxCount += <span class="number">1</span>; <span class="comment">// S盒计数+1</span></span><br><span class="line">            i += <span class="number">6</span>;         <span class="comment">//循环i+6</span></span><br><span class="line">            <span class="comment">// 注意：i变化范围：0~5，6~11，12~17，18...</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.3.5下一轮右：上一轮右置换P 32-&gt;32位</span></span><br><span class="line">        <span class="function">string <span class="title">preRightPRep</span><span class="params">(<span class="number">32</span>, <span class="string">&#x27;-&#x27;</span>)</span></span>; <span class="comment">//上一轮右的置换P</span></span><br><span class="line">        <span class="comment">//注意：因为需要使用下标赋值，所以需要初始化大小以预分配空间</span></span><br><span class="line">        <span class="comment">//注意：初始化为不是0或1的字符，以验证是否成功</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;pRepTable.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//置换规则：依据置换表，输入的第16位是输出的第1位-&gt;输入的第15位是输出的第0位</span></span><br><span class="line">            <span class="comment">//注意：下标从0开始</span></span><br><span class="line">            preRightPRep[i] = preRightSBoxSeRep[<span class="keyword">this</span>-&gt;pRepTable[i] - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.3.6下一轮右：上一轮右与上一轮左异或    32-&gt;32位</span></span><br><span class="line">        <span class="function">string <span class="title">preRightXor2</span><span class="params">(<span class="string">&quot;&quot;</span>)</span></span>; <span class="comment">//下一轮右的异或2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; preLeft.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (preRightPRep[i] == preLeft[i]) <span class="comment">//相同为0</span></span><br><span class="line">            &#123;</span><br><span class="line">                preRightXor2 += <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//不同为&#x27;1&#x27;</span></span><br><span class="line">            &#123;</span><br><span class="line">                preRightXor2 += <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">string <span class="title">nextRight</span><span class="params">(preRightXor2)</span></span>; <span class="comment">//下一轮右</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//注意：</span></span><br><span class="line">        <span class="comment">//循环外定义的变量可能需要更新</span></span><br><span class="line">        <span class="comment">//循环内定义的变量为局部变量，不需要更新，方便</span></span><br><span class="line">        preText = nextLeft + nextRight; <span class="comment">//更新上一轮文本</span></span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;明/密文的第&quot;</span> &lt;&lt; wheelCount &lt;&lt; <span class="string">&quot;轮输出：\t&quot;</span> &lt;&lt; preText &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    textWheelF = preText; <span class="comment">//文本的轮函数F为上一轮文本</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解密</span></span><br><span class="line"><span class="comment">//注意过程：</span></span><br><span class="line"><span class="comment">// 1.初始置换IP</span></span><br><span class="line"><span class="comment">// 2.轮函数F</span></span><br><span class="line"><span class="comment">// 3.左右置换</span></span><br><span class="line"><span class="comment">// 4.逆初始置换IP-1</span></span><br><span class="line"><span class="comment">//提示：因为通过重构解耦合，直接复用加密函数代码，修改变量名称和注释即可</span></span><br><span class="line"><span class="comment">//注意：</span></span><br><span class="line"><span class="comment">//加密的轮函数F中，使用轮密钥K1，K2...K16，轮函数下标0，1...15</span></span><br><span class="line"><span class="comment">//解密的轮函数F中，使用轮密钥K16，K15...K1，轮函数下标15，14...1</span></span><br><span class="line"><span class="comment">//所以，解密的轮密钥生成中，反向记录轮密钥，即可复用相同的轮函数函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DES::decrypt</span><span class="params">(<span class="type">const</span> string &amp;cipherTextASCII, <span class="type">const</span> string &amp;key, string &amp;plainTextASCII)</span> <span class="comment">//参数：密文的ASCII码，密钥，明文的ASCII码</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;解密过程：————————————————————&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对密文和密钥：</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;密钥：\t&quot;</span> &lt;&lt; key &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;cipherTextASCII = cipherTextASCII; <span class="comment">//记录密文的ASCII码</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;密文的ASCII码：\t&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;cipherTextASCII &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 0.初始化为二进制  8字节-&gt;64位</span></span><br><span class="line">    <span class="function">string <span class="title">keyASCII</span><span class="params">(<span class="string">&quot;&quot;</span>)</span></span>;                  <span class="comment">//密钥的ASCII码   64位</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">byteStrToBitStr</span>(key, keyASCII); <span class="comment">// 8字节字符串转64位字符串 依据ASCII码</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;keyASCII = keyASCII;            <span class="comment">//记录密钥的ASCII码</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;密钥的ASCII码：\t&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;keyASCII &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对密钥：</span></span><br><span class="line">    <span class="comment">// 1.密钥的选择置换 64-&gt;56位</span></span><br><span class="line">    <span class="function">string <span class="title">keySeRep</span><span class="params">(<span class="number">56</span>, <span class="string">&#x27;-&#x27;</span>)</span></span>; <span class="comment">//密钥的选择置换   56位</span></span><br><span class="line">    <span class="comment">//注意：因为需要使用下标赋值，所以需要初始化大小以预分配空间</span></span><br><span class="line">    <span class="comment">//注意：初始化为不是0或1的字符，以验证是否成功</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;keySeRepTable.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//置换规则：依据置换表，输入的第57位是输出的第1位-&gt;输入的第56位是输出的第0位</span></span><br><span class="line">        <span class="comment">//注意：下标从0开始</span></span><br><span class="line">        keySeRep[i] = <span class="keyword">this</span>-&gt;keyASCII[<span class="keyword">this</span>-&gt;keySeRepTable[i] - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;密钥的选择置换：\t&quot;</span> &lt;&lt; keySeRep &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.轮密钥生成</span></span><br><span class="line">    <span class="comment">//注意：预先生成</span></span><br><span class="line">    <span class="function">string <span class="title">preKey</span><span class="params">(keySeRep)</span></span>;  <span class="comment">//上一轮密钥 56位</span></span><br><span class="line">    <span class="function">string <span class="title">nextKey</span><span class="params">(<span class="string">&quot;&quot;</span>)</span></span>;       <span class="comment">//下一轮密钥 56位</span></span><br><span class="line">    <span class="function">string <span class="title">wheelKey</span><span class="params">(<span class="number">48</span>, <span class="string">&#x27;-&#x27;</span>)</span></span>; <span class="comment">//轮密钥 48位</span></span><br><span class="line">    <span class="comment">//注意：因为需要使用下标赋值，所以需要初始化大小以预分配空间</span></span><br><span class="line">    <span class="comment">//注意：初始化为不是0或1的字符，以验证是否成功</span></span><br><span class="line">    <span class="comment">//提示：</span></span><br><span class="line">    <span class="comment">//在循环外而不是循环中声明并初始化/定义对象，避免重复进行对象的构造和析构，减少开销</span></span><br><span class="line">    <span class="comment">//但可读性差</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 16轮轮函数</span></span><br><span class="line">    <span class="comment">//注意：轮数从1开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> wheelCount = <span class="number">1</span>; wheelCount &lt;= <span class="number">16</span>; ++wheelCount) <span class="comment">//轮数计数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//轮密钥生成</span></span><br><span class="line">        <span class="comment">//参数：上一轮密钥（56位），轮数（从1开始），下一轮密钥（56位），轮密钥（48位）</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">wheelKeyGener</span>(preKey, wheelCount, nextKey, wheelKey);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录轮密钥</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;wheelKeys[<span class="number">16</span> - wheelCount] = wheelKey;</span><br><span class="line">        <span class="comment">//注意：轮数从1开始，轮密钥下标从15开始</span></span><br><span class="line">        <span class="comment">//注意：记录轮密钥（48位）而不是下一轮密钥（56位）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//注意：</span></span><br><span class="line">        <span class="comment">//循环外定义的变量可能需要更新</span></span><br><span class="line">        <span class="comment">//循环内定义的变量为局部变量，不需要更新，方便</span></span><br><span class="line">        preKey = nextKey; <span class="comment">//更新上一轮密钥 56位</span></span><br><span class="line">        nextKey = <span class="string">&quot;&quot;</span>;     <span class="comment">//更新下一轮密钥 56位</span></span><br><span class="line">        <span class="comment">//轮密钥每轮都通过下标填充，不需要更新</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对密文：</span></span><br><span class="line">    <span class="comment">// 1.初始置换IP 64-&gt;64位</span></span><br><span class="line">    <span class="function">string <span class="title">cipherTextIp</span><span class="params">(<span class="number">64</span>, <span class="string">&#x27;-&#x27;</span>)</span></span>; <span class="comment">//密文的初始置换IP   64位</span></span><br><span class="line">    <span class="comment">//注意：因为需要使用下标赋值，所以需要初始化大小以预分配空间</span></span><br><span class="line">    <span class="comment">//注意：初始化为不是0或1的字符，以验证是否成功</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;ipTable.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//置换规则：依据置换表，输入的第58位是输出的第1位-&gt;输入的第57位是输出的第0位</span></span><br><span class="line">        <span class="comment">//注意：下标从0开始</span></span><br><span class="line">        cipherTextIp[i] = <span class="keyword">this</span>-&gt;cipherTextASCII[<span class="keyword">this</span>-&gt;ipTable[i] - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//注意：忘记修改this-&gt;plain为cipher了...</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;密文的初始置换IP：\t&quot;</span> &lt;&lt; cipherTextIp &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.轮函数F</span></span><br><span class="line">    <span class="function">string <span class="title">cipherTextWheelF</span><span class="params">(<span class="string">&quot;&quot;</span>)</span></span>; <span class="comment">//密文的轮函数  64位</span></span><br><span class="line">    <span class="built_in">wheelFunc</span>(cipherTextIp, keySeRep, cipherTextWheelF);</span><br><span class="line">    <span class="comment">//参数：密文的初始置换IP，密钥的选择置换，密文的轮函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;密文的轮函数F：\t&quot;</span> &lt;&lt; cipherTextWheelF &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.左右置换/轮函数F的第16轮不进行左右置换 64-&gt;64位</span></span><br><span class="line">    <span class="function">string <span class="title">left</span><span class="params">(cipherTextWheelF.substr(<span class="number">0</span>, <span class="number">32</span>))</span></span>;   <span class="comment">//左 范围：0~31</span></span><br><span class="line">    <span class="function">string <span class="title">right</span><span class="params">(cipherTextWheelF.substr(<span class="number">32</span>, <span class="number">32</span>))</span></span>; <span class="comment">//右 范围：32~63</span></span><br><span class="line">    string cipherTextLeRiRep = right + left;       <span class="comment">//密文的左右置换</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;密文的左右置换：\t&quot;</span> &lt;&lt; cipherTextLeRiRep &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.逆初始置换IP-1 64-&gt;64位</span></span><br><span class="line">    <span class="function">string <span class="title">cipherTextIIp</span><span class="params">(<span class="number">64</span>, <span class="string">&#x27;-&#x27;</span>)</span></span>; <span class="comment">//密文的逆初始置换IP-1</span></span><br><span class="line">    <span class="comment">//注意：因为需要使用下标赋值，所以需要初始化大小以预分配空间</span></span><br><span class="line">    <span class="comment">//注意：初始化为不是0或1的字符，以验证是否成功</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;iIpTable.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//置换规则：依据置换表，输入的第40位是输出的第1位-&gt;输入的第39位是输出的第0位</span></span><br><span class="line">        <span class="comment">//注意：下标从0开始</span></span><br><span class="line">        cipherTextIIp[i] = cipherTextLeRiRep[<span class="keyword">this</span>-&gt;iIpTable[i] - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;密文的逆初始置换IP-1：\t&quot;</span> &lt;&lt; cipherTextIIp &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;plainTextASCII = cipherTextIIp; <span class="comment">//记录明文的ASCII码   明文的ASCII码为密文的逆初始置换IP-1</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;明文的ASCII码：\t&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;plainTextASCII &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    plainTextASCII = cipherTextIIp; <span class="comment">//记录结果   明文的ASCII码为密文的逆初始置换IP-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a>main.cpp</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//预处理指令——————————</span></span><br><span class="line"><span class="comment">//自定义头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;des.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数声明——————————</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">compareStrBit</span><span class="params">(string str1, string str2)</span></span>; <span class="comment">//比较两字符串不同的位数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数——————————</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DES *des = <span class="keyword">new</span> <span class="built_in">DES</span>(); <span class="comment">//数据加密标准对象</span></span><br><span class="line">    <span class="comment">//提示：</span></span><br><span class="line">    <span class="comment">//复杂类型/自定义类型可能占用空间大，堆区比栈区大，需要在堆区手动管理</span></span><br><span class="line">    <span class="comment">//手动管理：使用new创建对象，使用delete释放对象-&gt;搭配使用</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> string <span class="title">plainText</span><span class="params">(<span class="string">&quot;yezhenin&quot;</span>)</span></span>; <span class="comment">//明文</span></span><br><span class="line">    <span class="function"><span class="type">const</span> string <span class="title">key</span><span class="params">(<span class="string">&quot;91002705&quot;</span>)</span></span>;       <span class="comment">//密钥</span></span><br><span class="line">    <span class="function">string <span class="title">cipherTextASCII</span><span class="params">(<span class="string">&quot;&quot;</span>)</span></span>;         <span class="comment">//密文的ASCII码</span></span><br><span class="line">    <span class="comment">//提示：</span></span><br><span class="line">    <span class="comment">//密文的ASCII码没有必要转换为字符，因为：</span></span><br><span class="line">    <span class="comment">// 1.转换的字符无意义</span></span><br><span class="line">    <span class="comment">// 2.转换的字符可能为非打印字符</span></span><br><span class="line">    <span class="function">string <span class="title">plainTextASCII</span><span class="params">(<span class="string">&quot;&quot;</span>)</span></span>; <span class="comment">//明文的ASCII码</span></span><br><span class="line"></span><br><span class="line">    des-&gt;<span class="built_in">encrypt</span>(plainText, key, cipherTextASCII); <span class="comment">//加密</span></span><br><span class="line">    <span class="comment">//参数：明文（已知），密钥（已知），密文的ASCII码（未知）</span></span><br><span class="line"></span><br><span class="line">    des-&gt;<span class="built_in">decrypt</span>(cipherTextASCII, key, plainTextASCII); <span class="comment">//解密</span></span><br><span class="line">    <span class="comment">//参数：密文的ASCII码（已知），密钥（已知），明文的ASCII码（未知）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//字符转ASCII码转换器网址：https://www.qqxiuzi.cn/bianma/ascii.htm</span></span><br><span class="line">    <span class="comment">// ASCII码转字符转换器网址：https://www.asciim.cn/m/tools/convert_ascii_to_string.html</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//雪崩效应测试</span></span><br><span class="line">    <span class="comment">//提示：</span></span><br><span class="line">    <span class="comment">//由设计接口：测试明文变化需要考虑到字节层面，传递明文参数；测试密文变化需要考虑到位层面，传递密文的ASCII码参数</span></span><br><span class="line">    <span class="comment">//因为加密和解密过程相似，所以变化密文进行测试</span></span><br><span class="line"></span><br><span class="line">    string cipherTextCo = <span class="string">&quot;0000110101111001101000001011100001101001111000010100000001011011&quot;</span>; <span class="comment">//密文正确码</span></span><br><span class="line">    string plainTextCo = <span class="string">&quot;0111100101100101011110100110100001100101011011100110100101101110&quot;</span>;  <span class="comment">//明文正确码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一组</span></span><br><span class="line">    string cipherTextEr = cipherTextCo;           <span class="comment">//密文错误码为密文正确码</span></span><br><span class="line">    cipherTextEr[<span class="number">0</span>] = <span class="number">1</span>;                          <span class="comment">//修改1位：0-&gt;1</span></span><br><span class="line">    <span class="function">string <span class="title">plainTextEr</span><span class="params">(<span class="string">&quot;&quot;</span>)</span></span>;                       <span class="comment">//明文错误码</span></span><br><span class="line">    des-&gt;<span class="built_in">decrypt</span>(cipherTextEr, key, plainTextEr); <span class="comment">//解密</span></span><br><span class="line">    <span class="comment">//参数：密文错误码（已知），密钥（已知），明文错误码（未知）</span></span><br><span class="line">    <span class="built_in">compareStrBit</span>(plainTextCo, plainTextEr); <span class="comment">//比较两字符串不同的位数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二组</span></span><br><span class="line">    cipherTextEr = cipherTextCo;                  <span class="comment">//密文错误码为密文正确码</span></span><br><span class="line">    cipherTextEr[<span class="number">0</span>] = <span class="number">1</span>;                          <span class="comment">//修改1位：0-&gt;1</span></span><br><span class="line">    cipherTextEr[<span class="number">63</span>] = <span class="number">0</span>;                         <span class="comment">//修改1位：1-&gt;0</span></span><br><span class="line">    plainTextEr = <span class="string">&quot;&quot;</span>;                             <span class="comment">//明文错误码</span></span><br><span class="line">    des-&gt;<span class="built_in">decrypt</span>(cipherTextEr, key, plainTextEr); <span class="comment">//解密</span></span><br><span class="line">    <span class="comment">//参数：密文错误码（已知），密钥（已知），明文错误码（未知）</span></span><br><span class="line">    <span class="built_in">compareStrBit</span>(plainTextCo, plainTextEr); <span class="comment">//较两字符串不同的位数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三组</span></span><br><span class="line">    cipherTextEr = cipherTextCo;                  <span class="comment">//密文错误码为密文正确码</span></span><br><span class="line">    cipherTextEr[<span class="number">0</span>] = <span class="number">1</span>;                          <span class="comment">//修改1位：0-&gt;1</span></span><br><span class="line">    cipherTextEr[<span class="number">1</span>] = <span class="number">1</span>;                          <span class="comment">//修改1位：0-&gt;1</span></span><br><span class="line">    cipherTextEr[<span class="number">63</span>] = <span class="number">0</span>;                         <span class="comment">//修改1位：1-&gt;0</span></span><br><span class="line">    plainTextEr = <span class="string">&quot;&quot;</span>;                             <span class="comment">//明文错误码</span></span><br><span class="line">    des-&gt;<span class="built_in">decrypt</span>(cipherTextEr, key, plainTextEr); <span class="comment">//解密</span></span><br><span class="line">    <span class="comment">//参数：密文错误码（已知），密钥（已知），明文错误码（未知）</span></span><br><span class="line">    <span class="built_in">compareStrBit</span>(plainTextCo, plainTextEr); <span class="comment">//较两字符串不同的位数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> des;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//比较两字符串不同的位数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">compareStrBit</span><span class="params">(string str1, string str2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> diffBitCount = <span class="number">0</span>; <span class="comment">//不同位计数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str<span class="number">1.</span><span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (str1[i] != str2[i])</span><br><span class="line">        &#123;</span><br><span class="line">            ++diffBitCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;不同位数：\t&quot;</span> &lt;&lt; diffBitCount &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h2><p><img src="/../img/des/989e73190b27409980f15ae2e56b5afe.png" alt="在这里插入图片描述"></p><hr><h2 id="解密过程"><a href="#解密过程" class="headerlink" title="解密过程"></a>解密过程</h2><p><img src="/../img/des/a1c357d0ea38425689fd7e7d8198e21a.png" alt="在这里插入图片描述"></p><hr><h2 id="雪崩效应"><a href="#雪崩效应" class="headerlink" title="雪崩效应"></a>雪崩效应</h2><ul><li>修改密文的1位，解密的错误明文与正确明文的不同位数为35：</li></ul><p><img src="/../img/des/2b7dfe4cb19242579b8cc85fa048fe10.png" alt="在这里插入图片描述"></p><ul><li>修改密文的2位，解密的错误明文与正确明文的不同位数为31：</li></ul><p><img src="/../img/des/9babad9d064f4cf1b1b006154b65934f.png" alt="在这里插入图片描述"></p><ul><li>修改密文的3位，解密的错误明文与正确明文的不同位数为30：</li></ul><p><img src="/../img/des/f1ce3d366265441c93bcf45ec203f513.png" alt="在这里插入图片描述"></p><p>分析：</p><ul><li><p>明文和密钥&#x2F;密文的一位发生变化会导致密文&#x2F;明文的多位发生变化</p></li><li><p>明文&#x2F;密文发生变化的位数近似为明文&#x2F;密文的二分之一（64÷2&#x3D;32位）</p></li><li><p>数据加密标准（DES）满足雪崩效应，强度高</p></li></ul><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>网络安全中数据加密标准（DES）的C++语言描述实现。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《密码编码学与网络安全——原理与实践(第五版)》作者：William Stallings</li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“图”学习提纲</title>
      <link href="/2022/10/19/%E2%80%9C%E5%9B%BE%E2%80%9D%E5%AD%A6%E4%B9%A0%E6%8F%90%E7%BA%B2/"/>
      <url>/2022/10/19/%E2%80%9C%E5%9B%BE%E2%80%9D%E5%AD%A6%E4%B9%A0%E6%8F%90%E7%BA%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>“图”学习提纲。</p><hr><h1 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h1><ul><li><a href="https://blog.csdn.net/m0_62083249/article/details/127380018">图的C++语言描述实现模板_夜悊的博客-CSDN博客</a></li></ul><hr><h1 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h1><p>依据相关定义：</p><ul><li>图：点，边</li></ul><blockquote><p>注意：图不可以为空图。即必须有点（有穷非空），不必须有边</p></blockquote><ul><li>无向图，有向图：无向边，有向边&#x2F;弧：弧尾，弧头</li><li>简单图，多重图</li></ul><blockquote><p>数据结构中一般讨论简单图：不存在顶点到自身的边，不存在重复的边</p></blockquote><ul><li>完全图：无向完全图，有向完全图</li></ul><blockquote><p>无向完全图：边数为n(n-1)&#x2F;2。n为点数<br>有向完全图：边数为n(n-1)。n为点数</p></blockquote><ul><li>稀疏图，稠密图</li></ul><blockquote><p>稀疏和稠密是相对而言的模糊概念</p></blockquote><ul><li><p>带权图&#x2F;网：权</p></li><li><p>子图：生成子图</p></li></ul><p>依据点与边的关系：</p><ul><li>点的度，入度，出度</li></ul><blockquote><p>对无向图：点的度的和&#x3D;边数×2<br>对有向图：点的入度的和&#x3D;点的出度的和&#x3D;边数；度&#x3D;入度+出度</p></blockquote><ul><li><p>有向树</p></li><li><p>路径，路径长度，回路&#x2F;环：简单路径，简单回路&#x2F;环，最短路径&#x2F;距离</p></li></ul><blockquote><p>若图有n个点，大于n-1条边，则存在回路</p></blockquote><ul><li>连通，连通图，非连通图，极大连通子图&#x2F;连通分量</li></ul><blockquote><p> 若图有n个点，小于n-1条边，则为非连通图</p></blockquote><ul><li>强连通，强连通图，强非连通图，极大强连通子图&#x2F;强连通分量</li></ul><blockquote><p>注意：对无向图，为连通性；对有向图，为强连通性</p></blockquote><ul><li>极小连通子图&#x2F;生成树，生成森林</li></ul><blockquote><p>图的生成树有n-1条边，有n-1条边不一定是图的生成树。n为点数</p></blockquote><hr><h1 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h1><h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p>类型：顺序存储结构</p><p>组成：</p><ul><li>点数</li><li>边数</li><li>点一维数组：存储点数据</li><li>边二维数组：存储数值，可存储权值</li></ul><p>创建的时间复杂度：</p><ul><li>O(v²)。v为点数</li><li>O(v+v²+e) 。v为点数，e为边数。v为初始化点一维数组，v²为初始化边二维数组，e为给边赋值</li></ul><p>空间复杂度：</p><ul><li>O(v²)。v为点数</li><li>O(v+v²)。v为点数。v为点一维数组，v²为边二维数组</li></ul><p>适用：稠密图</p><p>相关性质：</p><ul><li>无向图：对称（可压缩存储上&#x2F;下三角元素）；<strong>有效数值</strong>（如“1”表示点间存在边）数为边数的两倍；第i行或第i列的元素和为点i的度</li><li>有向图：不对称；有效数值数为边数；第i<strong>行</strong>的元素和为点i的<strong>出</strong>度，第i<strong>列</strong>的元素和为点i的<strong>入</strong>度</li><li>求点间是否有边：O(1)（依据点数据&#x2F;下标取值）</li><li>求点的邻边&#x2F;邻接点：O(v)。v为点数（遍历点数据所在的一行）</li><li>有权图：点到点有路径，数值为权值；点到<strong>当前点</strong>无路径，数值为0；点到<strong>其他点</strong>无路径，数值为无穷大</li><li>存在邻接矩阵A，A的n次方的元素：A的n次方[i][j]&#x3D;点i到点j中，长度为n的路径数</li><li>邻接矩阵唯一</li></ul><hr><h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><p>类型：顺序和链式存储结构；关注点</p><p>组成：</p><ul><li>点数</li><li>边数</li><li>点表：顺序存储结构；一维数组；单链表的头结点：存储点数据（<strong>当前点</strong>）和<strong>当前点</strong>指向第一个<strong>边结点</strong>的指针</li><li>（出）边表：链式存储结构；单链表；单链表的非头结点：存储点数据（<strong>其他邻接点</strong>）和<strong>当前点</strong>指向其他边结点的指针，可存储权值</li></ul><p>创建的时间复杂度：</p><ul><li>O(v+e) 。v为点数，e为边数。v为初始化点表，e为初始化边表</li></ul><p>空间复杂度：</p><ul><li>无向图：O(v+2e)。v为点数，e为边数</li><li>有向图：O(v+e)。v为点数，e为边数</li></ul><p>适用：稀疏图</p><p>相关性质：</p><ul><li>求点的出度：遍历该点的链表</li><li>求点的入度：遍历所有点的链表；使用逆邻接表</li><li>求点间是否有边：O(v)。v为<strong>其他邻接点</strong>数。（遍历该点的链表）</li><li>求点的邻边&#x2F;邻接点：O(v)。v为其他邻接点数。（遍历该点的链表）</li><li>邻接表不唯一</li></ul><hr><h2 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h2><p>类型：无向图的顺序和链式存储结构；关注边</p><p>组成：</p><ul><li>点表：顺序存储结构；单链表的头结点；存储点数据（<strong>当前点</strong>）和<strong>当前点</strong>指向第一个<strong>边结点</strong>的指针</li><li>边表：链式存储结构；单链表的非头结点；存储标志（可标记该边是否被搜索过），点i数据，点i（<strong>当前点</strong>）指向其他边结点的指针，点j数据（<strong>其他点</strong>），点j指向其他边结点的指针（<strong>“多重”的体现</strong>），可存储权值</li></ul><p>空间复杂度：</p><ul><li>无向图：O(v+2e)。v为点数，e为边数</li></ul><p>相关性质：</p><ul><li>易插入或删除边（相比于邻接表操作多个边结点，只需操作一个边结点）</li></ul><hr><h2 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h2><p>类型：有向图的顺序和链式存储结构</p><p>组成：</p><ul><li>点表：顺序存储结构；单链表的头结点；存储点数据（<strong>当前点</strong>），以<strong>当前点</strong>为<strong>弧头</strong>的第一个<strong>边结点</strong>的指针，以<strong>当前点</strong>为<strong>弧尾</strong>的第一个边结点的指针</li><li>边表：链式存储结构；单链表的非头结点；<strong>弧尾</strong>点（<strong>当前点</strong>）数据，<strong>弧头</strong>点（<strong>其他点</strong>）数据，<strong>弧尾</strong>点（<strong>当前点</strong>）指向<strong>弧头</strong>相同的边结点的指针，<strong>弧头</strong>点（<strong>其他点</strong>）指向<strong>弧尾</strong>相同的边结点的指针，可存储权值</li></ul><p>创建的时间复杂度：</p><ul><li>O(v+e) 。v为点数，e为边数。v为初始化点表，e为初始化边表</li></ul><p>空间复杂度：</p><ul><li>有向图：O(v+e)。v为点数，e为边数</li></ul><p>相关性质：</p><ul><li>易求点的入度和出度</li><li>图的十字链表不唯一，十字链表唯一确定图</li></ul><hr><h2 id="边集数组"><a href="#边集数组" class="headerlink" title="边集数组"></a>边集数组</h2><p>类型：顺序存储结构；关注边</p><p>组成：</p><ul><li>点一维数组：存储点数据</li><li>边一维数组：存储点（<strong>起点</strong>）数据，存储点（<strong>终点</strong>）数据，可存储权值</li></ul><p>相关性质：</p><ul><li>求点的度：遍历边一维数组</li><li>适合依次操作边，不适合操作点</li></ul><hr><h1 id="图的遍历算法"><a href="#图的遍历算法" class="headerlink" title="图的遍历算法"></a>图的遍历算法</h1><h2 id="深度优先遍历（DFS）概述"><a href="#深度优先遍历（DFS）概述" class="headerlink" title="深度优先遍历（DFS）概述"></a>深度优先遍历（DFS）概述</h2><ul><li>类似二叉树先序遍历</li><li>是递归过程</li><li>图的邻接矩阵唯一，广度优先遍历序列唯一；图的邻接表不唯一，广度优先遍历序列不唯</li><li>保留遍历的边，删除未遍历的边，可形成<strong>深度优先遍历生成树</strong>（对连通图）或<strong>深度优先遍历生成森林</strong>（对非连通图）</li></ul><hr><h2 id="深度优先遍历（DFS）的过程"><a href="#深度优先遍历（DFS）的过程" class="headerlink" title="深度优先遍历（DFS）的过程"></a>深度优先遍历（DFS）的过程</h2><ol><li>初始化标记数组（空间复杂度：O(v)。v为点数）</li><li>循环遍历点表，标记每点为未访问 </li><li>循环遍历点表，若点的标记为未访问，则深度优先遍历图g，从点v开始（连通图执行一次，非连通图执行多次。<strong>非连通无向图</strong>执行<strong>连通分量</strong>数次，<strong>非强连通有向图</strong>的<strong>非强连通分量</strong>不一定能遍历所有点）</li><li>深度优先遍历g，从v开始</li><li>访问v（二叉树先序遍历的体现）</li><li>标记v已访问</li><li>循环获取v的<strong>邻接</strong>点w</li><li>循环中，若w的标记为未访问，则深度优先遍历g，从w开始（递归的体现）</li></ol><p>时间复杂度：依据存储结构</p><ul><li>对邻接矩阵：遍历点数×查找每点的邻接点的时间&#x3D;O(v×v)&#x3D;O(v²)。v为点数（理解：遍历每一行）</li><li>对邻接表：遍历点数+查找每点的邻接点的时间&#x3D;O(v+e)。v为点数，e为边数（理解：遍历点表和边表，因为是链式存储结构）</li></ul><p>空间复杂度：O(v)。v为点数&#x2F;辅助空间规模&#x2F;递归栈规模</p><p>伪代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> visited[MAX_VERTEX_NUM];<span class="comment">//访问标记数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFSTraverse</span><span class="params">(Graph G)</span></span>&#123;<span class="comment">//对图G进行深度优先遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> v=<span class="number">0</span>;v&lt;G.vexnum;++v)</span><br><span class="line">visited[v] = FALSE;<span class="comment">//初始化已访问标记数据</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> v=<span class="number">0</span>;v&lt;G.vexnum;++v)<span class="comment">//本代码是从v=0开始遍历</span></span><br><span class="line"><span class="keyword">if</span>(!visited[v])</span><br><span class="line"><span class="built_in">DFS</span>(G,v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(Graph G,<span class="type">int</span> v)</span></span>&#123;<span class="comment">//从顶点v出发，深度优先遍历图G</span></span><br><span class="line"><span class="built_in">visit</span>(v);<span class="comment">//访问顶点v</span></span><br><span class="line">visited[v] = TRUE;<span class="comment">//设已访问标记</span></span><br><span class="line"><span class="keyword">for</span>(w = <span class="built_in">FirstNeighbor</span>(G,v);w&gt;=<span class="number">0</span>;w=<span class="built_in">NextNeighbor</span>(G,v,w))</span><br><span class="line"><span class="keyword">if</span>(!visited[w])&#123;<span class="comment">//w为v的尚未访问的邻接顶点</span></span><br><span class="line"><span class="built_in">DFS</span>(G,w);</span><br><span class="line">&#125;<span class="comment">//if</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="广度优先遍历（BFS）概述"><a href="#广度优先遍历（BFS）概述" class="headerlink" title="广度优先遍历（BFS）概述"></a>广度优先遍历（BFS）概述</h2><ul><li>类似二叉树层序遍历</li><li>是迭代过程</li><li>图的邻接矩阵唯一，广度优先遍历序列唯一；图的邻接表不唯一，广度优先遍历序列不唯一</li><li>保留遍历的边，删除未遍历的边，可形成<strong>广度优先遍历生成树</strong>（对连通图）或<strong>广度优先遍历生成森林</strong>（对非连通图）</li><li>类似迪杰斯特拉（Dijkstra）单源最短路径算法</li><li>类似普里姆（Prim）最小生成树算法</li></ul><hr><h2 id="广度优先遍历（BFS）的过程"><a href="#广度优先遍历（BFS）的过程" class="headerlink" title="广度优先遍历（BFS）的过程"></a>广度优先遍历（BFS）的过程</h2><ol><li>初始化标记数组（空间复杂度：O(v)。v为点数）</li><li>循环遍历点表，标记每点为未访问 </li><li>初始化队列（空间复杂度：O(v)。v为点数）</li><li>循环遍历点表，若点的标记为未访问，则广度优先遍历图g，从点v开始（连通图执行一次，非连通图执行多次。<strong>非连通无向图</strong>执行<strong>连通分量</strong>数次，<strong>非强连通有向图</strong>的<strong>非强连通分量</strong>不一定能遍历所有点）</li><li>广度优先遍历g，从v开始</li><li>访问v</li><li>标记v已访问</li><li>v入队</li><li>当队列不为空时，循环</li><li>循环中，获取v的<strong>所有邻接</strong>点w（迭代的体现）</li><li>循环中，若w的标记为未访问，则访问w，标记w已访问，w入队（二叉树层序遍历的体现）</li></ol><p>时间复杂度：依据存储结构</p><ul><li>对邻接矩阵：遍历点数×查找每点的邻接点的时间&#x3D;O(v×v)&#x3D;O(v²)。v为点数（理解：遍历每一行）</li><li>对邻接表：遍历点数+查找每点的邻接点的时间&#x3D;O(v+e)。v为点数，e为边数（理解：遍历点表和边表，因为是链式存储结构）</li></ul><p>空间复杂度：O(v)。v为点数&#x2F;辅助空间规模</p><p>伪代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> visited[MAX_VERTEX_NUM];<span class="comment">//访问标记数组</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BFSTraverse</span><span class="params">(Graph G)</span></span>&#123;<span class="comment">//对图G进行广度优先遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;++i)</span><br><span class="line">visited[i] = FALSE;<span class="comment">//访问标记数组初始化</span></span><br><span class="line"><span class="built_in">InitQueue</span>(Q);<span class="comment">//初始化辅助队列Q</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;++i)&#123;<span class="comment">//从0号顶点开始遍历</span></span><br><span class="line"><span class="keyword">if</span>(!visited[i])<span class="comment">//对每个连通分量调用一次BFS</span></span><br><span class="line"><span class="built_in">BFS</span>(G,i);<span class="comment">//vi未访问过，从vi开始BFS</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(Graph G,<span class="type">int</span> v)</span></span>&#123;<span class="comment">//从顶点v出发，广度优先遍历图G</span></span><br><span class="line"><span class="built_in">visit</span>(v);<span class="comment">//访问初始顶点v</span></span><br><span class="line">visited[v] = TRUE;<span class="comment">//对v做已访问标记</span></span><br><span class="line"><span class="built_in">EnQueue</span>(Q,v);<span class="comment">//顶点v入队列Q </span></span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isEmpty</span>(Q))&#123;</span><br><span class="line"><span class="built_in">DeQueue</span>(Q,v);<span class="comment">//顶点v出队列 </span></span><br><span class="line"><span class="keyword">for</span>(w = <span class="built_in">FirstNeighbor</span>(G,v);w&gt;=<span class="number">0</span>;w=<span class="built_in">NextNeighbor</span>(G,v,w))</span><br><span class="line"><span class="comment">//检测v所有邻接点</span></span><br><span class="line"><span class="keyword">if</span>(!visited[w])&#123;<span class="comment">//w为v的尚未访问的邻接顶点 </span></span><br><span class="line">visit[w];<span class="comment">//访问顶点w </span></span><br><span class="line">visited[w] = TRUE;<span class="comment">//对w做已访问标记</span></span><br><span class="line"><span class="built_in">EnQueue</span>(Q,w);<span class="comment">//顶点w入队列 </span></span><br><span class="line">&#125;<span class="comment">//if</span></span><br><span class="line">&#125;<span class="comment">//while</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="图的应用"><a href="#图的应用" class="headerlink" title="图的应用"></a>图的应用</h1><h2 id="最小（代价）生成树概述"><a href="#最小（代价）生成树概述" class="headerlink" title="最小（代价）生成树概述"></a>最小（代价）生成树概述</h2><p>概念：</p><ul><li>对连通图</li><li>是极小连通子图</li><li>有图的<strong>所有</strong>点，<strong>尽量少</strong>的边</li><li>若少一条边，则成非连通图；若多一条边，则存在回路</li></ul><p>性质：</p><ul><li>边数&#x3D;点数-1</li><li><strong>树形</strong>不唯一。若图中各边权值不相等，则唯一；若图中存在相等权值的边，构造时都被加入树中，则唯一</li><li>边权值的和唯一且最小</li></ul><p>构造算法：基于贪心思想；对无向图</p><ul><li>普里姆（Prim）算法</li><li>克鲁斯卡尔（Kruskal）算法</li></ul><p>构造算法的伪代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">GENERIC <span class="title">MST</span><span class="params">(G)</span></span>&#123;</span><br><span class="line">T=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> T未形成一棵生成树；</span><br><span class="line"><span class="keyword">do</span> 找到一条最小代价边(u,v)并且加入T后不会产生回路；</span><br><span class="line">T=T∪(u,v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="最小（代价）生成树的普里姆（Prim）算法"><a href="#最小（代价）生成树的普里姆（Prim）算法" class="headerlink" title="最小（代价）生成树的普里姆（Prim）算法"></a>最小（代价）生成树的普里姆（Prim）算法</h2><p>概述：</p><ul><li>类似图的最短路径的迪杰斯特拉（Dijkstra）算法</li><li><strong>对点</strong></li></ul><p>过程：<strong>选边加点加边</strong></p><ol><li>加点</li><li>加候选边</li><li>依据代价，<strong>从候选边中选边</strong>（每次构造一定为连通图）</li><li>依据所选边，加点</li><li>依据所加点，加候选边</li><li>重复345步，<strong>直到加入所有点</strong>（执行n-1次，n为点数）</li></ol><p>伪代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Prim</span><span class="params">(G,T)</span></span>&#123;</span><br><span class="line">T=空集;<span class="comment">//初始化空树</span></span><br><span class="line">U=&#123;w&#125;;<span class="comment">//添加任一顶点w </span></span><br><span class="line"><span class="keyword">while</span>((V-U)!=空集)&#123;<span class="comment">//若树中不含全部顶点</span></span><br><span class="line">设(u,v)是使u属于U与v属于(V-U),且权值最小的边；</span><br><span class="line">T=T∪&#123;(u,v)&#125;<span class="comment">//边归入树</span></span><br><span class="line">U=U∪&#123;v&#125;;<span class="comment">//顶点归入树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n²)。n为点数</p><p>空间复杂度：O(n)。n为点数。辅助空间记录标记已访问点和候选边</p><p>适用：边稠密图</p><hr><h2 id="最小（代价）生成树的克鲁斯卡尔（Kruskal）算法"><a href="#最小（代价）生成树的克鲁斯卡尔（Kruskal）算法" class="headerlink" title="最小（代价）生成树的克鲁斯卡尔（Kruskal）算法"></a>最小（代价）生成树的克鲁斯卡尔（Kruskal）算法</h2><p>概述：</p><ul><li><strong>对边</strong></li></ul><p>过程：<strong>加边加点</strong>；合并点&#x2F;连通分量&#x2F;树</p><ol><li>依据代价，排序边</li><li>依据代价，从小到大遍历边</li><li><strong>若边为候选边</strong>，则加边（每次构造不一定为连通图）</li><li>依据所加边，<strong>若点为候选点</strong>，则加点，否则不加边不加点并转2</li><li>重复234步，<strong>直到直到加入n-1条边。n为点数&#x2F;所有点在一个连通分量</strong></li></ol><blockquote><p>若边为候选边和若点为候选点的另一种描述：若加边不构成回路，则加边加点，否则不加边不加点并转2</p></blockquote><p>伪代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Kruskal</span><span class="params">(V,T)</span></span>&#123;</span><br><span class="line">T=V;<span class="comment">//初始化树T，仅含顶点</span></span><br><span class="line">numS=n;<span class="comment">//连通分量数</span></span><br><span class="line"><span class="keyword">while</span>(numS&gt;<span class="number">1</span>)&#123;<span class="comment">//若连通分量数大于1 </span></span><br><span class="line">从E中取出权值最小的边(v,u);</span><br><span class="line"><span class="keyword">if</span>(v和u属于T中不同的连通分量)&#123;</span><br><span class="line">T=T∪&#123;(v,u)&#125;;<span class="comment">//将此边加入生成树中</span></span><br><span class="line">numS--;<span class="comment">//连通分量数减1 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：排序算法中常用堆排序，堆存储边：O(eloge)。e为边数</p><p>空间复杂度：O(n)。n为点数。辅助空间并查集记录点的树型结构</p><p>适用：边稀疏点稠密图&#x2F;稀疏图</p><hr><h2 id="最短路径概述"><a href="#最短路径概述" class="headerlink" title="最短路径概述"></a>最短路径概述</h2><p>概念：</p><ul><li>对带权图</li><li>带权路径长度最短的路径</li></ul><p>算法：</p><ul><li>迪杰斯特拉（Dijkstra）算法</li><li>弗洛伊德（Floyd）算法</li></ul><hr><h2 id="最短路径的迪杰斯特拉（Dijkstra）算法"><a href="#最短路径的迪杰斯特拉（Dijkstra）算法" class="headerlink" title="最短路径的迪杰斯特拉（Dijkstra）算法"></a>最短路径的迪杰斯特拉（Dijkstra）算法</h2><p>概述：</p><ul><li>类似图的最小（代价）生成树的普里姆（Prim）算法</li><li><strong>对点</strong></li><li>基于贪心策略</li></ul><p>思想：求单源最短路径：图中某点到其他点的最短路径</p><blockquote><p>求多源最短路径：图中多点到其他点的最短路径。时间复杂度：O(n×n²)&#x3D;O(n的3次方)。n为点数</p></blockquote><p>过程：<strong>选边加点加边</strong></p><ol><li>加点</li><li>加候选边</li><li>依据代价，<strong>从候选边中选边</strong>（每次构造一定为连通图）</li><li>依据所选边，加点</li><li>依据所加点，加候选边，<strong>更新代价</strong></li><li>重复345步，<strong>直到加入所有点</strong>（执行n-1次，n为点数）</li></ol><p>伪代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(MGraph g,<span class="type">int</span> v,<span class="type">int</span> dist[],<span class="type">int</span> path[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> set[maxSize];</span><br><span class="line">    <span class="type">int</span> min, i, j, u;</span><br><span class="line">    <span class="comment">/*从这句开始对各数组进行初始化*/</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;g.n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        dist[i]=g.edges[v][i];</span><br><span class="line">        set[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(g.edges[v][i]&lt;INF)</span><br><span class="line">            path[i]=v;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            path[i]=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    set[v]=<span class="number">1</span>;path[v]=<span class="number">-1</span>;   </span><br><span class="line">    <span class="comment">/*初始化结束*/</span></span><br><span class="line">    <span class="comment">/*关键操作开始*/</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;g.n<span class="number">-1</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        min=INF;</span><br><span class="line">        <span class="comment">/*这个循环每次从剩余顶点中选出一个顶点，通往这个顶点的路径在通往所有剩余顶点的路径中是长度最短的*/</span></span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;g.n;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(set[j]==<span class="number">0</span>&amp;&amp;dist[j]&lt;min)</span><br><span class="line">            &#123;</span><br><span class="line">                u=j;</span><br><span class="line">                min=dist[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        set[u]=<span class="number">1</span>;<span class="comment">//将选出的顶点并入最短路径中</span></span><br><span class="line">        <span class="comment">/*这个循环以刚并入的顶点作为中间点，对所有通往剩余顶点的路径进行检测*/</span></span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;g.n;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*这个if语句判断顶点u的加入是否会出现通往顶点j的更短的路径，如果出现，则改变原来的路径及其长度，否则什么都不做*/</span></span><br><span class="line">            <span class="keyword">if</span>(set[j]==<span class="number">0</span>&amp;&amp;dist[u]+g.edges[u][j]&lt;dist[j])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j]=dist[u]+g.edges[u][j];</span><br><span class="line">                path[j]=u;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">/*关键操作结束*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*函数结束时，dist[]数组中存放了v点到其余顶点的最短路径长度，path[]中存放v点到其余各顶点的最短路径*/</span></span><br></pre></td></tr></table></figure><p>时间复杂度：O(n²)。n为点数</p><p>空间复杂度：O(n)。n为点数。辅助空间记录点间代价，路径中点的前一点和标记已访问点</p><p>适用：非带权图；不存在负权值的带权图</p><hr><h2 id="最短路径的弗洛伊德（Floyd）算法"><a href="#最短路径的弗洛伊德（Floyd）算法" class="headerlink" title="最短路径的弗洛伊德（Floyd）算法"></a>最短路径的弗洛伊德（Floyd）算法</h2><p>思想：求点间的最短路径</p><p>过程：迭代</p><ol><li>初始化代价矩阵为邻接矩阵，路径矩阵</li><li>遍历点</li><li>对所遍历点，遍历点对</li><li>对遍历点对，所遍历点作为中间点，依据代价，更新代价矩阵和路径矩阵</li><li>重复234步，直到遍历所有点（执行n-1次，n为点数）</li></ol><p>伪代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Floyd</span><span class="params">(MGraph *g,<span class="type">int</span> Path[][maxSize],<span class="type">int</span> A[][maxSize])</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//图g的边矩阵中，用INF来表示两点之间不存在边</span></span><br><span class="line">    <span class="type">int</span> i,j,k;    </span><br><span class="line">    <span class="comment">/*这个双循环对数组A[][]和Path[][]进行了初始化*/</span></span><br><span class="line">    <span class="type">int</span> A[MAXSIZE][MAXSIZE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;g-&gt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;g-&gt;n;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            A[i][j]=g-&gt;edges[i][j];</span><br><span class="line">            Path[i][j]=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*下面这个三层循环是本算法的主要操作，完成了以k为中间点对所有的顶点对(i,j)进行检测和修改*/</span></span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;g-&gt;n;++k)</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;g-&gt;n;++i)</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;g-&gt;n;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(A[i][j]&gt;A[i][k]+A[k][j])</span><br><span class="line">                Path[i][j] = k;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n的3次方)。n为点数</p><p>空间复杂度：O(n²)。辅助空间记录代价和路径</p><p>适用：非带权图；可存在负权值，负权值边不成回路的带权图</p><hr><h2 id="拓扑排序概述"><a href="#拓扑排序概述" class="headerlink" title="拓扑排序概述"></a>拓扑排序概述</h2><p>顶点表示活动的网&#x2F;活动在顶点上的网（AOV网）：</p><ul><li><strong>工程</strong>中，各<strong>活动</strong>间先后关系的<strong>有向无环图</strong></li><li>无回路的有向图&#x2F;有向无环图&#x2F;DAG图表示工程，点表示活动，边表示活动的先后关系</li></ul><blockquote><p>有向无环图可类比树，使用表达式描述</p></blockquote><p>算法：拓扑排序</p><hr><h2 id="拓扑排序算法"><a href="#拓扑排序算法" class="headerlink" title="拓扑排序算法"></a>拓扑排序算法</h2><p>概念：</p><ul><li>对有向无环图，构造拓扑排序序列的过程</li><li>每点访问且仅访问一次</li><li>若图中存在点A到点B的路径，则拓扑排序序列中点A在点B的前面</li></ul><p>过程：</p><ol><li>选择一个没有前驱&#x2F;入度为0的点，输出</li><li>删除该点和以该点为起点的有向边</li><li>重复12步，直到AOV网为空（排序成功）或AOV网不为空且不存在没有前驱&#x2F;入度为0的点（存在回路，排序失败）</li></ol><p>伪代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">TopSort</span><span class="params">(AGraph *G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,n=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> stack[maxSize],top=<span class="number">-1</span>;<span class="comment">//定义并初始化栈</span></span><br><span class="line">    ArcNode *p;</span><br><span class="line">    <span class="comment">/*这个循环将图中入度为0的顶点入栈*/</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;n;++i)<span class="comment">//图中顶点从0开始编号</span></span><br><span class="line">        <span class="keyword">if</span>(G-&gt;adjlist[i].count==<span class="number">0</span>)</span><br><span class="line">        stack[++top]=i;</span><br><span class="line">    <span class="comment">/*关键操作开始*/</span></span><br><span class="line">    <span class="keyword">while</span>(top!=<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        i=stack[top--];<span class="comment">//顶点出栈</span></span><br><span class="line">        ++n;    <span class="comment">//计数器加一，统计当前顶点</span></span><br><span class="line">        cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>;<span class="comment">//输出当前顶点</span></span><br><span class="line">        p=G-&gt;adjlist[i].firstarc;</span><br><span class="line">        <span class="comment">/*这个循环实现了将所有由此顶点引出的边所指向的顶点的入度都减少1，并将这个过程中入度变为0的顶点入栈*/</span></span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            j=p-&gt;adjvex;</span><br><span class="line">            --(G-&gt;adjlist[j].count);</span><br><span class="line">            <span class="keyword">if</span>(G-&gt;adjlist[i].count==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                stack[++top]=j;</span><br><span class="line">            &#125;</span><br><span class="line">            p=p-&gt;nextarc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*关键操作结束*/</span></span><br><span class="line">    <span class="keyword">if</span>(n==G-&gt;n)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：依据存储结构</p><ul><li>对邻接矩阵：O(n²)。n为点数（理解：遍历每一行）</li><li>对邻接表：O(n+e)。n为点数，e为边数（理解：遍历点表和边表，因为是链式存储结构）</li></ul><p>空间复杂度：O(n)。n为点数。辅助空间栈记录前驱&#x2F;入度为0点</p><p>其他：</p><ul><li>拓扑排序序列不唯一。因为可能<strong>同时</strong>存在多个入度为0的点，选择不同，序列不同</li><li>因为点地位平等，由人工编号，所以可依据拓扑排序序列对点重新编号，生成新邻接矩阵，该邻接矩阵可为三角矩阵</li><li>对一般图，若邻接矩阵是三角矩阵，则存在拓扑排序序列，反之不一定</li><li>拓扑排序：对<strong>入度</strong></li><li>逆拓扑排序：对<strong>出度</strong></li><li>若有向图无回路，则可用深度优先遍历进行拓扑排序，深度优先遍历序列为拓扑排序序列</li><li>判断有向图有回路的方法：深度优先遍历；拓扑排序</li></ul><hr><h2 id="关键路径概述"><a href="#关键路径概述" class="headerlink" title="关键路径概述"></a>关键路径概述</h2><p>边表示活动的网&#x2F;活动在边上的网（AOE网）：</p><ul><li><strong>工程</strong>中，各<strong>活动</strong>持续时间的有向无环图</li><li>无回路的有向图&#x2F;有向无环图&#x2F;DAG图表示工程，边表示活动，边的权值表示活动的持续时间；点表示事件（新活动开始或旧活动结束的标志）</li></ul><blockquote><p>注意：AOV网的边无权值</p></blockquote><p>AOE网的性质：</p><ul><li>只有点表示的事件发生后，以该点为起点的边表示的活动才能开始</li><li>只有<strong>所有</strong>以该点为终点的边表示的活动结束后，该点表示的事件才能发生</li></ul><p>相关概念：</p><ul><li>源点：入度为0的点，只有一个</li><li>汇点，出度为0的点，只有一个</li><li><strong>关键路径</strong>：从源点到汇点的所有路径中，有<strong>最长&#x2F;大路径长度</strong>的，<strong>最短完成工程时间</strong>的路径（<strong>重点理解</strong>）</li><li>最长&#x2F;大路径长度理解：只有所有最久持续时间的活动结束，工程才结束</li><li>最短完成工程时间理解：要想工程结束，最少&#x2F;必须经过的时间</li><li>关键活动：关键路径上的活动</li></ul><p>注意：</p><ul><li>关键活动决定工程。可缩短关键活动的持续时间，以缩短工程的工期；可延长关键活动的持续时间，以延长工程的工期</li><li>不能任意缩短关键活动的持续时间。若缩短到一定程度，则关键活动可能成为非关键活动</li><li>关键路径可能不唯一</li><li>若AOE网存在多条关键路径，缩短一条关键路径上关键活动的持续时间<strong>不一定能</strong>缩短工程的工期（因为关键活动可能成为非关键活动，关键路径可能成为非关键路径）；缩短<strong>所有</strong>关键路径上<strong>共有的</strong>关键活动<strong>能</strong>缩短工程的工期</li><li>无论AOE网存在一条或多条关键路径，延长任一条关键路径上任一个关键活动的持续时间<strong>能</strong>延长工程的工期</li></ul><p>算法：求关键路径</p><hr><h2 id="关键路径算法"><a href="#关键路径算法" class="headerlink" title="关键路径算法"></a>关键路径算法</h2><p>算法的参量（<strong>重点理解</strong>）：</p><ul><li>事件的最早发生时间：源点到点的<strong>最长路径长度</strong>（理解：只有最久的准备事件结束，才能开始当前事件）</li><li>事件的最晚发生时间：汇点到点的<strong>最短路径长度</strong>（理解：要想准时开始当前事件，只有最早开始准备事件）</li><li>活动的最早发生时间：边起点表示事件的最早发生时间（理解：只要事件开始，活动就开始）</li><li>活动的最晚发生时间：边终点表示事件的最晚发生时间-该边表示活动的持续时间（理解：事件最晚开始时间，减活动持续时间，得活动最晚开始时间）</li><li>活动的剩余时间：活动的最晚发生时间-活动的最早发生时间（反映活动完成的<strong>松紧度</strong>）</li><li>关键活动：活动的剩余时间&#x3D;0</li><li>关键路径：关键活动构成的路径</li></ul><p>过程：</p><ol><li>拓扑排序</li><li>依据拓扑排序序列，<strong>顺序</strong>求<strong>各</strong>点表示事件的最早发生时间（从前往后；源点表示事件的最早发生时间等于0）</li><li>逆拓扑排序</li><li>依据逆拓扑排序序列，<strong>顺序</strong>求<strong>各</strong>点表示事件的最晚发生时间（从后往前；汇点表示事件的最晚发生时间等于事件的最早发生时间）</li><li>求各点&#x2F;边表示活动的最早发生时间</li><li>求各点&#x2F;边表示活动的最晚发生时间</li><li>求活动的剩余时间&#x2F;关键活动</li><li>求关键路径</li></ol><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>“图”学习提纲。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《2023版数据结构高分笔记》主编：率辉</li><li>《2023年计算机组成原理考研复习指导》组编：王道论坛</li><li>《大话数据结构》作者：程杰</li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图的C++语言描述实现模板</title>
      <link href="/2022/10/18/%E5%9B%BE%E7%9A%84C++%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E5%AE%9E%E7%8E%B0%E6%A8%A1%E6%9D%BF/"/>
      <url>/2022/10/18/%E5%9B%BE%E7%9A%84C++%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E5%AE%9E%E7%8E%B0%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>数据结构中图的C++语言描述实现模板，有详细的步骤解析及使用示例。</p><hr><h1 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h1><ul><li><a href="https://github.com/yezhening/Programming-examples">yezhening&#x2F;Programming-examples: 编程实例 (github.com)</a></li><li><a href="https://gitee.com/yezhening/Programming-examples">Programming-examples: 编程实例 (gitee.com)</a></li></ul><hr><h1 id="图的邻接矩阵"><a href="#图的邻接矩阵" class="headerlink" title="图的邻接矩阵"></a>图的邻接矩阵</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件————————————————————</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//命名空间————————————————————</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//宏————————————————————</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTEX_NUM 5 <span class="comment">//最大顶点数</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型————————————————————</span></span><br><span class="line"><span class="comment">//邻接矩阵：</span></span><br><span class="line"><span class="comment">//顶点数据类型</span></span><br><span class="line"><span class="comment">//可使用结构体记录其他信息</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> VertexType;</span><br><span class="line"></span><br><span class="line"><span class="comment">//边数据类型</span></span><br><span class="line"><span class="comment">//若是有权图，则为浮点型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> EdgeType;</span><br><span class="line"></span><br><span class="line"><span class="comment">//图的邻接矩阵</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> vexNum;                                     <span class="comment">//顶点数</span></span><br><span class="line">    <span class="type">int</span> edgeNum;                                    <span class="comment">//边数</span></span><br><span class="line">    VertexType vexs[MAX_VERTEX_NUM];                <span class="comment">//顶点表</span></span><br><span class="line">    EdgeType edges[MAX_VERTEX_NUM][MAX_VERTEX_NUM]; <span class="comment">//边表 邻接矩阵</span></span><br><span class="line">&#125; Graph;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="comment">//已访问标志数组</span></span><br><span class="line"><span class="comment">//遍历时，未访问的顶点为false，已访问的顶点为true</span></span><br><span class="line"><span class="type">bool</span> g_visited[MAX_VERTEX_NUM];</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数声明————————————————————</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_example</span><span class="params">()</span></span>;             <span class="comment">//使用示例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createGraph</span><span class="params">(Graph &amp;graph)</span></span>; <span class="comment">//创建图 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfsTraverse</span><span class="params">(Graph graph)</span></span>;  <span class="comment">//深度优先遍历1    </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(Graph graph, <span class="type">int</span> i)</span></span>;   <span class="comment">//深度优先遍历2    </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfsTraverse</span><span class="params">(Graph graph)</span></span>;  <span class="comment">//广度优先遍历1    </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(Graph graph, <span class="type">int</span> i)</span></span>;   <span class="comment">//广度优先遍历2    </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数定义————————————————————</span></span><br><span class="line"><span class="comment">//使用示例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_example</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Graph graph;</span><br><span class="line">    <span class="built_in">createGraph</span>(graph); <span class="comment">//创建图    </span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfsTraverse</span>(graph); <span class="comment">//深度优先遍历1    </span></span><br><span class="line">    <span class="comment">//输出：0 1 3 2 4</span></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bfsTraverse</span>(graph); <span class="comment">//广度优先遍历1    </span></span><br><span class="line">    <span class="comment">//输出：0 1 2 3 4</span></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建图 </span></span><br><span class="line"><span class="comment">//时间复杂度：O(n+e)。n为顶点数，e为边数</span></span><br><span class="line"><span class="comment">//空间复杂度：O(1)。未使用额外辅助空间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createGraph</span><span class="params">(Graph &amp;graph)</span> <span class="comment">//参数：图</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//构建无向非连通图：</span></span><br><span class="line">    <span class="comment">// 5个顶点：0，1，2，3，4</span></span><br><span class="line">    <span class="comment">// 6条边：0-1，0-2，1-3，2-3</span></span><br><span class="line">    <span class="comment">//顶点0，1，2，3是一个连通分量，为矩形：0-1-2-3-0</span></span><br><span class="line">    <span class="comment">//顶点4是一个连通分量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化顶点数</span></span><br><span class="line">    graph.vexNum = <span class="number">5</span>; <span class="comment">// 5个顶点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化边数</span></span><br><span class="line">    graph.edgeNum = <span class="number">4</span>; <span class="comment">// 4条边</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化顶点表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph.vexNum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        graph.vexs[i] = i; <span class="comment">//顶点序号/数据为下标：0，1，2，3，4</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化边表</span></span><br><span class="line">    <span class="comment">// 0表示无边，1表示有边</span></span><br><span class="line">    <span class="comment">//注意：无向图的1条边，在邻接矩阵中需要赋值2次</span></span><br><span class="line">    graph.edges[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    graph.edges[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    graph.edges[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    graph.edges[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    graph.edges[<span class="number">1</span>][<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">    graph.edges[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    graph.edges[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">    graph.edges[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//深度优先遍历1    </span></span><br><span class="line"><span class="comment">//时间复杂度：依据存储结构</span></span><br><span class="line"><span class="comment">//：遍历点数×查找每点的邻接点的时间 = O(v×v) = O(v²)。v为点数（理解：遍历每一行）</span></span><br><span class="line"><span class="comment">//空间复杂度：O(v)。v为点数/辅助空间规模/递归栈规模</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfsTraverse</span><span class="params">(Graph graph)</span> <span class="comment">//参数：图</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化已访问标志数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph.vexNum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        g_visited[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph.vexNum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (g_visited[i] == <span class="literal">false</span>) <span class="comment">//若顶点未访问</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(graph, i); <span class="comment">//深度优先遍历2        从下标为i的顶点开始</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//注意：</span></span><br><span class="line">        <span class="comment">//使用下标判断顶点的已访问标志</span></span><br><span class="line">        <span class="comment">//使用下标对顶点进行深度优先遍历2   </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//连通图执行一次，非连通图执行多次</span></span><br><span class="line">    <span class="comment">//非连通无向图执行连通分量数次，非强连通有向图的非强连通分量不一定能遍历所有点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//深度优先遍历2    </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(Graph graph, <span class="type">int</span> i)</span> <span class="comment">//参数：图，开始顶点下标</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; graph.vexs[i] &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">//访问顶点</span></span><br><span class="line">    g_visited[i] = <span class="literal">true</span>;          <span class="comment">//已访问标志置位</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//对顶点i的邻接顶点j：若未访问，则递归进行深度优先遍历2 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; graph.vexNum; ++j) <span class="comment">//注意循环终止条件</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (graph.edges[i][j] == <span class="number">1</span> &amp;&amp; g_visited[j] == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(graph, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//广度优先遍历1    </span></span><br><span class="line"><span class="comment">//时间复杂度：依据存储结构</span></span><br><span class="line"><span class="comment">//：遍历点数×查找每点的邻接点的时间 = O(v×v) = O(v²)。v为点数（理解：遍历每一行）</span></span><br><span class="line"><span class="comment">//空间复杂度：O(v)。v为点数/辅助空间规模</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfsTraverse</span><span class="params">(Graph graph)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化已访问标志数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph.vexNum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        g_visited[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph.vexNum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (g_visited[i] == <span class="literal">false</span>) <span class="comment">//若顶点未访问</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">bfs</span>(graph, i); <span class="comment">//广度优先遍历2        从下标为i的顶点开始</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//注意：</span></span><br><span class="line">        <span class="comment">//使用下标判断顶点的已访问标志</span></span><br><span class="line">        <span class="comment">//使用下标对顶点进行广度优先遍历2   </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//连通图执行一次，非连通图执行多次</span></span><br><span class="line">    <span class="comment">//非连通无向图执行连通分量数次，非强连通有向图的非强连通分量不一定能遍历所有点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//广度优先遍历2    </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(Graph graph, <span class="type">int</span> i)</span> <span class="comment">//参数：图，开始顶点下标</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化队列    简单定义</span></span><br><span class="line">    <span class="type">int</span> queue[MAX_VERTEX_NUM]; <span class="comment">//循环队列</span></span><br><span class="line">    <span class="type">int</span> front = <span class="number">0</span>;             <span class="comment">//队列头指针</span></span><br><span class="line">    <span class="type">int</span> rear = <span class="number">0</span>;              <span class="comment">//队列尾指针</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; graph.vexs[i] &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">//访问顶点</span></span><br><span class="line">    g_visited[i] = <span class="literal">true</span>;          <span class="comment">//已访问标志置位</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//顶点下标入队</span></span><br><span class="line">    <span class="comment">//注意：是顶点下标入队</span></span><br><span class="line">    queue[rear] = i;</span><br><span class="line">    rear = (rear + <span class="number">1</span>) % MAX_VERTEX_NUM;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (front != rear) <span class="comment">//队列不为空时，循环遍历</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//顶点下标出队</span></span><br><span class="line">        <span class="comment">//注意：是顶点下标出队</span></span><br><span class="line">        i = queue[front];</span><br><span class="line">        front = (front + <span class="number">1</span>) % MAX_VERTEX_NUM;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对顶点i的邻接顶点j：若未访问，则迭代进行广度优先遍历2 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; graph.vexNum; ++j) <span class="comment">//注意循环终止条件</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (graph.edges[i][j] == <span class="number">1</span> &amp;&amp; g_visited[j] == <span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; graph.vexs[j] &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">//访问顶点</span></span><br><span class="line">                g_visited[j] = <span class="literal">true</span>;          <span class="comment">//已访问标志置位</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//顶点下标入队</span></span><br><span class="line">                <span class="comment">//注意：是顶点下标入队</span></span><br><span class="line">                queue[rear] = j;</span><br><span class="line">                rear = (rear + <span class="number">1</span>) % MAX_VERTEX_NUM;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数————————————————————</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">use_example</span>(); <span class="comment">//使用示例</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="图的邻接表"><a href="#图的邻接表" class="headerlink" title="图的邻接表"></a>图的邻接表</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件————————————————————</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//命名空间————————————————————</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//宏————————————————————</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTEX_NUM 5 <span class="comment">//最大顶点数</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型————————————————————</span></span><br><span class="line"><span class="comment">//邻接表：</span></span><br><span class="line"><span class="comment">//边表结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">EdgeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> adjVex;            <span class="comment">//邻接顶点的下标 注意：邻接顶点在邻接表的下标</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">EdgeNode</span> *next; <span class="comment">//指向下一个边表结点的指针</span></span><br><span class="line">    <span class="comment">// int info;              //边的其他信息，如权值</span></span><br><span class="line">&#125; EdgeNode;</span><br><span class="line"><span class="comment">// struct EdgeNode：结构体数据类型的名称</span></span><br><span class="line"><span class="comment">//如创建一个结点的语句：struct EdgeNode node;</span></span><br><span class="line"><span class="comment">//若结构体数据类型内存在指向该结构体的指针数据类型，则必须完整命名结构体数据类型的名称</span></span><br><span class="line"><span class="comment">//如结点结构体EdgeNode内存在指向该结构体的指针数据类型next，则命名语句为：typedef struct EdgeNode而不是typedef struct</span></span><br><span class="line"><span class="comment">// EdgeNode：typedef给结构体数据类型起的别名，可简化语句</span></span><br><span class="line"><span class="comment">//如创建一个结点的语句：EdgeNode node;</span></span><br><span class="line"><span class="comment">//结构体数据类型的名称和别名尽量一致，以方便记忆、使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点表结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> data;                   <span class="comment">//顶点的数据    注意：不同于邻接顶点在邻接表的下标</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">EdgeNode</span> *firstEdge; <span class="comment">//指向第一个边表结点的指针</span></span><br><span class="line">&#125; VertexNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//图的邻接表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> vexNum;                         <span class="comment">//顶点数</span></span><br><span class="line">    <span class="type">int</span> edgeNum;                        <span class="comment">//边数</span></span><br><span class="line">    VertexNode adjList[MAX_VERTEX_NUM]; <span class="comment">//邻接表</span></span><br><span class="line">&#125; Graph;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="comment">//已访问标志数组</span></span><br><span class="line"><span class="comment">//遍历时，未访问的顶点为false，已访问的顶点为true</span></span><br><span class="line"><span class="type">bool</span> g_visited[MAX_VERTEX_NUM];</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数声明————————————————————</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_example</span><span class="params">()</span></span>;             <span class="comment">//使用示例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createGraph</span><span class="params">(Graph &amp;graph)</span></span>; <span class="comment">//创建图</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfsTraverse</span><span class="params">(Graph graph)</span></span>;  <span class="comment">//深度优先遍历1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(Graph graph, <span class="type">int</span> i)</span></span>;   <span class="comment">//深度优先遍历2</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfsTraverse</span><span class="params">(Graph graph)</span></span>;  <span class="comment">//广度优先遍历1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(Graph graph, <span class="type">int</span> i)</span></span>;   <span class="comment">//广度优先遍历2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数定义————————————————————</span></span><br><span class="line"><span class="comment">//使用示例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_example</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Graph graph;</span><br><span class="line">    <span class="built_in">createGraph</span>(graph); <span class="comment">//创建图</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfsTraverse</span>(graph); <span class="comment">//深度优先遍历1</span></span><br><span class="line">    <span class="comment">//输出：0 1 3 2 4</span></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bfsTraverse</span>(graph); <span class="comment">//广度优先遍历1</span></span><br><span class="line">    <span class="comment">//输出：0 1 2 3 4</span></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建图</span></span><br><span class="line"><span class="comment">//时间复杂度：O(n+e)。n为顶点数，e为边数</span></span><br><span class="line"><span class="comment">//空间复杂度：</span></span><br><span class="line"><span class="comment">// O(1)。未使用额外辅助空间</span></span><br><span class="line"><span class="comment">// O(e)。e为边数（边表结点空间）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createGraph</span><span class="params">(Graph &amp;graph)</span> <span class="comment">//参数：图</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//构建无向非连通图：</span></span><br><span class="line">    <span class="comment">// 5个顶点：0，1，2，3，4</span></span><br><span class="line">    <span class="comment">// 6条边：0-1，0-2，1-3，2-3</span></span><br><span class="line">    <span class="comment">//顶点0，1，2，3是一个连通分量，为矩形：0-1-2-3-0</span></span><br><span class="line">    <span class="comment">//顶点4是一个连通分量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化顶点数</span></span><br><span class="line">    graph.vexNum = <span class="number">5</span>; <span class="comment">// 5个顶点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化边数</span></span><br><span class="line">    graph.edgeNum = <span class="number">4</span>; <span class="comment">// 4条边</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化顶点表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph.vexNum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        graph.adjList[i].data = i; <span class="comment">//顶点序号/数据为下标：0，1，2，3，4 注意：初始化顶点数据为  顶点在邻接表的下标</span></span><br><span class="line">        graph.adjList[i].firstEdge = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化边表</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">EdgeNode</span> *node = <span class="literal">nullptr</span>; <span class="comment">//边表节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0-&gt;1-&gt;2：顶点0的邻接点是顶点1和顶点2</span></span><br><span class="line">    node = (<span class="keyword">struct</span> EdgeNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> EdgeNode) * <span class="number">1</span>); <span class="comment">//创建边表结点</span></span><br><span class="line">    node-&gt;adjVex = <span class="number">2</span>;                                              <span class="comment">//顶点0的邻接点是顶点2</span></span><br><span class="line">    node-&gt;next = graph.adjList[<span class="number">0</span>].firstEdge;                       <span class="comment">//头插法</span></span><br><span class="line">    graph.adjList[<span class="number">0</span>].firstEdge = node;</span><br><span class="line"></span><br><span class="line">    node = (<span class="keyword">struct</span> EdgeNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> EdgeNode) * <span class="number">1</span>);</span><br><span class="line">    node-&gt;adjVex = <span class="number">1</span>;</span><br><span class="line">    node-&gt;next = graph.adjList[<span class="number">0</span>].firstEdge;</span><br><span class="line">    graph.adjList[<span class="number">0</span>].firstEdge = node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1-&gt;0-&gt;3：顶点1的邻接点是顶点0和顶点3</span></span><br><span class="line">    node = (<span class="keyword">struct</span> EdgeNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> EdgeNode) * <span class="number">1</span>); <span class="comment">//创建边表结点</span></span><br><span class="line">    node-&gt;adjVex = <span class="number">3</span>;                                              <span class="comment">//顶点1的邻接点是顶点3</span></span><br><span class="line">    node-&gt;next = graph.adjList[<span class="number">1</span>].firstEdge;                       <span class="comment">//头插法</span></span><br><span class="line">    graph.adjList[<span class="number">1</span>].firstEdge = node;</span><br><span class="line"></span><br><span class="line">    node = (<span class="keyword">struct</span> EdgeNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> EdgeNode) * <span class="number">1</span>);</span><br><span class="line">    node-&gt;adjVex = <span class="number">0</span>;</span><br><span class="line">    node-&gt;next = graph.adjList[<span class="number">1</span>].firstEdge;</span><br><span class="line">    graph.adjList[<span class="number">1</span>].firstEdge = node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2-&gt;0-&gt;3：顶点2的邻接点是顶点0和顶点3</span></span><br><span class="line">    node = (<span class="keyword">struct</span> EdgeNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> EdgeNode) * <span class="number">1</span>); <span class="comment">//创建边表结点</span></span><br><span class="line">    node-&gt;adjVex = <span class="number">3</span>;                                              <span class="comment">//顶点2的邻接点是顶点3</span></span><br><span class="line">    node-&gt;next = graph.adjList[<span class="number">2</span>].firstEdge;                       <span class="comment">//头插法</span></span><br><span class="line">    graph.adjList[<span class="number">2</span>].firstEdge = node;</span><br><span class="line"></span><br><span class="line">    node = (<span class="keyword">struct</span> EdgeNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> EdgeNode) * <span class="number">1</span>);</span><br><span class="line">    node-&gt;adjVex = <span class="number">0</span>;</span><br><span class="line">    node-&gt;next = graph.adjList[<span class="number">2</span>].firstEdge;</span><br><span class="line">    graph.adjList[<span class="number">2</span>].firstEdge = node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3-&gt;1-&gt;2：顶点3的邻接点是顶点1和顶点2</span></span><br><span class="line">    node = (<span class="keyword">struct</span> EdgeNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> EdgeNode) * <span class="number">1</span>); <span class="comment">//创建边表结点</span></span><br><span class="line">    node-&gt;adjVex = <span class="number">2</span>;                                              <span class="comment">//顶点3的邻接点是顶点2</span></span><br><span class="line">    node-&gt;next = graph.adjList[<span class="number">3</span>].firstEdge;                       <span class="comment">//头插法</span></span><br><span class="line">    graph.adjList[<span class="number">3</span>].firstEdge = node;</span><br><span class="line"></span><br><span class="line">    node = (<span class="keyword">struct</span> EdgeNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> EdgeNode) * <span class="number">1</span>);</span><br><span class="line">    node-&gt;adjVex = <span class="number">1</span>;</span><br><span class="line">    node-&gt;next = graph.adjList[<span class="number">3</span>].firstEdge;</span><br><span class="line">    graph.adjList[<span class="number">3</span>].firstEdge = node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意：无向图的1条边，在邻接表中需要赋值2次</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//深度优先遍历1</span></span><br><span class="line"><span class="comment">//时间复杂度：依据存储结构</span></span><br><span class="line"><span class="comment">//对邻接表：遍历点数+查找每点的邻接点的时间 = O(v+e)。v为点数，e为边数（理解：遍历点表和边表，因为是链式存储结构）</span></span><br><span class="line"><span class="comment">//空间复杂度：O(v)。v为点数/辅助空间规模/递归栈规模</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfsTraverse</span><span class="params">(Graph graph)</span> <span class="comment">//参数：图</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化已访问标志数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph.vexNum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        g_visited[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph.vexNum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (g_visited[i] == <span class="literal">false</span>) <span class="comment">//若顶点未访问</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(graph, i); <span class="comment">//深度优先遍历2        从下标为i的顶点开始</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//注意：</span></span><br><span class="line">        <span class="comment">//使用下标判断顶点的已访问标志</span></span><br><span class="line">        <span class="comment">//使用下标对顶点进行深度优先遍历2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//连通图执行一次，非连通图执行多次</span></span><br><span class="line">    <span class="comment">//非连通无向图执行连通分量数次，非强连通有向图的非强连通分量不一定能遍历所有点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//深度优先遍历2</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(Graph graph, <span class="type">int</span> i)</span> <span class="comment">//参数：图，开始顶点下标</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; graph.adjList[i].data &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">//访问顶点</span></span><br><span class="line">    g_visited[i] = <span class="literal">true</span>;                  <span class="comment">//已访问标志置位</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">EdgeNode</span> *node = graph.adjList[i].firstEdge; <span class="comment">//取边表结点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//对顶点i的邻接顶点：若未访问，则递归进行深度优先遍历2</span></span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (g_visited[node-&gt;adjVex] == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(graph, node-&gt;adjVex); <span class="comment">//注意参数</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//广度优先遍历1</span></span><br><span class="line"><span class="comment">//时间复杂度：依据存储结构</span></span><br><span class="line"><span class="comment">//对邻接表：遍历点数+查找每点的邻接点的时间=O(v+e)。v为点数，e为边数（理解：遍历点表和边表，因为是链式存储结构）</span></span><br><span class="line"><span class="comment">//空间复杂度：O(v)。v为点数/辅助空间规模</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfsTraverse</span><span class="params">(Graph graph)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化已访问标志数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph.vexNum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        g_visited[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph.vexNum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (g_visited[i] == <span class="literal">false</span>) <span class="comment">//若顶点未访问</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">bfs</span>(graph, i); <span class="comment">//广度优先遍历2        从下标为i的顶点开始</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//注意：</span></span><br><span class="line">        <span class="comment">//使用下标判断顶点的已访问标志</span></span><br><span class="line">        <span class="comment">//使用下标对顶点进行广度优先遍历2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//连通图执行一次，非连通图执行多次</span></span><br><span class="line">    <span class="comment">//非连通无向图执行连通分量数次，非强连通有向图的非强连通分量不一定能遍历所有点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//广度优先遍历2</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(Graph graph, <span class="type">int</span> i)</span> <span class="comment">//参数：图，开始顶点下标</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化队列    简单定义</span></span><br><span class="line">    <span class="type">int</span> queue[MAX_VERTEX_NUM]; <span class="comment">//循环队列</span></span><br><span class="line">    <span class="type">int</span> front = <span class="number">0</span>;             <span class="comment">//队列头指针</span></span><br><span class="line">    <span class="type">int</span> rear = <span class="number">0</span>;              <span class="comment">//队列尾指针</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; graph.adjList[i].data &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">//访问顶点</span></span><br><span class="line">    g_visited[i] = <span class="literal">true</span>;                  <span class="comment">//已访问标志置位</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//顶点下标入队</span></span><br><span class="line">    <span class="comment">//注意：是顶点下标入队</span></span><br><span class="line">    queue[rear] = i;</span><br><span class="line">    rear = (rear + <span class="number">1</span>) % MAX_VERTEX_NUM;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (front != rear) <span class="comment">//队列不为空时，循环遍历</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//顶点下标出队</span></span><br><span class="line">        <span class="comment">//注意：是顶点下标出队</span></span><br><span class="line">        i = queue[front];</span><br><span class="line">        front = (front + <span class="number">1</span>) % MAX_VERTEX_NUM;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">EdgeNode</span> *node = graph.adjList[i].firstEdge; <span class="comment">//取边表结点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//对顶点i的邻接顶点：若未访问，则迭代进行广度优先遍历2</span></span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) <span class="comment">//注意循环终止条件</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (g_visited[node-&gt;adjVex] == <span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; node-&gt;adjVex &lt;&lt; <span class="string">&quot; &quot;</span>;    <span class="comment">//访问顶点</span></span><br><span class="line">                g_visited[node-&gt;adjVex] = <span class="literal">true</span>; <span class="comment">//已访问标志置位</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//顶点下标入队</span></span><br><span class="line">                <span class="comment">//注意：是顶点下标入队</span></span><br><span class="line">                queue[rear] = node-&gt;adjVex;</span><br><span class="line">                rear = (rear + <span class="number">1</span>) % MAX_VERTEX_NUM;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            node = node-&gt;next; <span class="comment">//取下一个边表结点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数————————————————————</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">use_example</span>(); <span class="comment">//使用示例</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>不同参考资料中，图的描述实现各不相同，但基本思想是一致的。作者使用规范的变量命名、提供详细的步骤解析及使用示例，应用C++语言将其整合成模板，以帮助理解记忆。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《2023版数据结构高分笔记》主编：率辉</li><li>《2023年计算机组成原理考研复习指导》组编：王道论坛</li><li>《大话数据结构》作者：程杰</li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“排序”学习提纲</title>
      <link href="/2022/09/23/%E2%80%9C%E6%8E%92%E5%BA%8F%E2%80%9D%E5%AD%A6%E4%B9%A0%E6%8F%90%E7%BA%B2/"/>
      <url>/2022/09/23/%E2%80%9C%E6%8E%92%E5%BA%8F%E2%80%9D%E5%AD%A6%E4%B9%A0%E6%8F%90%E7%BA%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>“排序”学习提纲。</p><hr><h1 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h1><ul><li><a href="https://blog.csdn.net/m0_62083249/article/details/126988176">排序的C++语言描述实现模板</a></li></ul><hr><h1 id="排序的基本概念"><a href="#排序的基本概念" class="headerlink" title="排序的基本概念"></a>排序的基本概念</h1><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><ul><li>排序：关键字无序序列排列成有序序列的过程</li></ul><blockquote><p>关键字可以是主关键字、次关键字和关键字组合等</p></blockquote><blockquote><p>多关键字可以转换为单关键字</p></blockquote><ul><li>稳定性：排序前后，两个或两个以上相同的关键字，相对位置没有变化，称算法是稳定的，反之是不稳定的</li></ul><blockquote><p>若关键字无重复，则排序结果唯一<br>若关键字有重复，则排序结果不唯一，需要考虑算法的稳定性</p></blockquote><blockquote><p>判断方式：<br>若存在相邻地比较和移动&#x2F;交换关键字，则是稳定的<br>若存在跳跃地比较和移动&#x2F;交换关键字，则是不稳定的</p></blockquote><hr><h2 id="类型（依据思想）"><a href="#类型（依据思想）" class="headerlink" title="类型（依据思想）"></a>类型（依据思想）</h2><ul><li>插入类排序</li><li>交换类排序</li><li>选择类排序</li><li>归并类排序</li><li>基数类排序</li></ul><p>插入类排序：</p><ul><li>直接插入排序</li><li>折半插入排序</li><li>希尔排序</li></ul><p>交换类排序：</p><ul><li>冒泡排序</li><li>快速排序</li></ul><p>选择类排序：</p><ul><li>简单选择排序</li><li>堆排序</li></ul><p>归并类排序：</p><ul><li>二路归并排序</li></ul><p>基数类排序：</p><ul><li>基数排序</li></ul><hr><h2 id="类型（依据复杂度）"><a href="#类型（依据复杂度）" class="headerlink" title="类型（依据复杂度）"></a>类型（依据复杂度）</h2><ul><li>简单排序</li><li>复杂排序</li></ul><p>简单排序：</p><ul><li>直接插入排序</li><li>冒泡排序</li><li>简单选择排序</li></ul><p>复杂排序：</p><ul><li>希尔排序</li><li>快速排序</li><li>堆排序</li><li>归并排序</li></ul><hr><h2 id="类型（依据数据是否完全在内存中）"><a href="#类型（依据数据是否完全在内存中）" class="headerlink" title="类型（依据数据是否完全在内存中）"></a>类型（依据数据是否完全在内存中）</h2><ul><li>内部排序（是）</li><li>外部排序（否）</li></ul><p>内部排序：</p><ul><li>插入类排序</li><li>交换类排序</li><li>选择类排序</li><li>归并类排序</li><li>基数类排序</li></ul><hr><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul><li>比较</li><li>移动</li></ul><blockquote><p>注意：基数类排序基于多关键字比较</p></blockquote><blockquote><p>时间复杂度-&gt;比较和移动的次数</p></blockquote><hr><h1 id="插入类排序"><a href="#插入类排序" class="headerlink" title="插入类排序"></a>插入类排序</h1><h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接插入排序</span></span><br><span class="line"><span class="comment">//时间复杂度：O(n²)。n为数据规模</span></span><br><span class="line"><span class="comment">//时间复杂度：数据规模×比较次数</span></span><br><span class="line"><span class="comment">//最好：O(n)。n为数据规模。（有序）</span></span><br><span class="line"><span class="comment">//平均：O(n²)。n为数据规模</span></span><br><span class="line"><span class="comment">//最坏：O(n²)。n为数据规模。（无序的逆序）</span></span><br><span class="line"><span class="comment">//空间复杂度：O(1)。未使用额外辅助空间</span></span><br><span class="line"><span class="comment">//稳定性：稳定</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertSort</span><span class="params">(vector&lt;ELEM_TYPE&gt; &amp;elems)</span> <span class="comment">//参数：需排序元素的向量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">//循环变量</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>; <span class="comment">//需排序元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一个元素values[0]前无元素，不需要排序</span></span><br><span class="line">    <span class="comment">//从第二个元素values[1]开始遍历，需要排序</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; elems.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = elems[i]; <span class="comment">//记录需排序元素</span></span><br><span class="line">        <span class="comment">//需排序元素前的元素向后移动时，会覆盖需排序元素</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历需排序元素前的元素</span></span><br><span class="line">        <span class="comment">//比较需排序元素和需排序元素前的元素</span></span><br><span class="line">        <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp &lt; elems[j]) <span class="comment">//需排序元素&lt;需排序元素前的元素   1.比较   &lt;：稳定性体现</span></span><br><span class="line">            &#123;</span><br><span class="line">                elems[j + <span class="number">1</span>] = elems[j]; <span class="comment">//需排序元素前的元素向后移动 2.移动</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//&gt;=</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历需排序元素前的元素结束时：需排序元素&gt;=需排序元素前的元素    有插入位置</span></span><br><span class="line">        elems[j + <span class="number">1</span>] = temp; <span class="comment">//插入</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//折半插入排序</span></span><br><span class="line"><span class="comment">//时间复杂度：O(n²)。n为数据规模</span></span><br><span class="line"><span class="comment">//时间复杂度：数据规模×比较次数</span></span><br><span class="line"><span class="comment">//最好：O(nlogn)。n为数据规模</span></span><br><span class="line"><span class="comment">//平均：O(n²)。n为数据规模</span></span><br><span class="line"><span class="comment">//最坏：O(n²)。n为数据规模</span></span><br><span class="line"><span class="comment">//空间复杂度：O(1)。未使用额外辅助空间</span></span><br><span class="line"><span class="comment">//稳定性：稳定</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">binarySort</span><span class="params">(vector&lt;ELEM_TYPE&gt; &amp;elems)</span> <span class="comment">//参数：需排序元素的向量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">//循环变量</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>; <span class="comment">//需排序元素</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;                 <span class="comment">//左位置指针</span></span><br><span class="line">    <span class="type">int</span> right = elems.<span class="built_in">size</span>() - <span class="number">1</span>; <span class="comment">//右位置指针</span></span><br><span class="line">    <span class="type">int</span> mid = <span class="number">0</span>;                  <span class="comment">//中间位置指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一个元素elems[0]前无元素，不需要排序</span></span><br><span class="line">    <span class="comment">//从第二个元素elems[1]开始遍历，需要排序</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; elems.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = elems[i]; <span class="comment">//记录需排序元素</span></span><br><span class="line">        <span class="comment">//需排序元素前的元素向后移动时，会覆盖需排序元素</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//折半查找插入位置  1.比较</span></span><br><span class="line">        left = <span class="number">0</span>;      <span class="comment">//更新左位置指针</span></span><br><span class="line">        right = i - <span class="number">1</span>; <span class="comment">//更新右位置指针</span></span><br><span class="line">        <span class="comment">//查找范围：0~i-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) <span class="comment">//左位置指针&lt;=右位置指针时，循环</span></span><br><span class="line">        &#123;</span><br><span class="line">            mid = left + (right - left) / <span class="number">2</span>; <span class="comment">//取中间位置</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (temp == elems[mid]) <span class="comment">//需排序元素=中间位置元素时，在右区间查找    稳定性体现</span></span><br><span class="line">            &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (temp &gt; elems[mid]) <span class="comment">//需排序元素&gt;中间位置元素，在右区间查找</span></span><br><span class="line">            &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (temp &lt; elems[mid]) <span class="comment">//需排序元素&lt;中间位置元素，在左区间查找</span></span><br><span class="line">            &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//折半查找插入位置结束时：可推导插入位置为right + 1</span></span><br><span class="line">        <span class="comment">// right + 1 ~ i - 1的元素向后移动  2.移动</span></span><br><span class="line">        <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= right + <span class="number">1</span>; --j)</span><br><span class="line">        &#123;</span><br><span class="line">            elems[j + <span class="number">1</span>] = elems[j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        elems[right + <span class="number">1</span>] = temp; <span class="comment">//插入</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="希尔排序-缩小增量排序"><a href="#希尔排序-缩小增量排序" class="headerlink" title="希尔排序&#x2F;缩小增量排序"></a>希尔排序&#x2F;缩小增量排序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//希尔排序</span></span><br><span class="line"><span class="comment">//时间复杂度：O(n的1.3次方)~O(n²) 。n为数据规模</span></span><br><span class="line"><span class="comment">//时间复杂度：增量的函数/选取规则（仍是数学难题）</span></span><br><span class="line"><span class="comment">//最好：O(n的1.3次方)。n为数据规模（n在特定范围）</span></span><br><span class="line"><span class="comment">// O(n的1.5次方)。n为数据规模（增量选取规则：2的k次方+1，...，5，3，1。k为整数，k&gt;=1，2的k次方+1 &lt; n）</span></span><br><span class="line"><span class="comment">//最坏：O(n²)。n为数据规模。（增量选取规则：[n/2]下取整，[n/4]下取整，...，1）</span></span><br><span class="line"><span class="comment">//空间复杂度：O(1)。未使用额外辅助空间</span></span><br><span class="line"><span class="comment">//稳定性：不稳定（依据增量划分序列时，可能改变元素的相对位置）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellSort</span><span class="params">(vector&lt;ELEM_TYPE&gt; &amp;elems)</span> <span class="comment">//参数：需排序元素的向量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">//循环变量</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>; <span class="comment">//需排序元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//增量/步长范围：elems.size() / 2 ~ 1</span></span><br><span class="line">    <span class="comment">//步长变化规则：step /= 2</span></span><br><span class="line">    <span class="comment">//对每步长序列进行直接插入排序  类比直接插入排序过程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> step = elems.<span class="built_in">size</span>() / <span class="number">2</span>; step &gt;= <span class="number">1</span>; step /= <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//需排序元素位置：step ~ elems.size() - 1</span></span><br><span class="line">        <span class="comment">//需要比较需排序元素和需排序元素前的元素，从步长的位置开始才有意义</span></span><br><span class="line">        <span class="keyword">for</span> (i = step; i &lt; elems.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = elems[i]; <span class="comment">//记录需排序元素</span></span><br><span class="line">            <span class="comment">//需排序元素前的元素向后移动时，会覆盖需排序元素</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//遍历需排序元素前的元素</span></span><br><span class="line">            <span class="comment">//比较需排序元素和需排序元素前的元素</span></span><br><span class="line">            <span class="comment">//需排序元素前的元素位置：j = i - step ~ 0</span></span><br><span class="line">            <span class="keyword">for</span> (j = i - step; j &gt;= <span class="number">0</span>; j -= step)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp &lt; elems[j]) <span class="comment">//需排序元素&lt;需排序元素前的元素   1.比较</span></span><br><span class="line">                &#123;</span><br><span class="line">                    elems[j + step] = elems[j]; <span class="comment">//需排序元素前的元素向后移动 2.移动/交换</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="comment">//&gt;=</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//遍历需排序元素前的元素结束时：需排序元素&gt;=需排序元素前的元素    有插入位置</span></span><br><span class="line">            elems[j + step] = temp; <span class="comment">//插入</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="交换类排序"><a href="#交换类排序" class="headerlink" title="交换类排序"></a>交换类排序</h1><h2 id="冒泡排序-起泡排序简单版"><a href="#冒泡排序-起泡排序简单版" class="headerlink" title="冒泡排序&#x2F;起泡排序简单版"></a>冒泡排序&#x2F;起泡排序简单版</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡排序  简单版</span></span><br><span class="line"><span class="comment">//时间复杂度：O(n²)。n为数据规模</span></span><br><span class="line"><span class="comment">//时间复杂度：数据规模×比较次数</span></span><br><span class="line"><span class="comment">//最好：O(n)。n为数据规模。（有序）</span></span><br><span class="line"><span class="comment">//平均：O(n²)。n为数据规模</span></span><br><span class="line"><span class="comment">//最坏：O(n²)。n为数据规模。（无序的逆序）</span></span><br><span class="line"><span class="comment">//空间复杂度：O(1)。未使用额外辅助空间</span></span><br><span class="line"><span class="comment">//稳定性：稳定</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort1</span><span class="params">(vector&lt;ELEM_TYPE&gt; &amp;elems)</span> <span class="comment">//参数：需排序元素的向量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">//循环变量</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>; <span class="comment">//需排序元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历需排序元素</span></span><br><span class="line">    <span class="comment">//需排序元素位置：0 ~ elems.size() - 2</span></span><br><span class="line">    <span class="comment">// elems.size()个元素需elems.size() - 1次比较</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; elems.<span class="built_in">size</span>() - <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//遍历需排序元素后的元素</span></span><br><span class="line">        <span class="comment">//需排序元素后的元素位置：i + 1 ~ elems.size() - 1</span></span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; elems.<span class="built_in">size</span>(); ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (elems[i] &gt; elems[j]) <span class="comment">//需排序元素&gt;需排序元素后的元素   1.比较   稳定性体现</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 2.移动/交换</span></span><br><span class="line">                temp = elems[i];</span><br><span class="line">                elems[i] = elems[j];</span><br><span class="line">                elems[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="冒泡排序正版"><a href="#冒泡排序正版" class="headerlink" title="冒泡排序正版"></a>冒泡排序正版</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡排序  正版</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort2</span><span class="params">(vector&lt;ELEM_TYPE&gt; &amp;elems)</span> <span class="comment">//参数：需排序元素的向量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">//循环变量</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>; <span class="comment">//需排序元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历需排序位置</span></span><br><span class="line">    <span class="comment">//需排序位置：0 ~ elems.size() - 2</span></span><br><span class="line">    <span class="comment">// elems.size()个元素需elems.size() - 1次比较</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意：</span></span><br><span class="line">    <span class="comment">//排序位置而不是元素：一趟排序确定一个位置</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; elems.<span class="built_in">size</span>() - <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//遍历需排序位置后的元素</span></span><br><span class="line">        <span class="comment">//需排序位置后的元素位置：i + 1 ~ elems.size() - 1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//注意：</span></span><br><span class="line">        <span class="comment">//从后往前遍历</span></span><br><span class="line">        <span class="comment">//两两相邻元素排序  思想体现</span></span><br><span class="line">        <span class="keyword">for</span> (j = elems.<span class="built_in">size</span>() - <span class="number">1</span>; j &gt; i; --j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (elems[j - <span class="number">1</span>] &gt; elems[j]) <span class="comment">//前需排序元素&gt;后需排序元素   1.比较   稳定性体现</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 2.移动/交换</span></span><br><span class="line">                temp = elems[j - <span class="number">1</span>];</span><br><span class="line">                elems[j - <span class="number">1</span>] = elems[j];</span><br><span class="line">                elems[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="冒泡排序改进版"><a href="#冒泡排序改进版" class="headerlink" title="冒泡排序改进版"></a>冒泡排序改进版</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡排序  改进版</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort3</span><span class="params">(vector&lt;ELEM_TYPE&gt; &amp;elems)</span> <span class="comment">//参数：需排序元素的向量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">//循环变量</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>; <span class="comment">//需排序元素</span></span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//标志：</span></span><br><span class="line">    <span class="comment">// true：一趟排序中，有交换过程，序列无序，算法继续进行</span></span><br><span class="line">    <span class="comment">// false：一趟排序中，无交换过程，序列有序，算法结束</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历需排序位置</span></span><br><span class="line">    <span class="comment">//需排序位置：0 ~ elems.size() - 2</span></span><br><span class="line">    <span class="comment">// elems.size()个元素需elems.size() - 1次比较</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意：</span></span><br><span class="line">    <span class="comment">//排序位置而不是元素：一趟排序确定一个位置</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; elems.<span class="built_in">size</span>() - <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//遍历需排序位置后的元素</span></span><br><span class="line">        <span class="comment">//需排序位置后的元素位置：i + 1 ~ elems.size() - 1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//注意：</span></span><br><span class="line">        <span class="comment">//从后往前遍历</span></span><br><span class="line">        <span class="comment">//两两相邻元素排序  思想体现</span></span><br><span class="line">        <span class="keyword">for</span> (j = elems.<span class="built_in">size</span>() - <span class="number">1</span>; j &gt; i; --j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (elems[j - <span class="number">1</span>] &gt; elems[j]) <span class="comment">//前需排序元素&gt;后需排序元素   1.比较   稳定性体现</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 2.移动/交换</span></span><br><span class="line">                temp = elems[j - <span class="number">1</span>];</span><br><span class="line">                elems[j - <span class="number">1</span>] = elems[j];</span><br><span class="line">                elems[j] = temp;</span><br><span class="line"></span><br><span class="line">                flag = <span class="literal">true</span>; <span class="comment">//有交换过程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="literal">false</span>) <span class="comment">//无交换过程</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="comment">//时间复杂度：O(nlogn)。n为数据规模</span></span><br><span class="line"><span class="comment">//最好：O(nlogn)。n为数据规模。（无序）</span></span><br><span class="line"><span class="comment">//平均：O(nlogn)。n为数据规模。</span></span><br><span class="line"><span class="comment">//最坏：O(n²)。n为数据规模。（有序或无序的逆序）</span></span><br><span class="line"><span class="comment">//空间复杂度：O(logn)。n为数据规模</span></span><br><span class="line"><span class="comment">//空间复杂度：递归调用栈的大小/树的深度/高度</span></span><br><span class="line"><span class="comment">//最好：O(logn)。n为数据规模（平衡树）</span></span><br><span class="line"><span class="comment">//平均：O(logn)。n为数据规模</span></span><br><span class="line"><span class="comment">//最坏：O(n)。n为数据规模（斜树）</span></span><br><span class="line"><span class="comment">//稳定性：不稳定（依据枢轴划分并交换时，可能改变元素的相对位置）</span></span><br><span class="line"><span class="comment">//注意：时间复杂度和空间复杂度是平均而不是最坏情况</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序的优化</span></span><br><span class="line"><span class="comment">// 1.枢轴选取优化</span></span><br><span class="line"><span class="comment">//（1）随机法</span></span><br><span class="line"><span class="comment">//需排序元素的向量中，随机选取一个元素作为枢轴</span></span><br><span class="line"><span class="comment">//（2）三数取中法</span></span><br><span class="line"><span class="comment">//需排序元素的向量中，最左位置、中间位置和最右位置的元素排序，选取中间的元素作为枢轴</span></span><br><span class="line"><span class="comment">//适用小数据规模</span></span><br><span class="line"><span class="comment">//（3）九数取中法</span></span><br><span class="line"><span class="comment">//需排序元素的向量中，取样三次，每次取三个元素得中间元素，三个中间元素得中间元素</span></span><br><span class="line"><span class="comment">//可适用大数据规模</span></span><br><span class="line"><span class="comment">// 2.不必要交换优化</span></span><br><span class="line"><span class="comment">//备份枢轴</span></span><br><span class="line"><span class="comment">//左和右位置指针遍历时，进行元素替换而不是交换</span></span><br><span class="line"><span class="comment">//遍历后，枢轴放到确定位置</span></span><br><span class="line"><span class="comment">// 3.小数据规模优化</span></span><br><span class="line"><span class="comment">//设置数据规模阈值</span></span><br><span class="line"><span class="comment">//若数据规模&lt;阈值，使用直接插入排序</span></span><br><span class="line"><span class="comment">//若数据规模&gt;=阈值，使用快速排序</span></span><br><span class="line"><span class="comment">// 4.递归优化</span></span><br><span class="line"><span class="comment">//使用尾递归/迭代</span></span><br><span class="line"><span class="comment">//示例：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void quickSort(...)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    while (left &lt; right) //使用while</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        int i = left;  //逻辑处理</span></span><br><span class="line"><span class="comment">        int j = right;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        ...</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        quickSort(elems, left, privot - 1);  //左递归</span></span><br><span class="line"><span class="comment">        left = prvot + 1; //右迭代</span></span><br><span class="line"><span class="comment">        //左递归后，left无用，赋值为prvot + 1</span></span><br><span class="line"><span class="comment">        //while在下次迭代，i = pivot + 1，j = right，相当于右递归的逻辑处理</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;ELEM_TYPE&gt; &amp;elems, <span class="type">int</span> left, <span class="type">int</span> right)</span> <span class="comment">//参数：需排序元素的向量，左位置指针，右位置指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = left;  <span class="comment">//左位置指针    用于划分</span></span><br><span class="line">    <span class="type">int</span> j = right; <span class="comment">//右位置指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) <span class="comment">//左位置指针&lt;右位置指针时，递归</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 1.划分   确定枢轴</span></span><br><span class="line">        ELEM_TYPE privot = elems[left];</span><br><span class="line">        <span class="comment">//当前排序表的第一个元素作为枢轴    枢轴划分当前排序表为左排序表和右排序表</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) <span class="comment">//左位置指针小于右位置指针时，循环</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//左位置指针小于右位置指针时</span></span><br><span class="line">            <span class="comment">//右位置指针向左移动，直到找到比枢轴小的元素</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (elems[j] &gt;= privot) <span class="comment">//右位置指针&gt;=枢轴  向左移动    1.比较</span></span><br><span class="line">                &#123;</span><br><span class="line">                    --j;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="comment">//&lt;</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            elems[i] = elems[j]; <span class="comment">//比枢轴小的元素放在左指针位置  2.移动/交换</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//左位置指针小于右位置指针时</span></span><br><span class="line">            <span class="comment">//左位置指针向右移动，直到找到比枢轴大的元素</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (elems[i] &lt;= privot) <span class="comment">//左位置指针&lt;=枢轴  向右移动    1.比较</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ++i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="comment">//&gt;</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            elems[j] = elems[i]; <span class="comment">//比枢轴大的元素放在左指针位置  2.移动/交换</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环结束时，左排序表的元素比枢轴小，右排序表的元素比枢轴大</span></span><br><span class="line">        elems[i] = privot; <span class="comment">//枢轴放在左位置指针 可推导</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.递归</span></span><br><span class="line">        <span class="comment">//注意：使用left和right</span></span><br><span class="line">        <span class="built_in">quickSort</span>(elems, left, privot - <span class="number">1</span>);  <span class="comment">//左递归</span></span><br><span class="line">        <span class="built_in">quickSort</span>(elems, privot + <span class="number">1</span>, right); <span class="comment">//右递归</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>数据结构中的完全二叉树。满足：任意一个<strong>非叶结点</strong>的关键字都不小于（或不大于）其左和右孩子结点的关键字</li></ul><hr><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><ul><li>大顶&#x2F;根堆：任意一个<strong>非叶结点</strong>的关键字都不小于其左和右孩子结点的关键字</li><li>小顶&#x2F;根堆：任意一个<strong>非叶结点</strong>的关键字都不大于其左和右孩子结点的关键字</li></ul><hr><h2 id="插入过程"><a href="#插入过程" class="headerlink" title="插入过程"></a>插入过程</h2><ol><li>在最右下位置插入（满足完全二叉树定义）</li><li>调整（满足堆定义）</li></ol><hr><h2 id="删除过程"><a href="#删除过程" class="headerlink" title="删除过程"></a>删除过程</h2><ol><li>交换最右下位置和删除位置的关键字（满足完全二叉树定义）</li><li>从最右下位置删除（满足完全二叉树定义）</li><li>调整（满足堆定义）</li></ol><hr><h2 id="堆排序的过程"><a href="#堆排序的过程" class="headerlink" title="堆排序的过程"></a>堆排序的过程</h2><p>对大顶堆：</p><ol><li>无序序列-&gt;完全二叉树（依据层序遍历方法）</li><li>完全二叉树-&gt;大顶堆（依据大顶堆调整方法）</li><li>大顶堆-&gt;有序序列（依据堆排序方法）</li></ol><p>层序遍历方法：</p><ul><li>从上到下，从左到右，构造完全二叉树</li></ul><p>大顶堆调整方法：</p><ul><li>从完全二叉树的最后一个非叶子结点开始，从右到左，从下到上，调整结点</li><li>交换结点以满足大顶堆定义</li></ul><p>堆排序方法：</p><ol><li>交换树根结点和最右下位置结点，删除最右下位置结点，输出最右下位置结点（最右下位置结点进入有序序列）</li><li>调整（最右下位置结点被交换到树根结点，可能不满足堆定义）</li><li>重复1和2步，堆无结点时结束</li></ol><hr><h1 id="选择类排序"><a href="#选择类排序" class="headerlink" title="选择类排序"></a>选择类排序</h1><h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单选择排序</span></span><br><span class="line"><span class="comment">//时间复杂度：O(n²)。n为数据规模</span></span><br><span class="line"><span class="comment">//时间复杂度：数据规模×比较次数</span></span><br><span class="line"><span class="comment">//最好：O(n²)。n为数据规模</span></span><br><span class="line"><span class="comment">//平均：O(n²)。n为数据规模</span></span><br><span class="line"><span class="comment">//最坏：O(n²)。n为数据规模</span></span><br><span class="line"><span class="comment">//空间复杂度：O(1)。未使用额外辅助空间</span></span><br><span class="line"><span class="comment">//稳定性：不稳定（最小元素和需排序元素交换时，可能改变元素的相对位置）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectSort</span><span class="params">(vector&lt;ELEM_TYPE&gt; &amp;elems)</span> <span class="comment">//参数：需排序元素的向量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">//循环变量</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> min = <span class="number">0</span>;        <span class="comment">//最小元素位置</span></span><br><span class="line">    ELEM_TYPE temp = <span class="number">0</span>; <span class="comment">//交换时，记录暂存元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历需排序位置</span></span><br><span class="line">    <span class="comment">//需排序位置：0 ~ elems.size() - 2</span></span><br><span class="line">    <span class="comment">//最后一个位置elems.size() - 1不需要排序</span></span><br><span class="line">    <span class="comment">// elems.size()个位置需elems.size() - 1趟排序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意：</span></span><br><span class="line">    <span class="comment">//排序位置而不是元素：一趟排序确定一个位置</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; elems.<span class="built_in">size</span>() - <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        min = i; <span class="comment">//记录最小元素位置</span></span><br><span class="line">        <span class="comment">//理解：</span></span><br><span class="line">        <span class="comment">// i记录需排序位置</span></span><br><span class="line">        <span class="comment">// min记录最小元素位置</span></span><br><span class="line">        <span class="comment">//从最小元素位置，取最小元素，放到需排序位置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历需排序位置后的位置</span></span><br><span class="line">        <span class="comment">//比较当前最小元素和需排序位置后的位置的元素，取最小元素，放到需排序位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; elems.<span class="built_in">size</span>(); ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (elems[min] &gt; elems[j]) <span class="comment">//当前最小元素&gt;需排序元素位置后的位置的元素  1.比较/选择</span></span><br><span class="line">            &#123;</span><br><span class="line">                min = j; <span class="comment">//记录最小元素位置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.移动/交换</span></span><br><span class="line">        <span class="comment">//最小元素，放到需排序位置</span></span><br><span class="line">        <span class="comment">//需排序位置元素，放到最小元素位置</span></span><br><span class="line">        <span class="keyword">if</span> (min != i) <span class="comment">//最小元素位置!=需排序元素位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp = elems[i];</span><br><span class="line">            elems[i] = elems[min];</span><br><span class="line">            elems[min] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//堆调整    大顶堆法</span></span><br><span class="line"><span class="comment">//参数：需排序元素的向量，闭区间[low，high]位置结点调整为大顶堆</span></span><br><span class="line"><span class="comment">//关键理解：实际上，调整以low位置结点为根的树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapAdjust</span><span class="params">(vector&lt;ELEM_TYPE&gt; &amp;elems, <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = low; <span class="comment">//调整以i位置结点为根的树    调整时，i位置可能会从上到下更新</span></span><br><span class="line"></span><br><span class="line">    ELEM_TYPE temp = elems[low]; <span class="comment">//暂存i位置结点的关键字</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//关键理解：</span></span><br><span class="line">    <span class="comment">// j：需比较和交换结点的位置</span></span><br><span class="line">    <span class="comment">//范围：以i位置结点为根的树</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// int j = 2 * i：i位置结点的左孩子结点是2 * i位置结点（依据完全二叉树的性质）</span></span><br><span class="line">    <span class="comment">// j &lt;= high：位置不越界</span></span><br><span class="line">    <span class="comment">// j *= 2：左孩子结点的位置（依据完全二叉树的性质）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//每循环，比较i位置结点、2 * i位置结点和2 * i + 1位置结点的关键字</span></span><br><span class="line">    <span class="comment">//即比较i位置结点、i位置结点的左孩子结点和i位置结点的右孩子结点的关键字</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span> * i; j &lt;= high; j *= <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 1. 比较左孩子结点和右孩子结点的关键字</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//  j &lt; high：j不是最后一个结点的位置-&gt;i位置结点存在右孩子结点</span></span><br><span class="line">        <span class="comment">//  elems[j] &lt; elems[j + 1]：左孩子结点的关键字&lt;右孩子结点的关键字</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt; high &amp;&amp; elems[j] &lt; elems[j + <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            ++j; <span class="comment">//更新需比较和交换结点的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//目的：</span></span><br><span class="line">        <span class="comment">// j：需比较和交换结点的位置</span></span><br><span class="line">        <span class="comment">//取左孩子结点和右孩子结点中，关键字最大的位置</span></span><br><span class="line">        <span class="comment">// j = 2 * i或j = 2 * i + 1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.比较i位置结点、左孩子结点和右孩子结点中，关键字最大的结点</span></span><br><span class="line">        <span class="comment">// i位置结点&lt;左孩子结点和右孩子结点中，关键字最大的结点</span></span><br><span class="line">        <span class="comment">//需要调整</span></span><br><span class="line">        <span class="keyword">if</span> (temp &lt; elems[j])</span><br><span class="line">        &#123;</span><br><span class="line">            elems[i] = elems[j]; <span class="comment">// i位置结点的关键字赋值为j位置结点的关键字</span></span><br><span class="line">            i = j;               <span class="comment">//更新i位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//&gt;=    不需要调整</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">//调整结束</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    elems[i] = temp; <span class="comment">// i位置结点的关键字赋值为暂存的关键字 注意：i可能已更新</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//堆排序    大顶堆法</span></span><br><span class="line"><span class="comment">//时间复杂度：O(nlogn)。n为数据规模</span></span><br><span class="line"><span class="comment">//时间复杂度：建堆和堆排序</span></span><br><span class="line"><span class="comment">//建堆：O(n)。n为数据规模</span></span><br><span class="line"><span class="comment">//堆排序：排序次数×调整堆/树高</span></span><br><span class="line"><span class="comment">//堆排序：O(nlogn)。n为数据规模</span></span><br><span class="line"><span class="comment">//最好：O(nlogn)。n为数据规模</span></span><br><span class="line"><span class="comment">//平均：O(nlogn)。n为数据规模</span></span><br><span class="line"><span class="comment">//最坏：O(nlogn)。n为数据规模</span></span><br><span class="line"><span class="comment">//空间复杂度：O(1)。未使用额外辅助空间</span></span><br><span class="line"><span class="comment">//稳定性：不稳定（需排序元素交换时，可能改变元素的相对位置）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(vector&lt;ELEM_TYPE&gt; &amp;elems)</span> <span class="comment">//参数：需排序元素的向量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ELEM_TYPE temp = <span class="number">0</span>; <span class="comment">//暂存交换结点的关键字</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.建堆</span></span><br><span class="line">    <span class="comment">//从完全二叉树的最后一个非叶子结点开始，从右到左，从下到上，调整结点</span></span><br><span class="line">    <span class="comment">//范围：1~(elems.size() - 1) / 2</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = (elems.<span class="built_in">size</span>() - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heapAdjust</span>(elems, i, elems.<span class="built_in">size</span>() - <span class="number">1</span>); <span class="comment">//注意：闭区间[low，high]位置结点调整为大顶堆   1.比较</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.堆排序</span></span><br><span class="line">    <span class="comment">//范围：2~elems.size() - 1</span></span><br><span class="line">    <span class="comment">//对1~elems.size() - 1个结点，需进行elems.size() - 2次排序，最后一个结点已有序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = elems.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">2</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//交换树根结点和最右下位置结点，删除最右下位置结点，输出最右下位置结点（最右下位置结点进入有序序列）    2.移动/交换</span></span><br><span class="line">        temp = elems[<span class="number">1</span>];</span><br><span class="line">        elems[<span class="number">1</span>] = elems[i];</span><br><span class="line">        elems[i] = temp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调整（最右下位置结点被交换到树根结点，可能不满足堆定义）  1.比较</span></span><br><span class="line">        <span class="built_in">heapAdjust</span>(elems, <span class="number">1</span>, i - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//注意：i - 1：因为最右下位置结点进入有序序列，无需进行调整</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="归并类排序"><a href="#归并类排序" class="headerlink" title="归并类排序"></a>归并类排序</h1><h2 id="二路归并排序-递归法-分治法"><a href="#二路归并排序-递归法-分治法" class="headerlink" title="二路归并排序 递归法 分治法"></a>二路归并排序 递归法 分治法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二路归并</span></span><br><span class="line"><span class="comment">//参数：需排序元素的向量，归并闭区间[low，mid]和[mid + 1，high]序列</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;ELEM_TYPE&gt; &amp;elems, <span class="type">int</span> low, <span class="type">int</span> mid, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;ELEM_TYPE&gt; <span class="title">temp</span><span class="params">(elems.size(), <span class="number">0</span>)</span></span>; <span class="comment">//暂存需排序元素的向量</span></span><br><span class="line">    <span class="comment">//因为需要修改elems，elems存储已排序元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//暂存需排序元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = low; i &lt;= high; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        temp[i] = elems[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环变量</span></span><br><span class="line">    <span class="type">int</span> i = low;     <span class="comment">//闭区间[low，mid]序列位置</span></span><br><span class="line">    <span class="type">int</span> j = mid + <span class="number">1</span>; <span class="comment">//闭区间[mid + 1，high]序列位置</span></span><br><span class="line">    <span class="type">int</span> k = low;     <span class="comment">// elems位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//闭区间[low，mid]序列位置和闭区间[mid + 1，high]序列位置未越界时，循环</span></span><br><span class="line">    <span class="comment">//比较，取两区间中的最小元素，存储在elems位置</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp[i] &lt;= temp[j]) <span class="comment">//闭区间[low，mid]序列元素 &lt;= 闭区间[mid + 1，high]序列元素 两两比较，稳定性体现</span></span><br><span class="line">        &#123;</span><br><span class="line">            elems[k] = temp[i];</span><br><span class="line"></span><br><span class="line">            ++k; <span class="comment">//更新位置</span></span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//&gt;</span></span><br><span class="line">        &#123;</span><br><span class="line">            elems[k] = temp[j];</span><br><span class="line"></span><br><span class="line">            ++k; <span class="comment">//更新位置</span></span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//闭区间[low，mid]序列位置或闭区间[mid + 1，high]序列位置越界</span></span><br><span class="line">    <span class="comment">//若另一个序列有未排序元素，存储在elems位置</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid)</span><br><span class="line">    &#123;</span><br><span class="line">        elems[k] = temp[i];</span><br><span class="line"></span><br><span class="line">        ++k; <span class="comment">//更新位置</span></span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= high)</span><br><span class="line">    &#123;</span><br><span class="line">        elems[k] = temp[j];</span><br><span class="line"></span><br><span class="line">        ++k; <span class="comment">//更新位置</span></span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二路归并排序递归法  分治法</span></span><br><span class="line"><span class="comment">//时间复杂度：O(nlogn)。n为数据规模</span></span><br><span class="line"><span class="comment">//时间复杂度：归并趟数×一趟归并的操作次数</span></span><br><span class="line"><span class="comment">//归并趟数：O(nlogn)。n为数据规模</span></span><br><span class="line"><span class="comment">//一趟归并的操作次数：O(n)。n为数据规模</span></span><br><span class="line"><span class="comment">//最好：O(nlogn)。n为数据规模</span></span><br><span class="line"><span class="comment">//平均：O(nlogn)。n为数据规模</span></span><br><span class="line"><span class="comment">//最坏：O(nlogn)。n为数据规模</span></span><br><span class="line"><span class="comment">//空间复杂度：O(n)。n为数据规模</span></span><br><span class="line"><span class="comment">//空间复杂度：暂存需排序元素辅助空间的大小或递归调用栈的大小</span></span><br><span class="line"><span class="comment">//暂存需排序元素辅助空间的大小：O(n)。n为数据规模</span></span><br><span class="line"><span class="comment">//递归调用栈的大小：O(logn)。n为数据规模</span></span><br><span class="line"><span class="comment">//稳定性：稳定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二路归并排序  迭代法简介</span></span><br><span class="line"><span class="comment">//循环中：更新步长/增量，两两归并，归并剩余单个序列</span></span><br><span class="line"><span class="comment">//时间复杂度：无递归，比递归法更优，数量级不变</span></span><br><span class="line"><span class="comment">//空间复杂度：无递归调用栈，比递归法更优，数量级不变</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//另：m = (log以k为底的n)上取整。m为归并趟数，k为归并路数，n为数据规模</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//参数：需排序元素的向量，排序闭区间[low，high]序列：左位置指针，右位置指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;ELEM_TYPE&gt; &amp;elems, <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) <span class="comment">//左位置指针 &lt; 右位置指针，区间合法</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = low + (high - low) / <span class="number">2</span>; <span class="comment">//中间位置指针    划分左右区间</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">mergeSort</span>(elems, low, mid);      <span class="comment">//左区间归并排序   左</span></span><br><span class="line">        <span class="built_in">mergeSort</span>(elems, mid + <span class="number">1</span>, high); <span class="comment">//右区间归并排序   右</span></span><br><span class="line">        <span class="built_in">merge</span>(elems, low, mid, high);    <span class="comment">//归并 中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="基数类排序"><a href="#基数类排序" class="headerlink" title="基数类排序"></a>基数类排序</h1><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基数排序</span></span><br><span class="line"><span class="comment">//思想：多关键字比较，无需进行比较和移动</span></span><br><span class="line"><span class="comment">//类型：最高位优先（MSD）；最低位优先（LSD）</span></span><br><span class="line"><span class="comment">//最高位优先（MSD）：排序最高位，排序次高位...以此类推</span></span><br><span class="line"><span class="comment">//最低位优先（LSD）：分配和收集最低位，分配和收集次低位...以此类推。对每个数据分配入队列，对每个队列收集出队列数据</span></span><br><span class="line"><span class="comment">//注意和理解：最高位优先能够在一定程度上确定排序，最低位优先不能</span></span><br><span class="line"><span class="comment">//时间复杂度：O(d(n+r))。d为数据位数，n为数据规模，r为数据基数/取值范围。如十进制数字基数为10、小写字母基数为26</span></span><br><span class="line"><span class="comment">//时间复杂度：排序趟数×分配和收集次数。排序趟数为数据位数，分配次数为数据规模，收集次数为数据基数</span></span><br><span class="line"><span class="comment">//最好：O(d(n+r))</span></span><br><span class="line"><span class="comment">//平均：O(d(n+r))</span></span><br><span class="line"><span class="comment">//最坏：O(d(n+r))</span></span><br><span class="line"><span class="comment">//空间复杂度：O(r)。r为数据基数/取值范围。如十进制数字基数为10、小写字母基数为26</span></span><br><span class="line"><span class="comment">//空间复杂度：分配和收集队列的大小</span></span><br><span class="line"><span class="comment">//稳定性：稳定（按位排序时，稳定性体现）</span></span><br></pre></td></tr></table></figure><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="插入类排序-1"><a href="#插入类排序-1" class="headerlink" title="插入类排序"></a>插入类排序</h2><table><thead><tr><th>名称</th><th>时间复杂度</th><th>空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td>直接插入排序</td><td>O(n²)</td><td>O(1)</td><td>稳定</td></tr><tr><td>折半插入排序</td><td>O(n²)</td><td>O(1)</td><td>稳定</td></tr><tr><td>希尔排序</td><td>O(n的1.3次方)~O(n²)</td><td>O(1)</td><td>不稳定</td></tr></tbody></table><h2 id="交换类排序-1"><a href="#交换类排序-1" class="headerlink" title="交换类排序"></a>交换类排序</h2><table><thead><tr><th>名称</th><th>时间复杂度</th><th>空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td>冒泡排序</td><td>O(n²)</td><td>O(1)</td><td>稳定</td></tr><tr><td>快速排序</td><td>O(nlogn)</td><td>O(logn)</td><td>不稳定</td></tr></tbody></table><h2 id="选择类排序-1"><a href="#选择类排序-1" class="headerlink" title="选择类排序"></a>选择类排序</h2><table><thead><tr><th>名称</th><th>时间复杂度</th><th>空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td>简单选择排序</td><td>O(n²)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>堆排序</td><td>O(nlogn)</td><td>O(1)</td><td>不稳定</td></tr></tbody></table><h2 id="归并类排序-1"><a href="#归并类排序-1" class="headerlink" title="归并类排序"></a>归并类排序</h2><table><thead><tr><th>名称</th><th>时间复杂度</th><th>空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td>二路归并排序</td><td>O(nlogn)</td><td>O(n)</td><td>稳定</td></tr></tbody></table><h2 id="基数类排序-1"><a href="#基数类排序-1" class="headerlink" title="基数类排序"></a>基数类排序</h2><table><thead><tr><th>名称</th><th>时间复杂度</th><th>空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td>基数排序</td><td>O(d(n+r))</td><td>O(r)</td><td>稳定</td></tr></tbody></table><h2 id="总表1"><a href="#总表1" class="headerlink" title="总表1"></a>总表1</h2><table><thead><tr><th>名称</th><th>时间复杂度</th><th>空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td>直接插入排序</td><td>O(n²)</td><td>O(1)</td><td>稳定</td></tr><tr><td>折半插入排序</td><td>O(n²)</td><td>O(1)</td><td>稳定</td></tr><tr><td>希尔排序</td><td>O(n的1.3次方)~O(n²)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>冒泡排序</td><td>O(n²)</td><td>O(1)</td><td>稳定</td></tr><tr><td>快速排序</td><td>O(nlogn)</td><td>O(logn)</td><td>不稳定</td></tr><tr><td>简单选择排序</td><td>O(n²)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>堆排序</td><td>O(nlogn)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>二路归并排序</td><td>O(nlogn)</td><td>O(n)</td><td>稳定</td></tr><tr><td>基数排序</td><td>O(d(n+r))</td><td>O(r)</td><td>稳定</td></tr></tbody></table><h2 id="总表2"><a href="#总表2" class="headerlink" title="总表2"></a>总表2</h2><table><thead><tr><th>名称</th><th>最好时间复杂度</th><th>平均时间复杂度</th><th>最坏时间复杂度</th><th>空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td>直接插入排序</td><td>O(n)</td><td>O(n²)</td><td>O(n²)</td><td>O(1)</td><td>稳定</td></tr><tr><td>折半插入排序</td><td>O(nlogn)</td><td>O(n²)</td><td>O(n²)</td><td>O(1)</td><td>稳定</td></tr><tr><td>希尔排序</td><td>O(n的1.3次方)</td><td>O(n的1.3次方)~O(n²)</td><td>O(n²)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>冒泡排序</td><td>O(n)</td><td>O(n²)</td><td>O(n²)</td><td>O(1)</td><td>稳定</td></tr><tr><td>快速排序</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(n²)</td><td>O(logn)</td><td>不稳定</td></tr><tr><td>简单选择排序</td><td>O(n²)</td><td>O(n²)</td><td>O(n²)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>堆排序</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>二路归并排序</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(n)</td><td>稳定</td></tr><tr><td>基数排序</td><td>O(d(n+r))</td><td>O(d(n+r))</td><td>O(d(n+r))</td><td>O(r)</td><td>稳定</td></tr></tbody></table><h2 id="记忆"><a href="#记忆" class="headerlink" title="记忆"></a>记忆</h2><p>时间复杂度为O(n²)：</p><ul><li>简单排序：直接插入排序，折半插入排序，冒泡排序，简单选择排序</li></ul><p>时间复杂度为O(nlogn)：</p><ul><li>复杂排序：希尔排序（可能），快速排序，堆排序</li><li>归并排序：二路归并排序</li></ul><p>时间复杂度特殊：</p><ul><li>基数排序</li></ul><p>最好、平均和最坏时间复杂度相同：</p><ul><li>简单选择排序</li><li>堆排序</li><li>二路归并排序</li><li>基数排序</li></ul><p>最好和平均时间复杂度不同：</p><ul><li>直接插入排序</li><li>折半插入排序</li><li>希尔排序</li><li>冒泡排序</li></ul><p>最坏和平均时间复杂度不同：</p><ul><li>希尔排序</li><li>快速排序</li></ul><p>空间复杂度不为O(1)：</p><ul><li>快速排序</li><li>二路归并排序</li><li>基数排序</li></ul><p>稳定：</p><ul><li>简单排序：直接插入排序，折半插入排序，冒泡排序</li><li>归并排序，基数排序：二路归并排序</li></ul><p>不稳定：</p><ul><li>复杂排序：希尔排序，快速排序</li><li>选择类排序：简单选择排序，堆排序</li></ul><p>一趟排序，能够确定元素的最终位置：</p><ul><li>交换类排序：冒泡排序，快速排序</li><li>选择类排序：简单选择排序，堆排序</li></ul><p>比较次数和初始序列无关：</p><ul><li>折半插入排序</li><li>简单选择排序</li><li>二路归并排序</li><li>基数排序</li></ul><p>移动次数和初始序列无关：</p><ul><li>基数排序</li></ul><p>排序趟数和初始序列有关：</p><ul><li>交换类排序：冒泡排序，快速排序</li></ul><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>数据基本有序：最好时间复杂度小</p><ul><li>直接插入排序</li><li>冒泡排序</li></ul><p>数据规模小（&lt;10000）：简单排序</p><ul><li>直接插入排序（性能最优；数据规模&lt;&#x3D;25）</li><li>折半插入排序（相对直接插入排序，适用数据规模更大）</li><li>冒泡排序</li><li>简单选择排序（相对冒泡排序，性能更优）</li></ul><p>数据规模小，信息量大（如：数据是数十位的数字-&gt;占用空间大-&gt;移动时间长）：</p><ul><li>简单选择排序（移动次数少）</li></ul><p>数据规模大：复杂排序</p><ul><li>数据规模&lt;&#x3D;1000：希尔排序</li><li>数据随机分布：快速排序（性能最优；数据基本有序时，性能最差）</li><li>空间复杂度小；从大数据规模排序小部分数据：堆排序</li><li>稳定：归并排序</li><li>多关键字排序：基数排序</li></ul><p>数据规模更大：外部排序</p><p>数据规模大，数据位数少：</p><ul><li>基数排序</li></ul><p>数据规模大，数据位数多：</p><ul><li>最高位优先（MSD）的基数排序结合直接插入排序</li></ul><p>其他：</p><ul><li>堆排序只适用顺序存储方式</li><li>堆排序建堆时比较次数多，不适用数据规模小</li><li>归并排序尽量用迭代法而不是递归法</li><li>基数排序不适用实数类型</li><li>混合排序使用</li></ul><hr><h1 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><ul><li>内存作为工作&#x2F;辅助空间，排序外存数据</li><li>算法相对复杂</li><li>时间&#x3D;读写外存内存时间+内存排序时间+内存归并时间</li><li>时间-&gt;访问外存&#x2F;输入&#x2F;输出（I&#x2F;O）次数</li><li>优化：减少访问外存&#x2F;输入&#x2F;输出（I&#x2F;O）次数-&gt;减少初始归并段数，增多</li></ul><hr><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ol><li>外存数据分段</li><li>段读入内存</li><li>段在内存排序，为初始归并段</li><li>初始归并段写回外存</li><li>初始归并段读入内存</li><li>初始归并段在内存归并，为归并段</li><li>归并段写回外存</li></ol><p>另：</p><ol><li>分段</li><li>排序</li><li>归并</li></ol><hr><h2 id="排序方法"><a href="#排序方法" class="headerlink" title="排序方法"></a>排序方法</h2><p>常用：</p><ul><li>归并排序</li></ul><p>子算法：</p><ul><li>置换-选择排序</li><li>最佳归并树</li><li>败者树</li></ul><p>置换-选择排序：</p><ul><li>作用：<strong>排序时</strong>，生成初始归并段时不受内存限制；减少初始归并段数</li><li>外存段中，每记录读入内存</li><li><strong>依据排序规则</strong>，选择一个最值生成初始归并段。不符合排序规则的最值<strong>等待</strong>生成下一初始归并段</li><li>初始归并段长度不同</li></ul><p>最佳归并树：</p><ul><li>作用：<strong>归并时</strong>，减少访问外存&#x2F;输入&#x2F;输出（I&#x2F;O）次数；适应长度不同初始归并段的归并</li><li>生成哈夫曼树</li><li>权：初始归并段的数据规模</li><li>路径长度：归并次数</li><li>2：读和写</li><li>访问外存&#x2F;输入&#x2F;输出（I&#x2F;O）次数 &#x3D; 带权路径长度（WPL） × 2</li></ul><p>败者树：</p><ul><li>作用：<strong>排序和归并时</strong>，减少选最值的比较次数&#x2F;时间复杂度；增多归并路数</li></ul><p>对最小值败者树：</p><ul><li>叶子结点：值为归并段的段首值，旁为归并段的序号</li><li>非叶子结点：值为归并段的序号，旁为归并段的段首值</li><li>构造：<strong>比较值</strong>，构造二叉树。败者（值大者）为双亲结点，胜者（值小者）为双亲结点的双亲结点</li><li>由树根结点的序号，取值写回外存，取另外值读入内存</li><li>调整：同构造过程</li></ul><blockquote><p><strong>选择树</strong>：堆，败者树</p></blockquote><p>时间复杂度：相对复杂</p><ul><li>置换-选择排序中，每记录有两次访问外存&#x2F;输入&#x2F;输出（I&#x2F;O）</li><li>每一趟归并，每记录有两次访问外存&#x2F;输入&#x2F;输出（I&#x2F;O）</li><li>归并趟数：[log以k为底的m]上取整。k为归并路数，m为初始归并段数&#x3D;外存记录数÷内存能容纳的记录数</li><li>k路归并败者树：k个记录&#x2F;叶子结点的<strong>二叉树</strong></li><li>k路归并败者树构造的时间复杂度：O(klogk)。k为归并路数</li><li>k路归并败者树的树高：[log以2为底的k]上取整+1。k为归并路数（不包括树根结点层）</li><li>传统选最值的比较次数：k-1。k为归并路数</li><li>k路归并败者树选最值的比较次数：[log以2为底的k]上取整。k为归并路数</li><li>k路归并败者树选最值的时间复杂度：O(logk)。k为归并路数</li></ul><p>空间复杂度：O(1)。未使用辅助空间</p><hr><h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><p>“排序”学习提纲。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《2023版数据结构高分笔记》主编：率辉</li><li>《2023年计算机组成原理考研复习指导》组编：王道论坛</li><li>《大话数据结构》作者：程杰</li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序的C++语言描述实现模板</title>
      <link href="/2022/09/22/%E6%8E%92%E5%BA%8F%E7%9A%84C++%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E5%AE%9E%E7%8E%B0%E6%A8%A1%E6%9D%BF/"/>
      <url>/2022/09/22/%E6%8E%92%E5%BA%8F%E7%9A%84C++%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E5%AE%9E%E7%8E%B0%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>数据结构中排序的C++语言描述实现模板，有详细的步骤解析及使用示例。</p><hr><h1 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h1><ul><li><a href="https://github.com/yezhening/Programming-examples">yezhening&#x2F;Programming-examples: 编程实例 (github.com)</a></li><li><a href="https://gitee.com/yezhening/Programming-examples">Programming-examples: 编程实例 (gitee.com)</a></li></ul><hr><h1 id="sort-cpp"><a href="#sort-cpp" class="headerlink" title="sort.cpp"></a>sort.cpp</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件————————————————————</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//命名空间</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型————————————————————</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ELEM_TYPE; <span class="comment">//数据的（数据）类型 依据数据的实际类型定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数声明————————————————————</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_example</span><span class="params">()</span></span>;                        <span class="comment">//使用示例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertSort</span><span class="params">(vector&lt;ELEM_TYPE&gt; &amp;elems)</span></span>; <span class="comment">//直接插入排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">binarySort</span><span class="params">(vector&lt;ELEM_TYPE&gt; &amp;elems)</span></span>; <span class="comment">//折半插入排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellSort</span><span class="params">(vector&lt;ELEM_TYPE&gt; &amp;elems)</span></span>;  <span class="comment">//希尔排序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort1</span><span class="params">(vector&lt;ELEM_TYPE&gt; &amp;elems)</span></span>;                    <span class="comment">//冒泡排序    简单版</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort2</span><span class="params">(vector&lt;ELEM_TYPE&gt; &amp;elems)</span></span>;                    <span class="comment">//冒泡排序  正版</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort3</span><span class="params">(vector&lt;ELEM_TYPE&gt; &amp;elems)</span></span>;                    <span class="comment">//冒泡排序  改进版</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;ELEM_TYPE&gt; &amp;elems, <span class="type">int</span> left, <span class="type">int</span> right)</span></span>; <span class="comment">//快速排序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectSort</span><span class="params">(vector&lt;ELEM_TYPE&gt; &amp;elems)</span></span>;                    <span class="comment">//简单选择排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapAdjust</span><span class="params">(vector&lt;ELEM_TYPE&gt; &amp;elems, <span class="type">int</span> low, <span class="type">int</span> high)</span></span>; <span class="comment">//堆调整    大顶堆法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(vector&lt;ELEM_TYPE&gt; &amp;elems)</span></span>;                      <span class="comment">//堆排序  大顶堆法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;ELEM_TYPE&gt; &amp;elems, <span class="type">int</span> low, <span class="type">int</span> mid, <span class="type">int</span> high)</span></span>; <span class="comment">//二路归并</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;ELEM_TYPE&gt; &amp;elems, <span class="type">int</span> low, <span class="type">int</span> high)</span></span>;      <span class="comment">//二路归并排序   递归法  分治法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数定义————————————————————</span></span><br><span class="line"><span class="comment">//使用示例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_example</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建</span></span><br><span class="line">    vector&lt;ELEM_TYPE&gt; elems = &#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;; <span class="comment">//需排序元素的向量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入类排序————————————————————</span></span><br><span class="line">    <span class="built_in">insertSort</span>(elems); <span class="comment">//直接插入排序</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;直接插入排序: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> elem : elems)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//输出：直接插入排序：1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//恢复需排序元素向量</span></span><br><span class="line">    elems[<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line">    elems[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    elems[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    elems[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">    elems[<span class="number">4</span>] = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">binarySort</span>(elems); <span class="comment">//折半插入排序</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;折半插入排序: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> elem : elems)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//输出：折半插入排序：1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//恢复需排序元素向量</span></span><br><span class="line">    elems[<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line">    elems[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    elems[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    elems[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">    elems[<span class="number">4</span>] = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">shellSort</span>(elems); <span class="comment">//希尔排序</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;希尔排序: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> elem : elems)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//输出：希尔排序：1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//恢复需排序元素向量</span></span><br><span class="line">    elems[<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line">    elems[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    elems[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    elems[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">    elems[<span class="number">4</span>] = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换类排序————————————————————</span></span><br><span class="line">    <span class="built_in">bubbleSort1</span>(elems); <span class="comment">//冒泡排序    简单版</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;冒泡排序    简单版: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> elem : elems)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//输出：冒泡排序    简单版：1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//恢复需排序元素向量</span></span><br><span class="line">    elems[<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line">    elems[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    elems[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    elems[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">    elems[<span class="number">4</span>] = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bubbleSort2</span>(elems); <span class="comment">//冒泡排序  正版</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;冒泡排序    正版: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> elem : elems)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//输出：冒泡排序    正版：1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//恢复需排序元素向量</span></span><br><span class="line">    elems[<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line">    elems[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    elems[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    elems[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">    elems[<span class="number">4</span>] = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bubbleSort3</span>(elems); <span class="comment">//冒泡排序  改进版</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;冒泡排序    改进版: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> elem : elems)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//输出：冒泡排序    改进版：1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//恢复需排序元素向量</span></span><br><span class="line">    elems[<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line">    elems[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    elems[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    elems[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">    elems[<span class="number">4</span>] = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//快速排序</span></span><br><span class="line">    <span class="built_in">quickSort</span>(elems, <span class="number">0</span>, elems.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;快速排序: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> elem : elems)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//输出：快速排序：1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//恢复需排序元素向量</span></span><br><span class="line">    elems[<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line">    elems[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    elems[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    elems[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">    elems[<span class="number">4</span>] = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//选择类排序————————————————————</span></span><br><span class="line">    <span class="comment">//简单选择排序</span></span><br><span class="line">    <span class="built_in">selectSort</span>(elems);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;简单选择排序: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> elem : elems)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//输出：简单选择排序：1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//恢复需排序元素向量</span></span><br><span class="line">    elems[<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line">    elems[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    elems[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    elems[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">    elems[<span class="number">4</span>] = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//堆排序    大顶堆法</span></span><br><span class="line">    <span class="built_in">heapSort</span>(elems);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;堆排序    大顶堆法: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> elem : elems)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//输出：堆排序    大顶堆法：4 1 2 3 5</span></span><br><span class="line">    <span class="comment">//注意：第一个元素不参与排序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//恢复需排序元素向量</span></span><br><span class="line">    elems[<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line">    elems[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    elems[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    elems[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">    elems[<span class="number">4</span>] = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//归并类排序————————————————————</span></span><br><span class="line">    <span class="comment">//二路归并排序   递归法  分治法</span></span><br><span class="line">    <span class="built_in">mergeSort</span>(elems, <span class="number">0</span>, elems.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//注意：闭区间</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;二路归并排序   递归法  分治法: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> elem : elems)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//输出：二路归并排序   递归法  分治法：1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//恢复需排序元素向量</span></span><br><span class="line">    elems[<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line">    elems[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    elems[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    elems[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">    elems[<span class="number">4</span>] = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接插入排序</span></span><br><span class="line"><span class="comment">//时间复杂度：O(n²)。n为数据规模</span></span><br><span class="line"><span class="comment">//时间复杂度：数据规模×比较次数</span></span><br><span class="line"><span class="comment">//最好：O(n)。n为数据规模。（有序）</span></span><br><span class="line"><span class="comment">//平均：O(n²)。n为数据规模</span></span><br><span class="line"><span class="comment">//最坏：O(n²)。n为数据规模。（无序的逆序）</span></span><br><span class="line"><span class="comment">//空间复杂度：O(1)。未使用额外辅助空间</span></span><br><span class="line"><span class="comment">//稳定性：稳定</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertSort</span><span class="params">(vector&lt;ELEM_TYPE&gt; &amp;elems)</span> <span class="comment">//参数：需排序元素的向量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">//循环变量</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>; <span class="comment">//需排序元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一个元素values[0]前无元素，不需要排序</span></span><br><span class="line">    <span class="comment">//从第二个元素values[1]开始遍历，需要排序</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; elems.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = elems[i]; <span class="comment">//记录需排序元素</span></span><br><span class="line">        <span class="comment">//需排序元素前的元素向后移动时，会覆盖需排序元素</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历需排序元素前的元素</span></span><br><span class="line">        <span class="comment">//比较需排序元素和需排序元素前的元素</span></span><br><span class="line">        <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp &lt; elems[j]) <span class="comment">//需排序元素&lt;需排序元素前的元素   1.比较   &lt;：稳定性体现</span></span><br><span class="line">            &#123;</span><br><span class="line">                elems[j + <span class="number">1</span>] = elems[j]; <span class="comment">//需排序元素前的元素向后移动 2.移动</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//&gt;=</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历需排序元素前的元素结束时：需排序元素&gt;=需排序元素前的元素    有插入位置</span></span><br><span class="line">        elems[j + <span class="number">1</span>] = temp; <span class="comment">//插入</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//折半插入排序</span></span><br><span class="line"><span class="comment">//时间复杂度：O(n²)。n为数据规模</span></span><br><span class="line"><span class="comment">//时间复杂度：数据规模×比较次数</span></span><br><span class="line"><span class="comment">//最好：O(nlogn)。n为数据规模</span></span><br><span class="line"><span class="comment">//平均：O(n²)。n为数据规模</span></span><br><span class="line"><span class="comment">//最坏：O(n²)。n为数据规模</span></span><br><span class="line"><span class="comment">//空间复杂度：O(1)。未使用额外辅助空间</span></span><br><span class="line"><span class="comment">//稳定性：稳定</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">binarySort</span><span class="params">(vector&lt;ELEM_TYPE&gt; &amp;elems)</span> <span class="comment">//参数：需排序元素的向量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">//循环变量</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>; <span class="comment">//需排序元素</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;                 <span class="comment">//左位置指针</span></span><br><span class="line">    <span class="type">int</span> right = elems.<span class="built_in">size</span>() - <span class="number">1</span>; <span class="comment">//右位置指针</span></span><br><span class="line">    <span class="type">int</span> mid = <span class="number">0</span>;                  <span class="comment">//中间位置指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一个元素elems[0]前无元素，不需要排序</span></span><br><span class="line">    <span class="comment">//从第二个元素elems[1]开始遍历，需要排序</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; elems.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = elems[i]; <span class="comment">//记录需排序元素</span></span><br><span class="line">        <span class="comment">//需排序元素前的元素向后移动时，会覆盖需排序元素</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//折半查找插入位置  1.比较</span></span><br><span class="line">        left = <span class="number">0</span>;      <span class="comment">//更新左位置指针</span></span><br><span class="line">        right = i - <span class="number">1</span>; <span class="comment">//更新右位置指针</span></span><br><span class="line">        <span class="comment">//查找范围：0~i-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) <span class="comment">//左位置指针&lt;=右位置指针时，循环</span></span><br><span class="line">        &#123;</span><br><span class="line">            mid = left + (right - left) / <span class="number">2</span>; <span class="comment">//取中间位置</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (temp == elems[mid]) <span class="comment">//需排序元素=中间位置元素时，在右区间查找    稳定性体现</span></span><br><span class="line">            &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (temp &gt; elems[mid]) <span class="comment">//需排序元素&gt;中间位置元素，在右区间查找</span></span><br><span class="line">            &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (temp &lt; elems[mid]) <span class="comment">//需排序元素&lt;中间位置元素，在左区间查找</span></span><br><span class="line">            &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//折半查找插入位置结束时：可推导插入位置为right + 1</span></span><br><span class="line">        <span class="comment">// right + 1 ~ i - 1的元素向后移动  2.移动</span></span><br><span class="line">        <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= right + <span class="number">1</span>; --j)</span><br><span class="line">        &#123;</span><br><span class="line">            elems[j + <span class="number">1</span>] = elems[j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        elems[right + <span class="number">1</span>] = temp; <span class="comment">//插入</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//希尔排序</span></span><br><span class="line"><span class="comment">//时间复杂度：O(n的1.3次方)~O(n²) 。n为数据规模</span></span><br><span class="line"><span class="comment">//时间复杂度：增量的函数/选取规则（仍是数学难题）</span></span><br><span class="line"><span class="comment">//最好：O(n的1.3次方)。n为数据规模（n在特定范围）</span></span><br><span class="line"><span class="comment">// O(n的1.5次方)。n为数据规模（增量选取规则：2的k次方+1，...，5，3，1。k为整数，k&gt;=1，2的k次方+1 &lt; n）</span></span><br><span class="line"><span class="comment">//最坏：O(n²)。n为数据规模。（增量选取规则：[n/2]下取整，[n/4]下取整，...，1）</span></span><br><span class="line"><span class="comment">//空间复杂度：O(1)。未使用额外辅助空间</span></span><br><span class="line"><span class="comment">//稳定性：不稳定（依据增量划分序列时，可能改变元素的相对位置）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellSort</span><span class="params">(vector&lt;ELEM_TYPE&gt; &amp;elems)</span> <span class="comment">//参数：需排序元素的向量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">//循环变量</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>; <span class="comment">//需排序元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//增量/步长范围：elems.size() / 2 ~ 1</span></span><br><span class="line">    <span class="comment">//步长变化规则：step /= 2</span></span><br><span class="line">    <span class="comment">//对每步长序列进行直接插入排序  类比直接插入排序过程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> step = elems.<span class="built_in">size</span>() / <span class="number">2</span>; step &gt;= <span class="number">1</span>; step /= <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//需排序元素位置：step ~ elems.size() - 1</span></span><br><span class="line">        <span class="comment">//需要比较需排序元素和需排序元素前的元素，从步长的位置开始才有意义</span></span><br><span class="line">        <span class="keyword">for</span> (i = step; i &lt; elems.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = elems[i]; <span class="comment">//记录需排序元素</span></span><br><span class="line">            <span class="comment">//需排序元素前的元素向后移动时，会覆盖需排序元素</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//遍历需排序元素前的元素</span></span><br><span class="line">            <span class="comment">//比较需排序元素和需排序元素前的元素</span></span><br><span class="line">            <span class="comment">//需排序元素前的元素位置：j = i - step ~ 0</span></span><br><span class="line">            <span class="keyword">for</span> (j = i - step; j &gt;= <span class="number">0</span>; j -= step)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp &lt; elems[j]) <span class="comment">//需排序元素&lt;需排序元素前的元素   1.比较</span></span><br><span class="line">                &#123;</span><br><span class="line">                    elems[j + step] = elems[j]; <span class="comment">//需排序元素前的元素向后移动 2.移动/交换</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="comment">//&gt;=</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//遍历需排序元素前的元素结束时：需排序元素&gt;=需排序元素前的元素    有插入位置</span></span><br><span class="line">            elems[j + step] = temp; <span class="comment">//插入</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//冒泡排序  简单版</span></span><br><span class="line"><span class="comment">//时间复杂度：O(n²)。n为数据规模</span></span><br><span class="line"><span class="comment">//时间复杂度：数据规模×比较次数</span></span><br><span class="line"><span class="comment">//最好：O(n)。n为数据规模。（有序）</span></span><br><span class="line"><span class="comment">//平均：O(n²)。n为数据规模</span></span><br><span class="line"><span class="comment">//最坏：O(n²)。n为数据规模。（无序的逆序）</span></span><br><span class="line"><span class="comment">//空间复杂度：O(1)。未使用额外辅助空间</span></span><br><span class="line"><span class="comment">//稳定性：稳定</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort1</span><span class="params">(vector&lt;ELEM_TYPE&gt; &amp;elems)</span> <span class="comment">//参数：需排序元素的向量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">//循环变量</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>; <span class="comment">//需排序元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历需排序元素</span></span><br><span class="line">    <span class="comment">//需排序元素位置：0 ~ elems.size() - 2</span></span><br><span class="line">    <span class="comment">// elems.size()个元素需elems.size() - 1次比较</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; elems.<span class="built_in">size</span>() - <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//遍历需排序元素后的元素</span></span><br><span class="line">        <span class="comment">//需排序元素后的元素位置：i + 1 ~ elems.size() - 1</span></span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; elems.<span class="built_in">size</span>(); ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (elems[i] &gt; elems[j]) <span class="comment">//需排序元素&gt;需排序元素后的元素   1.比较   稳定性体现</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 2.移动/交换</span></span><br><span class="line">                temp = elems[i];</span><br><span class="line">                elems[i] = elems[j];</span><br><span class="line">                elems[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//冒泡排序  正版</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort2</span><span class="params">(vector&lt;ELEM_TYPE&gt; &amp;elems)</span> <span class="comment">//参数：需排序元素的向量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">//循环变量</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>; <span class="comment">//需排序元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历需排序位置</span></span><br><span class="line">    <span class="comment">//需排序位置：0 ~ elems.size() - 2</span></span><br><span class="line">    <span class="comment">// elems.size()个元素需elems.size() - 1次比较</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意：</span></span><br><span class="line">    <span class="comment">//排序位置而不是元素：一趟排序确定一个位置</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; elems.<span class="built_in">size</span>() - <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//遍历需排序位置后的元素</span></span><br><span class="line">        <span class="comment">//需排序位置后的元素位置：i + 1 ~ elems.size() - 1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//注意：</span></span><br><span class="line">        <span class="comment">//从后往前遍历</span></span><br><span class="line">        <span class="comment">//两两相邻元素排序  思想体现</span></span><br><span class="line">        <span class="keyword">for</span> (j = elems.<span class="built_in">size</span>() - <span class="number">1</span>; j &gt; i; --j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (elems[j - <span class="number">1</span>] &gt; elems[j]) <span class="comment">//前需排序元素&gt;后需排序元素   1.比较   稳定性体现</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 2.移动/交换</span></span><br><span class="line">                temp = elems[j - <span class="number">1</span>];</span><br><span class="line">                elems[j - <span class="number">1</span>] = elems[j];</span><br><span class="line">                elems[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//冒泡排序  改进版</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort3</span><span class="params">(vector&lt;ELEM_TYPE&gt; &amp;elems)</span> <span class="comment">//参数：需排序元素的向量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">//循环变量</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>; <span class="comment">//需排序元素</span></span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//标志：</span></span><br><span class="line">    <span class="comment">// true：一趟排序中，有交换过程，序列无序，算法继续进行</span></span><br><span class="line">    <span class="comment">// false：一趟排序中，无交换过程，序列有序，算法结束</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历需排序位置</span></span><br><span class="line">    <span class="comment">//需排序位置：0 ~ elems.size() - 2</span></span><br><span class="line">    <span class="comment">// elems.size()个元素需elems.size() - 1次比较</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意：</span></span><br><span class="line">    <span class="comment">//排序位置而不是元素：一趟排序确定一个位置</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; elems.<span class="built_in">size</span>() - <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//遍历需排序位置后的元素</span></span><br><span class="line">        <span class="comment">//需排序位置后的元素位置：i + 1 ~ elems.size() - 1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//注意：</span></span><br><span class="line">        <span class="comment">//从后往前遍历</span></span><br><span class="line">        <span class="comment">//两两相邻元素排序  思想体现</span></span><br><span class="line">        <span class="keyword">for</span> (j = elems.<span class="built_in">size</span>() - <span class="number">1</span>; j &gt; i; --j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (elems[j - <span class="number">1</span>] &gt; elems[j]) <span class="comment">//前需排序元素&gt;后需排序元素   1.比较   稳定性体现</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 2.移动/交换</span></span><br><span class="line">                temp = elems[j - <span class="number">1</span>];</span><br><span class="line">                elems[j - <span class="number">1</span>] = elems[j];</span><br><span class="line">                elems[j] = temp;</span><br><span class="line"></span><br><span class="line">                flag = <span class="literal">true</span>; <span class="comment">//有交换过程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="literal">false</span>) <span class="comment">//无交换过程</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="comment">//时间复杂度：O(nlogn)。n为数据规模</span></span><br><span class="line"><span class="comment">//最好：O(nlogn)。n为数据规模。（无序）</span></span><br><span class="line"><span class="comment">//平均：O(nlogn)。n为数据规模。</span></span><br><span class="line"><span class="comment">//最坏：O(n²)。n为数据规模。（有序或无序的逆序）</span></span><br><span class="line"><span class="comment">//空间复杂度：O(logn)。n为数据规模</span></span><br><span class="line"><span class="comment">//空间复杂度：递归调用栈的大小/树的深度/高度</span></span><br><span class="line"><span class="comment">//最好：O(logn)。n为数据规模（平衡树）</span></span><br><span class="line"><span class="comment">//平均：O(logn)。n为数据规模</span></span><br><span class="line"><span class="comment">//最坏：O(n)。n为数据规模（斜树）</span></span><br><span class="line"><span class="comment">//稳定性：不稳定（依据枢轴划分并交换时，可能改变元素的相对位置）</span></span><br><span class="line"><span class="comment">//注意：时间复杂度和空间复杂度是平均而不是最坏情况</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序的优化</span></span><br><span class="line"><span class="comment">// 1.枢轴选取优化</span></span><br><span class="line"><span class="comment">//（1）随机法</span></span><br><span class="line"><span class="comment">//需排序元素的向量中，随机选取一个元素作为枢轴</span></span><br><span class="line"><span class="comment">//（2）三数取中法</span></span><br><span class="line"><span class="comment">//需排序元素的向量中，最左位置、中间位置和最右位置的元素排序，选取中间的元素作为枢轴</span></span><br><span class="line"><span class="comment">//适用小数据规模</span></span><br><span class="line"><span class="comment">//（3）九数取中法</span></span><br><span class="line"><span class="comment">//需排序元素的向量中，取样三次，每次取三个元素得中间元素，三个中间元素得中间元素</span></span><br><span class="line"><span class="comment">//可适用大数据规模</span></span><br><span class="line"><span class="comment">// 2.不必要交换优化</span></span><br><span class="line"><span class="comment">//备份枢轴</span></span><br><span class="line"><span class="comment">//左和右位置指针遍历时，进行元素替换而不是交换</span></span><br><span class="line"><span class="comment">//遍历后，枢轴放到确定位置</span></span><br><span class="line"><span class="comment">// 3.小数据规模优化</span></span><br><span class="line"><span class="comment">//设置数据规模阈值</span></span><br><span class="line"><span class="comment">//若数据规模&lt;阈值，使用直接插入排序</span></span><br><span class="line"><span class="comment">//若数据规模&gt;=阈值，使用快速排序</span></span><br><span class="line"><span class="comment">// 4.递归优化</span></span><br><span class="line"><span class="comment">//使用尾递归/迭代</span></span><br><span class="line"><span class="comment">//示例：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void quickSort(...)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    while (left &lt; right) //使用while</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        int i = left;  //逻辑处理</span></span><br><span class="line"><span class="comment">        int j = right;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        ...</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        quickSort(elems, left, privot - 1);  //左递归</span></span><br><span class="line"><span class="comment">        left = prvot + 1; //右迭代</span></span><br><span class="line"><span class="comment">        //左递归后，left无用，赋值为prvot + 1</span></span><br><span class="line"><span class="comment">        //while在下次迭代，i = pivot + 1，j = right，相当于右递归的逻辑处理</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;ELEM_TYPE&gt; &amp;elems, <span class="type">int</span> left, <span class="type">int</span> right)</span> <span class="comment">//参数：需排序元素的向量，左位置指针，右位置指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = left;  <span class="comment">//左位置指针    用于划分</span></span><br><span class="line">    <span class="type">int</span> j = right; <span class="comment">//右位置指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) <span class="comment">//左位置指针&lt;右位置指针时，递归</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 1.划分   确定枢轴</span></span><br><span class="line">        ELEM_TYPE privot = elems[left];</span><br><span class="line">        <span class="comment">//当前排序表的第一个元素作为枢轴    枢轴划分当前排序表为左排序表和右排序表</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) <span class="comment">//左位置指针小于右位置指针时，循环</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//左位置指针小于右位置指针时</span></span><br><span class="line">            <span class="comment">//右位置指针向左移动，直到找到比枢轴小的元素</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (elems[j] &gt;= privot) <span class="comment">//右位置指针&gt;=枢轴  向左移动    1.比较</span></span><br><span class="line">                &#123;</span><br><span class="line">                    --j;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="comment">//&lt;</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            elems[i] = elems[j]; <span class="comment">//比枢轴小的元素放在左指针位置  2.移动/交换</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//左位置指针小于右位置指针时</span></span><br><span class="line">            <span class="comment">//左位置指针向右移动，直到找到比枢轴大的元素</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (elems[i] &lt;= privot) <span class="comment">//左位置指针&lt;=枢轴  向右移动    1.比较</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ++i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="comment">//&gt;</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            elems[j] = elems[i]; <span class="comment">//比枢轴大的元素放在左指针位置  2.移动/交换</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环结束时，左排序表的元素比枢轴小，右排序表的元素比枢轴大</span></span><br><span class="line">        elems[i] = privot; <span class="comment">//枢轴放在左位置指针 可推导</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.递归</span></span><br><span class="line">        <span class="comment">//注意：使用left和right</span></span><br><span class="line">        <span class="built_in">quickSort</span>(elems, left, privot - <span class="number">1</span>);  <span class="comment">//左递归</span></span><br><span class="line">        <span class="built_in">quickSort</span>(elems, privot + <span class="number">1</span>, right); <span class="comment">//右递归</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//简单选择排序</span></span><br><span class="line"><span class="comment">//时间复杂度：O(n²)。n为数据规模</span></span><br><span class="line"><span class="comment">//时间复杂度：数据规模×比较次数</span></span><br><span class="line"><span class="comment">//最好：O(n²)。n为数据规模</span></span><br><span class="line"><span class="comment">//平均：O(n²)。n为数据规模</span></span><br><span class="line"><span class="comment">//最坏：O(n²)。n为数据规模</span></span><br><span class="line"><span class="comment">//空间复杂度：O(1)。未使用额外辅助空间</span></span><br><span class="line"><span class="comment">//稳定性：不稳定（最小元素和需排序元素交换时，可能改变元素的相对位置）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectSort</span><span class="params">(vector&lt;ELEM_TYPE&gt; &amp;elems)</span> <span class="comment">//参数：需排序元素的向量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">//循环变量</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> min = <span class="number">0</span>;        <span class="comment">//最小元素位置</span></span><br><span class="line">    ELEM_TYPE temp = <span class="number">0</span>; <span class="comment">//交换时，记录暂存元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历需排序位置</span></span><br><span class="line">    <span class="comment">//需排序位置：0 ~ elems.size() - 2</span></span><br><span class="line">    <span class="comment">//最后一个位置elems.size() - 1不需要排序</span></span><br><span class="line">    <span class="comment">// elems.size()个位置需elems.size() - 1趟排序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意：</span></span><br><span class="line">    <span class="comment">//排序位置而不是元素：一趟排序确定一个位置</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; elems.<span class="built_in">size</span>() - <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        min = i; <span class="comment">//记录最小元素位置</span></span><br><span class="line">        <span class="comment">//理解：</span></span><br><span class="line">        <span class="comment">// i记录需排序位置</span></span><br><span class="line">        <span class="comment">// min记录最小元素位置</span></span><br><span class="line">        <span class="comment">//从最小元素位置，取最小元素，放到需排序位置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历需排序位置后的位置</span></span><br><span class="line">        <span class="comment">//比较当前最小元素和需排序位置后的位置的元素，取最小元素，放到需排序位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; elems.<span class="built_in">size</span>(); ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (elems[min] &gt; elems[j]) <span class="comment">//当前最小元素&gt;需排序元素位置后的位置的元素  1.比较/选择</span></span><br><span class="line">            &#123;</span><br><span class="line">                min = j; <span class="comment">//记录最小元素位置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.移动/交换</span></span><br><span class="line">        <span class="comment">//最小元素，放到需排序位置</span></span><br><span class="line">        <span class="comment">//需排序位置元素，放到最小元素位置</span></span><br><span class="line">        <span class="keyword">if</span> (min != i) <span class="comment">//最小元素位置!=需排序元素位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp = elems[i];</span><br><span class="line">            elems[i] = elems[min];</span><br><span class="line">            elems[min] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//堆调整    大顶堆法</span></span><br><span class="line"><span class="comment">//参数：需排序元素的向量，闭区间[low，high]位置结点调整为大顶堆</span></span><br><span class="line"><span class="comment">//关键理解：实际上，调整以low位置结点为根的树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapAdjust</span><span class="params">(vector&lt;ELEM_TYPE&gt; &amp;elems, <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = low; <span class="comment">//调整以i位置结点为根的树    调整时，i位置可能会从上到下更新</span></span><br><span class="line"></span><br><span class="line">    ELEM_TYPE temp = elems[low]; <span class="comment">//暂存i位置结点的关键字</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//关键理解：</span></span><br><span class="line">    <span class="comment">// j：需比较和交换结点的位置</span></span><br><span class="line">    <span class="comment">//范围：以i位置结点为根的树</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// int j = 2 * i：i位置结点的左孩子结点是2 * i位置结点（依据完全二叉树的性质）</span></span><br><span class="line">    <span class="comment">// j &lt;= high：位置不越界</span></span><br><span class="line">    <span class="comment">// j *= 2：左孩子结点的位置（依据完全二叉树的性质）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//每循环，比较i位置结点、2 * i位置结点和2 * i + 1位置结点的关键字</span></span><br><span class="line">    <span class="comment">//即比较i位置结点、i位置结点的左孩子结点和i位置结点的右孩子结点的关键字</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span> * i; j &lt;= high; j *= <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 1. 比较左孩子结点和右孩子结点的关键字</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//  j &lt; high：j不是最后一个结点的位置-&gt;i位置结点存在右孩子结点</span></span><br><span class="line">        <span class="comment">//  elems[j] &lt; elems[j + 1]：左孩子结点的关键字&lt;右孩子结点的关键字</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt; high &amp;&amp; elems[j] &lt; elems[j + <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            ++j; <span class="comment">//更新需比较和交换结点的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//目的：</span></span><br><span class="line">        <span class="comment">// j：需比较和交换结点的位置</span></span><br><span class="line">        <span class="comment">//取左孩子结点和右孩子结点中，关键字最大的位置</span></span><br><span class="line">        <span class="comment">// j = 2 * i或j = 2 * i + 1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.比较i位置结点、左孩子结点和右孩子结点中，关键字最大的结点</span></span><br><span class="line">        <span class="comment">// i位置结点&lt;左孩子结点和右孩子结点中，关键字最大的结点</span></span><br><span class="line">        <span class="comment">//需要调整</span></span><br><span class="line">        <span class="keyword">if</span> (temp &lt; elems[j])</span><br><span class="line">        &#123;</span><br><span class="line">            elems[i] = elems[j]; <span class="comment">// i位置结点的关键字赋值为j位置结点的关键字</span></span><br><span class="line">            i = j;               <span class="comment">//更新i位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//&gt;=    不需要调整</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">//调整结束</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    elems[i] = temp; <span class="comment">// i位置结点的关键字赋值为暂存的关键字 注意：i可能已更新</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//堆排序    大顶堆法</span></span><br><span class="line"><span class="comment">//时间复杂度：O(nlogn)。n为数据规模</span></span><br><span class="line"><span class="comment">//时间复杂度：建堆和堆排序</span></span><br><span class="line"><span class="comment">//建堆：O(n)。n为数据规模</span></span><br><span class="line"><span class="comment">//堆排序：排序次数×调整堆/树高</span></span><br><span class="line"><span class="comment">//堆排序：O(nlogn)。n为数据规模</span></span><br><span class="line"><span class="comment">//最好：O(nlogn)。n为数据规模</span></span><br><span class="line"><span class="comment">//平均：O(nlogn)。n为数据规模</span></span><br><span class="line"><span class="comment">//最坏：O(nlogn)。n为数据规模</span></span><br><span class="line"><span class="comment">//空间复杂度：O(1)。未使用额外辅助空间</span></span><br><span class="line"><span class="comment">//稳定性：不稳定（需排序元素交换时，可能改变元素的相对位置）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(vector&lt;ELEM_TYPE&gt; &amp;elems)</span> <span class="comment">//参数：需排序元素的向量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ELEM_TYPE temp = <span class="number">0</span>; <span class="comment">//暂存交换结点的关键字</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.建堆</span></span><br><span class="line">    <span class="comment">//从完全二叉树的最后一个非叶子结点开始，从右到左，从下到上，调整结点</span></span><br><span class="line">    <span class="comment">//范围：1~(elems.size() - 1) / 2</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = (elems.<span class="built_in">size</span>() - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heapAdjust</span>(elems, i, elems.<span class="built_in">size</span>() - <span class="number">1</span>); <span class="comment">//注意：闭区间[low，high]位置结点调整为大顶堆   1.比较</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.堆排序</span></span><br><span class="line">    <span class="comment">//范围：2~elems.size() - 1</span></span><br><span class="line">    <span class="comment">//对1~elems.size() - 1个结点，需进行elems.size() - 2次排序，最后一个结点已有序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = elems.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">2</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//交换树根结点和最右下位置结点，删除最右下位置结点，输出最右下位置结点（最右下位置结点进入有序序列）    2.移动/交换</span></span><br><span class="line">        temp = elems[<span class="number">1</span>];</span><br><span class="line">        elems[<span class="number">1</span>] = elems[i];</span><br><span class="line">        elems[i] = temp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调整（最右下位置结点被交换到树根结点，可能不满足堆定义）  1.比较</span></span><br><span class="line">        <span class="built_in">heapAdjust</span>(elems, <span class="number">1</span>, i - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//注意：i - 1：因为最右下位置结点进入有序序列，无需进行调整</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二路归并</span></span><br><span class="line"><span class="comment">//参数：需排序元素的向量，归并闭区间[low，mid]和[mid + 1，high]序列</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;ELEM_TYPE&gt; &amp;elems, <span class="type">int</span> low, <span class="type">int</span> mid, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;ELEM_TYPE&gt; <span class="title">temp</span><span class="params">(elems.size(), <span class="number">0</span>)</span></span>; <span class="comment">//暂存需排序元素的向量</span></span><br><span class="line">    <span class="comment">//因为需要修改elems，elems存储已排序元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//暂存需排序元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = low; i &lt;= high; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        temp[i] = elems[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环变量</span></span><br><span class="line">    <span class="type">int</span> i = low;     <span class="comment">//闭区间[low，mid]序列位置</span></span><br><span class="line">    <span class="type">int</span> j = mid + <span class="number">1</span>; <span class="comment">//闭区间[mid + 1，high]序列位置</span></span><br><span class="line">    <span class="type">int</span> k = low;     <span class="comment">// elems位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//闭区间[low，mid]序列位置和闭区间[mid + 1，high]序列位置未越界时，循环</span></span><br><span class="line">    <span class="comment">//比较，取两区间中的最小元素，存储在elems位置</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp[i] &lt;= temp[j]) <span class="comment">//闭区间[low，mid]序列元素 &lt;= 闭区间[mid + 1，high]序列元素 两两比较，稳定性体现</span></span><br><span class="line">        &#123;</span><br><span class="line">            elems[k] = temp[i];</span><br><span class="line"></span><br><span class="line">            ++k; <span class="comment">//更新位置</span></span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//&gt;</span></span><br><span class="line">        &#123;</span><br><span class="line">            elems[k] = temp[j];</span><br><span class="line"></span><br><span class="line">            ++k; <span class="comment">//更新位置</span></span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//闭区间[low，mid]序列位置或闭区间[mid + 1，high]序列位置越界</span></span><br><span class="line">    <span class="comment">//若另一个序列有未排序元素，存储在elems位置</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid)</span><br><span class="line">    &#123;</span><br><span class="line">        elems[k] = temp[i];</span><br><span class="line"></span><br><span class="line">        ++k; <span class="comment">//更新位置</span></span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= high)</span><br><span class="line">    &#123;</span><br><span class="line">        elems[k] = temp[j];</span><br><span class="line"></span><br><span class="line">        ++k; <span class="comment">//更新位置</span></span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二路归并排序  递归法  分治法</span></span><br><span class="line"><span class="comment">//时间复杂度：O(nlogn)。n为数据规模</span></span><br><span class="line"><span class="comment">//时间复杂度：归并趟数×一趟归并的操作次数</span></span><br><span class="line"><span class="comment">//归并趟数：O(nlogn)。n为数据规模</span></span><br><span class="line"><span class="comment">//一趟归并的操作次数：O(n)。n为数据规模</span></span><br><span class="line"><span class="comment">//最好：O(nlogn)。n为数据规模</span></span><br><span class="line"><span class="comment">//平均：O(nlogn)。n为数据规模</span></span><br><span class="line"><span class="comment">//最坏：O(nlogn)。n为数据规模</span></span><br><span class="line"><span class="comment">//空间复杂度：O(n)。n为数据规模</span></span><br><span class="line"><span class="comment">//空间复杂度：暂存需排序元素辅助空间的大小或递归调用栈的大小</span></span><br><span class="line"><span class="comment">//暂存需排序元素辅助空间的大小：O(n)。n为数据规模</span></span><br><span class="line"><span class="comment">//递归调用栈的大小：O(logn)。n为数据规模</span></span><br><span class="line"><span class="comment">//稳定性：稳定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二路归并排序  迭代法简介</span></span><br><span class="line"><span class="comment">//循环中：更新步长/增量，两两归并，归并剩余单个序列</span></span><br><span class="line"><span class="comment">//时间复杂度：无递归，比递归法更优，数量级不变</span></span><br><span class="line"><span class="comment">//空间复杂度：无递归调用栈，比递归法更优，数量级不变</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//另：m = (log以k为底的n)上取整。m为归并趟数，k为归并路数，n为数据规模</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//参数：需排序元素的向量，排序闭区间[low，high]序列：左位置指针，右位置指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;ELEM_TYPE&gt; &amp;elems, <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) <span class="comment">//左位置指针 &lt; 右位置指针，区间合法</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = low + (high - low) / <span class="number">2</span>; <span class="comment">//中间位置指针    划分左右区间</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">mergeSort</span>(elems, low, mid);      <span class="comment">//左区间归并排序   左</span></span><br><span class="line">        <span class="built_in">mergeSort</span>(elems, mid + <span class="number">1</span>, high); <span class="comment">//右区间归并排序   右</span></span><br><span class="line">        <span class="built_in">merge</span>(elems, low, mid, high);    <span class="comment">//归并 中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基数排序</span></span><br><span class="line"><span class="comment">//思想：多关键字比较，无需进行比较和移动</span></span><br><span class="line"><span class="comment">//类型：最高位优先（MSD）；最低位优先（LSD）</span></span><br><span class="line"><span class="comment">//最高位优先（MSD）：排序最高位，排序次高位...以此类推</span></span><br><span class="line"><span class="comment">//最低位优先（LSD）：分配和收集最低位，分配和收集次低位...以此类推。对每个数据分配入队列，对每个队列收集出队列数据</span></span><br><span class="line"><span class="comment">//注意和理解：最高位优先能够在一定程度上确定排序，最低位优先不能</span></span><br><span class="line"><span class="comment">//时间复杂度：O(d(n+r))。d为数据位数，n为数据规模，r为数据基数/取值范围。如十进制数字基数为10、小写字母基数为26</span></span><br><span class="line"><span class="comment">//时间复杂度：排序趟数×分配和收集次数。排序趟数为数据位数，分配次数为数据规模，收集次数为数据基数</span></span><br><span class="line"><span class="comment">//最好：O(d(n+r))</span></span><br><span class="line"><span class="comment">//平均：O(d(n+r))</span></span><br><span class="line"><span class="comment">//最坏：O(d(n+r))</span></span><br><span class="line"><span class="comment">//空间复杂度：O(r)。r为数据基数/取值范围。如十进制数字基数为10、小写字母基数为26</span></span><br><span class="line"><span class="comment">//空间复杂度：分配和收集队列的大小</span></span><br><span class="line"><span class="comment">//稳定性：稳定（按位排序时，稳定性体现）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数————————————————————</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">use_example</span>(); <span class="comment">//使用示例</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>不同参考资料中，排序的描述实现各不相同，但基本思想是一致的。作者使用规范的变量命名、提供详细的步骤解析及使用示例，应用C++语言将其整合成模板，以帮助理解记忆。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《2023版数据结构高分笔记》主编：率辉</li><li>《2023年计算机组成原理考研复习指导》组编：王道论坛</li><li>《大话数据结构》作者：程杰</li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“查找”学习提纲（三）——总结</title>
      <link href="/2022/09/21/%E2%80%9C%E6%9F%A5%E6%89%BE%E2%80%9D%E5%AD%A6%E4%B9%A0%E6%8F%90%E7%BA%B2%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E6%80%BB%E7%BB%93/"/>
      <url>/2022/09/21/%E2%80%9C%E6%9F%A5%E6%89%BE%E2%80%9D%E5%AD%A6%E4%B9%A0%E6%8F%90%E7%BA%B2%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>“查找”学习提纲（三）——总结</p><hr><h1 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h1><ul><li><a href="https://blog.csdn.net/m0_62083249/article/details/126670470">“查找”学习提纲（一）——线性查找_夜悊的博客-CSDN博客</a></li></ul><hr><h1 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h1><ul><li><a href="https://blog.csdn.net/m0_62083249/article/details/126742184">线性查找的C++语言描述实现模板_夜悊的博客-CSDN博客</a></li><li><a href="https://blog.csdn.net/m0_62083249/article/details/126798146">二叉排序树的C++语言描述实现模板_夜悊的博客-CSDN博客</a></li></ul><hr><h1 id="查找方式的选择因素"><a href="#查找方式的选择因素" class="headerlink" title="查找方式的选择因素"></a>查找方式的选择因素</h1><ul><li>目的：静态查找或动态查找</li><li>次序：无序或有序</li><li>数据结构：顺序存储或链式存储；线性结构或非线性结构</li><li>性能：低效或高效</li></ul><hr><h1 id="线性查找"><a href="#线性查找" class="headerlink" title="线性查找"></a>线性查找</h1><table><thead><tr><th>名称</th><th>适用</th><th>时间复杂度</th><th>空间复杂度</th></tr></thead><tbody><tr><td>顺序查找</td><td>线性表</td><td>O(n)</td><td>O(1)</td></tr><tr><td>折半查找</td><td>有序顺序表</td><td>O(logn)</td><td>O(1)</td></tr><tr><td>插值查找</td><td>有序顺序表</td><td>O(logn)</td><td>O(1)</td></tr><tr><td>斐波那契查找</td><td>有序顺序表</td><td>O(logn)</td><td>O(m)</td></tr><tr><td>稠密索引查找</td><td>-</td><td>-</td><td>-</td></tr><tr><td>分块查找</td><td>线性表</td><td>O(logn)~O(n)</td><td>O(m)</td></tr><tr><td>倒排索引查找</td><td>-</td><td>-</td><td>-</td></tr></tbody></table><h2 id="折半查找、插值查找和斐波那契查找"><a href="#折半查找、插值查找和斐波那契查找" class="headerlink" title="折半查找、插值查找和斐波那契查找"></a>折半查找、插值查找和斐波那契查找</h2><ul><li>过程相似，分隔值的选择策略不同，可能影响性能：折半查找为加法和除法运算，插值查找为加、减、乘和除法运算，斐波那契查找为加法和减法运算</li><li>若数据规模大，关键字分布均匀，则性能：插值查找优于折半查找</li><li>平均性能：斐波那契查找优于折半查找</li></ul><hr><h1 id="树型查找"><a href="#树型查找" class="headerlink" title="树型查找"></a>树型查找</h1><table><thead><tr><th>名称</th><th>适用</th><th>时间复杂度</th><th>空间复杂度</th></tr></thead><tbody><tr><td>二叉排序树查找</td><td>动态表-&gt;二叉排序树</td><td>O(logn)~O(n)</td><td>O(n)</td></tr><tr><td>平衡二叉排序树查找</td><td>动态表-&gt;平衡二叉排序树</td><td>O(logn)</td><td>O(n)</td></tr><tr><td>红黑二叉排序树查找</td><td>动态表-&gt;红黑二叉排序树</td><td>O(logn)</td><td>O(n)</td></tr><tr><td>B树查找</td><td>动态表-&gt;B树</td><td>O(logn)</td><td>O(n)</td></tr><tr><td>B+树查找</td><td>动态表-&gt;B+树</td><td>O(logn) | O(mlogn) | O(logmlogn)</td><td>O(n)</td></tr></tbody></table><h2 id="折半查找和二叉排序树查找"><a href="#折半查找和二叉排序树查找" class="headerlink" title="折半查找和二叉排序树查找"></a>折半查找和二叉排序树查找</h2><ul><li>过程相似</li></ul><p>折半查找：</p><ul><li>适用有序顺序表</li><li><strong>二叉判定树</strong>唯一</li><li>插入和删除的时间复杂度：O(n)。n为数据规模</li></ul><p>二叉排序树查找：</p><ul><li>适用动态表</li><li>二叉排序树不唯一（关键字相同，插入顺序不同）</li><li>插入和删除的时间复杂度：O(logn)。n为数据规模（平均情况）</li></ul><h2 id="二叉排序树查找、平衡二叉排序树查找和红黑二叉排序树查找"><a href="#二叉排序树查找、平衡二叉排序树查找和红黑二叉排序树查找" class="headerlink" title="二叉排序树查找、平衡二叉排序树查找和红黑二叉排序树查找"></a>二叉排序树查找、平衡二叉排序树查找和红黑二叉排序树查找</h2><ul><li>一般性能：平衡二叉排序树查找和红黑二叉排序树查找优于二叉排序树查找</li><li>若插入和删除操作相对少，查找操作相对多，适用平衡二叉排序树查找</li><li>若插入和删除操作相对多，查找操作相对少，适用红黑二叉排序树查找</li></ul><hr><h1 id="散列查找"><a href="#散列查找" class="headerlink" title="散列查找"></a>散列查找</h1><table><thead><tr><th>名称</th><th>适用</th><th>时间复杂度</th><th>空间复杂度</th></tr></thead><tbody><tr><td>散列查找</td><td>查找性能要求高，记录关系无要求</td><td>O(1)</td><td>O(m)</td></tr></tbody></table><hr><h1 id="总表"><a href="#总表" class="headerlink" title="总表"></a>总表</h1><table><thead><tr><th>名称</th><th>适用</th><th>时间复杂度</th><th>空间复杂度</th></tr></thead><tbody><tr><td>顺序查找</td><td>线性表</td><td>O(n)</td><td>O(1)</td></tr><tr><td>折半查找</td><td>有序顺序表</td><td>O(logn)</td><td>O(1)</td></tr><tr><td>插值查找</td><td>有序顺序表</td><td>O(logn)</td><td>O(1)</td></tr><tr><td>斐波那契查找</td><td>有序顺序表</td><td>O(logn)</td><td>O(m)</td></tr><tr><td>稠密索引查找</td><td>-</td><td>-</td><td>-</td></tr><tr><td>分块查找</td><td>线性表</td><td>O(logn)~O(n)</td><td>O(m)</td></tr><tr><td>倒排索引查找</td><td>-</td><td>-</td><td>-</td></tr><tr><td>二叉排序树查找</td><td>动态表-&gt;二叉排序树</td><td>O(logn)~O(n)</td><td>O(n)</td></tr><tr><td>平衡二叉排序树查找</td><td>动态表-&gt;平衡二叉排序树</td><td>O(logn)</td><td>O(n)</td></tr><tr><td>红黑二叉排序树查找</td><td>动态表-&gt;红黑二叉排序树</td><td>O(logn)</td><td>O(n)</td></tr><tr><td>B树查找</td><td>动态表-&gt;B树</td><td>O(logn)</td><td>O(n)</td></tr><tr><td>B+树查找</td><td>动态表-&gt;B+树</td><td>O(logn) | O(mlogn) | O(logmlogn)</td><td>O(n)</td></tr><tr><td>散列查找</td><td>查找性能要求高，记录关系无要求</td><td>O(1)</td><td>O(m)</td></tr></tbody></table><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“查找”学习提纲（二）——树型查找和散列查找</title>
      <link href="/2022/09/19/%E2%80%9C%E6%9F%A5%E6%89%BE%E2%80%9D%E5%AD%A6%E4%B9%A0%E6%8F%90%E7%BA%B2%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E6%A0%91%E5%9E%8B%E6%9F%A5%E6%89%BE%E5%92%8C%E6%95%A3%E5%88%97%E6%9F%A5%E6%89%BE/"/>
      <url>/2022/09/19/%E2%80%9C%E6%9F%A5%E6%89%BE%E2%80%9D%E5%AD%A6%E4%B9%A0%E6%8F%90%E7%BA%B2%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E6%A0%91%E5%9E%8B%E6%9F%A5%E6%89%BE%E5%92%8C%E6%95%A3%E5%88%97%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>“查找”学习提纲（二）——树型查找和散列查找。</p><hr><h1 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h1><ul><li><a href="https://blog.csdn.net/m0_62083249/article/details/126798146">二叉排序树的C++语言描述实现模板_夜悊的博客-CSDN博客</a></li></ul><hr><h1 id="二叉排序-查找-搜索树查找"><a href="#二叉排序-查找-搜索树查找" class="headerlink" title="二叉排序&#x2F;查找&#x2F;搜索树查找"></a>二叉排序&#x2F;查找&#x2F;搜索树查找</h1><h2 id="适用"><a href="#适用" class="headerlink" title="适用"></a>适用</h2><ul><li>动态表-&gt;二叉排序树</li></ul><hr><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>时间复杂度：O(logn)~O(n)。n为数据规模</p><ul><li>时间复杂度：树的深度&#x2F;高度</li><li>O(logn)。n为数据规模（树是平衡树）</li><li>O(n)。n为数据规模（树是斜树）</li></ul><p>空间复杂度：O(n)。n为数据规模</p><ul><li>空间复杂度：二叉排序树的大小或递归调用栈的规模&#x2F;树的深度&#x2F;高度：</li><li>O(1)。未使用额外辅助空间（不包括二叉排序树的大小；迭代法）</li><li>O(logn)。n为数据规模（不包括二叉排序树的大小；递归法，树是平衡树）</li><li>O(n)。n为数据规模（包括二叉排序树的大小；递归法，树是斜数）</li></ul><blockquote><p>插入和删除的时间复杂度：O(logn)。n为数据规模（平均情况）</p></blockquote><hr><h2 id="代码模板-1"><a href="#代码模板-1" class="headerlink" title="代码模板"></a>代码模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找   前序遍历   递归法</span></span><br><span class="line"><span class="comment">//适用：</span></span><br><span class="line"><span class="comment">//动态表-&gt;二叉排序树</span></span><br><span class="line"><span class="comment">//时间复杂度：O(logn)~O(n)。n为数据规模</span></span><br><span class="line"><span class="comment">//时间复杂度：树的深度/高度</span></span><br><span class="line"><span class="comment">// O(logn)。n为数据规模（二叉排序树是平衡树）</span></span><br><span class="line"><span class="comment">// O(n)。n为数据规模（二叉排序树是斜树）</span></span><br><span class="line"><span class="comment">//空间复杂度：</span></span><br><span class="line"><span class="comment">//空间复杂度：二叉排序树的大小或递归调用栈的规模/树的深度/高度：</span></span><br><span class="line"><span class="comment">// O(1)。未使用额外辅助空间（不包括二叉排序树的大小；迭代法）</span></span><br><span class="line"><span class="comment">// O(n)。n为数据规模（包括二叉排序树的大小；递归法）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">searchBSTree</span><span class="params">(<span class="keyword">struct</span> BSTNode *root, ELEM_TYPE key)</span> <span class="comment">//参数：根结点指针，需插入的关键字    返回值：查找成功为true，查找失败为false</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="comment">//空树  无查找位置</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//查找失败</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//非空树   递归查找</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == root-&gt;key) <span class="comment">//需插入的关键字等于根结点的关键字</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//查找成功</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; root-&gt;key) <span class="comment">//需插入的关键字小于根结点的关键字</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">searchBSTree</span>(root-&gt;lChild, key); <span class="comment">//查找左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; root-&gt;key) <span class="comment">//需插入的关键字大于根结点的关键字</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">searchBSTree</span>(root-&gt;rChild, key); <span class="comment">//查找右子树</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找   前序遍历   迭代法</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">searchBSTree2</span><span class="params">(<span class="keyword">struct</span> BSTNode *root, ELEM_TYPE key)</span> <span class="comment">//参数：根结点指针，需插入的关键字    返回值：查找成功为true，查找失败为false</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="comment">//空树  无查找位置</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//查找失败</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//非空树   迭代查找</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (key == root-&gt;key) <span class="comment">//需插入的关键字等于根结点的关键字</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//查找成功</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; root-&gt;key) <span class="comment">//需插入的关键字小于根结点的关键字</span></span><br><span class="line">            &#123;</span><br><span class="line">                root = root-&gt;lChild; <span class="comment">//查找左子树</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; root-&gt;key) <span class="comment">//需插入的关键字大于根结点的关键字</span></span><br><span class="line">            &#123;</span><br><span class="line">                root = root-&gt;rChild; <span class="comment">//查找右子树</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//未查找成功返回，则查找失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="comment">//对删除结点node：</span></span><br><span class="line"><span class="comment">// 1.是叶子节点：直接删除node</span></span><br><span class="line"><span class="comment">// 2.有一棵左子树或右子树：子树作为node的双亲结点的子树，删除node（子树拼接）</span></span><br><span class="line"><span class="comment">// 3.有左右两棵子树：</span></span><br><span class="line"><span class="comment">//取node的左子树的最大关键字结点或右子树的最小关键字结点替换node，删除node-&gt;第1或2情况（取左最小或右最大替换）</span></span><br><span class="line"><span class="comment">//取中序遍历时，node的直接前驱结点或直接后继结点替换node，删除node-&gt;第1或2情况（取直接前驱或直接后继替换）</span></span><br></pre></td></tr></table></figure><hr><h1 id="折半查找和二叉排序树查找总结"><a href="#折半查找和二叉排序树查找总结" class="headerlink" title="折半查找和二叉排序树查找总结"></a>折半查找和二叉排序树查找总结</h1><ul><li>过程相似</li></ul><p>折半查找：</p><ul><li><strong>二叉判定树</strong>唯一</li><li>插入和删除的时间复杂度为O(n)。n为数据规模</li><li>适用有序顺序表</li></ul><p>二叉排序树查找：</p><ul><li>二叉排序树不唯一（关键字相同，插入顺序不同）</li><li>插入和删除的时间复杂度为O(logn)。n为数据规模（平均情况）</li><li>适用动态表</li></ul><hr><h1 id="平衡二叉（排序）树-AVL树"><a href="#平衡二叉（排序）树-AVL树" class="headerlink" title="平衡二叉（排序）树&#x2F;AVL树"></a>平衡二叉（排序）树&#x2F;AVL树</h1><blockquote><p>注意：平衡二叉树是特殊的二叉排序树</p></blockquote><h2 id="构造相应层数的树至少需要的结点数"><a href="#构造相应层数的树至少需要的结点数" class="headerlink" title="构造相应层数的树至少需要的结点数"></a>构造相应层数的树至少需要的结点数</h2><p>由递推公式：</p><ul><li>0层：0</li><li>1层：1（根结点在第1层）</li><li>2层：2</li><li>…</li><li>h层：构造h-2层的树至少需要的结点数+构造h-1层的树至少需要的结点数+1</li></ul><hr><h2 id="平衡调整的过程"><a href="#平衡调整的过程" class="headerlink" title="平衡调整的过程"></a>平衡调整的过程</h2><ol><li>确定最小失衡&#x2F;不平衡子树：插入路径上离插入结点最近的平衡因子的绝对值大于1的结点为根的子树</li><li>调整子树的平衡</li></ol><hr><h2 id="平衡调整的类型"><a href="#平衡调整的类型" class="headerlink" title="平衡调整的类型"></a>平衡调整的类型</h2><p>LL型：</p><ul><li>名称：LL调整；右单旋转调整</li><li>现象：插入结点在最小不平衡树根结点A的左（L）孩子B的左（L）子树上</li><li>状态：左高右低</li><li>思想：左上右下；右单旋转</li><li>过程：B作根，B的右子树挂接到A的左子树，A成B的右孩子</li></ul><p>RR型：</p><ul><li>名称：RR调整；左单旋转调整</li><li>现象：插入结点在最小不平衡树根结点A的右（R）孩子B的右（R）子树上</li><li>状态：左低右高</li><li>思想：左下右上；左单旋转</li><li>过程：B作根，B的左子树挂接到A的右子树，A成B的左孩子</li></ul><p>LR型：</p><ul><li>名称：LR调整；先左后右双旋转调整</li><li>现象：插入结点在最小不平衡树根结点A的左（L）孩子B的右（R）子树C上</li><li>状态：左低中高右低</li><li>思想：左下中上右下</li><li>过程：C作根，C的左子树挂接到B的右子树，B成C的左孩子，C的右子树挂接到A的左子树，A成C的右孩子</li></ul><p>RL型：</p><ul><li>名称：RL调整；先右后左双旋转调整</li><li>现象：插入结点在最小不平衡树根结点A的右（R）孩子B的左（L）子树C上</li><li>状态：左低中高右低</li><li>思想：左下中上右下</li><li>过程：C作根，C的左子树挂接到A的右子树，A成C的左孩子，C的右子树挂接到B的左子树，B成C的右孩子</li></ul><p>插入和删除的平衡调整：</p><ul><li>过程和类型相似</li><li>删除导致树高变化，可能需要回溯调整</li></ul><hr><h1 id="平衡二叉排序树查找"><a href="#平衡二叉排序树查找" class="headerlink" title="平衡二叉排序树查找"></a>平衡二叉排序树查找</h1><h2 id="适用-1"><a href="#适用-1" class="headerlink" title="适用"></a>适用</h2><ul><li>动态表-&gt;平衡二叉排序树</li></ul><hr><h2 id="性能-1"><a href="#性能-1" class="headerlink" title="性能"></a>性能</h2><p>平均查找长度（ASL）：</p><ul><li>平均查找长度（ASL）：树的深度&#x2F;高度</li><li>O(logn)。n为数据规模</li></ul><p>时间复杂度： O(logn)。n为数据规模</p><ul><li>时间复杂度：树的深度&#x2F;高度</li><li>O(logn)。n为数据规模</li></ul><p>空间复杂度：O(n)。n为数据规模</p><ul><li>空间复杂度：平衡二叉排序树的大小或递归调用栈的规模&#x2F;树的深度&#x2F;高度</li><li>O(1)。未使用额外辅助空间（不包括平衡二叉排序树的大小；迭代法）</li><li>O(logn)。n为数据规模（不包括B树的大小；递归法）</li><li>O(n)。n为数据规模（包括平衡二叉排序树的大小）</li></ul><blockquote><p>插入和删除的时间复杂度：O(logn)。n为数据规模</p></blockquote><hr><h1 id="红黑（二叉排序）树"><a href="#红黑（二叉排序）树" class="headerlink" title="红黑（二叉排序）树"></a>红黑（二叉排序）树</h1><blockquote><p>注意：红黑树是特殊的二叉排序树。大致&#x2F;非严格平衡</p></blockquote><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p>性质：</p><ul><li>结点是红色或黑色</li><li>根结点是黑色</li><li>叶子结点&#x2F;外部结点&#x2F;虚拟结点&#x2F;空结点是黑色</li><li>不存在两个相邻的红色结点&#x2F;红色结点的双亲结点和孩子结点是黑色</li><li>每个结点到任一叶子结点的简单路径，黑色结点的数量相同</li></ul><p>其他：</p><ul><li>引入n+1个叶子结点&#x2F;外部结点&#x2F;虚拟结点&#x2F;空结点，保证内部结点的左、右孩子结点非空。即：外部结点无数据，黑色；内部结点有数据，红色或黑色</li><li>结点的黑高：结点到任一叶子结点的简单路径，不包括该结点的黑色结点数量&#x2F;黑色结点的数量-1（由性质5）</li><li>结点的深度的差&#x3D;结点到任一叶子结点的简单路径，红色结点数量的差（由性质2和性质5）</li><li>红色结点数量影响树的深度&#x2F;高度（由性质2和性质5）</li></ul><p>结论：</p><ul><li>根结点到叶子结点的最长路径不大于最短路径的两倍（由性质4和性质5）</li><li>n个内部节点，树的高度不大于2log以2为底的(n+1)（由结论1）</li></ul><hr><h2 id="红黑调整的基本操作"><a href="#红黑调整的基本操作" class="headerlink" title="红黑调整的基本操作"></a>红黑调整的基本操作</h2><ul><li>旋转：左旋转和右旋转</li><li>着色：红色和黑色</li></ul><hr><h2 id="插入过程"><a href="#插入过程" class="headerlink" title="插入过程"></a>插入过程</h2><blockquote><p>插入操作可能破坏性质4</p></blockquote><p>有：</p><ul><li>插入结点Z</li><li>插入结点Z的双亲结点P</li><li>插入结点Z的叔叔结点Y</li><li>插入结点Z的爷爷结点PP</li></ul><ol><li>Z涂红色</li><li>补充Z的叶子结点</li><li>插入：转分类讨论A</li></ol><p>分类讨论A：<strong>判断Z和P</strong></p><ul><li>Z是根结点：Z涂黑色</li><li>Z不是根结点，P是黑色：不操作</li><li>Z不是根结点，P是红色：转分类讨论B（<strong>Z和P破坏性质4</strong>）</li></ul><p>分类讨论B：<strong>判断Y、PP、P和Z</strong></p><blockquote><p>前提：Z是红色，P是红色，PP是黑色（插入前是合法的红黑（二叉排序）树，由性质2和4得）</p></blockquote><ul><li>Y是黑色，Z是PP的左孩子的左孩子（LL）：右旋转，P涂黑色，PP涂红色</li><li>Y是黑色，Z是PP的右孩子的右孩子（RR）：左旋转，P涂黑色，PP涂红色</li></ul><blockquote><p>LL型：P作根，P的右子树挂接到PP的左子树，PP成P的右孩子；红红黑-&gt;红黑红<br>RR型：P作根，P的左子树挂接到PP的右子树，PP成P的左孩子；黑红红-&gt;红黑红</p></blockquote><ul><li>Y是黑色，Z是PP的左孩子的右孩子（LR）：左旋转，右旋转，P涂黑色，PP涂红色</li><li>Y是黑色，Z是PP的右孩子的左孩子（RL）：右旋转，左旋转，P涂黑色，PP涂红色</li></ul><blockquote><p>LR型：Z的左子树挂接到P的右子树，Z成PP的左孩子，P成Z的左孩子，成LL型<br>RR型：Z的右子树挂接到P的左子树，Z成PP的右孩子，P成Z的右孩子，成RR型</p></blockquote><ul><li>Y是红色：Y涂黑色，P涂黑色，PP涂红色（<strong>局部恢复性质4</strong>），将PP作为插入结点，转分类讨论A</li></ul><hr><h2 id="删除过程"><a href="#删除过程" class="headerlink" title="删除过程"></a>删除过程</h2><blockquote><p>删除操作可能破坏性质2、4和5</p></blockquote><ol><li>转二叉排序树的删除操作</li><li>转作双色结点</li><li>转双色讨论</li></ol><p>二叉排序树的删除操作：对删除结点node</p><ul><li>是叶子节点：直接删除node</li><li>有一棵左子树或右子树：子树作为node的双亲结点的子树，删除node（子树拼接）</li><li>有左右两棵子树：取node的左子树的最大关键字结点或右子树的最小关键字结点替换node，删除node-&gt;第1或2情况（取左最小或右最大替换）。或取中序遍历时，node的直接前驱结点或直接后继结点替换node，删除node-&gt;第1或2情况（取直接前驱或直接后继替换）</li></ul><p>有：</p><ul><li>删除结点Z</li><li>二叉排序树的删除操作后，替换删除结点Z的替换结点X</li><li>X的双亲结点P</li><li>X的兄弟结点W</li><li>W的左孩子结点WL</li><li>W的右孩子结点WR</li><li>X是P的左孩子，W是P的右孩子</li></ul><p>作双色结点：</p><ul><li>假设替换结点X有两种颜色：原来的颜色（红色或黑色）和增加的黑色</li></ul><blockquote><p>从Z继承增加的黑色：因为若Z是红色，删除Z不会破坏性质；若Z是黑色，删除会破坏性质</p></blockquote><blockquote><p>假设替换结点X有两种颜色的目的：恢复性质5，破坏性质1</p></blockquote><blockquote><p>后续操作的核心：恢复双色结点为单色结点&#x2F;性质1</p></blockquote><p>双色讨论：</p><ul><li>X是红色和黑色：删除红色，保留黑色</li><li>X是黑色和黑色，X是根结点：不操作</li><li>X是黑色和黑色，X不是根结点，转分类讨论A</li></ul><p>分类讨论A：</p><ul><li>转W是红色</li><li>转W是黑色</li></ul><p>W是红色：</p><ul><li>由性质4：W是红色，则P、WL和WR是黑色</li><li>处理：P涂红色，W涂黑色（P和W交换颜色）。X是P的左孩子，则P&#x2F;W左旋转（调整P到X一侧）。转W是黑色</li></ul><p>W是黑色：</p><ul><li>WL是红色，WR是黑色：转WL是红色，WR是黑色</li><li>WL是红色或黑色，WR是红色：转WL是红色或黑色，WR是红色</li><li>WL是黑色，WR是黑色：转WL是黑色，WR是黑色</li></ul><p>WL是红色，WR是黑色：</p><ul><li>RL型：红色结点WL是爷爷结点的右孩子W的左孩子</li><li>RL型：W涂红色，WL涂黑色（W和WL交换颜色）。WL右旋（调整W为WL的右孩子）。转WL是红色或黑色，WR是红色</li></ul><p>WL是红色或黑色，WR是红色：</p><ul><li>W涂P的颜色，P涂黑色（W和P交换颜色），WR涂黑色（<strong>保持W一侧的黑高</strong>）。X是P的左孩子，P&#x2F;W左旋转（<strong>补充一黑色结点P到X一侧</strong>）。<strong>结束</strong></li></ul><p>WL是黑色，WR是黑色：</p><ul><li>X和W各提取一重黑色：X是黑色，W是红色</li><li>由性质5，需要补偿该一重黑色：P有两种颜色：原来的颜色（红色或黑色）和增加的黑色</li><li>将P作为替换结点X，转双色讨论</li></ul><hr><h2 id="删除过程总结"><a href="#删除过程总结" class="headerlink" title="删除过程总结"></a>删除过程总结</h2><p>一、二叉排序树的删除操作：保持二叉排序树的性质</p><p>二、作双色结点：恢复性质5，破坏性质1</p><p>三、双色讨论：恢复性质1。转123</p><p>1 若X红色+黑色：删除红色，保留黑色</p><p>2 若X黑色+黑色，是根结点：不操作</p><p>3 若X黑色+黑色，不是根结点：<strong>性质5真正被破坏</strong>。转(1)(2)</p><p>(1) 若W红色：W涂黑色，P涂红色，W左旋。转(2)</p><blockquote><p>由性质4：W红色，P、WL和WR黑色<br>W涂黑色，W左旋：W成根替换P的位置，保持黑高<br>P涂红色，W左旋：P成W的左孩子，保持黑高<br>W左旋：W的WL子树挂接到P的右子树，WL成X的兄弟<br>目的：转换X的兄弟为黑色</p></blockquote><p>(2) 若W黑色</p><p>① WL红色，WR黑色：WL涂黑色，W涂红色，WL右旋。转②</p><blockquote><p>由性质4：WL红色，P黑色<br>WL涂黑色，WL右旋：WL成根替换W的位置，保持黑高<br>P涂红色，W右旋：W成WL的右孩子，保持黑高<br>WL右旋：WL的右子树挂接到W的左子树，WL成X的兄弟<br>先：RL型。后：RR型<br>目的：转换W的右孩子为红色</p></blockquote><p>② WR红色：W涂红色，P涂黑色，WR涂黑色，W左旋</p><blockquote><p>由性质4：WR红色，W黑色<br>W涂红色，W左旋：W成根替换P的位置，原W侧的黑高-1，<strong>破坏性质5</strong><br>P涂黑色，W左旋：P成W的左孩子，X侧的黑高+1，X恢复单色，<strong>恢复性质1</strong><br>W左旋：W的左子树挂接到P的右子树，WR成X的兄弟<br>WR涂黑色：原W侧的黑高+1，<strong>恢复性质5</strong><br>目的：调整一黑色结点到X侧</p></blockquote><p>③ WL黑色，WR黑色：W涂红色，P作双色结点。转二</p><blockquote><p>X恢复单色，W涂红色：各提取一重黑色<br>P作双色结点：从X和W提取的黑色增加到P，保持黑高。P替换为X继续处理</p></blockquote><blockquote><p>注意：X是P的右孩子，W是P的左孩子时，(1)(2)①②③有对称情况</p></blockquote><p><strong>总结(1)(2)①②③：</strong></p><blockquote><p>关于黑色提取：<br>(2)③：有重复黑色可提取，调整操作向上委托的同时能够保持黑高<br>(1)：W红色，不能提取黑色<br>(2)①：WL红色，WR黑色，由性质4，W黑色。若W提取黑色，W成红色，则W-&gt;WL和W-&gt;WR的黑高不同，破坏性质5<br>(2)②：WR红色，由性质4，W黑色。若W提取黑色，W成红色，则W和WR红色，破坏性质4</p></blockquote><blockquote><p>关于目的：<br>(1)：转换为(2)<br>(2)①：转换为(2)②<br>(2)②：调整结束<br>(2)③：调整操作向上委托</p></blockquote><blockquote><p>关于执行情况：<br>(2)③：唯一可重复执行的情况，每执行一次委托向上一层，最多次数是树的深度&#x2F;高度，为logn<br>有流程：(1)-&gt;(2)③，结束<br>最少流程：(2)②，结束<br>最多流程：(1)-&gt;(2)①-&gt;(2)②，结束<br>最多流程时，执行常数次的着色操作和至多三次的旋转操作</p></blockquote><hr><h1 id="红黑二叉排序树查找"><a href="#红黑二叉排序树查找" class="headerlink" title="红黑二叉排序树查找"></a>红黑二叉排序树查找</h1><h2 id="适用-2"><a href="#适用-2" class="headerlink" title="适用"></a>适用</h2><ul><li>动态表-&gt;红黑二叉排序树</li></ul><hr><h2 id="性能-2"><a href="#性能-2" class="headerlink" title="性能"></a>性能</h2><p>时间复杂度：O(logn)。n为数据规模</p><ul><li>时间复杂度：树的深度&#x2F;高度</li><li>O(logn)。n为数据规模</li></ul><p>空间复杂度：O(n)。n为数据规模</p><ul><li>空间复杂度：红黑二叉排序树的大小或递归调用栈的规模&#x2F;树的深度&#x2F;高度</li><li>O(1)。未使用额外辅助空间（不包括红黑二叉排序树的大小；迭代法）</li><li>O(logn)。n为数据规模（不包括红黑二叉排序树树的大小；递归法）</li><li>O(n)。n为数据规模（包括红黑二叉排序树的大小）</li></ul><blockquote><p>插入和删除的时间复杂度：O(logn)。n为数据规模</p></blockquote><hr><h1 id="二叉排序树查找、平衡二叉排序树查找和红黑二叉排序树查找总结"><a href="#二叉排序树查找、平衡二叉排序树查找和红黑二叉排序树查找总结" class="headerlink" title="二叉排序树查找、平衡二叉排序树查找和红黑二叉排序树查找总结"></a>二叉排序树查找、平衡二叉排序树查找和红黑二叉排序树查找总结</h1><ul><li>平衡二叉排序树查找和红黑二叉排序树查找的一般性能优于二叉排序树查找</li><li>若插入和删除操作相对少，查找操作相对多，适用平衡二叉排序树查找</li><li>若插入和删除操作相对多，查找操作相对少，适用红黑二叉排序树查找</li></ul><hr><h1 id="B树-B-树-平衡多路查找树"><a href="#B树-B-树-平衡多路查找树" class="headerlink" title="B树&#x2F;B-树&#x2F;平衡多路查找树"></a>B树&#x2F;B-树&#x2F;平衡多路查找树</h1><blockquote><p>注意：-无意义，不念做B减树，念做B树</p></blockquote><blockquote><p>B树是平衡多路查找树，但限制更强：叶子结点在同一层</p></blockquote><h2 id="相关概念-1"><a href="#相关概念-1" class="headerlink" title="相关概念"></a>相关概念</h2><ul><li>树的阶&#x2F;度m：结点的分支数的最大值</li><li>树的深度&#x2F;高度&#x2F;外存存取次数h（<strong>一般不包括叶子结点层</strong>）：log以m为底的(n+1) &lt;&#x3D; h &lt;&#x3D; log以[m&#x2F;2]上取整为底的[(n+1)&#x2F;2]+1。n为关键字数</li></ul><hr><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>若结点有n个子树，则有n-1个关键字</li><li>若<strong>根结点不是叶子结点</strong>，则至少有2个子树。若结点是非根非叶子结点，则至少有[m&#x2F;2]上取整个子树。结点至多有m个子树</li><li>非叶子结点的结构：（n,P0,K1,P1,K2,P2…Kn,Pn）。Ki（i&#x3D;1,2,…,n）为结点的关键字，K1&lt;K2&lt;…Kn。Pi（i&#x3D;0,1,…,n）为子树根结点指针，P(i-1)所指子树中所有结点的关键字&lt;Ki，Pi所指子树中所有结点的关键字&gt;Ki。n为结点的关键字数</li><li>叶子结点在同一层，为外部结点&#x2F;虚拟结点&#x2F;空结点，不包含信息</li></ul><p>其他：</p><ul><li>若有n个关键字，则有n+1个叶子结点（叶子结点对应查找失败的情况）</li></ul><hr><h2 id="插入过程-1"><a href="#插入过程-1" class="headerlink" title="插入过程"></a>插入过程</h2><ol><li>确定结点中关键字数的范围：n为关键字数，有[m&#x2F;2]上取整-1 &lt;&#x3D; n &lt;&#x3D; m-1</li><li>查找插入位置：若无插入位置，插入失败；若有插入位置，插入</li><li>检查结点中关键字数：若n &lt;&#x3D; m-1，插入完成；若n &gt; m-1，结点拆分</li></ol><blockquote><p>注意：<br>查找时，查找到叶子结点，表明有插入位置<br>插入时，插入到相应的<strong>最底层的</strong>非叶子结点</p></blockquote><p>结点拆分：</p><ul><li>结点中关键字数：n &#x3D; m &gt; m-1</li><li>取第[m&#x2F;2]上取整个关键字K</li><li>K的左指针指向第1~[m&#x2F;2]上取整-1个关键字</li><li>K的右指针指向第[m&#x2F;2]上取整+1~m个关键字</li><li>K插入双亲结点的相应位置中</li><li>检查双亲结点中关键字数：若n &lt;&#x3D; m-1，插入完成；若n &gt; m-1，结点拆分</li></ul><hr><h2 id="删除过程-1"><a href="#删除过程-1" class="headerlink" title="删除过程"></a>删除过程</h2><ol><li>确定结点中关键字数的范围：n为关键字数，有[m&#x2F;2]上取整-1 &lt;&#x3D; n &lt;&#x3D; m-1</li><li>查找删除位置：若无删除位置，删除失败；若有删除位置，检查结点中关键字数</li><li>检查结点中关键字数：删除讨论1和2</li></ol><blockquote><p>注意：<br>查找时，查找到非叶子结点，表明有删除位置<br>删除时，在相应的的非叶子结点上删除</p></blockquote><p>删除讨论1：删除的关键字不在最底层的非叶子结点上</p><ul><li>转换：删除的关键字在最底层的非叶子结点上</li><li>类比二叉排序树的删除操作：在中序遍历中，查找删除结点的左子树的最大值或右子树的最小值结点&#x2F;直接前驱或直接后继结点</li><li>关键字交换：取删除关键字X的相邻关键字Y，Y替换X（X不在最底层的非叶子结点上），删除Y（Y在最底层的非叶子结点上）</li></ul><p>删除讨论2：删除的关键字在最底层的非叶子结点上</p><ul><li>若n &gt; [m&#x2F;2]上取整-1：直接删除</li><li>若n &#x3D; [m&#x2F;2]上取整-1，删除关键字结点的左兄弟结点<strong>或</strong>右兄弟结点的关键字 &gt; [m&#x2F;2]上取整-1：关键字借位ie。关键字流向：兄弟结点-&gt;双亲结点-&gt;当前结点</li><li>若n &#x3D; [m&#x2F;2]上取整-1，删除关键字结点的左兄弟结点<strong>和</strong>右兄弟结点的关键字 &#x3D; [m&#x2F;2]上取整-1：结点合并。关键字流向：当前结点+双亲结点+兄弟结点；注意：可能导致双亲结点的关键字数不合法</li></ul><p>删除讨论总结：</p><ul><li>直接删除</li><li>关键字交换</li><li>关键字借位</li><li>结点合并</li></ul><hr><h1 id="B树查找"><a href="#B树查找" class="headerlink" title="B树查找"></a>B树查找</h1><h2 id="适用-3"><a href="#适用-3" class="headerlink" title="适用"></a>适用</h2><ul><li>动态表-&gt;B树</li></ul><hr><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><blockquote><p>类似二叉排序树查找</p></blockquote><ol><li>在B树中查找结点（在外存进行）</li><li>在结点中查找关键字（在内存进行）。可使用线性查找</li></ol><hr><h2 id="性能-3"><a href="#性能-3" class="headerlink" title="性能"></a>性能</h2><p>时间复杂度：O(logn)。n为数据规模</p><ul><li>时间复杂度：树的深度&#x2F;高度</li><li>O(logn)。n为数据规模</li></ul><p>空间复杂度：O(n)。n为数据规模</p><ul><li>空间复杂度：B树的大小或递归调用栈的规模&#x2F;树的深度&#x2F;高度</li><li>O(1)。未使用额外辅助空间（不包括B树的大小；迭代法）</li><li>O(logn)。n为数据规模（不包括B树的大小；递归法）</li><li>O(n)。n为数据规模（包括B树的大小）</li></ul><hr><h1 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h1><h2 id="B-树与B树的区别"><a href="#B-树与B树的区别" class="headerlink" title="B+树与B树的区别"></a>B+树与B树的区别</h2><ul><li>若结点有n个子树，则有n个关键字</li><li>根结点关键字数n的取值范围：2 &lt;&#x3D; n &lt;&#x3D; m；除根结点关键字数n的取值范围：[m&#x2F;2]上取整 &lt;&#x3D; n &lt;&#x3D; m</li><li>叶子结点包含信息：全部关键字和全部记录指针</li><li>非叶子结点只起索引作用，索引项：有子树的最大关键字和子树指针，无最大关键字对应记录的存储地址</li><li>有一个指针指向最小关键字的叶子结点，所有叶子结点链接成线性链表</li></ul><hr><h1 id="B-树查找"><a href="#B-树查找" class="headerlink" title="B+树查找"></a>B+树查找</h1><h2 id="适用-4"><a href="#适用-4" class="headerlink" title="适用"></a>适用</h2><ul><li>动态表-&gt;B+树</li></ul><hr><h2 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h2><ul><li>从根结点开始：树型查找</li><li>从最小关键字叶子结点开始：线性查找</li></ul><hr><h2 id="性能-4"><a href="#性能-4" class="headerlink" title="性能"></a>性能</h2><p>时间复杂度：O(logn) | O(mlogn) | O(logmlogn)。n为数据规模，m为树的阶</p><p>时间复杂度：查找结点时间（树型查找）×查找结点中关键字时间（线性查找）</p><ul><li>查找结点时间：O(logn)。n为数据规模（树的深度&#x2F;高度）</li><li>查找结点中关键字时间：O(m)。m为树的阶（顺序查找）</li><li>查找结点中关键字时间：O(logm)。m为树的阶（折半查找等）</li></ul><p>时间复杂度：访问外存的输入&#x2F;输出（I&#x2F;O）次数</p><ul><li>一次访问外存的输入&#x2F;输出（I&#x2F;O）读取一页</li><li>页大小 &#x3D; 非叶子结点大小</li><li>访问外存的输入&#x2F;输出（I&#x2F;O）次数 &#x3D; 树的深度&#x2F;高度：O(logn)。n为数据规模</li></ul><p>空间复杂度：O(n)。n为数据规模</p><ul><li>空间复杂度：B+树的大小或递归调用栈的规模&#x2F;树的深度&#x2F;高度</li><li>O(1)。未使用额外辅助空间（不包括B+树的大小；迭代法）</li><li>O(logn)。n为数据规模（不包括B+树的大小；递归法）</li><li>O(n)。n为数据规模（包括B+树的大小）</li></ul><hr><h1 id="其他特殊的多路查找树"><a href="#其他特殊的多路查找树" class="headerlink" title="其他特殊的多路查找树"></a>其他特殊的多路查找树</h1><ul><li>2-3树：3阶B树</li><li>2-3-4树：4阶B树</li></ul><hr><h1 id="散列-哈希表"><a href="#散列-哈希表" class="headerlink" title="散列&#x2F;哈希表"></a>散列&#x2F;哈希表</h1><h2 id="相关概念-2"><a href="#相关概念-2" class="headerlink" title="相关概念"></a>相关概念</h2><ul><li>查找表：存储记录&#x2F;关键字</li><li>散列表：类比索引表和映射表，存储关键字和<strong>散列表地址</strong>的映射关系</li><li>映射：h(key) &#x3D; addr。key为关键字，h()为散列函数 ，addr为散列表地址</li><li>冲突&#x2F;碰撞：两个或两个以上的不同关键字，通过散列函数，映射到散列表相同地址</li><li>同义词：<strong>对某个散列函数</strong>，能够发生冲突的不同关键字</li><li>装填因子：散列表的装填程度。α &#x3D; n&#x2F;m。α为装填因子，n为散列表中的记录数，m为散列表的大小</li></ul><blockquote><p>注意：散列表的平均查找长度（ASL）与α有关，与n和m无关</p></blockquote><hr><h2 id="散列函数的构造原则"><a href="#散列函数的构造原则" class="headerlink" title="散列函数的构造原则"></a>散列函数的构造原则</h2><ul><li>定义域包含查找表的所有关键字，值域取决于散列表的大小&#x2F;地址范围</li><li>简单：能够在较短时间计算出结果</li><li>尽量避免冲突：计算的散列表地址能等概率和均匀地分布在散列表中（<strong>理解</strong>）</li></ul><p>另：</p><ul><li>散列表的大小</li><li>关键字的大小&#x2F;长度&#x2F;位数</li><li>关键字的分布</li><li>计算散列表地址的时间</li><li>关键字查找的频率</li></ul><hr><h2 id="散列函数的构造方法"><a href="#散列函数的构造方法" class="headerlink" title="散列函数的构造方法"></a>散列函数的构造方法</h2><p>直接定址法：</p><ul><li>方法：h(key) &#x3D; key或h(key) &#x3D; a × key + b(a和b为常数)</li><li>特点：简单，均匀（关键字映射的散列表地址在散列表中分布均匀），<strong>不会产生冲突</strong></li><li>适用：查找表的规模比较小；关键字的分布基本连续</li></ul><p>除留余数法：</p><ul><li>方法：h(key) &#x3D; key % <strong>p</strong>(m为散列表的大小，p为质数，有p &lt;&#x3D; m。一般取p为小于或等于散列表的大小的最大质数或不包含小于20质因子的合数，能够尽量避免冲突：若p &gt; m，则取余的散列表地址可能越界；质数的取余运算可以使散列表地址尽量均匀)</li></ul><p>平方取中法：</p><ul><li>方法：h(key) &#x3D; key²的中间几位数</li><li>适用：未知关键字的分布；关键字的位数比较少，可能小于散列表地址需要的位数；关键字的每位取值比较不均匀</li></ul><p>数字分析法：</p><ul><li>方法：取关键字的若干数位，可进行旋转、反转和叠加等操作</li><li>适用：关键字的位数比较多；关键字若干数位的取值比较均匀</li></ul><p>折叠法：</p><ul><li>方法：关键字从左到右分割成位数相等的几部分（最后一部分位数不够可短些），各部分求和，依据散列表的大小，取和的后几位</li><li>适用：未知关键字的分布；关键字位数比较多</li></ul><p>随机数法：</p><ul><li>方法：h(key) &#x3D; random(key)。random()为随机函数。即关键字的随机函数值为散列表地址</li><li>适用：各关键字的位数不相等</li></ul><blockquote><p>注意：关键字不是数字，是符号，可通过ASCII码、Unicode码等转换为数字</p></blockquote><hr><h2 id="冲突处理的方法"><a href="#冲突处理的方法" class="headerlink" title="冲突处理的方法"></a>冲突处理的方法</h2><p>开放定址法：</p><ul><li>含义：空闲散列表地址向同义词开放，也向非同义词开放</li><li>理解：同义词通过散列函数映射到散列表地址A（固有的），非同义词通过散列函数映射到散列表地址B（固有的），在B发生冲突，通过冲突处理能够映射到A（变化的）</li><li>发生冲突的散列表地址作自变量，通过冲突处理函数，映射到新的散列表地址</li><li>数学递推公式：hi &#x3D; (h(key) + di) % <strong>m</strong>。m为散列表的大小，i为发生冲突的次数&#x2F;新散列表地址的计数值，0 &lt;&#x3D; i &lt;&#x3D; m，di为增量序列，key为关键字，h()为散列函数，h(key)为散列表地址，hi为新散列表地址</li><li>数学递推公式中，确定di-&gt;确定冲突处理方法</li><li>有线性探测法，平方探测法，双散列法，伪随机序列法</li><li>注意：对散列表，不能物理删除关键字&#x2F;关键字-散列表地址映射（因为会<strong>截断</strong>其他该散列表地址的关键字的探测地址）。能逻辑删除关键字&#x2F;关键字-散列表地址映射（使用标记；需要定期维护散列表避免未利用表项过多）</li></ul><p>线性探测法：</p><ul><li>方法：di &#x3D; 0,1,…,m-1</li><li>缺点：易出现聚集&#x2F;堆积问题（同义词和非同义词映射到相同的散列表地址）</li></ul><p>平方探测法&#x2F;二次探测法：</p><ul><li>方法：di &#x3D; 0²,1²,-1²,…,k²,-k²。k &lt;&#x3D; m&#x2F;2，m为可表示成4×k+3的质数</li><li>缺点：不能<strong>探测</strong>到所有散列表地址，至少能探测到一半的散列表地址</li></ul><p>双散列法：</p><ul><li>方法：di &#x3D; i × h2(key)</li><li>特点：最多m-1次探测回到第一次发生冲突的位置&#x2F;原散列表地址</li></ul><p>伪随机序列法：</p><ul><li>方法：di &#x3D; <strong>伪随机数</strong></li><li>伪随机数：<strong>随机种子</strong>相同，每过程（冲突处理过程和查找过程）生成的伪随机数数列相同，数列中的伪随机数互不相同</li></ul><p>链地址法&#x2F;拉链法&#x2F;链接法：</p><ul><li>方法：同义词链接成单链表&#x2F;同义词子表，散列表的散列表地址表项不存储关键字，存储单链表头指针</li><li>优点：散列表不会满</li><li>缺点：增加遍历单链表的时间</li></ul><p>再散列函数法：</p><ul><li>方法：每冲突时，更换散列函数再计算</li><li>优点：不易出现聚集&#x2F;堆积问题</li><li>缺点：增加散列函数再计算时间</li></ul><p>公共溢出区法：</p><ul><li>方法：每冲突时，将关键字顺序存储到另一溢出表中</li><li>适用：冲突少-&gt;溢出表相对散列表的规模小</li></ul><hr><h1 id="散列查找"><a href="#散列查找" class="headerlink" title="散列查找"></a>散列查找</h1><h2 id="适用-5"><a href="#适用-5" class="headerlink" title="适用"></a>适用</h2><ul><li>查找性能要求高，记录关系无要求</li></ul><hr><h2 id="性能-5"><a href="#性能-5" class="headerlink" title="性能"></a>性能</h2><p>影响因素：</p><ul><li>散列函数</li><li>冲突处理方法</li><li>装填因子</li></ul><p>平均查找长度（ASL）&#x2F;平均比较次数：</p><ul><li>查找成功：依据<strong>关键字</strong>计算：每关键字的比较次数的和&#x2F;关键字数。每关键字的比较次数的和：（计算散列表地址）无冲突比较1次，有1次冲突（计算新散列表地址）比较2次，以此类推</li><li>查找失败：依据<strong>散列表地址</strong>计算：每<strong>可以映射到的</strong>散列表地址上，比较到空散列表地址（<strong>比较空散列表地址算作比较1次</strong>）比较次数的和&#x2F;可以映射到的散列表地址数</li></ul><p>时间复杂度：O(1)</p><p>空间复杂度：O(m)。m为散列表的大小</p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="树型查找"><a href="#树型查找" class="headerlink" title="树型查找"></a>树型查找</h2><table><thead><tr><th>名称</th><th>适用</th><th>时间复杂度</th><th>空间复杂度</th></tr></thead><tbody><tr><td>二叉排序树查找</td><td>动态表-&gt;二叉排序树</td><td>O(logn)~O(n)</td><td>O(n)</td></tr><tr><td>平衡二叉排序树查找</td><td>动态表-&gt;平衡二叉排序树</td><td>O(logn)</td><td>O(n)</td></tr><tr><td>红黑二叉排序树查找</td><td>动态表-&gt;红黑二叉排序树</td><td>O(logn)</td><td>O(n)</td></tr><tr><td>B树查找</td><td>动态表-&gt;B树</td><td>O(logn)</td><td>O(n)</td></tr><tr><td>B+树查找</td><td>动态表-&gt;B+树</td><td>O(logn) | O(mlogn) | O(logmlogn)</td><td>O(n)</td></tr></tbody></table><h2 id="散列查找-1"><a href="#散列查找-1" class="headerlink" title="散列查找"></a>散列查找</h2><table><thead><tr><th>名称</th><th>适用</th><th>时间复杂度</th><th>空间复杂度</th></tr></thead><tbody><tr><td>散列查找</td><td>查找性能要求高，记录关系无要求</td><td>O(1)</td><td>O(m)</td></tr></tbody></table><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《2023版数据结构高分笔记》主编：率辉</li><li>《2023年计算机组成原理考研复习指导》组编：王道论坛</li><li>《大话数据结构》作者：程杰</li><li><a href="https://zhuanlan.zhihu.com/p/402951795?ivk_sa=1025883i">B+ 树搜索时间复杂度到底是什么：mlogmN &#x2F; logN？ - 知乎 (zhihu.com)</a></li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉排序树的C++语言描述实现模板</title>
      <link href="/2022/09/10/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84C++%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E5%AE%9E%E7%8E%B0%E6%A8%A1%E6%9D%BF/"/>
      <url>/2022/09/10/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84C++%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E5%AE%9E%E7%8E%B0%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>数据结构中二叉排序树的C++语言描述实现模板，有详细的步骤解析及使用示例。</p><hr><h1 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h1><ul><li><a href="https://github.com/yezhening/Programming-examples">yezhening&#x2F;Programming-examples: 编程实例 (github.com)</a></li><li><a href="https://gitee.com/yezhening/Programming-examples">Programming-examples: 编程实例 (gitee.com)</a></li></ul><hr><h1 id="bSTree-cpp"><a href="#bSTree-cpp" class="headerlink" title="bSTree.cpp"></a>bSTree.cpp</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件————————————————————</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//命名空间</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型————————————————————</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ELEM_TYPE; <span class="comment">//数据的（数据）类型 依据数据的实际类型定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体</span></span><br><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="comment">//结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BSTNode</span></span><br><span class="line">&#123;</span><br><span class="line">    ELEM_TYPE key;          <span class="comment">//关键字</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BSTNode</span> *lChild; <span class="comment">//指向左孩子结点的指针</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BSTNode</span> *rChild; <span class="comment">//指向右孩子结点的指针</span></span><br><span class="line">&#125; BSTNode;</span><br><span class="line"><span class="comment">// struct BSTNode：结构体数据类型的名称</span></span><br><span class="line"><span class="comment">//如创建一个结点的语句：struct BSTNode node;</span></span><br><span class="line"><span class="comment">//若结构体数据类型内，存在指向该结构体的指针数据类型，则必须完整命名结构体数据类型的名称</span></span><br><span class="line"><span class="comment">//如结点结构体BSTNode内，存在指向该结构体的指针数据类型lChild和rChild，则命名语句为：typedef struct BSTNode而不是typedef struct</span></span><br><span class="line"><span class="comment">// &#125;BTNode;：typedef给结构体数据类型起的别名，可简化语句</span></span><br><span class="line"><span class="comment">//如创建一个结点的语句：BSTNode node;</span></span><br><span class="line"><span class="comment">//结构体数据类型的名称和别名尽量一致，以方便记忆、使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数声明————————————————————</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_example</span><span class="params">()</span></span>;                                      <span class="comment">//使用示例</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">insertBSTree</span><span class="params">(<span class="keyword">struct</span> BSTNode *&amp;root, ELEM_TYPE key)</span></span>; <span class="comment">//插入 前序遍历</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">searchBSTree</span><span class="params">(<span class="keyword">struct</span> BSTNode *root, ELEM_TYPE key)</span></span>;  <span class="comment">//查找   前序遍历</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">searchBSTree2</span><span class="params">(<span class="keyword">struct</span> BSTNode *root, ELEM_TYPE key)</span></span>; <span class="comment">//查找   前序遍历   迭代法</span></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="comment">//对删除结点node：</span></span><br><span class="line"><span class="comment">// 1.是叶子节点：直接删除node</span></span><br><span class="line"><span class="comment">// 2.有一棵左子树或右子树：子树作为node的双亲结点的子树，删除node（子树拼接）</span></span><br><span class="line"><span class="comment">// 3.有左右两棵子树：</span></span><br><span class="line"><span class="comment">//取node的左子树的最大关键字结点或右子树的最小关键字结点替换node，删除node-&gt;第1或2情况（取左最小或右最大替换）</span></span><br><span class="line"><span class="comment">//取中序遍历时，node的直接前驱结点或直接后继结点替换node，删除node-&gt;第1或2情况（取直接前驱或直接后继替换）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数定义————————————————————</span></span><br><span class="line"><span class="comment">//使用示例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_example</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BSTNode</span> *root; <span class="comment">//根结点指针</span></span><br><span class="line"></span><br><span class="line">    vector&lt;ELEM_TYPE&gt; keys = &#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">7</span>&#125;; <span class="comment">//需插入的关键字向量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> key : keys)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">insertBSTree</span>(root, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造三层二叉树：</span></span><br><span class="line">    <span class="comment">//第一层：4</span></span><br><span class="line">    <span class="comment">//第二层：2，6</span></span><br><span class="line">    <span class="comment">//第三层：1，3，5，7</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找  前序遍历    递归法</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">searchBSTree</span>(root, <span class="number">3</span>) &lt;&lt; endl;  <span class="comment">//输出：1</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">searchBSTree</span>(root, <span class="number">-1</span>) &lt;&lt; endl; <span class="comment">//输出：0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找  前序遍历    迭代法</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">searchBSTree2</span>(root, <span class="number">3</span>) &lt;&lt; endl;  <span class="comment">//输出：1</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">searchBSTree2</span>(root, <span class="number">-1</span>) &lt;&lt; endl; <span class="comment">//输出：0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入  前序遍历</span></span><br><span class="line"><span class="comment">//时间复杂度：O(n)。n为数据规模</span></span><br><span class="line"><span class="comment">//最好：O(1)</span></span><br><span class="line"><span class="comment">//最坏：O(n)。n为数据规模</span></span><br><span class="line"><span class="comment">//空间复杂度：O(n)。n为数据规模</span></span><br><span class="line"><span class="comment">//空间复杂度：递归调用栈的规模/树的深度/高度：</span></span><br><span class="line"><span class="comment">//最好：O(1)。未使用额外辅助空间</span></span><br><span class="line"><span class="comment">//最坏：n。n为数据规模</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">insertBSTree</span><span class="params">(<span class="keyword">struct</span> BSTNode *&amp;root, ELEM_TYPE key)</span> <span class="comment">//参数：根结点指针，需插入的关键字</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="comment">//空树  有插入位置，可插入</span></span><br><span class="line">    &#123;</span><br><span class="line">        root = (<span class="keyword">struct</span> BSTNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> BSTNode)); <span class="comment">//创建根结点，根结点指针指向根结点</span></span><br><span class="line">        root-&gt;key = key;                                         <span class="comment">//初始化根结点的数据域</span></span><br><span class="line">        root-&gt;lChild = <span class="literal">nullptr</span>;                                  <span class="comment">//初始化根结点的指针域</span></span><br><span class="line">        root-&gt;rChild = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//插入成功</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//非空树   递归查找插入位置</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == root-&gt;key) <span class="comment">//需插入的关键字等于根结点的关键字，关键字已存在    无插入位置，不可插入</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//插入失败</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; root-&gt;key) <span class="comment">//需插入的关键字小于根结点的关键字，关键字不一定存在    可能有插入位置，可能可插入</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">insertBSTree</span>(root-&gt;lChild, key); <span class="comment">//插入左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; root-&gt;key) <span class="comment">//需插入的关键字大于根结点的关键字，关键字不一定存在    可能有插入位置，可能可插入</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">insertBSTree</span>(root-&gt;rChild, key); <span class="comment">//插入右子树</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//注意：</span></span><br><span class="line">    <span class="comment">//在if()外，最好有返回语句</span></span><br><span class="line">    <span class="comment">//因为可能不进入if()，无返回值  编译器报警告</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找   前序遍历   递归法</span></span><br><span class="line"><span class="comment">//适用：</span></span><br><span class="line"><span class="comment">//动态表-&gt;二叉排序树</span></span><br><span class="line"><span class="comment">//时间复杂度：O(logn)~O(n)。n为数据规模</span></span><br><span class="line"><span class="comment">//时间复杂度：树的深度/高度</span></span><br><span class="line"><span class="comment">// O(logn)。n为数据规模（二叉排序树是平衡树）</span></span><br><span class="line"><span class="comment">// O(n)。n为数据规模（二叉排序树是斜树）</span></span><br><span class="line"><span class="comment">//空间复杂度：</span></span><br><span class="line"><span class="comment">//空间复杂度：二叉排序树的大小或递归调用栈的规模/树的深度/高度：</span></span><br><span class="line"><span class="comment">// O(1)。未使用额外辅助空间（不包括二叉排序树的大小；迭代法）</span></span><br><span class="line"><span class="comment">// O(n)。n为数据规模（包括二叉排序树的大小；递归法）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">searchBSTree</span><span class="params">(<span class="keyword">struct</span> BSTNode *root, ELEM_TYPE key)</span> <span class="comment">//参数：根结点指针，需插入的关键字    返回值：查找成功为true，查找失败为false</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="comment">//空树  无查找位置</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//查找失败</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//非空树   递归查找</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == root-&gt;key) <span class="comment">//需插入的关键字等于根结点的关键字</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//查找成功</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; root-&gt;key) <span class="comment">//需插入的关键字小于根结点的关键字</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">searchBSTree</span>(root-&gt;lChild, key); <span class="comment">//查找左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; root-&gt;key) <span class="comment">//需插入的关键字大于根结点的关键字</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">searchBSTree</span>(root-&gt;rChild, key); <span class="comment">//查找右子树</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找   前序遍历   迭代法</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">searchBSTree2</span><span class="params">(<span class="keyword">struct</span> BSTNode *root, ELEM_TYPE key)</span> <span class="comment">//参数：根结点指针，需插入的关键字    返回值：查找成功为true，查找失败为false</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="comment">//空树  无查找位置</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//查找失败</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//非空树   迭代查找</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (key == root-&gt;key) <span class="comment">//需插入的关键字等于根结点的关键字</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//查找成功</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; root-&gt;key) <span class="comment">//需插入的关键字小于根结点的关键字</span></span><br><span class="line">            &#123;</span><br><span class="line">                root = root-&gt;lChild; <span class="comment">//查找左子树</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; root-&gt;key) <span class="comment">//需插入的关键字大于根结点的关键字</span></span><br><span class="line">            &#123;</span><br><span class="line">                root = root-&gt;rChild; <span class="comment">//查找右子树</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//未查找成功返回，则查找失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数————————————————————</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">use_example</span>(); <span class="comment">//使用示例</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>不同参考资料中，二叉排序树的描述实现各不相同，但基本思想是一致的。作者使用规范的变量命名、提供详细的步骤解析及使用示例，应用C++语言将其整合成模板，以帮助理解记忆。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《2023版数据结构高分笔记》主编：率辉</li><li>《2023年计算机组成原理考研复习指导》组编：王道论坛</li><li>《大话数据结构》作者：程杰</li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“查找”学习提纲（一）——线性查找</title>
      <link href="/2022/09/08/%E2%80%9C%E6%9F%A5%E6%89%BE%E2%80%9D%E5%AD%A6%E4%B9%A0%E6%8F%90%E7%BA%B2%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E6%9F%A5%E6%89%BE/"/>
      <url>/2022/09/08/%E2%80%9C%E6%9F%A5%E6%89%BE%E2%80%9D%E5%AD%A6%E4%B9%A0%E6%8F%90%E7%BA%B2%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>“查找”学习提纲（一）——线性查找</p><hr><h1 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h1><ul><li><a href="https://blog.csdn.net/m0_62083249/article/details/126742184">线性查找的C++语言描述实现模板_夜悊的博客-CSDN博客</a></li></ul><hr><h1 id="查找的基本概念"><a href="#查找的基本概念" class="headerlink" title="查找的基本概念"></a>查找的基本概念</h1><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><ul><li>查找：在数据集合中寻找满足某种条件的数据元素的过程</li><li>查找表：同一类型的数据元素的集合</li><li>记录：数据元素</li><li>关键字：唯一标识数据元素的数据项&#x2F;字段的值</li></ul><hr><h2 id="查找（表）的类型"><a href="#查找（表）的类型" class="headerlink" title="查找（表）的类型"></a>查找（表）的类型</h2><ul><li>静态查找（表）</li><li>动态查找（表）</li></ul><hr><h2 id="查找的相关操作"><a href="#查找的相关操作" class="headerlink" title="查找的相关操作"></a>查找的相关操作</h2><ul><li>判断是否存在——静态</li><li>检索各种属性——静态</li><li>插入——动态</li><li>删除——动态</li></ul><hr><h2 id="查找的结果"><a href="#查找的结果" class="headerlink" title="查找的结果"></a>查找的结果</h2><ul><li>成功</li><li>失败</li></ul><hr><h2 id="查找方式的选择因素"><a href="#查找方式的选择因素" class="headerlink" title="查找方式的选择因素"></a>查找方式的选择因素</h2><ul><li>查找表的数据结构：如顺序存储或链式存储</li><li>查找表中关键字的次序：如无序或有序</li></ul><hr><h2 id="查找的性能分析"><a href="#查找的性能分析" class="headerlink" title="查找的性能分析"></a>查找的性能分析</h2><p>时间复杂度-&gt;平均查找长度（ASL）&#x2F;平均比较次数：</p><ul><li>查找长度&#x2F;比较次数：<strong>比较</strong>关键字的次数</li><li>平均查找长度（ASL）：查找每记录的概率（一般为1&#x2F;n）×查找长度。n为数据规模</li></ul><p>空间复杂度</p><hr><h1 id="顺序-线性查找"><a href="#顺序-线性查找" class="headerlink" title="顺序&#x2F;线性查找"></a>顺序&#x2F;线性查找</h1><h2 id="适用"><a href="#适用" class="headerlink" title="适用"></a>适用</h2><ul><li>线性表</li></ul><p>注意：有序<strong>线性表</strong>的顺序查找和有序<strong>顺序表</strong>的折半查找，思想不同</p><hr><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>平均查找长度（ASL）：</p><ul><li>查找成功：(n+1)&#x2F;2。n为数据规模</li><li>查找失败：n或n+1（使用哨兵机制）</li></ul><p>时间复杂度：O(n)</p><p>空间复杂度：O(1)。未使用额外辅助空间</p><blockquote><p>有序表查找失败的平均查找长度（ASL）：n&#x2F;2+n&#x2F;(n+1)。其他相同</p></blockquote><hr><h2 id="代码模板-1"><a href="#代码模板-1" class="headerlink" title="代码模板"></a>代码模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顺序/线性查找 无序</span></span><br><span class="line"><span class="comment">//适用：</span></span><br><span class="line"><span class="comment">//线性表</span></span><br><span class="line"><span class="comment">//注意：有序线性表的顺序查找和有序顺序表的折半查找，思想不同</span></span><br><span class="line"><span class="comment">//平均查找长度（ASL）：</span></span><br><span class="line"><span class="comment">//查找成功：(n+1)/2。n为数据规模</span></span><br><span class="line"><span class="comment">//查找失败：n或n+1（使用哨兵机制）</span></span><br><span class="line"><span class="comment">//时间复杂度：O(n)</span></span><br><span class="line"><span class="comment">//空间复杂度：O(1)。未使用额外辅助空间</span></span><br><span class="line"><span class="comment">//有序表查找失败的平均查找长度（ASL）：n/2+n/(n+1)。其他相同</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">seqSearch</span><span class="params">(<span class="type">const</span> vector&lt;ELEM_TYPE&gt; &amp;sTable, ELEM_TYPE sKey)</span> <span class="comment">//参数：查找表，需查找的关键字</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sTable.<span class="built_in">size</span>(); ++i) <span class="comment">//循环遍历</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (sTable[i] == sKey) <span class="comment">//查找成功</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//查找失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顺序/线性查找 无序    使用“哨兵”机制</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">seqSearch2</span><span class="params">(vector&lt;ELEM_TYPE&gt; &amp;sTable2, ELEM_TYPE sKey)</span> <span class="comment">//参数：查找表，需查找的关键字</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//约定：第一个位置为哨兵</span></span><br><span class="line">    sTable2[<span class="number">0</span>] = sKey; <span class="comment">//设置哨兵</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = sTable<span class="number">2.</span><span class="built_in">size</span>() - <span class="number">1</span>; <span class="comment">//循环变量</span></span><br><span class="line">    <span class="keyword">while</span> (sTable2[i] != sKey)  <span class="comment">//循环遍历    每循环只比较1次而不是2次</span></span><br><span class="line">    &#123;</span><br><span class="line">        --i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i; <span class="comment">//查找成功或查找失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="折半-二分查找"><a href="#折半-二分查找" class="headerlink" title="折半&#x2F;二分查找"></a>折半&#x2F;二分查找</h1><h2 id="适用-1"><a href="#适用-1" class="headerlink" title="适用"></a>适用</h2><ul><li>有序顺序表</li></ul><hr><h2 id="性能-1"><a href="#性能-1" class="headerlink" title="性能"></a>性能</h2><p>平均查找长度（ASL）：[log以2为底的(n+1)]-1。n为数据规模</p><p>时间复杂度：O(logn)</p><p>空间复杂度：O(1)。未使用额外辅助空间</p><hr><h2 id="代码模板-2"><a href="#代码模板-2" class="headerlink" title="代码模板"></a>代码模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//折半/二分查找</span></span><br><span class="line"><span class="comment">//适用：</span></span><br><span class="line"><span class="comment">//有序顺序表</span></span><br><span class="line"><span class="comment">//平均查找长度（ASL）：[log以2为底的(n+1)]-1。n为数据规模</span></span><br><span class="line"><span class="comment">//时间复杂度：O(logn)</span></span><br><span class="line"><span class="comment">//空间复杂度：O(1)。未使用额外辅助空间</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binSearch</span><span class="params">(<span class="type">const</span> vector&lt;ELEM_TYPE&gt; &amp;sTable, ELEM_TYPE sKey)</span> <span class="comment">//参数：查找表，需查找的关键字</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//约定：</span></span><br><span class="line">    <span class="comment">//采用递增/升序排序</span></span><br><span class="line">    <span class="comment">//循环不变量原则：左闭右闭为有效区间</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;                  <span class="comment">//左位置的指针</span></span><br><span class="line">    <span class="type">int</span> right = sTable.<span class="built_in">size</span>() - <span class="number">1</span>; <span class="comment">//右位置的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) <span class="comment">//当左位置的指针&lt;=右位置的指针时，循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = (left + right) / <span class="number">2</span>; <span class="comment">//中间位置的指针  注意：下取整</span></span><br><span class="line">        <span class="comment">//int mid = left + (right - left) / 2; </span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sTable[mid] == sKey) <span class="comment">//查找成功</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (sTable[mid] &gt; sKey) <span class="comment">//中间位置的的值比需查找的关键字大</span></span><br><span class="line">        &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>; <span class="comment">//在左半边区间查找</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (sTable[mid] &lt; sKey) <span class="comment">//中间位置的的值比需查找的关键字小</span></span><br><span class="line">        &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">//在左半边区间查找</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//查找失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h1><h2 id="适用-2"><a href="#适用-2" class="headerlink" title="适用"></a>适用</h2><ul><li>有序顺序表</li></ul><hr><h2 id="性能-2"><a href="#性能-2" class="headerlink" title="性能"></a>性能</h2><p>时间复杂度：O(logn)。n为数据规模</p><p>空间复杂度：O(1)。未使用额外辅助空间</p><blockquote><p>若数据规模大，关键字分布均匀，则性能优于折半查找</p></blockquote><hr><h2 id="代码模板-3"><a href="#代码模板-3" class="headerlink" title="代码模板"></a>代码模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插值查找</span></span><br><span class="line"><span class="comment">//适用：</span></span><br><span class="line"><span class="comment">//有序顺序表</span></span><br><span class="line"><span class="comment">//时间复杂度：O(logn)。n为数据规模</span></span><br><span class="line"><span class="comment">//空间复杂度：O(1)。未使用额外辅助空间</span></span><br><span class="line"><span class="comment">//若数据规模大，关键字分布均匀，则性能优于折半查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">insSearch</span><span class="params">(<span class="type">const</span> vector&lt;ELEM_TYPE&gt; &amp;sTable, ELEM_TYPE sKey)</span> <span class="comment">//参数：查找表，需查找的关键字</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//约定：</span></span><br><span class="line">    <span class="comment">//采用递增/升序排序</span></span><br><span class="line">    <span class="comment">//循环不变量原则：左闭右闭为有效区间</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;                  <span class="comment">//左位置的指针</span></span><br><span class="line">    <span class="type">int</span> right = sTable.<span class="built_in">size</span>() - <span class="number">1</span>; <span class="comment">//右位置的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) <span class="comment">//当左位置的指针&lt;=右位置的指针时，循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) * (sKey - sTable[left]) / (sTable[right] - sTable[left]); <span class="comment">//插值位置的指针  注意：下取整</span></span><br><span class="line">        <span class="comment">//与折半查找唯一不同的地方</span></span><br><span class="line">        <span class="comment">//折半查找：int mid = left + (right - left) / 2;</span></span><br><span class="line">        <span class="comment">//插值公式：(sKey - sTable[left]) / (sTable[right] - sTable[left])</span></span><br><span class="line">        <span class="comment">//核心思想：依据需要查找的值动态确定区间的缩减幅度</span></span><br><span class="line">        <span class="comment">//若(sKey - sTable[left]) / (sTable[right] - sTable[left])大，则mid大</span></span><br><span class="line">        <span class="comment">//即：在区间范围内，需要查找的值与左边界相对差大，则插值位置应靠右</span></span><br><span class="line">        <span class="comment">//若(sKey - sTable[left]) / (sTable[right] - sTable[left])小，则mid小</span></span><br><span class="line">        <span class="comment">//即：在区间范围内，需要查找的值与左边界相对差小，则插值位置应靠左</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sTable[mid] == sKey) <span class="comment">//查找成功</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (sTable[mid] &gt; sKey) <span class="comment">//插值位置的的值比需查找的关键字大</span></span><br><span class="line">        &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>; <span class="comment">//在左半边区间查找</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (sTable[mid] &lt; sKey) <span class="comment">//插值位置的的值比需查找的关键字小</span></span><br><span class="line">        &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">//在左半边区间查找</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//查找失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="斐波那契查找"><a href="#斐波那契查找" class="headerlink" title="斐波那契查找"></a>斐波那契查找</h1><h2 id="适用-3"><a href="#适用-3" class="headerlink" title="适用"></a>适用</h2><ul><li>有序顺序表</li></ul><hr><h2 id="性能-3"><a href="#性能-3" class="headerlink" title="性能"></a>性能</h2><p>时间复杂度：O(logn)。n为数据规模</p><p>空间复杂度：</p><ul><li>O(1)。未使用额外辅助空间（不包括斐波那契数列的大小）</li><li>O(m)。m为斐波那契数列的大小（包括斐波那契数列的大小）</li></ul><blockquote><p>通常性能优于折半查找</p></blockquote><hr><h2 id="代码模板-4"><a href="#代码模板-4" class="headerlink" title="代码模板"></a>代码模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//斐波那契查找</span></span><br><span class="line"><span class="comment">//适用：</span></span><br><span class="line"><span class="comment">//有序顺序表</span></span><br><span class="line"><span class="comment">//时间复杂度：O(logn)。n为数据规模</span></span><br><span class="line"><span class="comment">//空间复杂度：O(n)。n为斐波那契数列的大小</span></span><br><span class="line"><span class="comment">//通常性能优于折半查找</span></span><br><span class="line"><span class="comment">//核心思想</span></span><br><span class="line"><span class="comment">// 1.创建大小合适的斐波那契数列</span></span><br><span class="line"><span class="comment">// 2.获取基准斐波那契数的下标：基准斐波那契数-1刚好&gt;=查找表的大小</span></span><br><span class="line"><span class="comment">// 3.如果查找表的大小&lt;基准斐波那契数-1：查找时，分隔值的下标对查找表可能越界，需要扩充查找表</span></span><br><span class="line"><span class="comment">// 4.查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fibSearch</span><span class="params">(vector&lt;ELEM_TYPE&gt; &amp;sTable3, ELEM_TYPE sKey)</span> <span class="comment">//参数：查找表，需查找的关键字</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建大小合适的斐波那契数列</span></span><br><span class="line">    <span class="comment">//大小合适：</span></span><br><span class="line">    <span class="comment">//依据第2步：获取基准斐波那契数的下标：基准斐波那契数-1刚好&gt;=查找表的大小</span></span><br><span class="line">    <span class="comment">//即：斐波那契数列中，存在一个斐波那契数，该斐波那契数-1&gt;=查找表的大小</span></span><br><span class="line">    <span class="comment">//若:</span></span><br><span class="line">    <span class="comment">//查找表的大小为1，查找表 = &#123;2&#125;</span></span><br><span class="line">    <span class="comment">//斐波那契数列大小为1，斐波那契数列 = &#123;0&#125;</span></span><br><span class="line">    <span class="comment">//有0 - 1 &lt; 2，不满足条件</span></span><br><span class="line">    <span class="comment">//若:</span></span><br><span class="line">    <span class="comment">//查找表的大小为1，查找表 = &#123;2&#125;</span></span><br><span class="line">    <span class="comment">//斐波那契数列大小为5，斐波那契数列 = &#123;0,1,1,2,3&#125;</span></span><br><span class="line">    <span class="comment">//有3 - 1 &gt;= 2，满足条件</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(<span class="number">10</span>, <span class="number">0</span>)</span></span>; <span class="comment">//大小合适，初始化为0</span></span><br><span class="line"></span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i] = f[i - <span class="number">2</span>] + f[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出斐波那契数列</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;斐波那契数列：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : f)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.获取基准斐波那契数的下标：基准斐波那契数-1刚好&gt;=查找表的大小</span></span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>; <span class="comment">//斐波那契数的下标</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// while (f[index] - 1 &lt; sTable3.size()) //会判断为false跳过循环，导致错误</span></span><br><span class="line">    <span class="comment">// while (f[index] &lt; sTable3.size()) //无错误</span></span><br><span class="line">    <span class="type">int</span> tmp = sTable<span class="number">3.</span><span class="built_in">size</span>(); <span class="comment">//临时变量存储查找表的大小</span></span><br><span class="line">    <span class="keyword">while</span> (f[index] - <span class="number">1</span> &lt; tmp)</span><br><span class="line">    &#123;</span><br><span class="line">        ++index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出基准斐波那契数的下标</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;基准斐波那契数的下标：&quot;</span> &lt;&lt; index &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.如果查找表的大小&lt;基准斐波那契数-1：查找时，分隔值的下标对查找表可能越界，需要扩充查找表</span></span><br><span class="line">    <span class="comment">// 扩充查找表的大小=基准斐波那契数-1</span></span><br><span class="line">    <span class="comment">//理由：统一格式，方便循环或者递归的编写</span></span><br><span class="line">    <span class="comment">//由斐波那契数列的性质：f[index - 2] + f[index - 1] = f[index]</span></span><br><span class="line">    <span class="comment">//总共有f[index] -  1个元素</span></span><br><span class="line">    <span class="comment">// mid为下标有1个元素</span></span><br><span class="line">    <span class="comment">//剩余f[index] - 2个元素：f[index] - 2 = (f[index - 2] - 1) + (f[index - 1] - 1)</span></span><br><span class="line">    <span class="comment">//左区间有f[index - 1] - 1个元素</span></span><br><span class="line">    <span class="comment">//右区间有f[index - 2] - 1个元素</span></span><br><span class="line">    <span class="comment">//左、右区间元素个数的格式与之前统一</span></span><br><span class="line">    <span class="comment">//否则有可能是f[index - 2]、f[index - 2] - 1、f[index - 1]、f[index - 1] - 1</span></span><br><span class="line">    <span class="comment">//查找表中，下标为原查找表大小到斐波那契数-1-1的值=下标为原查找表大小-1的查找表值 即扩充值=原查找表最右边的值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//验证：</span></span><br><span class="line">    <span class="comment">//斐波那契数列 = &#123;0,1,1,2,3,5,8,13,21,34&#125;</span></span><br><span class="line">    <span class="comment">//查找表 = &#123;1,2,3,4,5,6,7,8,9,10,10,10&#125;</span></span><br><span class="line">    <span class="comment">//第一次循环：</span></span><br><span class="line">    <span class="comment">// index = 7</span></span><br><span class="line">    <span class="comment">// f[index - 1] = f[6] = 8</span></span><br><span class="line">    <span class="comment">// f[index - 1] - 1 = f[6] - 1 = 8 - 1 = 7</span></span><br><span class="line">    <span class="comment">// left = 0</span></span><br><span class="line">    <span class="comment">// mid = left +  f[index - 1] - 1 = 0 + 7 = 7   注意：针对下标</span></span><br><span class="line">    <span class="comment">//分隔值：sTable[7] = 8</span></span><br><span class="line">    <span class="comment">//左区间 = &#123;1,2,3,4,5,6,7&#125;  有f[index - 1] - 1 = 7个元素</span></span><br><span class="line">    <span class="comment">//右区间 = &#123;9,10,10,10&#125; 有f[index - 2] - 1 = f[5] - 1 = 5- 1 = 4个元素</span></span><br><span class="line">    <span class="comment">//以此类推</span></span><br><span class="line">    <span class="type">int</span> oldSize = sTable<span class="number">3.</span><span class="built_in">size</span>(); <span class="comment">//记录原查找表的大小 在第4步需要使用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sTable<span class="number">3.</span><span class="built_in">size</span>() &lt; f[index])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//查找表中，下标为原查找表大小到斐波那契数 - 1 - 1的值=下标为原查找表大小-1的查找表值 即扩充值=原查找表最右边的值</span></span><br><span class="line">        <span class="comment">//斐波那契数 - 1：针对大小</span></span><br><span class="line">        <span class="comment">//斐波那契数 - 1 - 1：针对下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = sTable<span class="number">3.</span><span class="built_in">size</span>(); i &lt; f[index] - <span class="number">1</span> - <span class="number">1</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            sTable<span class="number">3.</span><span class="built_in">push_back</span>(sTable3[sTable<span class="number">3.</span><span class="built_in">size</span>() - <span class="number">1</span>]); <span class="comment">//注意：sTable3.size()+1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出查找表</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;查找表：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (ELEM_TYPE num : sTable3)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.查找</span></span><br><span class="line">    <span class="comment">//约定：</span></span><br><span class="line">    <span class="comment">//采用递增/升序排序</span></span><br><span class="line">    <span class="comment">//循环不变量原则：左闭右闭为有效区间</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;                   <span class="comment">//左位置的指针</span></span><br><span class="line">    <span class="type">int</span> right = sTable<span class="number">3.</span><span class="built_in">size</span>() - <span class="number">1</span>; <span class="comment">//右位置的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试案例：sKey&gt;10，如=11时，left和mid不变，index不断-1，&lt;0无效时仍进入循环导致错误</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right &amp;&amp; index &gt;= <span class="number">0</span>) <span class="comment">//当左位置的指针&lt;=右位置的指针且基准斐波那契数的下标有效时，循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//见第3步的解析</span></span><br><span class="line">        <span class="comment">//左区间有f[index - 1] - 1个元素</span></span><br><span class="line">        <span class="comment">//分隔值的元素是第f[index - 1] - 1 + 1个</span></span><br><span class="line">        <span class="comment">//因为下标从0开始，所以分隔值的位置：f[index - 1] - 1</span></span><br><span class="line">        <span class="type">int</span> mid = left + f[index - <span class="number">1</span>] - <span class="number">1</span>; <span class="comment">//分隔值位置的指针</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sTable3[mid] == sKey) <span class="comment">//查找成功</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (mid &lt; oldSize) <span class="comment">// oldSize针对下标 分隔值位置的指针&lt;原查找表的大小，对原查找表未越界</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> mid; <span class="comment">//分隔值位置的指针即查找位置</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//分隔值位置的指针&gt;=原查找表的大小，对原查找表越界</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//在第3步：扩充值=原查找表最右边的值</span></span><br><span class="line">                <span class="comment">//对原查找表越界的位置/扩充值查找成功-&gt;对原查找表最右边的值查找成功</span></span><br><span class="line">                <span class="comment">//原查找表最右边的值的下标即查找位置</span></span><br><span class="line">                <span class="keyword">return</span> oldSize - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (sTable3[mid] &gt; sKey) <span class="comment">//分隔值位置的的值比需查找的关键字大</span></span><br><span class="line">        &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>; <span class="comment">//在左半边区间查找</span></span><br><span class="line"></span><br><span class="line">            index = index - <span class="number">1</span>; <span class="comment">//更新基准斐波那契数的下标</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (sTable3[mid] &lt; sKey) <span class="comment">//分隔值位置的的值比需查找的关键字小</span></span><br><span class="line">        &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">//在左半边区间查找</span></span><br><span class="line"></span><br><span class="line">            index = index - <span class="number">2</span>; <span class="comment">//更新基准斐波那契数的下标</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//见第3步解析</span></span><br><span class="line">        <span class="comment">//左区间有f[index - 1] - 1个元素    更新基准斐波那契数的下标-1</span></span><br><span class="line">        <span class="comment">//右区间有f[index - 2] - 1个元素    更新基准斐波那契数的下标-2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//查找失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="折半、插值和斐波那契查找总结"><a href="#折半、插值和斐波那契查找总结" class="headerlink" title="折半、插值和斐波那契查找总结"></a>折半、插值和斐波那契查找总结</h1><ul><li>过程相似</li><li>分隔值的选择策略不同</li></ul><hr><h1 id="索引查找的类型"><a href="#索引查找的类型" class="headerlink" title="索引查找的类型"></a>索引查找的类型</h1><ul><li>线性索引</li><li>树形索引</li><li>多级索引</li></ul><hr><h1 id="线性索引的类型"><a href="#线性索引的类型" class="headerlink" title="线性索引的类型"></a>线性索引的类型</h1><ul><li>稠密索引：一个索引对应一条记录；记录可无序，索引有序；索引是主关键字</li><li>分块索引：一个索引对应多条记录&#x2F;一个块；块内可无序，块间有序；索引是主关键字</li><li>倒排索引：一个索引对应多条记录；记录可无序，索引有序；索引是次关键字</li></ul><hr><h1 id="分块-索引顺序查找"><a href="#分块-索引顺序查找" class="headerlink" title="分块&#x2F;索引顺序查找"></a>分块&#x2F;索引顺序查找</h1><h2 id="适用-4"><a href="#适用-4" class="headerlink" title="适用"></a>适用</h2><ul><li>线性表</li></ul><hr><h2 id="结构描述"><a href="#结构描述" class="headerlink" title="结构描述"></a>结构描述</h2><p>查找表：</p><ul><li>块内可无序</li><li>块间有序：前一个块中的<strong>最大</strong>关键字小于后一个块中的<strong>所有</strong>关键字，以此类推</li></ul><p>索引表：索引块，有序</p><ul><li>键值分量：各块的最大关键字</li><li>链值分量：各块的第一条记录的地址&#x2F;指针</li><li>…。如块中记录的个数等</li></ul><hr><h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><ol><li>对块间&#x2F;索引表：顺序查找或折半查找等</li><li>对块内&#x2F;查找表：一般为顺序查找，若有序可为折半查找等</li></ol><hr><h2 id="性能-4"><a href="#性能-4" class="headerlink" title="性能"></a>性能</h2><p>平均查找长度（ASL）：ASL1 +  ASL2。其中ASL1为对块间查找的平均查找长度（ASL），ASL2为对块内顺序查找的平均查找长度（ASL）</p><p>时间复杂度：O(logn)~O(n)。n为数据规模</p><ul><li>O(logn)。n为数据规模（对块间折半查找等+对块内顺序查找）</li><li>O(n)。n为数据规模（对块间顺序查找+对块内顺序查找）</li></ul><p>空间复杂度：</p><ul><li>O(1)。未使用额外辅助空间（不包括索引表的大小）</li><li>O(m)。m为索引表的大小（包括索引表的大小）</li></ul><p>查找表的大小为n，块数为b，每块中的记录数为s，等概率情况：</p><ul><li>对块间顺序查找，对块内顺序查找：ASL &#x3D; ASL1 + ASL2 &#x3D; (b + 1)&#x2F;2 + (s + 1)&#x2F;2 &#x3D; (s² + 2 × s + n)&#x2F;(2 × s）</li><li>对块间顺序查找，对块内顺序查找，b &#x3D; s &#x3D; 根号n：ASL &#x3D; 根号n + 1</li><li>对块间折半查找，对块内顺序查找：ASL &#x3D; ASL1 + ASL2 &#x3D;  [log以2为底的b]下取整+1或[log以2为底的(b + 1)]上取整 + (s + 1)&#x2F;2</li><li>b &#x3D; s &#x3D; 根号n，ASL为最小&#x2F;优值</li></ul><hr><h2 id="代码模板-5"><a href="#代码模板-5" class="headerlink" title="代码模板"></a>代码模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结构体</span></span><br><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="comment">//分块查找中，索引表元素</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">IndexElem</span></span><br><span class="line">&#123;</span><br><span class="line">    ELEM_TYPE maxKey; <span class="comment">//键值分量：各块的最大关键字</span></span><br><span class="line">    ELEM_TYPE first;  <span class="comment">//链值分量：各块的第一条记录的地址/指针</span></span><br><span class="line">&#125; IndexElem;</span><br><span class="line"><span class="comment">// struct IndexElem：结构体数据类型的名称</span></span><br><span class="line"><span class="comment">//如创建一个索引表元素的语句：struct IndexElem elem;</span></span><br><span class="line"><span class="comment">//若结构体数据类型内，存在指向该结构体的指针数据类型，则必须完整命名结构体数据类型的名称</span></span><br><span class="line"><span class="comment">//如索引表元素结构体IndexElem内，若存在指向该结构体的指针数据类型，则命名语句为：typedef struct IndexElem而不是typedef struct</span></span><br><span class="line"><span class="comment">// &#125;IndexElem;：typedef给结构体数据类型起的别名，可简化语句</span></span><br><span class="line"><span class="comment">//如创建一个索引表元素的语句：IndexElem elem;</span></span><br><span class="line"><span class="comment">//结构体数据类型的名称和别名尽量一致，以方便记忆、使用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IndexElem</span> indexTable[<span class="number">10</span>]; <span class="comment">//创建索引表</span></span><br></pre></td></tr></table></figure><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><table><thead><tr><th>名称</th><th>适用</th><th>时间复杂度</th><th>空间复杂度</th></tr></thead><tbody><tr><td>顺序查找</td><td>线性表</td><td>O(n)</td><td>O(1)</td></tr><tr><td>折半查找</td><td>有序顺序表</td><td>O(logn)</td><td>O(1)</td></tr><tr><td>插值查找</td><td>有序顺序表</td><td>O(logn)</td><td>O(1)</td></tr><tr><td>斐波那契查找</td><td>有序顺序表</td><td>O(logn)</td><td>O(m)</td></tr><tr><td>稠密索引查找</td><td>-</td><td>-</td><td>-</td></tr><tr><td>分块查找</td><td>线性表</td><td>O(logn)~O(n)</td><td>O(m)</td></tr><tr><td>倒排索引查找</td><td>-</td><td>-</td><td>-</td></tr></tbody></table><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《2023版数据结构高分笔记》主编：率辉</li><li>《2023年计算机组成原理考研复习指导》组编：王道论坛</li><li>《大话数据结构》作者：程杰</li><li><a href="https://zhuanlan.zhihu.com/p/106059055">插值查找算法原理分析——及python与C++实现 - 知乎 (zhihu.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/106883697">斐波那契查找原理——附python和C++实现 - 知乎 (zhihu.com)</a></li><li><a href="https://cloud.tencent.com/developer/article/1065224">斐波那契查找原理详解与实现 - 腾讯云开发者社区-腾讯云 (tencent.com)</a></li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性查找的C++语言描述实现模板</title>
      <link href="/2022/09/07/%E7%BA%BF%E6%80%A7%E6%9F%A5%E6%89%BE%E7%9A%84C++%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E5%AE%9E%E7%8E%B0%E6%A8%A1%E6%9D%BF/"/>
      <url>/2022/09/07/%E7%BA%BF%E6%80%A7%E6%9F%A5%E6%89%BE%E7%9A%84C++%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E5%AE%9E%E7%8E%B0%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>数据结构中线性查找的C++语言描述实现模板，有详细的步骤解析及使用示例。</p><hr><h1 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h1><ul><li><a href="https://github.com/yezhening/Programming-examples">yezhening&#x2F;Programming-examples: 编程实例 (github.com)</a></li><li><a href="https://gitee.com/yezhening/Programming-examples">Programming-examples: 编程实例 (gitee.com)</a></li></ul><hr><h1 id="linearSearch-cpp"><a href="#linearSearch-cpp" class="headerlink" title="linearSearch.cpp"></a>linearSearch.cpp</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件————————————————————</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//命名空间</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型————————————————————</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ELEM_TYPE; <span class="comment">//数据的（数据）类型 依据数据的实际类型定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体</span></span><br><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="comment">//分块查找中，索引表元素</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">IndexElem</span></span><br><span class="line">&#123;</span><br><span class="line">    ELEM_TYPE maxKey; <span class="comment">//键值分量：各块的最大关键字</span></span><br><span class="line">    ELEM_TYPE first;  <span class="comment">//链值分量：各块的第一条记录的地址/指针</span></span><br><span class="line">&#125; IndexElem;</span><br><span class="line"><span class="comment">// struct IndexElem：结构体数据类型的名称</span></span><br><span class="line"><span class="comment">//如创建一个索引表元素的语句：struct IndexElem elem;</span></span><br><span class="line"><span class="comment">//若结构体数据类型内，存在指向该结构体的指针数据类型，则必须完整命名结构体数据类型的名称</span></span><br><span class="line"><span class="comment">//如索引表元素结构体IndexElem内，若存在指向该结构体的指针数据类型，则命名语句为：typedef struct IndexElem而不是typedef struct</span></span><br><span class="line"><span class="comment">// &#125;IndexElem;：typedef给结构体数据类型起的别名，可简化语句</span></span><br><span class="line"><span class="comment">//如创建一个索引表元素的语句：IndexElem elem;</span></span><br><span class="line"><span class="comment">//结构体数据类型的名称和别名尽量一致，以方便记忆、使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数声明————————————————————</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_example</span><span class="params">()</span></span>;                                             <span class="comment">//使用示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">seqSearch</span><span class="params">(<span class="type">const</span> vector&lt;ELEM_TYPE&gt; &amp;sTable, ELEM_TYPE sKey)</span></span>; <span class="comment">//顺序/线性查找  无序顺序表</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">seqSearch2</span><span class="params">(vector&lt;ELEM_TYPE&gt; &amp;sTable2, ELEM_TYPE sKey)</span></span>;     <span class="comment">//顺序/线性查找  无序顺序表    使用哨兵机制</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binSearch</span><span class="params">(<span class="type">const</span> vector&lt;ELEM_TYPE&gt; &amp;sTable, ELEM_TYPE sKey)</span></span>; <span class="comment">//折半/二分查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">insSearch</span><span class="params">(<span class="type">const</span> vector&lt;ELEM_TYPE&gt; &amp;sTable, ELEM_TYPE sKey)</span></span>; <span class="comment">//插值查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fibSearch</span><span class="params">(vector&lt;ELEM_TYPE&gt; &amp;sTable3, ELEM_TYPE sKey)</span></span>;      <span class="comment">//斐波那契查找</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数定义————————————————————</span></span><br><span class="line"><span class="comment">//使用示例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_example</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//顺序/线性查找 无序顺序表————————————————————</span></span><br><span class="line">    <span class="type">const</span> vector&lt;ELEM_TYPE&gt; sTable = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">//创建查找表 向量数据类型的常量</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sResult = <span class="number">-1</span>; <span class="comment">//查找结果</span></span><br><span class="line">    <span class="comment">//约定：</span></span><br><span class="line">    <span class="comment">//查找成功：返回记录的位置，记录的位置&gt;-1</span></span><br><span class="line">    <span class="comment">//查找失败：返回-1</span></span><br><span class="line"></span><br><span class="line">    sResult = <span class="built_in">seqSearch</span>(sTable, <span class="number">3</span>); <span class="comment">//顺序/线性查找 无序顺序表</span></span><br><span class="line">    cout &lt;&lt; sResult &lt;&lt; endl;        <span class="comment">//输出：2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//顺序/线性查找 无序顺序表    使用哨兵机制————————————————————</span></span><br><span class="line">    <span class="comment">//约定：第一个位置为哨兵    -1为无效数据</span></span><br><span class="line">    vector&lt;ELEM_TYPE&gt; sTable2 = &#123;<span class="number">-1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">//创建查找表2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//约定：</span></span><br><span class="line">    <span class="comment">//查找成功：返回记录的位置，记录的位置&gt;0</span></span><br><span class="line">    <span class="comment">//查找失败：返回0</span></span><br><span class="line"></span><br><span class="line">    sResult = <span class="built_in">seqSearch2</span>(sTable2, <span class="number">3</span>); <span class="comment">//顺序/线性查找   无序顺序表    使用哨兵机制</span></span><br><span class="line">    cout &lt;&lt; sResult &lt;&lt; endl;          <span class="comment">//输出：2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//折半/二分查找————————————————————</span></span><br><span class="line">    sResult = <span class="built_in">binSearch</span>(sTable, <span class="number">3</span>); <span class="comment">//折半/二分查找</span></span><br><span class="line">    cout &lt;&lt; sResult &lt;&lt; endl;        <span class="comment">//输出：2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//插值查找————————————————————</span></span><br><span class="line">    sResult = <span class="built_in">insSearch</span>(sTable, <span class="number">3</span>); <span class="comment">//插值查找</span></span><br><span class="line">    cout &lt;&lt; sResult &lt;&lt; endl;        <span class="comment">//输出：2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//斐波那契查找————————————————————</span></span><br><span class="line">    vector&lt;ELEM_TYPE&gt; sTable3 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;; <span class="comment">//创建查找表3</span></span><br><span class="line"></span><br><span class="line">    sResult = <span class="built_in">fibSearch</span>(sTable3, <span class="number">3</span>); <span class="comment">//斐波那契查找</span></span><br><span class="line">    cout &lt;&lt; sResult &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//输出：</span></span><br><span class="line">    <span class="comment">//斐波那契数列：0 1 1 2 3 5 8 13 21 34</span></span><br><span class="line">    <span class="comment">//基准斐波那契数的下标：7</span></span><br><span class="line">    <span class="comment">//查找表：1 2 3 4 5 6 7 8 9 10 10</span></span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//分块/索引顺序查找————————————————————</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">IndexElem</span> indexTable[<span class="number">10</span>]; <span class="comment">//创建索引表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序/线性查找 无序顺序表</span></span><br><span class="line"><span class="comment">//适用：</span></span><br><span class="line"><span class="comment">//线性表</span></span><br><span class="line"><span class="comment">//注意：有序线性表的顺序查找和有序顺序表的折半查找，思想不同</span></span><br><span class="line"><span class="comment">//平均查找长度（ASL）：</span></span><br><span class="line"><span class="comment">//查找成功：(n+1)/2。n为数据规模</span></span><br><span class="line"><span class="comment">//查找失败：n或n+1（使用哨兵机制）</span></span><br><span class="line"><span class="comment">//时间复杂度：O(n)</span></span><br><span class="line"><span class="comment">//空间复杂度：O(1)。未使用额外辅助空间</span></span><br><span class="line"><span class="comment">//有序表查找失败的平均查找长度（ASL）：n/2+n/(n+1)。其他相同</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">seqSearch</span><span class="params">(<span class="type">const</span> vector&lt;ELEM_TYPE&gt; &amp;sTable, ELEM_TYPE sKey)</span> <span class="comment">//参数：查找表，需查找的关键字</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sTable.<span class="built_in">size</span>(); ++i) <span class="comment">//循环遍历</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (sTable[i] == sKey) <span class="comment">//查找成功</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//查找失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序/线性查找 无序顺序表    使用“哨兵”机制</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">seqSearch2</span><span class="params">(vector&lt;ELEM_TYPE&gt; &amp;sTable2, ELEM_TYPE sKey)</span> <span class="comment">//参数：查找表，需查找的关键字</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//约定：第一个位置为哨兵</span></span><br><span class="line">    sTable2[<span class="number">0</span>] = sKey; <span class="comment">//设置哨兵</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = sTable<span class="number">2.</span><span class="built_in">size</span>() - <span class="number">1</span>; <span class="comment">//循环变量</span></span><br><span class="line">    <span class="keyword">while</span> (sTable2[i] != sKey)  <span class="comment">//循环遍历    每循环只比较1次而不是2次</span></span><br><span class="line">    &#123;</span><br><span class="line">        --i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i; <span class="comment">//查找成功或查找失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//折半/二分查找</span></span><br><span class="line"><span class="comment">//适用：</span></span><br><span class="line"><span class="comment">//有序顺序表</span></span><br><span class="line"><span class="comment">//平均查找长度（ASL）：[log以2为底的(n+1)]-1。n为数据规模</span></span><br><span class="line"><span class="comment">//时间复杂度：O(logn)</span></span><br><span class="line"><span class="comment">//空间复杂度：O(1)。未使用额外辅助空间</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binSearch</span><span class="params">(<span class="type">const</span> vector&lt;ELEM_TYPE&gt; &amp;sTable, ELEM_TYPE sKey)</span> <span class="comment">//参数：查找表，需查找的关键字</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//约定：</span></span><br><span class="line">    <span class="comment">//采用递增/升序排序</span></span><br><span class="line">    <span class="comment">//循环不变量原则：左闭右闭为有效区间</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;                  <span class="comment">//左位置的指针</span></span><br><span class="line">    <span class="type">int</span> right = sTable.<span class="built_in">size</span>() - <span class="number">1</span>; <span class="comment">//右位置的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) <span class="comment">//当左位置的指针&lt;=右位置的指针时，循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = (left + right) / <span class="number">2</span>; <span class="comment">//中间位置的指针  注意：下取整</span></span><br><span class="line">        <span class="comment">// int mid = left + (right - left) / 2;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sTable[mid] == sKey) <span class="comment">//查找成功</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (sTable[mid] &gt; sKey) <span class="comment">//中间位置的的值比需查找的关键字大</span></span><br><span class="line">        &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>; <span class="comment">//在左半边区间查找</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (sTable[mid] &lt; sKey) <span class="comment">//中间位置的的值比需查找的关键字小</span></span><br><span class="line">        &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">//在左半边区间查找</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//查找失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插值查找</span></span><br><span class="line"><span class="comment">//适用：</span></span><br><span class="line"><span class="comment">//有序顺序表</span></span><br><span class="line"><span class="comment">//时间复杂度：O(logn)。n为数据规模</span></span><br><span class="line"><span class="comment">//空间复杂度：O(1)。未使用额外辅助空间</span></span><br><span class="line"><span class="comment">//若数据规模大，关键字分布均匀，则性能优于折半查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">insSearch</span><span class="params">(<span class="type">const</span> vector&lt;ELEM_TYPE&gt; &amp;sTable, ELEM_TYPE sKey)</span> <span class="comment">//参数：查找表，需查找的关键字</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//约定：</span></span><br><span class="line">    <span class="comment">//采用递增/升序排序</span></span><br><span class="line">    <span class="comment">//循环不变量原则：左闭右闭为有效区间</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;                  <span class="comment">//左位置的指针</span></span><br><span class="line">    <span class="type">int</span> right = sTable.<span class="built_in">size</span>() - <span class="number">1</span>; <span class="comment">//右位置的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) <span class="comment">//当左位置的指针&lt;=右位置的指针时，循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) * (sKey - sTable[left]) / (sTable[right] - sTable[left]); <span class="comment">//插值位置的指针  注意：下取整</span></span><br><span class="line">        <span class="comment">//与折半查找唯一不同的地方</span></span><br><span class="line">        <span class="comment">//折半查找：int mid = left + (right - left) / 2;</span></span><br><span class="line">        <span class="comment">//插值公式：(sKey - sTable[left]) / (sTable[right] - sTable[left])</span></span><br><span class="line">        <span class="comment">//核心思想：依据需要查找的值动态确定区间的缩减幅度</span></span><br><span class="line">        <span class="comment">//若(sKey - sTable[left]) / (sTable[right] - sTable[left])大，则mid大</span></span><br><span class="line">        <span class="comment">//即：在区间范围内，需要查找的值与左边界相对差大，则插值位置应靠右</span></span><br><span class="line">        <span class="comment">//若(sKey - sTable[left]) / (sTable[right] - sTable[left])小，则mid小</span></span><br><span class="line">        <span class="comment">//即：在区间范围内，需要查找的值与左边界相对差小，则插值位置应靠左</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sTable[mid] == sKey) <span class="comment">//查找成功</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (sTable[mid] &gt; sKey) <span class="comment">//插值位置的的值比需查找的关键字大</span></span><br><span class="line">        &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>; <span class="comment">//在左半边区间查找</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (sTable[mid] &lt; sKey) <span class="comment">//插值位置的的值比需查找的关键字小</span></span><br><span class="line">        &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">//在左半边区间查找</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//查找失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//斐波那契查找</span></span><br><span class="line"><span class="comment">//适用：</span></span><br><span class="line"><span class="comment">//有序顺序表</span></span><br><span class="line"><span class="comment">//时间复杂度：O(logn)。n为数据规模</span></span><br><span class="line"><span class="comment">//空间复杂度：O(n)。n为斐波那契数列的大小</span></span><br><span class="line"><span class="comment">//通常性能优于折半查找</span></span><br><span class="line"><span class="comment">//核心思想</span></span><br><span class="line"><span class="comment">// 1.创建大小合适的斐波那契数列</span></span><br><span class="line"><span class="comment">// 2.获取基准斐波那契数的下标：基准斐波那契数-1刚好&gt;=查找表的大小</span></span><br><span class="line"><span class="comment">// 3.如果查找表的大小&lt;基准斐波那契数-1：查找时，分隔值的下标对查找表可能越界，需要扩充查找表</span></span><br><span class="line"><span class="comment">// 4.查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fibSearch</span><span class="params">(vector&lt;ELEM_TYPE&gt; &amp;sTable3, ELEM_TYPE sKey)</span> <span class="comment">//参数：查找表，需查找的关键字</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建大小合适的斐波那契数列</span></span><br><span class="line">    <span class="comment">//大小合适：</span></span><br><span class="line">    <span class="comment">//依据第2步：获取基准斐波那契数的下标：基准斐波那契数-1刚好&gt;=查找表的大小</span></span><br><span class="line">    <span class="comment">//即：斐波那契数列中，存在一个斐波那契数，该斐波那契数-1&gt;=查找表的大小</span></span><br><span class="line">    <span class="comment">//若:</span></span><br><span class="line">    <span class="comment">//查找表的大小为1，查找表 = &#123;2&#125;</span></span><br><span class="line">    <span class="comment">//斐波那契数列大小为1，斐波那契数列 = &#123;0&#125;</span></span><br><span class="line">    <span class="comment">//有0 - 1 &lt; 2，不满足条件</span></span><br><span class="line">    <span class="comment">//若:</span></span><br><span class="line">    <span class="comment">//查找表的大小为1，查找表 = &#123;2&#125;</span></span><br><span class="line">    <span class="comment">//斐波那契数列大小为5，斐波那契数列 = &#123;0,1,1,2,3&#125;</span></span><br><span class="line">    <span class="comment">//有3 - 1 &gt;= 2，满足条件</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(<span class="number">10</span>, <span class="number">0</span>)</span></span>; <span class="comment">//大小合适，初始化为0</span></span><br><span class="line"></span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i] = f[i - <span class="number">2</span>] + f[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出斐波那契数列</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;斐波那契数列：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : f)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.获取基准斐波那契数的下标：基准斐波那契数-1刚好&gt;=查找表的大小</span></span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>; <span class="comment">//斐波那契数的下标</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// while (f[index] - 1 &lt; sTable3.size()) //会判断为false跳过循环，导致错误</span></span><br><span class="line">    <span class="comment">// while (f[index] &lt; sTable3.size()) //无错误</span></span><br><span class="line">    <span class="type">int</span> tmp = sTable<span class="number">3.</span><span class="built_in">size</span>(); <span class="comment">//临时变量存储查找表的大小</span></span><br><span class="line">    <span class="keyword">while</span> (f[index] - <span class="number">1</span> &lt; tmp)</span><br><span class="line">    &#123;</span><br><span class="line">        ++index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出基准斐波那契数的下标</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;基准斐波那契数的下标：&quot;</span> &lt;&lt; index &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.如果查找表的大小&lt;基准斐波那契数-1：查找时，分隔值的下标对查找表可能越界，需要扩充查找表</span></span><br><span class="line">    <span class="comment">// 扩充查找表的大小=基准斐波那契数-1</span></span><br><span class="line">    <span class="comment">//理由：统一格式，方便循环或者递归的编写</span></span><br><span class="line">    <span class="comment">//由斐波那契数列的性质：f[index - 2] + f[index - 1] = f[index]</span></span><br><span class="line">    <span class="comment">//总共有f[index] -  1个元素</span></span><br><span class="line">    <span class="comment">// mid为下标有1个元素</span></span><br><span class="line">    <span class="comment">//剩余f[index] - 2个元素：f[index] - 2 = (f[index - 2] - 1) + (f[index - 1] - 1)</span></span><br><span class="line">    <span class="comment">//左区间有f[index - 1] - 1个元素</span></span><br><span class="line">    <span class="comment">//右区间有f[index - 2] - 1个元素</span></span><br><span class="line">    <span class="comment">//左、右区间元素个数的格式与之前统一</span></span><br><span class="line">    <span class="comment">//否则有可能是f[index - 2]、f[index - 2] - 1、f[index - 1]、f[index - 1] - 1</span></span><br><span class="line">    <span class="comment">//查找表中，下标为原查找表大小到斐波那契数-1-1的值=下标为原查找表大小-1的查找表值 即扩充值=原查找表最右边的值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//验证：</span></span><br><span class="line">    <span class="comment">//斐波那契数列 = &#123;0,1,1,2,3,5,8,13,21,34&#125;</span></span><br><span class="line">    <span class="comment">//查找表 = &#123;1,2,3,4,5,6,7,8,9,10,10,10&#125;</span></span><br><span class="line">    <span class="comment">//第一次循环：</span></span><br><span class="line">    <span class="comment">// index = 7</span></span><br><span class="line">    <span class="comment">// f[index - 1] = f[6] = 8</span></span><br><span class="line">    <span class="comment">// f[index - 1] - 1 = f[6] - 1 = 8 - 1 = 7</span></span><br><span class="line">    <span class="comment">// left = 0</span></span><br><span class="line">    <span class="comment">// mid = left +  f[index - 1] - 1 = 0 + 7 = 7   注意：针对下标</span></span><br><span class="line">    <span class="comment">//分隔值：sTable[7] = 8</span></span><br><span class="line">    <span class="comment">//左区间 = &#123;1,2,3,4,5,6,7&#125;  有f[index - 1] - 1 = 7个元素</span></span><br><span class="line">    <span class="comment">//右区间 = &#123;9,10,10,10&#125; 有f[index - 2] - 1 = f[5] - 1 = 5- 1 = 4个元素</span></span><br><span class="line">    <span class="comment">//以此类推</span></span><br><span class="line">    <span class="type">int</span> oldSize = sTable<span class="number">3.</span><span class="built_in">size</span>(); <span class="comment">//记录原查找表的大小 在第4步需要使用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sTable<span class="number">3.</span><span class="built_in">size</span>() &lt; f[index])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//查找表中，下标为原查找表大小到斐波那契数 - 1 - 1的值=下标为原查找表大小-1的查找表值 即扩充值=原查找表最右边的值</span></span><br><span class="line">        <span class="comment">//斐波那契数 - 1：针对大小</span></span><br><span class="line">        <span class="comment">//斐波那契数 - 1 - 1：针对下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = sTable<span class="number">3.</span><span class="built_in">size</span>(); i &lt; f[index] - <span class="number">1</span> - <span class="number">1</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            sTable<span class="number">3.</span><span class="built_in">push_back</span>(sTable3[sTable<span class="number">3.</span><span class="built_in">size</span>() - <span class="number">1</span>]); <span class="comment">//注意：sTable3.size()+1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出查找表</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;查找表：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (ELEM_TYPE num : sTable3)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.查找</span></span><br><span class="line">    <span class="comment">//约定：</span></span><br><span class="line">    <span class="comment">//采用递增/升序排序</span></span><br><span class="line">    <span class="comment">//循环不变量原则：左闭右闭为有效区间</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;                   <span class="comment">//左位置的指针</span></span><br><span class="line">    <span class="type">int</span> right = sTable<span class="number">3.</span><span class="built_in">size</span>() - <span class="number">1</span>; <span class="comment">//右位置的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试案例：sKey&gt;10，如=11时，left和mid不变，index不断-1，&lt;0无效时仍进入循环导致错误</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right &amp;&amp; index &gt;= <span class="number">0</span>) <span class="comment">//当左位置的指针&lt;=右位置的指针且基准斐波那契数的下标有效时，循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//见第3步的解析</span></span><br><span class="line">        <span class="comment">//左区间有f[index - 1] - 1个元素</span></span><br><span class="line">        <span class="comment">//分隔值的元素是第f[index - 1] - 1 + 1个</span></span><br><span class="line">        <span class="comment">//因为下标从0开始，所以分隔值的位置：f[index - 1] - 1</span></span><br><span class="line">        <span class="type">int</span> mid = left + f[index - <span class="number">1</span>] - <span class="number">1</span>; <span class="comment">//分隔值位置的指针</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sTable3[mid] == sKey) <span class="comment">//查找成功</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (mid &lt; oldSize) <span class="comment">// oldSize针对下标 分隔值位置的指针&lt;原查找表的大小，对原查找表未越界</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> mid; <span class="comment">//分隔值位置的指针即查找位置</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//分隔值位置的指针&gt;=原查找表的大小，对原查找表越界</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//在第3步：扩充值=原查找表最右边的值</span></span><br><span class="line">                <span class="comment">//对原查找表越界的位置/扩充值查找成功-&gt;对原查找表最右边的值查找成功</span></span><br><span class="line">                <span class="comment">//原查找表最右边的值的下标即查找位置</span></span><br><span class="line">                <span class="keyword">return</span> oldSize - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (sTable3[mid] &gt; sKey) <span class="comment">//分隔值位置的的值比需查找的关键字大</span></span><br><span class="line">        &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>; <span class="comment">//在左半边区间查找</span></span><br><span class="line"></span><br><span class="line">            index = index - <span class="number">1</span>; <span class="comment">//更新基准斐波那契数的下标</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (sTable3[mid] &lt; sKey) <span class="comment">//分隔值位置的的值比需查找的关键字小</span></span><br><span class="line">        &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">//在左半边区间查找</span></span><br><span class="line"></span><br><span class="line">            index = index - <span class="number">2</span>; <span class="comment">//更新基准斐波那契数的下标</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//见第3步解析</span></span><br><span class="line">        <span class="comment">//左区间有f[index - 1] - 1个元素    更新基准斐波那契数的下标-1</span></span><br><span class="line">        <span class="comment">//右区间有f[index - 2] - 1个元素    更新基准斐波那契数的下标-2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//查找失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数————————————————————</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">use_example</span>(); <span class="comment">//使用示例</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>不同参考资料中，线性查找的描述实现各不相同，但基本思想是一致的。作者使用规范的变量命名、提供详细的步骤解析及使用示例，应用C++语言将其整合成模板，以帮助理解记忆。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《2023版数据结构高分笔记》主编：率辉</li><li>《2023年计算机组成原理考研复习指导》组编：王道论坛</li><li>《大话数据结构》作者：程杰</li><li><a href="https://zhuanlan.zhihu.com/p/106059055">插值查找算法原理分析——及python与C++实现 - 知乎 (zhihu.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/106883697">斐波那契查找原理——附python和C++实现 - 知乎 (zhihu.com)</a></li><li><a href="https://cloud.tencent.com/developer/article/1065224">斐波那契查找原理详解与实现 - 腾讯云开发者社区-腾讯云 (tencent.com)</a></li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“树与二叉树”学习提纲</title>
      <link href="/2022/09/05/%E2%80%9C%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E2%80%9D%E5%AD%A6%E4%B9%A0%E6%8F%90%E7%BA%B2/"/>
      <url>/2022/09/05/%E2%80%9C%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E2%80%9D%E5%AD%A6%E4%B9%A0%E6%8F%90%E7%BA%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>“树与二叉树”学习提纲。</p><hr><h1 id="树的基本概念"><a href="#树的基本概念" class="headerlink" title="树的基本概念"></a>树的基本概念</h1><h2 id="树的关键概念"><a href="#树的关键概念" class="headerlink" title="树的关键概念"></a>树的关键概念</h2><ul><li>结点的度：分支数</li><li>树的度：各结点度的最大值</li><li>结点的层次：根结点为第1层，根结点的孩子结点为第2层，依次类推</li><li>结点的深度：从根结点到当前结点的层数</li><li>结点的高度：从当前结点到叶子结点的层数的最大值</li><li>树的深度&#x2F;高度：各结点层次的最大值</li><li>结点间的路径：结点间的点数</li><li>结点间的路径长度：结点间的边数</li><li>树的路径长度：根结点到每个结点的路径长度的和</li></ul><hr><h2 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h2><p>顺序存储：</p><ul><li>双亲表示法</li></ul><p>双亲表示法</p><ul><li>整型一维数组：下标为当前结点，值为当前结点的双亲</li><li>结构体一维数组：结点结构可灵活设计：当前结点，当前结点的双亲，当前结点的孩子，当前结点的兄弟等</li></ul><p>链式存储：</p><ul><li>多重链表表示法</li><li>孩子表示法（改进：双亲孩子表示法）</li><li>孩子兄弟表示法&#x2F;二叉树表示法</li></ul><p>多重链表表示法：</p><ul><li>指针域数量&#x3D;树的度。结点结构：数据域，孩子指针域</li><li>指针域数量&#x3D;结点的度：结点结构：数据域，度域，孩子指针域</li></ul><p>孩子表示法：</p><ul><li>一维数组+单链表</li><li>一维数组，存储单链表的头指针。结点结构：数据域，头指针域</li><li>单链表，存储孩子结点。结点结构：数据域，孩子指针域</li></ul><p>孩子兄弟表示法：</p><ul><li>多重链表&#x2F;二叉链表。结点结构：数据域，第一个孩子指针域，右兄弟指针域</li></ul><hr><h2 id="树的常用性质"><a href="#树的常用性质" class="headerlink" title="树的常用性质"></a>树的常用性质</h2><ul><li>结点数-1&#x3D;分支数&#x2F;边&#x3D;所有结点的度数和</li></ul><hr><h1 id="二叉树的概念"><a href="#二叉树的概念" class="headerlink" title="二叉树的概念"></a>二叉树的概念</h1><h2 id="二叉树的基本形态"><a href="#二叉树的基本形态" class="headerlink" title="二叉树的基本形态"></a>二叉树的基本形态</h2><ul><li>空二叉树</li><li>只有一个根结点</li><li>根结点只有左子树</li><li>根结点只有右子树</li><li>根节点有左子树和右子树</li></ul><hr><h2 id="特殊的二叉树"><a href="#特殊的二叉树" class="headerlink" title="特殊的二叉树"></a>特殊的二叉树</h2><ul><li>斜二叉树：左斜二叉树，右斜二叉树</li><li>满二叉树</li><li>完全二叉树</li><li>二叉排序&#x2F;搜索树</li><li>平衡二叉树（AVL）</li><li>线索二叉树：前序线索二叉树，中序线索二叉树，后序线索二叉树</li><li>最优二叉树：带权路径长度最短</li><li>正则&#x2F;严格二叉树：无度为1的结点</li></ul><hr><h2 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h2><ul><li>叶子结点数&#x2F;度为0的结点数&#x3D;度为2的结点数+1：n0&#x3D;n2+1</li><li>第k（k&gt;&#x3D;1）层，该层最多有2的k-1次方个结点</li><li>深度&#x2F;高度为h，该树（满二叉树）最多有2的h次方-1个结点。-&gt;结点数为n，满二叉树的深度&#x2F;高度：[log以2为底的n]下取整+1或[log以2为底的(n+1)]上取整</li><li>完全二叉树依据从上到下，从左到右编号为1到n。当前结点的编号为i：</li><li>函数Catalan()&#x2F;卡特兰数：结点数为n，能构成的不同二叉树数：[C右上n右下2×n]组合÷(n+1)</li></ul><p>完全二叉树依据从上到下，从左到右编号为1到n。当前结点的编号为i：</p><ul><li>i&#x3D;1，当前结点为根节点，无双亲结点</li><li>i不等于或&gt;1时，双亲结点的编号：[i÷2]下取整</li><li>i不等于或&gt;1时，若i为偶数，双亲结点的编号：i÷2，当前结点是双亲结点的左孩子</li><li>i不等于或&gt;1时，若i为奇数，双亲结点的编号：(i-1)÷2，当前结点是双亲结点的右孩子</li><li>2×i&lt;&#x3D;n时，当前结点有左孩子结点，左孩子结点的编号：2×i</li><li>2×i&gt;n时，当前结点无左孩子结点</li><li>2×i+1&lt;&#x3D;n时，当前结点有右孩子结点，右孩子结点的编号：2×i+1</li><li>2×i+1&gt;n时，当前结点无右孩子结点</li><li>当前结点的层次&#x2F;深度：[log以2为底的i]下取整+1</li><li>树的深度&#x2F;高度：[log以2为底的n]下取整+1或[log以2为底的(n+1)]上取整</li><li>最后一个非叶子结点的编号：[n&#x2F;2]下取整</li></ul><p>完全二叉树依据从上到下，从左到右编号为0到n。当前结点的编号为i：</p><ul><li>双亲结点的编号：[i÷2]上取整-1</li><li>左孩子结点的编号：2×i+1</li><li>右孩子结点的编号：2×i+2</li></ul><hr><h2 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h2><ul><li>顺序存储：一维数组（依据完全二叉树）</li><li>链式存储：多重链表（灵活设计：二叉链表，三叉链表等）</li></ul><blockquote><p>重要性质：二叉链表的结点数为n，空指针域数：n+1</p></blockquote><blockquote><p>注意：树的顺序存储结构：数组下标反映结点的编号；二叉树的顺序存储结构依据完全二叉树编号、设计：数组下标反映结点的编号和结点间关系；</p></blockquote><hr><h1 id="二叉树的遍历和线索二叉树"><a href="#二叉树的遍历和线索二叉树" class="headerlink" title="二叉树的遍历和线索二叉树"></a>二叉树的遍历和线索二叉树</h1><h2 id="二叉树的遍历方式"><a href="#二叉树的遍历方式" class="headerlink" title="二叉树的遍历方式"></a>二叉树的遍历方式</h2><p>深度优先遍历：</p><ul><li>先序遍历（NLR）（递归法，迭代法）</li><li>中序遍历（LNR）（递归法，迭代法）</li><li>后序遍历（LRN）（递归法，迭代法）</li></ul><p>广度优先遍历：</p><ul><li>层次遍历（递归法，迭代法）</li></ul><hr><h2 id="二叉树遍历的性质"><a href="#二叉树遍历的性质" class="headerlink" title="二叉树遍历的性质"></a>二叉树遍历的性质</h2><ul><li>已知二叉树的<strong>前</strong>序遍历序列和<strong>中</strong>序遍历序列，<strong>可以</strong>唯一确定一颗二叉树</li><li>已知二叉树的<strong>后</strong>序遍历序列和<strong>中</strong>序遍历序列，<strong>可以</strong>唯一确定一颗二叉树</li><li>已知二叉树的<strong>前</strong>序遍历序列和<strong>后</strong>序遍历序列，<strong>不可以</strong>唯一确定一颗二叉树，可以唯一确定结点的祖先和子孙关系</li><li>已知二叉树的<strong>中</strong>序遍历序列和<strong>层</strong>序遍历序列，<strong>可以</strong>唯一确定一颗二叉树</li></ul><hr><h2 id="二叉树遍历的应用"><a href="#二叉树遍历的应用" class="headerlink" title="二叉树遍历的应用"></a>二叉树遍历的应用</h2><ul><li>查找</li><li>线索化二叉树</li><li>求深度&#x2F;高度：前序遍历，后序遍历，层序遍历</li><li>表达式求值：后序遍历</li><li>求路径：后序遍历</li><li>交换左右子树：后序遍历</li><li>求宽度：层序遍历</li><li>…</li></ul><blockquote><p>注意：一般求深度（从上到下）用前序遍历，求高度（从下到上）用后序遍历</p></blockquote><hr><h2 id="二叉树线索化的方式"><a href="#二叉树线索化的方式" class="headerlink" title="二叉树线索化的方式"></a>二叉树线索化的方式</h2><ul><li>前序遍历</li><li>中序遍历</li><li>后序遍历</li></ul><hr><h1 id="二叉树、树和森林"><a href="#二叉树、树和森林" class="headerlink" title="二叉树、树和森林"></a>二叉树、树和森林</h1><h2 id="树转换为二叉树的方式"><a href="#树转换为二叉树的方式" class="headerlink" title="树转换为二叉树的方式"></a>树转换为二叉树的方式</h2><p>依据：孩子兄弟表示法</p><p>过程：</p><ol><li>连接兄弟结点——兄弟表示</li><li>只保留每结点和第一个孩子结点的连接，断开和其他孩子结点的连接——孩子表示</li><li>调整层次结构（以根结点为轴心，顺时针旋转45°：孩子结点为左孩子，兄弟结点为右孩子）——二叉树层次结构表示</li></ol><hr><h2 id="二叉树转换为树的方式"><a href="#二叉树转换为树的方式" class="headerlink" title="二叉树转换为树的方式"></a>二叉树转换为树的方式</h2><p>依据：孩子兄弟表示法</p><p>过程：</p><ol><li>调整层次结构（以根结点为轴心，逆时针旋转45°：左孩子结点为第一个孩子，右孩子结点为其他孩子）——树层次结构表示</li><li>连接每结点和其他孩子结点（每结点的第一个孩子结点和其他孩子结点在同一层）——逆孩子表示</li><li>断开兄弟结点的连接——逆兄弟表示</li></ol><hr><h2 id="森林转换为二叉树的方式"><a href="#森林转换为二叉树的方式" class="headerlink" title="森林转换为二叉树的方式"></a>森林转换为二叉树的方式</h2><p>依据：孩子兄弟表示法</p><p>过程：</p><ol><li>树转换为二叉树——孩子兄弟表示</li><li>连接树根结点（第二颗树根结点为第一颗树根结点的右孩子，第三颗树根结点为第二颗树根结点的右孩子，以此类推）——森林&#x2F;多颗树-&gt;一颗二叉树</li></ol><hr><h2 id="二叉树转换为森林的方式"><a href="#二叉树转换为森林的方式" class="headerlink" title="二叉树转换为森林的方式"></a>二叉树转换为森林的方式</h2><p>依据：孩子兄弟表示法</p><p>过程：</p><ol><li>断开树根结点和右孩子结点的连接——一颗二叉树-&gt;森林&#x2F;多颗二叉树</li><li>二叉树转换为树——逆孩子兄弟表示</li></ol><p>注意：</p><ul><li>若二叉树根结点的右孩子不存在，转换为树；若存在，转换为森林</li><li>二叉树转换为的树和森林是唯一的，树和森林转换为的二叉树是不唯一的</li></ul><hr><h2 id="树遍历的方式"><a href="#树遍历的方式" class="headerlink" title="树遍历的方式"></a>树遍历的方式</h2><ul><li>先序遍历——与相应二叉树的先序遍历同</li><li>后序遍历——与相应二叉树的中序遍历同</li><li>层次遍历</li></ul><hr><h2 id="森林的遍历方式"><a href="#森林的遍历方式" class="headerlink" title="森林的遍历方式"></a>森林的遍历方式</h2><ul><li>先序遍历——与相应二叉树的先序遍历同</li><li>中&#x2F;后序遍历——与相应二叉树的中序遍历同</li></ul><hr><h1 id="树与二叉树的应用"><a href="#树与二叉树的应用" class="headerlink" title="树与二叉树的应用"></a>树与二叉树的应用</h1><h2 id="树与二叉树的应用-1"><a href="#树与二叉树的应用-1" class="headerlink" title="树与二叉树的应用"></a>树与二叉树的应用</h2><ul><li>哈&#x2F;赫夫曼树（Huffman）</li><li>并查集</li></ul><hr><h2 id="哈夫曼树的相关概念"><a href="#哈夫曼树的相关概念" class="headerlink" title="哈夫曼树的相关概念"></a>哈夫曼树的相关概念</h2><ul><li>结点间的路径：结点间的点数</li><li>结点间的路径长度：结点间的边数</li><li>树的路径长度：根结点到每个结点的路径长度的和</li><li>结点的带权路径长度：结点的权值×结点到根结点的路径长度</li><li>树的带权路径长度（WPL）：所有叶子结点的带权路径长度的和</li><li>哈夫曼树的构造</li><li>哈夫曼编码：最短前缀码</li></ul><p>哈夫曼树的构造：</p><ul><li>n个原结点，n-1个新结点，共2n-1个结点</li><li>哈夫曼树可能不唯一，树的带权路径长度（WPL）唯一</li></ul><p>注意：</p><ul><li>存在哈夫曼多叉树</li><li>常称哈夫曼二叉树为哈夫曼树</li><li>哈夫曼二叉树是最优二叉树、正则&#x2F;严格二叉树</li></ul><hr><h2 id="并查集顺序存储的双亲表示法"><a href="#并查集顺序存储的双亲表示法" class="headerlink" title="并查集顺序存储的双亲表示法"></a>并查集顺序存储的双亲表示法</h2><ul><li>一维数组</li><li>数组下标：结点名，唯一</li><li>数组值：结点的双亲结点名，不唯一，负数，绝对值为树中结点数</li></ul><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>“树与二叉树”学习提纲。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《2023版数据结构高分笔记》主编：率辉</li><li>《2023年计算机组成原理考研复习指导》组编：王道论坛</li><li>《大话数据结构》作者：程杰</li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git的基本原理和常用命令</title>
      <link href="/2022/09/03/Git%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%92%8C%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/09/03/Git%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%92%8C%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Git的基本原理和常用命令。</p><hr><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>Git是分布式版本控制系统：</p><ul><li>分布式：每台计算机都有完整的版本仓库，可无需联网工作，可无需服务端支持</li><li>版本控制：版本管理（旧版本和新版本），分支管理（其他分支和当前分支）</li><li>系统：软件</li></ul><hr><h1 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h1><h2 id="系统区域"><a href="#系统区域" class="headerlink" title="系统区域"></a>系统区域</h2><ul><li>用户文件夹：普通的文件夹</li><li>工作区（Workspace）：用户文件夹中，除.git文件夹外的其他文件</li><li>版本库：用户文件夹中的.git文件夹</li><li>暂存区（Stage&#x2F;Index）：.git文件夹中的index文件</li><li>本地仓库（Repository）：.git文件夹中，除index文件外的其他文件</li><li>远程仓库（Remote）：不在本地的文件（一般存储在代码托管平台：如Github或Gitee）</li></ul><h2 id="文件的系统区域流"><a href="#文件的系统区域流" class="headerlink" title="文件的系统区域流"></a>文件的系统区域流</h2><p>工作区-&gt;暂存区-&gt;本地仓库-&gt;远程仓库：</p><ul><li>git add：工作区-&gt;暂存区</li><li>git commit：暂存区-&gt;本地仓库</li><li>git push：本地仓库-&gt;远程仓库</li></ul><p>远程仓库-&gt;本地仓库-&gt;暂存区-&gt;工作区：</p><ul><li>git clone：远程仓库-&gt;用户文件夹</li><li>git pull：远程仓库-&gt;工作区</li><li>git fetch：远程仓库-&gt;本地仓库</li><li>git merge：本地仓库-&gt;工作区</li></ul><blockquote><p>git pull &#x3D; git fetch + git merge</p></blockquote><ul><li>git reset：本地仓库-&gt;暂存区</li><li>git restore：暂存区-&gt;工作区</li></ul><h2 id="工作区的文件状态"><a href="#工作区的文件状态" class="headerlink" title="工作区的文件状态"></a>工作区的文件状态</h2><ul><li>未跟踪（Untracked）：未上传过暂存区的文件，不参与版本控制</li><li>未修改（Unmodified）：上传过暂存区的文件，参与版本控制，和本地仓库的版本相同</li><li>已修改（Modified）：上传过暂存区的文件，参与版本控制，和本地仓库的版本不同</li><li>已暂存（Staged ），暂存区中的文件</li></ul><h2 id="文件的工作区状态流"><a href="#文件的工作区状态流" class="headerlink" title="文件的工作区状态流"></a>文件的工作区状态流</h2><ul><li>git add：未跟踪-&gt;已暂存</li><li>git rm：已暂存-&gt;未跟踪</li><li>修改文件：未修改-&gt;已修改</li><li>git checkout：已修改-&gt;未修改</li><li>git add：已修改-&gt;已暂存</li></ul><h2 id="映射关系"><a href="#映射关系" class="headerlink" title="映射关系"></a>映射关系</h2><ul><li>本地用户名和邮箱——远程用户名和邮箱</li><li>本地仓库——远程仓库</li><li>本地分支——远程分支</li></ul><h2 id="映射关系的建立"><a href="#映射关系的建立" class="headerlink" title="映射关系的建立"></a>映射关系的建立</h2><p>本地用户名和邮箱——远程用户名和邮箱：</p><ol><li>在代码托管平台绑定邮箱</li><li>git config</li></ol><p>本地仓库——远程仓库：</p><ul><li>git remote</li><li>git clone</li></ul><p>本地分支——远程分支：</p><ul><li>git pull &#x3D; git fetch + git merge</li><li>git push</li></ul><h2 id="特殊文件"><a href="#特殊文件" class="headerlink" title="特殊文件"></a>特殊文件</h2><ul><li>HEAD：指针，在本地指向：HEAD-&gt;当前分支-&gt;当前分支最近提交的版本</li><li>index：暂存区</li></ul><hr><h1 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h1><h2 id="用户配置流程"><a href="#用户配置流程" class="headerlink" title="用户配置流程"></a>用户配置流程</h2><ol><li>在代码托管平台绑定邮箱</li><li>git config –list</li><li>git config –global user.name &lt;用户名&gt;</li><li>git config –global user.email &lt;邮箱&gt;</li></ol><blockquote><p>作用：记录用户操作信息</p></blockquote><blockquote><p>本地用户名和邮箱——远程用户名和邮箱的映射无严格关系：<br>未在代码托管平台绑定邮箱，有本地配置，可操作，不显示代码托管平台的账号信息<br>在代码托管平台绑定邮箱，有本地配置，可操作，显示代码托管平台的账号信息</p></blockquote><blockquote><p>初始化（下载和安装）Git后，需进行用户配置流程<br>再使用Git时，一般无需进行用户配置流程</p></blockquote><h2 id="初始化并使用流程"><a href="#初始化并使用流程" class="headerlink" title="初始化并使用流程"></a>初始化并使用流程</h2><ol><li>创建并初始化远程仓库</li><li>创建用户文件夹</li><li>git init</li><li>git remote add &lt;本地对远程仓库的别名：一般为origin&gt; &lt;远程仓库的地址&gt;</li><li>git pull &lt;本地对远程仓库的别名：一般为origin&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</li><li>基本上传流程，回退操作，分支开发流程，分支合并流程</li></ol><h2 id="克隆并使用流程"><a href="#克隆并使用流程" class="headerlink" title="克隆并使用流程"></a>克隆并使用流程</h2><ol><li>创建并初始化远程仓库</li><li>git clone &lt;远程仓库的地址&gt;</li><li>基本上传流程，回退操作，分支开发流程，分支合并流程</li></ol><h2 id="基本上传流程"><a href="#基本上传流程" class="headerlink" title="基本上传流程"></a>基本上传流程</h2><ol><li>创建或修改文件</li><li>git add .（注意有“.”）</li><li>git commit -m &lt;说明&gt;</li><li>git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</li></ol><h2 id="回退操作"><a href="#回退操作" class="headerlink" title="回退操作"></a>回退操作</h2><ul><li>git reset –soft &lt;版本号&gt;（使用git log查看版本号）</li><li>git checkout – &lt;文件名&gt;</li><li>git rm –cached &lt;文件名&gt;</li></ul><p>提示：</p><ul><li>单人开发：本地仓库版本在远程仓库版本的上游，无法拉取远程仓库版本。在远程仓库的版本必在本地仓库，若需要远程仓库版本，获取本地仓库版本即可</li><li>多人开发：是更新而不是回退操作，进行分支开发流程，分支合并流程</li></ul><h2 id="分支开发流程"><a href="#分支开发流程" class="headerlink" title="分支开发流程"></a>分支开发流程</h2><ol><li>在代码托管平台创建其他分支或已有其他分支</li><li>git branch &lt;分支名&gt;</li><li>git switch &lt;分支名&gt;</li><li>git pull &lt;本地对远程仓库的别名：一般为origin&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; </li><li>基本上传流程</li></ol><h2 id="分支合并流程"><a href="#分支合并流程" class="headerlink" title="分支合并流程"></a>分支合并流程</h2><ol><li>被合并分支进行基本上传流程</li><li>合并分支进行基本上传流程</li><li>git switch &lt;合并分支名&gt;</li><li>git merge &lt;被合并分支名&gt;</li><li>打开文件，查看冲突内容</li><li>修改文件，解决冲突内容</li><li>基本上传流程</li><li>git branch -d &lt;被合并分支名&gt;</li></ol><p><strong>理解：</strong></p><ul><li>假设：合并分支为master，被合并分支为feature</li><li>原先：HEAD-&gt;master-&gt;最近提交点A</li><li>git branch feature：feature-&gt;A</li><li>git switch feature：HEAD-&gt;feature-&gt;A</li></ul><p>情况一：</p><ul><li>修改feature的文件</li><li>若feature提交：HEAD-&gt;feature-&gt;最近提交点B</li><li>git merge feature：HEAD-&gt;master-&gt;最近提交点B，master的文件更新为feature的文件</li><li>因为A-&gt;B，B是A的上游，A更新为B，不会发生冲突</li></ul><p>情况二：</p><ul><li>修改feature的文件</li><li>若feature提交：HEAD-&gt;feature-&gt;最近提交点B</li><li>修改master的文件</li><li>若master提交：HEAD-&gt;master-&gt;最近提交点C</li><li>git merge feature：HEAD-&gt;master-&gt;最近提交点D，feature-&gt;最近提交点D</li><li>因为A-&gt;B和A-&gt;C互不相交，可能发生冲突。合并后为D，有A-&gt;B-&gt;D和A-&gt;C-&gt;D</li></ul><hr><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="用户配置流程-1"><a href="#用户配置流程-1" class="headerlink" title="用户配置流程"></a>用户配置流程</h2><ul><li>git config –list：查看配置信息</li><li>git config –global user.name &lt;用户名&gt;：配置全局用户名</li><li>git config –global user.email &lt;邮箱&gt;：配置全局邮箱</li><li>git config user.name &lt;用户名&gt;：配置当前用户名</li><li>git config user.email &lt;邮箱&gt;：配置当前邮箱</li></ul><h2 id="初始化并使用流程-1"><a href="#初始化并使用流程-1" class="headerlink" title="初始化并使用流程"></a>初始化并使用流程</h2><ul><li>git init：用户文件夹-&gt;工作区+版本库</li><li>git remote add &lt;本地对远程仓库的别名：一般为origin&gt; &lt;远程仓库的地址&gt;：本地仓库——远程仓库</li><li>git remote rm &lt;本地对远程仓库的别名：一般为origin&gt;：删除本地仓库——远程仓库映射</li><li>git pull &lt;本地对远程仓库的别名：一般为origin&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;：远程仓库的远程分支-&gt;本地仓库的本地分支</li></ul><h2 id="克隆并使用流程-1"><a href="#克隆并使用流程-1" class="headerlink" title="克隆并使用流程"></a>克隆并使用流程</h2><ul><li>git clone &lt;远程仓库的地址&gt;：远程仓库-&gt;用户文件夹</li><li>git clone &lt;远程仓库的地址&gt; &lt;用户文件夹名&gt;：远程仓库-&gt;用户文件夹，指定用户文件夹名</li></ul><h2 id="基本上传流程-1"><a href="#基本上传流程-1" class="headerlink" title="基本上传流程"></a>基本上传流程</h2><ul><li>git add .（注意有“.”）：工作区-&gt;暂存区</li><li>git commit -m &lt;说明&gt;：暂存区-&gt;本地仓库</li><li>git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;：本地仓库的本地分支-&gt;远程仓库的远程分支</li></ul><h2 id="回退操作-1"><a href="#回退操作-1" class="headerlink" title="回退操作"></a>回退操作</h2><ul><li>git reset –soft &lt;版本号&gt;（使用git log查看版本号）：本地仓库-&gt;暂存区</li><li>git checkout – &lt;文件名&gt;：暂存区-&gt;工作区</li><li>git rm –cached &lt;文件名&gt;：已暂存-&gt;未跟踪</li></ul><h2 id="分支开发流程-1"><a href="#分支开发流程-1" class="headerlink" title="分支开发流程"></a>分支开发流程</h2><ul><li>git branch：查看分支</li><li>git branch &lt;分支名&gt;：创建分支</li><li>git switch &lt;分支名&gt;：切换分支</li><li>ls：查看当前分支的工作区文件</li></ul><h2 id="分支合并流程-1"><a href="#分支合并流程-1" class="headerlink" title="分支合并流程"></a>分支合并流程</h2><ul><li>git merge &lt;被合并分支名&gt;：当前分支合并指定分支</li><li>git branch -d &lt;被合并分支名&gt;：删除分支</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>git status：查看状态</li><li>git status -s：查看精简的状态</li><li>git diff：比较工作区和暂存区文件的不同</li><li>git log：查看日志</li><li>git blame &lt;文件名&gt;：查看文件的日志</li><li>git tag：设置标签</li></ul><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Git的基本原理和常用命令。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.liaoxuefeng.com/wiki/896043488029600">Git教程 - 廖雪峰的官方网站 (liaoxuefeng.com)</a>——教程</li><li><a href="https://www.runoob.com/git/git-tutorial.html">Git 教程 | 菜鸟教程 (runoob.com)</a>——教程</li><li><a href="https://blog.csdn.net/LXX_YYT/article/details/123853883">Git:工作原理(核心)_LXX_YYT的博客-CSDN博客_git工作原理</a>——系统区域图，文件的系统区域流图</li><li><a href="https://www.php.cn/tool/git/490641.html">深入分析Git基本工作原理-git-PHP中文网</a>——教程</li><li><a href="https://blog.csdn.net/Forever_wj/article/details/120383949">Git之深入解析reset命令原理以及与checkout命令的区别_╰つ栺尖篴夢ゞ的博客-CSDN博客_git reset原理</a>——reset命令的原理</li><li><a href="https://zhuanlan.zhihu.com/p/66506485">Git原理及使用 - 知乎 (zhihu.com)</a>——详尽原理</li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 开发和管理工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发和管理工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树和线索二叉树的C++语言描述实现模板</title>
      <link href="/2022/08/31/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84C++%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E5%AE%9E%E7%8E%B0%E6%A8%A1%E6%9D%BF/"/>
      <url>/2022/08/31/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84C++%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E5%AE%9E%E7%8E%B0%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>数据结构中二叉树和线索二叉树的C++语言描述实现模板，有详细的步骤解析及使用示例。</p><hr><h1 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h1><ul><li><a href="https://github.com/yezhening/Programming-examples">yezhening&#x2F;Programming-examples: 编程实例 (github.com)</a></li><li><a href="https://gitee.com/yezhening/Programming-examples">Programming-examples: 编程实例 (gitee.com)</a></li></ul><hr><h1 id="bTree-cpp（二叉树）"><a href="#bTree-cpp（二叉树）" class="headerlink" title="bTree.cpp（二叉树）"></a>bTree.cpp（二叉树）</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件————————————————————</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//命名空间</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型————————————————————</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ELEM_TYPE; <span class="comment">//数据的（数据）类型 依据数据的实际类型定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体</span></span><br><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="comment">//结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BTNode</span></span><br><span class="line">&#123;</span><br><span class="line">    ELEM_TYPE data;        <span class="comment">//数据</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BTNode</span> *lChild; <span class="comment">//指向左孩子结点的指针</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BTNode</span> *rChild; <span class="comment">//指向右孩子结点的指针</span></span><br><span class="line">&#125; BTNode;</span><br><span class="line"><span class="comment">// struct BTNode：结构体数据类型的名称</span></span><br><span class="line"><span class="comment">//如创建一个结点的语句：struct BTNode node;</span></span><br><span class="line"><span class="comment">//若结构体数据类型内，存在指向该结构体的指针数据类型，则必须完整命名结构体数据类型的名称</span></span><br><span class="line"><span class="comment">//如结点结构体BTNode内，存在指向该结构体的指针数据类型lChild和rChild，则命名语句为：typedef struct BTNode而不是typedef struct</span></span><br><span class="line"><span class="comment">// &#125;BTNode;：typedef给结构体数据类型起的别名，可简化语句</span></span><br><span class="line"><span class="comment">//如创建一个结点的语句：BTNode node;</span></span><br><span class="line"><span class="comment">//结构体数据类型的名称和别名尽量一致，以方便记忆、使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数声明————————————————————</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_example</span><span class="params">()</span></span>;                     <span class="comment">//使用示例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createBTree</span><span class="params">(<span class="keyword">struct</span> BTNode *&amp;root)</span></span>; <span class="comment">//创建 前序法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrderTraverse</span><span class="params">(<span class="keyword">struct</span> BTNode *root)</span></span>;                                              <span class="comment">//前序遍历    递归法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrderTraverse</span><span class="params">(<span class="keyword">struct</span> BTNode *root)</span></span>;                                               <span class="comment">//中序遍历    递归法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postOrderTraverse</span><span class="params">(<span class="keyword">struct</span> BTNode *root)</span></span>;                                             <span class="comment">//后序遍历    递归法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">levelOrderTraverse</span><span class="params">(<span class="keyword">struct</span> BTNode *root, <span class="type">int</span> layer, vector&lt;vector&lt;ELEM_TYPE&gt;&gt; &amp;res)</span></span>; <span class="comment">//层序遍历   递归法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrderTraverse2</span><span class="params">(<span class="keyword">struct</span> BTNode *root)</span></span>;   <span class="comment">//前序遍历  迭代法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrderTraverse2</span><span class="params">(<span class="keyword">struct</span> BTNode *root)</span></span>;    <span class="comment">//中序遍历  迭代法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postOrderTraverse2</span><span class="params">(<span class="keyword">struct</span> BTNode *root)</span></span>;  <span class="comment">//后序遍历  迭代法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">levelOrderTraverse2</span><span class="params">(<span class="keyword">struct</span> BTNode *root)</span></span>; <span class="comment">//层序遍历   迭代法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getDepth</span><span class="params">(<span class="keyword">struct</span> BTNode *root)</span></span>; <span class="comment">//获取深度/高度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数定义————————————————————</span></span><br><span class="line"><span class="comment">//使用示例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_example</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BTNode</span> *root; <span class="comment">//根结点指针</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">createBTree</span>(root); <span class="comment">//创建 前序法</span></span><br><span class="line">    <span class="comment">//构造三层二叉树：</span></span><br><span class="line">    <span class="comment">//第一层：1</span></span><br><span class="line">    <span class="comment">//第二层：2，3</span></span><br><span class="line">    <span class="comment">//第三层：-1，-1，-1，4</span></span><br><span class="line">    <span class="comment">//输入数据：1，2，-1，-1，3，-1，4，-1，-1</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">preOrderTraverse</span>(root); <span class="comment">//前序遍历  递归法   输出：1，2，3，4</span></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">inOrderTraverse</span>(root); <span class="comment">//中序遍历   递归法   输出：2，1，3，4</span></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">postOrderTraverse</span>(root); <span class="comment">//后序遍历 递归法    输出：2，4，3，1</span></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;ELEM_TYPE&gt;&gt; res; <span class="comment">//层序遍历 递归法 输出：1，2，3，4</span></span><br><span class="line">    <span class="built_in">levelOrderTraverse</span>(root, <span class="number">0</span>, res);</span><br><span class="line">    <span class="keyword">for</span> (vector&lt;ELEM_TYPE&gt; vec : res)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (ELEM_TYPE data : vec)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">preOrderTraverse2</span>(root); <span class="comment">//前序遍历  迭代法   输出：1，2，3，4</span></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">inOrderTraverse2</span>(root); <span class="comment">//中序遍历  迭代法    输出：2，1，3，4</span></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">postOrderTraverse2</span>(root); <span class="comment">//后序遍历  迭代法    输出：2，4，3，1</span></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">levelOrderTraverse2</span>(root); <span class="comment">//层序遍历 迭代法 输出：1，2，3，4</span></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">getDepth</span>(root) &lt;&lt; endl; <span class="comment">//获取深度/高度 输出：3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建 前序法</span></span><br><span class="line"><span class="comment">//时间复杂度：O(n)。n为数据规模</span></span><br><span class="line"><span class="comment">//空间复杂度：O(n)。n为数据规模</span></span><br><span class="line"><span class="comment">//空间复杂度：递归调用栈的规模/树的深度/高度：</span></span><br><span class="line"><span class="comment">//最好：[log以2为底的n]下取整+1或[log以2为底的(n+1)]上取整。n为数据规模</span></span><br><span class="line"><span class="comment">//最坏：n。n为数据规模</span></span><br><span class="line"><span class="comment">//注意：参数使用*&amp;，指向指针的引用数据类型</span></span><br><span class="line"><span class="comment">//若只使用*：指针数据类型，在函数体中并未进行解引用调用修改*root的值，使用malloc()修改的是root的值</span></span><br><span class="line"><span class="comment">//所以是值拷贝，函数返回后数据丢失。地址拷贝需要引用数据类型的配合</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createBTree</span><span class="params">(<span class="keyword">struct</span> BTNode *&amp;root)</span> <span class="comment">//参数：根结点指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ELEM_TYPE value = <span class="number">0</span>; <span class="comment">//值</span></span><br><span class="line">    cin &gt;&gt; value;        <span class="comment">//获取输入值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="number">-1</span>) <span class="comment">//空树  约定值为-1时无结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        root = <span class="literal">nullptr</span>; <span class="comment">//根结点指针指向空</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//非空树</span></span><br><span class="line">    &#123;</span><br><span class="line">        root = (<span class="keyword">struct</span> BTNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> BTNode)); <span class="comment">//创建根结点，根结点指针指向根结点</span></span><br><span class="line"></span><br><span class="line">        root-&gt;data = value;        <span class="comment">//初始化根结点的数据域</span></span><br><span class="line">        <span class="built_in">createBTree</span>(root-&gt;lChild); <span class="comment">//递归构造左子树</span></span><br><span class="line">        <span class="built_in">createBTree</span>(root-&gt;rChild); <span class="comment">//递归构造右子树</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前序遍历  递归法</span></span><br><span class="line"><span class="comment">//时间复杂度：O(n)。n为数据规模</span></span><br><span class="line"><span class="comment">//空间复杂度：O(n)。n为数据规模</span></span><br><span class="line"><span class="comment">//空间复杂度：递归调用栈的规模/树的深度/高度：</span></span><br><span class="line"><span class="comment">//最好：[log以2为底的n]下取整+1或[log以2为底的(n+1)]上取整。n为数据规模</span></span><br><span class="line"><span class="comment">//最坏：n。n为数据规模</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrderTraverse</span><span class="params">(<span class="keyword">struct</span> BTNode *root)</span> <span class="comment">//参数：根结点指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="comment">//空树</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//非空树</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; root-&gt;data;             <span class="comment">//输出数据</span></span><br><span class="line">        <span class="built_in">preOrderTraverse</span>(root-&gt;lChild); <span class="comment">//前序遍历左子树</span></span><br><span class="line">        <span class="built_in">preOrderTraverse</span>(root-&gt;rChild); <span class="comment">//前序遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历  递归法</span></span><br><span class="line"><span class="comment">//时间复杂度：O(n)。n为数据规模</span></span><br><span class="line"><span class="comment">//空间复杂度：O(n)。n为数据规模</span></span><br><span class="line"><span class="comment">//空间复杂度：递归调用栈的规模/树的深度/高度：</span></span><br><span class="line"><span class="comment">//最好：[log以2为底的n]下取整+1或[log以2为底的(n+1)]上取整。n为数据规模</span></span><br><span class="line"><span class="comment">//最坏：n。n为数据规模</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrderTraverse</span><span class="params">(<span class="keyword">struct</span> BTNode *root)</span> <span class="comment">//参数：根结点指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="comment">//空树</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//非空树</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">inOrderTraverse</span>(root-&gt;lChild); <span class="comment">//中序遍历左子树</span></span><br><span class="line">        cout &lt;&lt; root-&gt;data;            <span class="comment">//输出数据</span></span><br><span class="line">        <span class="built_in">inOrderTraverse</span>(root-&gt;rChild); <span class="comment">//中序遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历  递归法</span></span><br><span class="line"><span class="comment">//时间复杂度：O(n)。n为数据规模</span></span><br><span class="line"><span class="comment">//空间复杂度：O(n)。n为数据规模</span></span><br><span class="line"><span class="comment">//空间复杂度：递归调用栈的规模/树的深度/高度：</span></span><br><span class="line"><span class="comment">//最好：[log以2为底的n]下取整+1或[log以2为底的(n+1)]上取整。n为数据规模</span></span><br><span class="line"><span class="comment">//最坏：n。n为数据规模</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postOrderTraverse</span><span class="params">(<span class="keyword">struct</span> BTNode *root)</span> <span class="comment">//参数：根结点指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="comment">//空树</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//非空树</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">postOrderTraverse</span>(root-&gt;lChild); <span class="comment">//后序遍历左子树</span></span><br><span class="line">        <span class="built_in">postOrderTraverse</span>(root-&gt;rChild); <span class="comment">//后序遍历右子树</span></span><br><span class="line">        cout &lt;&lt; root-&gt;data;              <span class="comment">//输出数据</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//层序遍历  递归法</span></span><br><span class="line"><span class="comment">//时间复杂度：O(n)。n为数据规模</span></span><br><span class="line"><span class="comment">//空间复杂度：O(n)。n为数据规模</span></span><br><span class="line"><span class="comment">//空间复杂度：递归调用栈的规模/树的深度/高度：</span></span><br><span class="line"><span class="comment">//最好：[log以2为底的n]下取整+1或[log以2为底的(n+1)]上取整。n为数据规模</span></span><br><span class="line"><span class="comment">//最坏：n。n为数据规模</span></span><br><span class="line"><span class="comment">//空间复杂度：存储结点数据的二维向量：n。n为数据规模</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">levelOrderTraverse</span><span class="params">(<span class="keyword">struct</span> BTNode *root, <span class="type">int</span> layer, vector&lt;vector&lt;ELEM_TYPE&gt;&gt; &amp;res)</span> <span class="comment">//参数：根结点指针，层次，记录结点数据的二维向量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="comment">//空树</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//非空树</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//一维向量vec记录一层中，从左到右结点的数据</span></span><br><span class="line">        <span class="comment">//二维向量res记录从上到下每一层的vec</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为向量大小从0开始，约定：层次从0开始，根结点为第0层，根结点的孩子结点为第1层，依次类推</span></span><br><span class="line">        <span class="comment">//每遍历到新的层次，当前层次layer等于res的大小，如：</span></span><br><span class="line">        <span class="comment">//第一层：layer为0，res.size()为0</span></span><br><span class="line">        <span class="comment">//第二层：layer为1，res已记录第0层的vec，res.size()为1</span></span><br><span class="line">        <span class="comment">//每遍历到新的层次，创建vec，res记录vec</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//依据layer定位res中的vec，记录结点的数据</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//核心思想：</span></span><br><span class="line">        <span class="comment">//本质：前序递归遍历，需要递归访问根结点的左子树和右子树</span></span><br><span class="line">        <span class="comment">//访问结点顺序：中-&gt;左-&gt;右，处理结点顺序：每层的左-&gt;右</span></span><br><span class="line">        <span class="comment">//所以需要结合vec、layer和res记录层次遍历结点的数据</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (layer == res.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;ELEM_TYPE&gt; vec;</span><br><span class="line">            res.<span class="built_in">push_back</span>(vec);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res[layer].<span class="built_in">push_back</span>(root-&gt;data);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;lChild != <span class="literal">nullptr</span>) <span class="comment">//根结点的左孩子结点不为空</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">levelOrderTraverse</span>(root-&gt;lChild, layer + <span class="number">1</span>, res);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;rChild != <span class="literal">nullptr</span>) <span class="comment">//根结点的右孩子结点不为空</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">levelOrderTraverse</span>(root-&gt;rChild, layer + <span class="number">1</span>, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前序遍历  迭代法</span></span><br><span class="line"><span class="comment">//时间复杂度：O(n)。n为数据规模</span></span><br><span class="line"><span class="comment">//空间复杂度：O(n)。n为数据规模/用户栈规模</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrderTraverse2</span><span class="params">(<span class="keyword">struct</span> BTNode *root)</span> <span class="comment">//参数：根结点指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> maxSize = <span class="number">10</span>;             <span class="comment">//指向结点的指针的向量/栈的初始化大小    大小&gt;=结点数</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">struct</span> BTNode *&gt; <span class="title">stack</span><span class="params">(maxSize)</span></span>; <span class="comment">//指向结点的指针的向量/栈</span></span><br><span class="line">    <span class="type">int</span> top = <span class="number">-1</span>;                           <span class="comment">//指向栈顶结点的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BTNode</span> *visitNode = <span class="literal">nullptr</span>; <span class="comment">//指向访问结点的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="comment">//空树</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//非空树</span></span><br><span class="line">    &#123;</span><br><span class="line">        ++top;</span><br><span class="line">        stack[top] = root; <span class="comment">//根结点入栈</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (top != <span class="number">-1</span>) <span class="comment">//栈不为空时，循环</span></span><br><span class="line">        &#123;</span><br><span class="line">            visitNode = stack[top]; <span class="comment">//指向访问结点的指针指向栈顶结点</span></span><br><span class="line">            --top;                  <span class="comment">//栈顶结点出栈</span></span><br><span class="line"></span><br><span class="line">            cout &lt;&lt; visitNode-&gt;data; <span class="comment">//访问结点的数据</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (visitNode-&gt;rChild != <span class="literal">nullptr</span>) <span class="comment">//右孩子结点不为空</span></span><br><span class="line">            &#123;</span><br><span class="line">                ++top;</span><br><span class="line">                stack[top] = visitNode-&gt;rChild; <span class="comment">//右孩子结点入栈</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (visitNode-&gt;lChild != <span class="literal">nullptr</span>) <span class="comment">//左孩子结点不为空</span></span><br><span class="line">            &#123;</span><br><span class="line">                ++top;</span><br><span class="line">                stack[top] = visitNode-&gt;lChild; <span class="comment">//左孩子结点入栈</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历  迭代法</span></span><br><span class="line"><span class="comment">//时间复杂度：O(n)。n为数据规模</span></span><br><span class="line"><span class="comment">//空间复杂度：O(n)。n为数据规模/用户栈规模</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrderTraverse2</span><span class="params">(<span class="keyword">struct</span> BTNode *root)</span> <span class="comment">//参数：根结点指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> maxSize = <span class="number">10</span>;             <span class="comment">//指向结点的指针的向量/栈的初始化大小    大小&gt;=结点数</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">struct</span> BTNode *&gt; <span class="title">stack</span><span class="params">(maxSize)</span></span>; <span class="comment">//指向结点的指针的向量/栈</span></span><br><span class="line">    <span class="type">int</span> top = <span class="number">-1</span>;                           <span class="comment">//指向栈顶结点的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BTNode</span> *visitNode = root; <span class="comment">//指向访问结点的指针    指向根结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="comment">//空树</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//非空树</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//注意：栈顶结点/根结点出栈并访问后，还没有访问右子树</span></span><br><span class="line">        <span class="comment">//可能存在栈空，右子树不为空的情况，需要继续遍历/循环</span></span><br><span class="line">        <span class="comment">//指向访问结点的指针指向栈顶结点/根结点的右孩子结点，若指针不空，则存在右子树，需要继续遍历/循环</span></span><br><span class="line">        <span class="keyword">while</span> (top != <span class="number">-1</span> || visitNode != <span class="literal">nullptr</span>) <span class="comment">//栈不为空或指向访问结点的指针不为空时，循环</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//左孩子结点循环入栈</span></span><br><span class="line">            <span class="keyword">while</span> (visitNode != <span class="literal">nullptr</span>) <span class="comment">//指向访问结点的指针不为空</span></span><br><span class="line">            &#123;</span><br><span class="line">                ++top;</span><br><span class="line">                stack[top] = visitNode; <span class="comment">//指向访问结点的指针入栈</span></span><br><span class="line"></span><br><span class="line">                visitNode = visitNode-&gt;lChild; <span class="comment">//指向访问结点的指针指向访问结点的左孩子结点</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (top != <span class="number">-1</span>) <span class="comment">//栈不为空</span></span><br><span class="line">            &#123;</span><br><span class="line">                visitNode = stack[top]; <span class="comment">//指向访问结点的指针指向栈顶结点</span></span><br><span class="line">                --top;                  <span class="comment">//栈顶结点出栈</span></span><br><span class="line"></span><br><span class="line">                cout &lt;&lt; visitNode-&gt;data; <span class="comment">//访问结点的数据</span></span><br><span class="line"></span><br><span class="line">                visitNode = visitNode-&gt;rChild; <span class="comment">//指向访问结点的指针指向栈顶结点/根结点的右孩子结点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历  迭代法</span></span><br><span class="line"><span class="comment">//时间复杂度：O(n)。n为数据规模</span></span><br><span class="line"><span class="comment">//空间复杂度：O(n)。n为数据规模/用户栈规模</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postOrderTraverse2</span><span class="params">(<span class="keyword">struct</span> BTNode *root)</span> <span class="comment">//参数：根结点指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//核心思想：</span></span><br><span class="line">    <span class="comment">//反前序遍历：中-&gt;右-&gt;左</span></span><br><span class="line">    <span class="comment">//逆后序遍历 = 反前序遍历</span></span><br><span class="line">    <span class="comment">//后序遍历 = 逆逆后序遍历-&gt;反前序遍历中，访问结点出栈1、入栈2再出栈2的顺序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> maxSize = <span class="number">10</span>;              <span class="comment">//指向结点的指针的向量/栈的初始化大小    大小&gt;=结点数</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">struct</span> BTNode *&gt; <span class="title">stack1</span><span class="params">(maxSize)</span></span>; <span class="comment">//指向结点的指针的向量/栈1 反前序遍历使用</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">struct</span> BTNode *&gt; <span class="title">stack2</span><span class="params">(maxSize)</span></span>; <span class="comment">//指向结点的指针的向量/栈2 逆逆后序遍历使用</span></span><br><span class="line">    <span class="type">int</span> top1 = <span class="number">-1</span>;                           <span class="comment">//指向栈1顶结点的指针1</span></span><br><span class="line">    <span class="type">int</span> top2 = <span class="number">-1</span>;                           <span class="comment">//指向栈2顶结点的指针2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BTNode</span> *visitNode = <span class="literal">nullptr</span>; <span class="comment">//指向访问结点的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="comment">//空树</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//非空树</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//反前序遍历过程</span></span><br><span class="line">        ++top1;</span><br><span class="line">        stack1[top1] = root; <span class="comment">//根结点入栈1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (top1 != <span class="number">-1</span>) <span class="comment">//栈1不为空时，循环</span></span><br><span class="line">        &#123;</span><br><span class="line">            visitNode = stack1[top1]; <span class="comment">//指向访问结点的指针指向栈1顶结点</span></span><br><span class="line">            --top1;                   <span class="comment">//栈1顶结点出栈1</span></span><br><span class="line"></span><br><span class="line">            ++top2;</span><br><span class="line">            stack2[top2] = visitNode; <span class="comment">//访问结点入栈2</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//反前序遍历与前序遍历操作相反</span></span><br><span class="line">            <span class="keyword">if</span> (visitNode-&gt;lChild != <span class="literal">nullptr</span>) <span class="comment">//左孩子结点不为空</span></span><br><span class="line">            &#123;</span><br><span class="line">                ++top1;</span><br><span class="line">                stack1[top1] = visitNode-&gt;lChild; <span class="comment">//左孩子结点入栈1</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (visitNode-&gt;rChild != <span class="literal">nullptr</span>) <span class="comment">//右孩子结点不为空</span></span><br><span class="line">            &#123;</span><br><span class="line">                ++top1;</span><br><span class="line">                stack1[top1] = visitNode-&gt;rChild; <span class="comment">//右孩子结点入栈1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//逆逆后序遍历过程</span></span><br><span class="line">        <span class="keyword">while</span> (top2 != <span class="number">-1</span>) <span class="comment">//栈2不为空时，循环</span></span><br><span class="line">        &#123;</span><br><span class="line">            visitNode = stack2[top2]; <span class="comment">//指向访问结点的指针指向栈2顶结点</span></span><br><span class="line">            --top2;                   <span class="comment">//栈2顶结点出栈2</span></span><br><span class="line"></span><br><span class="line">            cout &lt;&lt; visitNode-&gt;data; <span class="comment">//访问结点的数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//层序遍历  迭代法</span></span><br><span class="line"><span class="comment">//时间复杂度：O(n)。n为数据规模</span></span><br><span class="line"><span class="comment">//空间复杂度：O(n)。n为数据规模</span></span><br><span class="line"><span class="comment">//空间复杂度：指向结点的指针的向量/循环队列的大小</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">levelOrderTraverse2</span><span class="params">(<span class="keyword">struct</span> BTNode *root)</span> <span class="comment">//参数：根结点指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> maxSize = <span class="number">10</span>;             <span class="comment">//指向结点的指针的向量/循环队列的初始化大小    大小尽量&gt;=结点数</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">struct</span> BTNode *&gt; <span class="title">queue</span><span class="params">(maxSize)</span></span>; <span class="comment">//指向结点的指针的向量/循环队列</span></span><br><span class="line">    <span class="type">int</span> front = <span class="number">0</span>;                          <span class="comment">//指向队列头结点的指针</span></span><br><span class="line">    <span class="type">int</span> rear = <span class="number">0</span>;                           <span class="comment">//指向队列尾结点的下一结点的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BTNode</span> *visitNode = <span class="literal">nullptr</span>; <span class="comment">//指向访问结点的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="comment">//空树</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//非空树</span></span><br><span class="line">    &#123;</span><br><span class="line">        queue[rear] = root; <span class="comment">//根结点入队</span></span><br><span class="line">        rear = (rear + <span class="number">1</span>) % maxSize;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (front != rear) <span class="comment">//队列不为空，循环</span></span><br><span class="line">        &#123;</span><br><span class="line">            visitNode = queue[front];      <span class="comment">//指向访问结点的指针指向队列头结点</span></span><br><span class="line">            front = (front + <span class="number">1</span>) % maxSize; <span class="comment">//队列头结点出队</span></span><br><span class="line"></span><br><span class="line">            cout &lt;&lt; visitNode-&gt;data; <span class="comment">//访问结点的数据</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (visitNode-&gt;lChild != <span class="literal">nullptr</span>) <span class="comment">//左子树不为空</span></span><br><span class="line">            &#123;</span><br><span class="line">                queue[rear] = visitNode-&gt;lChild; <span class="comment">//左子树的根结点入队</span></span><br><span class="line">                rear = (rear + <span class="number">1</span>) % maxSize;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (visitNode-&gt;rChild != <span class="literal">nullptr</span>) <span class="comment">//右子树不为空</span></span><br><span class="line">            &#123;</span><br><span class="line">                queue[rear] = visitNode-&gt;rChild; <span class="comment">//右子树的根结点入队</span></span><br><span class="line">                rear = (rear + <span class="number">1</span>) % maxSize;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取深度/高度</span></span><br><span class="line"><span class="comment">//本质：后序遍历</span></span><br><span class="line"><span class="comment">//时间复杂度：O(n)。n为数据规模</span></span><br><span class="line"><span class="comment">//空间复杂度：O(n)。n为数据规模</span></span><br><span class="line"><span class="comment">//空间复杂度：递归调用栈的规模/树的深度/高度：</span></span><br><span class="line"><span class="comment">//最好：[log以2为底的n]下取整+1或[log以2为底的(n+1)]上取整。n为数据规模</span></span><br><span class="line"><span class="comment">//最坏：n。n为数据规模</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getDepth</span><span class="params">(<span class="keyword">struct</span> BTNode *root)</span> <span class="comment">//参数：根结点指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> lDepth = <span class="number">0</span>; <span class="comment">//左子树的深度</span></span><br><span class="line">    <span class="type">int</span> rDepth = <span class="number">0</span>; <span class="comment">//右子树的深度</span></span><br><span class="line">    <span class="type">int</span> depth = <span class="number">0</span>;  <span class="comment">//深度=左子树深度和右子树深度间的最大值+1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="comment">//空树</span></span><br><span class="line">    &#123;</span><br><span class="line">        depth = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//非空树</span></span><br><span class="line">    &#123;</span><br><span class="line">        lDepth = <span class="built_in">getDepth</span>(root-&gt;lChild); <span class="comment">//后序遍历获取左子树的深度</span></span><br><span class="line">        rDepth = <span class="built_in">getDepth</span>(root-&gt;rChild); <span class="comment">//后序遍历获取右子树的深度</span></span><br><span class="line">        <span class="keyword">if</span> (lDepth &lt; rDepth)</span><br><span class="line">        &#123;</span><br><span class="line">            depth = rDepth + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            depth = lDepth + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> depth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数————————————————————</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">use_example</span>(); <span class="comment">//使用示例</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="tBTree-cpp（线索二叉树）"><a href="#tBTree-cpp（线索二叉树）" class="headerlink" title="tBTree.cpp（线索二叉树）"></a>tBTree.cpp（线索二叉树）</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件————————————————————</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//命名空间</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型————————————————————</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ELEM_TYPE; <span class="comment">//数据的（数据）类型 依据数据的实际类型定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体</span></span><br><span class="line"><span class="comment">//结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TBTNode</span></span><br><span class="line">&#123;</span><br><span class="line">    ELEM_TYPE data; <span class="comment">//数据</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> lTag;               <span class="comment">//左线索标志    可用bool数据类型</span></span><br><span class="line">    <span class="type">int</span> rTag;               <span class="comment">//右线索标志</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TBTNode</span> *lChild; <span class="comment">//指向左孩子结点的指针</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TBTNode</span> *rChild; <span class="comment">//指向右孩子结点的指针</span></span><br><span class="line">    <span class="comment">//约定：</span></span><br><span class="line">    <span class="comment">//当lTag=0时，lChild为指针，指向左孩子结点；当lTag=1时，lChild为线索，指向直接前驱结点</span></span><br><span class="line">    <span class="comment">//当rTag=0时，rChild为指针，指向右孩子结点；当rTag=1时，rChild为线索，指向直接后继结点</span></span><br><span class="line">&#125; TBTNode;</span><br><span class="line"><span class="comment">// struct TBTNode：结构体数据类型的名称</span></span><br><span class="line"><span class="comment">//如创建一个结点的语句：struct TBTNode node;</span></span><br><span class="line"><span class="comment">//若结构体数据类型内，存在指向该结构体的指针数据类型，则必须完整命名结构体数据类型的名称</span></span><br><span class="line"><span class="comment">//如结点结构体TBTNode内，存在指向该结构体的指针数据类型lChild和rChild，则命名语句为：typedef struct TBTNode而不是typedef struct</span></span><br><span class="line"><span class="comment">// &#125;TBTNode;：typedef给结构体数据类型起的别名，可简化语句</span></span><br><span class="line"><span class="comment">//如创建一个结点的语句：TBTNode node;</span></span><br><span class="line"><span class="comment">//结构体数据类型的名称和别名尽量一致，以方便记忆、使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数声明————————————————————</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_example</span><span class="params">()</span></span>;                       <span class="comment">//使用示例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createTBTree</span><span class="params">(<span class="keyword">struct</span> TBTNode *&amp;root)</span></span>; <span class="comment">//创建 前序法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inThread</span><span class="params">(<span class="keyword">struct</span> TBTNode *cur, <span class="keyword">struct</span> TBTNode *&amp;pre)</span></span>; <span class="comment">//线索化    中序遍历法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createInThread</span><span class="params">(<span class="keyword">struct</span> TBTNode *root)</span></span>;                <span class="comment">//线索化创建    中序遍历法</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TBTNode</span> *<span class="built_in">inFirst</span>(<span class="keyword">struct</span> TBTNode *cur);             <span class="comment">//获取第一个结点    中序遍历法</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TBTNode</span> *<span class="built_in">inNext</span>(<span class="keyword">struct</span> TBTNode *cur);              <span class="comment">//获取后继结点    中序遍历法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrderTraverse</span><span class="params">(<span class="keyword">struct</span> TBTNode *root)</span></span>;               <span class="comment">//中序遍历</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preThread</span><span class="params">(<span class="keyword">struct</span> TBTNode *cur, <span class="keyword">struct</span> TBTNode *&amp;pre)</span></span>; <span class="comment">//线索化    前序遍历法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrderTraverse</span><span class="params">(<span class="keyword">struct</span> TBTNode *root)</span></span>;               <span class="comment">//前序遍历</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postThread</span><span class="params">(<span class="keyword">struct</span> TBTNode *cur, <span class="keyword">struct</span> TBTNode *&amp;pre)</span></span>; <span class="comment">//线索化    后序遍历法</span></span><br><span class="line"><span class="comment">//后序遍历：复杂，需要知道结点双亲-&gt;使用带标志域的三叉链表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数定义————————————————————</span></span><br><span class="line"><span class="comment">//使用示例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_example</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TBTNode</span> *root; <span class="comment">//根结点指针</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">createTBTree</span>(root); <span class="comment">//创建 前序法</span></span><br><span class="line">    <span class="comment">//构造三层二叉树：</span></span><br><span class="line">    <span class="comment">//第一层：1</span></span><br><span class="line">    <span class="comment">//第二层：2，3</span></span><br><span class="line">    <span class="comment">//第三层：-1，-1，-1，4</span></span><br><span class="line">    <span class="comment">//输入数据：1，2，-1，-1，3，-1，4，-1，-1</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">createInThread</span>(root); <span class="comment">//线索化创建    中序遍历法</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">inOrderTraverse</span>(root); <span class="comment">//中序遍历  输出：2，1，3，4</span></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TBTNode</span> *root1; <span class="comment">//根结点指针1</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">createTBTree</span>(root1); <span class="comment">//创建 前序法</span></span><br><span class="line">    <span class="comment">//构造三层二叉树：</span></span><br><span class="line">    <span class="comment">//第一层：1</span></span><br><span class="line">    <span class="comment">//第二层：2，3</span></span><br><span class="line">    <span class="comment">//第三层：-1，-1，-1，4</span></span><br><span class="line">    <span class="comment">//输入数据：1，2，-1，-1，3，-1，4，-1，-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TBTNode</span> *pre = <span class="literal">nullptr</span>; <span class="comment">//前驱结点指针  指向空</span></span><br><span class="line">    <span class="built_in">preThread</span>(root1, pre);         <span class="comment">//线索化    前序遍历法</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">preOrderTraverse</span>(root1); <span class="comment">//前序遍历  输入：1，2，3，4</span></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TBTNode</span> *root2; <span class="comment">//根结点指针2</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">createTBTree</span>(root2); <span class="comment">//创建 前序法</span></span><br><span class="line">    <span class="comment">//构造三层二叉树：</span></span><br><span class="line">    <span class="comment">//第一层：1</span></span><br><span class="line">    <span class="comment">//第二层：2，3</span></span><br><span class="line">    <span class="comment">//第三层：-1，-1，-1，4</span></span><br><span class="line">    <span class="comment">//输入数据：1，2，-1，-1，3，-1，4，-1，-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TBTNode</span> *pre1 = <span class="literal">nullptr</span>; <span class="comment">//前驱结点指针1  指向空</span></span><br><span class="line">    <span class="built_in">postThread</span>(root2, pre1);        <span class="comment">//线索化    后序遍历法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建 前序法</span></span><br><span class="line"><span class="comment">//时间复杂度：O(n)。n为数据规模</span></span><br><span class="line"><span class="comment">//空间复杂度：O(n)。n为数据规模</span></span><br><span class="line"><span class="comment">//空间复杂度：递归调用栈的规模/树的深度/高度：</span></span><br><span class="line"><span class="comment">//最好：[log以2为底的n]下取整+1或[log以2为底的(n+1)]上取整。n为数据规模</span></span><br><span class="line"><span class="comment">//最坏：n。n为数据规模</span></span><br><span class="line"><span class="comment">//注意：参数使用*&amp;，指向指针的引用数据类型</span></span><br><span class="line"><span class="comment">//若只使用*：指针数据类型，在函数体中并未进行解引用调用修改*root的值，使用malloc()修改的是root的值</span></span><br><span class="line"><span class="comment">//所以是值拷贝，函数返回后数据丢失。地址拷贝需要引用数据类型的配合</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createTBTree</span><span class="params">(<span class="keyword">struct</span> TBTNode *&amp;root)</span> <span class="comment">//参数：根结点指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ELEM_TYPE value = <span class="number">0</span>; <span class="comment">//值</span></span><br><span class="line">    cin &gt;&gt; value;        <span class="comment">//获取输入值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="number">-1</span>) <span class="comment">//空树  约定值为-1时无结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        root = <span class="literal">nullptr</span>; <span class="comment">//根结点指针指向空</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//非空树</span></span><br><span class="line">    &#123;</span><br><span class="line">        root = (<span class="keyword">struct</span> TBTNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> TBTNode)); <span class="comment">//创建根结点，根结点指针指向根结点</span></span><br><span class="line"></span><br><span class="line">        root-&gt;data = value;         <span class="comment">//初始化根结点的数据域</span></span><br><span class="line">        root-&gt;lTag = <span class="number">0</span>;             <span class="comment">//初始化根结点的左线索标志</span></span><br><span class="line">        root-&gt;rTag = <span class="number">0</span>;             <span class="comment">//初始化右结点的左线索标志</span></span><br><span class="line">        <span class="built_in">createTBTree</span>(root-&gt;lChild); <span class="comment">//递归构造左子树</span></span><br><span class="line">        <span class="built_in">createTBTree</span>(root-&gt;rChild); <span class="comment">//递归构造右子树</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线索化    中序遍历法</span></span><br><span class="line"><span class="comment">//时间复杂度：O(n)。n为数据规模</span></span><br><span class="line"><span class="comment">//空间复杂度：O(n)。n为数据规模</span></span><br><span class="line"><span class="comment">//空间复杂度：递归调用栈的规模/树的深度/高度：</span></span><br><span class="line"><span class="comment">//最好：[log以2为底的n]下取整+1或[log以2为底的(n+1)]上取整。n为数据规模</span></span><br><span class="line"><span class="comment">//最坏：n。n为数据规模</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inThread</span><span class="params">(<span class="keyword">struct</span> TBTNode *cur, <span class="keyword">struct</span> TBTNode *&amp;pre)</span> <span class="comment">//参数：当前结点指针，前驱结点指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>) <span class="comment">//空树</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//非空树</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">inThread</span>(cur-&gt;lChild, pre); <span class="comment">//当前结点的左子树线索化</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//线索化</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;lChild == <span class="literal">nullptr</span>) <span class="comment">//当前结点的左孩子结点为空   建立当前结点的前驱线索</span></span><br><span class="line">        &#123;</span><br><span class="line">            cur-&gt;lTag = <span class="number">1</span>;     <span class="comment">//当前结点的左线索标志置1</span></span><br><span class="line">            cur-&gt;lChild = pre; <span class="comment">//当前结点的左孩子结点指针指向前驱结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="literal">nullptr</span> &amp;&amp; pre-&gt;rChild == <span class="literal">nullptr</span>) <span class="comment">//前驱结点不为空且前驱结点的右孩子结点为空   建立前驱结点的后继线索</span></span><br><span class="line">        &#123;</span><br><span class="line">            pre-&gt;rTag = <span class="number">1</span>;     <span class="comment">//前驱结点的右线索标志置1</span></span><br><span class="line">            pre-&gt;rChild = cur; <span class="comment">//前驱结点的右孩子结点指针指向当前结点</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pre = cur; <span class="comment">//更新结点指针：前驱结点指针指向当前结点</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">inThread</span>(cur-&gt;rChild, pre); <span class="comment">//当前结点的右子树线索化</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线索化创建    中序遍历法</span></span><br><span class="line"><span class="comment">//时间复杂度：O(n)。n为数据规模</span></span><br><span class="line"><span class="comment">//空间复杂度：O(n)。n为数据规模</span></span><br><span class="line"><span class="comment">//空间复杂度：递归调用栈的规模/树的深度/高度：</span></span><br><span class="line"><span class="comment">//最好：[log以2为底的n]下取整+1或[log以2为底的(n+1)]上取整。n为数据规模</span></span><br><span class="line"><span class="comment">//最坏：n。n为数据规模</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createInThread</span><span class="params">(<span class="keyword">struct</span> TBTNode *root)</span> <span class="comment">//参数：根结点指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TBTNode</span> *pre = <span class="literal">nullptr</span>; <span class="comment">//前驱结点指针  指向空</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="comment">//空树</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//非空树</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">inThread</span>(root, pre); <span class="comment">//线索化 中序遍历法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//已更新结点指针：前驱结点指针指向最后一个结点</span></span><br><span class="line">        <span class="comment">//处理最后一个结点：必为叶子结点，右孩子结点为空</span></span><br><span class="line">        pre-&gt;rTag = <span class="number">1</span>;</span><br><span class="line">        pre-&gt;rChild = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取第一个结点    中序遍历法</span></span><br><span class="line"><span class="comment">//时间复杂度：O(n)。n为数据规模</span></span><br><span class="line"><span class="comment">//时间复杂度：树的深度/高度：</span></span><br><span class="line"><span class="comment">//最好：[log以2为底的n]下取整+1或[log以2为底的(n+1)]上取整。n为数据规模</span></span><br><span class="line"><span class="comment">//最坏：n。n为数据规模</span></span><br><span class="line"><span class="comment">//空间复杂度：O(1)。未使用辅助空间</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TBTNode</span> *<span class="built_in">inFirst</span>(<span class="keyword">struct</span> TBTNode *cur) <span class="comment">//参数：当前结点指针    返回值：以当前结点为根的树，中序遍历时的第一个结点</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//以当前结点为根的树，中序遍历的第一个结点是最左下结点</span></span><br><span class="line">    <span class="keyword">while</span> (cur-&gt;lTag == <span class="number">0</span>) <span class="comment">//当前结点的左线索标志为0</span></span><br><span class="line">    &#123;</span><br><span class="line">        cur = cur-&gt;lChild; <span class="comment">//更新当前结点指针指向当前结点的左孩子结点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取后继结点    中序遍历法</span></span><br><span class="line"><span class="comment">//时间复杂度：O(n)。n为数据规模</span></span><br><span class="line"><span class="comment">//时间复杂度：树的深度/高度或直接获取</span></span><br><span class="line"><span class="comment">//最好：[log以2为底的n]下取整+1或[log以2为底的(n+1)]上取整。n为数据规模。或O(1)</span></span><br><span class="line"><span class="comment">//最坏：n。n为数据规模</span></span><br><span class="line"><span class="comment">//空间复杂度：O(1)。未使用辅助空间</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TBTNode</span> *<span class="built_in">inNext</span>(<span class="keyword">struct</span> TBTNode *cur) <span class="comment">//参数：当前结点指针    返回值：中序遍历时，当前结点的后继结点</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//若当前结点的右线索标志为0，存在以当前结点的右孩子结点为根的右子树，获取第一个结点</span></span><br><span class="line">    <span class="comment">//若当前结点的右线索标志为1，右孩子结点指针指向直接后继结点，直接获取</span></span><br><span class="line">    <span class="keyword">if</span> (cur-&gt;rTag == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">inFirst</span>(cur-&gt;rChild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> cur-&gt;rChild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="comment">//时间复杂度：O(n)。n为数据规模</span></span><br><span class="line"><span class="comment">//空间复杂度：O(1)。未使用辅助空间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrderTraverse</span><span class="params">(<span class="keyword">struct</span> TBTNode *root)</span> <span class="comment">//参数：根结点指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">struct</span> TBTNode *cur = <span class="built_in">inFirst</span>(root); cur != <span class="literal">nullptr</span>; cur = <span class="built_in">inNext</span>(cur))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; cur-&gt;data; <span class="comment">//访问结点的数据</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线索化    前序遍历法</span></span><br><span class="line"><span class="comment">//时间复杂度：O(n)。n为数据规模</span></span><br><span class="line"><span class="comment">//空间复杂度：O(n)。n为数据规模</span></span><br><span class="line"><span class="comment">//空间复杂度：递归调用栈的规模/树的深度/高度：</span></span><br><span class="line"><span class="comment">//最好：[log以2为底的n]下取整+1或[log以2为底的(n+1)]上取整。n为数据规模</span></span><br><span class="line"><span class="comment">//最坏：n。n为数据规模</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preThread</span><span class="params">(<span class="keyword">struct</span> TBTNode *cur, <span class="keyword">struct</span> TBTNode *&amp;pre)</span> <span class="comment">//参数：当前结点指针，前驱结点指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>) <span class="comment">//空树</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//非空树</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//线索化</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;lChild == <span class="literal">nullptr</span>) <span class="comment">//当前结点的左孩子结点为空   建立当前结点的前驱线索</span></span><br><span class="line">        &#123;</span><br><span class="line">            cur-&gt;lTag = <span class="number">1</span>;     <span class="comment">//当前结点的左线索标志置1</span></span><br><span class="line">            cur-&gt;lChild = pre; <span class="comment">//当前结点的左孩子结点指针指向前驱结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="literal">nullptr</span> &amp;&amp; pre-&gt;rChild == <span class="literal">nullptr</span>) <span class="comment">//前驱结点不为空且前驱结点的右孩子结点为空   建立前驱结点的后继线索</span></span><br><span class="line">        &#123;</span><br><span class="line">            pre-&gt;rTag = <span class="number">1</span>;     <span class="comment">//前驱结点的右线索标志置1</span></span><br><span class="line">            pre-&gt;rChild = cur; <span class="comment">//前驱结点的右孩子结点指针指向当前结点</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pre = cur; <span class="comment">//更新结点指针：前驱结点指针指向当前结点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//注意：有限制条件</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;lTag == <span class="number">0</span>) <span class="comment">//当前结点的左线索标志为0，存在左孩子结点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">preThread</span>(cur-&gt;lChild, pre); <span class="comment">//当前结点的左子树线索化</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;rTag == <span class="number">0</span>) <span class="comment">//当前结点的左线索标志为0，存在右孩子结点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">preThread</span>(cur-&gt;rChild, pre); <span class="comment">//当前结点的右子树线索化</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="comment">//时间复杂度：O(n)。n为数据规模</span></span><br><span class="line"><span class="comment">//空间复杂度：O(1)。未使用辅助空间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrderTraverse</span><span class="params">(<span class="keyword">struct</span> TBTNode *root)</span> <span class="comment">//参数：根结点指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TBTNode</span> *cur = <span class="literal">nullptr</span>; <span class="comment">//当前结点指针  指向空</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="comment">//空树</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//非空树</span></span><br><span class="line">    &#123;</span><br><span class="line">        cur = root; <span class="comment">//当前结点指针指向根结点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) <span class="comment">//当前结点不为空时，说明未遍历完，循环</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (cur-&gt;lTag == <span class="number">0</span>) <span class="comment">//当前结点的左线索标志为0，左孩子结点不为空</span></span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; cur-&gt;data; <span class="comment">//访问当前结点的数据</span></span><br><span class="line">                cur = cur-&gt;lChild; <span class="comment">//当前结点指针指向当前结点的左孩子结点：中-&gt;左</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当前结点的左线索标志为1，左孩子结点为空</span></span><br><span class="line">            cout &lt;&lt; cur-&gt;data; <span class="comment">//访问当前结点的数据</span></span><br><span class="line">            cur = cur-&gt;rChild;</span><br><span class="line">            <span class="comment">//若当前结点的右线索标志为0，右孩子结点不为空，当前结点指针指向当前结点的右孩子结点：中-&gt;左（空）-&gt;右</span></span><br><span class="line">            <span class="comment">//若当前结点的右线索标志为1，右孩子结点为空，当前结点指针指向当前结点的直接后继结点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线索化    后序遍历法</span></span><br><span class="line"><span class="comment">//时间复杂度：O(n)。n为数据规模</span></span><br><span class="line"><span class="comment">//空间复杂度：O(n)。n为数据规模</span></span><br><span class="line"><span class="comment">//空间复杂度：递归调用栈的规模/树的深度/高度：</span></span><br><span class="line"><span class="comment">//最好：[log以2为底的n]下取整+1或[log以2为底的(n+1)]上取整。n为数据规模</span></span><br><span class="line"><span class="comment">//最坏：n。n为数据规模</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postThread</span><span class="params">(<span class="keyword">struct</span> TBTNode *cur, <span class="keyword">struct</span> TBTNode *&amp;pre)</span> <span class="comment">//参数：当前结点指针，前驱结点指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>) <span class="comment">//空树</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//非空树</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">postThread</span>(cur-&gt;lChild, pre); <span class="comment">//当前结点的左子树线索化</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">postThread</span>(cur-&gt;rChild, pre); <span class="comment">//当前结点的右子树线索化</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//线索化</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;lChild == <span class="literal">nullptr</span>) <span class="comment">//当前结点的左孩子结点为空   建立当前结点的前驱线索</span></span><br><span class="line">        &#123;</span><br><span class="line">            cur-&gt;lTag = <span class="number">1</span>;     <span class="comment">//当前结点的左线索标志置1</span></span><br><span class="line">            cur-&gt;lChild = pre; <span class="comment">//当前结点的左孩子结点指针指向前驱结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="literal">nullptr</span> &amp;&amp; pre-&gt;rChild == <span class="literal">nullptr</span>) <span class="comment">//前驱结点不为空且前驱结点的右孩子结点为空   建立前驱结点的后继线索</span></span><br><span class="line">        &#123;</span><br><span class="line">            pre-&gt;rTag = <span class="number">1</span>;     <span class="comment">//前驱结点的右线索标志置1</span></span><br><span class="line">            pre-&gt;rChild = cur; <span class="comment">//前驱结点的右孩子结点指针指向当前结点</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pre = cur; <span class="comment">//更新结点指针：前驱结点指针指向当前结点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数————————————————————</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">use_example</span>(); <span class="comment">//使用示例</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>不同参考资料中，二叉树和线索二叉树的描述实现各不相同，但基本思想是一致的。作者使用规范的变量命名、提供详细的步骤解析及使用示例，应用C++语言将其整合成模板，以帮助理解记忆。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《2023版数据结构高分笔记》主编：率辉</li><li>《2023年计算机组成原理考研复习指导》组编：王道论坛</li><li>《大话数据结构》作者：程杰</li><li>《代码随想录》作者：孙秀洋</li><li><a href="https://programmercarl.com/0102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.html">代码随想录 (programmercarl.com)</a></li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“数组、矩阵与广义表”学习提纲</title>
      <link href="/2022/08/24/%E2%80%9C%E6%95%B0%E7%BB%84%E3%80%81%E7%9F%A9%E9%98%B5%E4%B8%8E%E5%B9%BF%E4%B9%89%E8%A1%A8%E2%80%9D%E5%AD%A6%E4%B9%A0%E6%8F%90%E7%BA%B2/"/>
      <url>/2022/08/24/%E2%80%9C%E6%95%B0%E7%BB%84%E3%80%81%E7%9F%A9%E9%98%B5%E4%B8%8E%E5%B9%BF%E4%B9%89%E8%A1%A8%E2%80%9D%E5%AD%A6%E4%B9%A0%E6%8F%90%E7%BA%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>“数组、矩阵与广义表”学习提纲。</p><hr><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="多维数组的存储方式"><a href="#多维数组的存储方式" class="headerlink" title="多维数组的存储方式"></a>多维数组的存储方式</h2><ul><li>行优先</li><li>列优先</li></ul><hr><h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><h2 id="常见的特殊矩阵"><a href="#常见的特殊矩阵" class="headerlink" title="常见的特殊矩阵"></a>常见的特殊矩阵</h2><p>矩阵分区：上三角区，主对角线，下三角区</p><ul><li>对称矩阵</li><li>三角矩阵：上三角矩阵，下三角矩阵</li><li>对角矩阵&#x2F;带状矩阵：三对角矩阵</li></ul><hr><h2 id="对称矩阵的压缩存储计算"><a href="#对称矩阵的压缩存储计算" class="headerlink" title="对称矩阵的压缩存储计算"></a>对称矩阵的压缩存储计算</h2><p>数组表示：a[n][n]。其中a为数组名称，n为行和列数<br>元素表示：a[i][j]。其中i为行下标，j为列下标</p><p>存储元素数量：(1+n)×n÷2</p><p>存储下标（<strong>从0开始；行下标和列下标从1开始，行优先，存下三角区</strong>）：</p><ul><li>i×(i-1)÷2+j-1，i&gt;&#x3D;j（下三角区和主对角线元素）</li><li>j×(j-1)÷2+i-1，i&lt;j（上三角区元素）</li></ul><p><strong>注意：</strong></p><ul><li>关注：行下标和列下标从0或1开始，存储下标从0或1开始，依据行或列优先存储。对称矩阵还要多关注存储在上或下三角区</li><li>行下标和列下标从0开始相比从1开始需要重新推导公式</li><li>存储下标从1开始相比从0开始需要多+1</li><li>选择题可以使用特殊值代入法判断</li></ul><hr><h2 id="三角矩阵的压缩存储计算"><a href="#三角矩阵的压缩存储计算" class="headerlink" title="三角矩阵的压缩存储计算"></a>三角矩阵的压缩存储计算</h2><p>数组表示：a[n][n]。其中a为数组名称，n为行和列数<br>元素表示：a[i][j]。其中i为行下标，j为列下标</p><p>存储元素数量：(1+n)×n÷2+1</p><p>下三角矩阵的存储下标（<strong>从0开始；行下标和列下标从1开始，行优先</strong>）：</p><ul><li>i×(i-1)÷2+j-1，i&gt;&#x3D;j（下三角区和主对角线元素）</li><li>(1+n)×n÷2，i&lt;j（上三角区元素）</li></ul><p>上三角矩阵的存储下标（<strong>从0开始；行下标和列下标从1开始，行优先</strong>）：</p><ul><li>(2×n-i+2)×(i-1)÷2+(j-i)，i&lt;&#x3D;j（上三角区和主对角线元素）</li><li>(1+n)×n÷2，i&gt;j（下三角区元素）</li></ul><p>下三角矩阵的存储下标（<strong>从0开始；行下标和列下标从1开始，列优先</strong>）：</p><ul><li>(2×n-j+2)×(j-1)÷2+(i-j)，i&gt;&#x3D;j（下三角区和主对角线元素）</li><li>(1+n)×n÷2，i&lt;j（上三角区元素）</li></ul><p>上三角矩阵的存储下标（<strong>从0开始；行下标和列下标从1开始，列优先</strong>）：</p><ul><li>j×(j-1)÷2+i-1，i&lt;&#x3D;j（上三角区和主对角线元素）</li><li>(1+n)×n÷2，i&gt;j（下三角区元素）</li></ul><hr><h2 id="三对角矩阵的压缩存储计算"><a href="#三对角矩阵的压缩存储计算" class="headerlink" title="三对角矩阵的压缩存储计算"></a>三对角矩阵的压缩存储计算</h2><p>数组表示：a[n][n]。其中a为数组名称，n为行和列数<br>元素表示：a[i][j]。其中i为行下标，j为列下标</p><p>存储下标（<strong>从0开始；行下标和列下标从1开始</strong>）：2×i+j-3</p><p>由存储下标得行下标（<strong>从1开始</strong>）和列下标（<strong>从1开始</strong>）（假设存储下标为k）：</p><ul><li>i&#x3D;[(k+1)÷3+1]下取整</li><li>j&#x3D;k-2i+3</li></ul><hr><h2 id="稀疏矩阵的压缩存储方式"><a href="#稀疏矩阵的压缩存储方式" class="headerlink" title="稀疏矩阵的压缩存储方式"></a>稀疏矩阵的压缩存储方式</h2><p>顺序存储：</p><ul><li>三元组表示法：结构体或二维数组，行数为非零元素数量，列数为3：值，行下标，列下标</li><li>伪地址表示法：二维数组，行数为非零元素数量，列数为2：值，伪地址&#x2F;相对位置</li></ul><p>伪地址表示法的相关存储计算：</p><ul><li>数组表示：a[m][n]。其中a为数组名称，m为行数，n为列数</li><li>元素表示：a[i][j]。其中i为行下标，j为列下标</li><li>伪地址&#x2F;相对位置（从0开始，行优先）：(i-1)×n+j</li></ul><p>链式存储：</p><ul><li>邻接表表示法：一行为一个单链表，头结点有行下标和指针，其他结点有值、列下标和指针</li><li>十字链表表示法：一行为一个单链表，一列为一个单链表，单链表纵横链接。结点有5个分量：值，行下标，列下标，指向下方结点的指针，指向右方结点的指针</li></ul><hr><h1 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h1><h2 id="广义表的属性"><a href="#广义表的属性" class="headerlink" title="广义表的属性"></a>广义表的属性</h2><ul><li>长度：最上层元素的数量</li><li>深度：展开子表后，括号的最大层数</li><li>表头：表非空时，第一个元素</li><li>表尾：表非空时，除第一个元素的其他元素</li></ul><hr><h2 id="广义表的存储方式"><a href="#广义表的存储方式" class="headerlink" title="广义表的存储方式"></a>广义表的存储方式</h2><ul><li>头尾链表（类似无头结点的单链表）：原子结点：标记，值；广义表结点：标记，头指针，尾指针</li><li>扩展线性表链表（类似有头结点的单链表）：原子结点：标记，值，尾指针；广义表结点：标记，头指针，尾指针</li></ul><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>“数组、矩阵与广义表”学习提纲。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《2023版数据结构高分笔记》主编：率辉</li><li>《2023年计算机组成原理考研复习指导》组编：王道论坛</li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>串模式匹配的C++语言描述实现模板</title>
      <link href="/2022/08/23/%E4%B8%B2%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%9A%84C++%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E5%AE%9E%E7%8E%B0%E6%A8%A1%E6%9D%BF/"/>
      <url>/2022/08/23/%E4%B8%B2%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%9A%84C++%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E5%AE%9E%E7%8E%B0%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>数据结构中串模式匹配的C++语言描述实现模板，有详细的步骤解析及使用示例。</p><hr><h1 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h1><ul><li><a href="https://github.com/yezhening/Programming-examples">yezhening&#x2F;Programming-examples: 编程实例 (github.com)</a></li><li><a href="https://gitee.com/yezhening/Programming-examples">Programming-examples: 编程实例 (gitee.com)</a></li></ul><hr><h1 id="暴力-简单-朴素算法"><a href="#暴力-简单-朴素算法" class="headerlink" title="暴力&#x2F;简单&#x2F;朴素算法"></a>暴力&#x2F;简单&#x2F;朴素算法</h1><h2 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件————————————————————</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//命名空间————————————————————</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数声明————————————————————</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useExample</span><span class="params">()</span></span>;                                      <span class="comment">//使用示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">index</span><span class="params">(<span class="type">const</span> string &amp;mainStr, <span class="type">const</span> string &amp;subStr)</span></span>; <span class="comment">//暴力/简单/朴素算法  返回主串与子串匹配的第一个位置索引</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数定义————————————————————</span></span><br><span class="line"><span class="comment">//使用示例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useExample</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> string mainStr = <span class="string">&quot;abcde&quot;</span>; <span class="comment">//主串</span></span><br><span class="line">    <span class="type">const</span> string subStr = <span class="string">&quot;cd&quot;</span>;     <span class="comment">//子串</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">index</span>(mainStr, subStr) &lt;&lt; endl; <span class="comment">//输出：2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//暴力/简单/朴素算法  返回主串与子串匹配的第一个位置索引</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">index</span><span class="params">(<span class="type">const</span> string &amp;mainStr, <span class="type">const</span> string &amp;subStr)</span> <span class="comment">//参数：主串，子串</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">//主串的匹配位置</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>; <span class="comment">//子串的匹配位置</span></span><br><span class="line">    <span class="comment">// int k = i; //记录每轮匹配时主串和子串匹配的起始位置  用于匹配失败时主串匹配位置的定位回溯</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; mainStr.<span class="built_in">size</span>() &amp;&amp; j &lt; subStr.<span class="built_in">size</span>()) <span class="comment">//遍历主串和子串进行匹配</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (mainStr[i] == subStr[j]) <span class="comment">//匹配成功</span></span><br><span class="line">        &#123;</span><br><span class="line">            ++i; <span class="comment">//继续匹配主串的下一个位置</span></span><br><span class="line">            ++j; <span class="comment">//继续匹配子串的下一个位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//匹配失败</span></span><br><span class="line">        &#123;</span><br><span class="line">            i = i - j + <span class="number">1</span>; <span class="comment">//主串匹配位置回溯 或：i = ++k;</span></span><br><span class="line">            j = <span class="number">0</span>;         <span class="comment">//子串匹配位置回溯为0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (j == subStr.<span class="built_in">size</span>()) <span class="comment">//遍历完子串，表明匹配成功</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> i - subStr.<span class="built_in">size</span>(); <span class="comment">//返回主串与子串匹配的第一个位置索引  或：return k;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//匹配失败</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//返回-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数————————————————————</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">useExample</span>(); <span class="comment">//使用示例</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>理论时间复杂度：O(n×m)。n为主串规模，m为子串规模</li><li>实际（一般情况下的）时间复杂度：：O(n+m)。n为主串规模，m为子串规模</li><li>空间复杂度：O(1)。未使用辅助空间</li></ul><hr><h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><ul><li>作用：字符串（主串和子串）匹配；字符串（主串中的子串间）重复</li><li>前缀：<strong>除最后一个字符外</strong>，字符串的首部<strong>连续</strong>子串</li><li>后缀：<strong>除第一个字符外</strong>，字符串的尾部<strong>连续</strong>子串</li><li>最长相等前后缀：<strong>待匹配字符前的子串中</strong>，最长且相等的前后缀子串</li><li>前缀表：记录最长相等前后缀的长度</li><li>next数组：前缀表<strong>或</strong>值统一减一的前缀表</li><li>next数组的值next [ j ]：子串的第 j 个字符与主串的当前字符匹配失败，跳转到子串的第next [ j ]个字符与主串的当前字符<strong>进行</strong>匹配（可能匹配失败或匹配成功）</li><li>时间复杂度：O(n+m)。n为主串规模，m为子串&#x2F;next数组规模</li><li>空间复杂度：O(m)。m为子串&#x2F;next数组规模</li></ul><h2 id="代码模板-1"><a href="#代码模板-1" class="headerlink" title="代码模板"></a>代码模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件————————————————————</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//命名空间————————————————————</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数声明————————————————————</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useExample</span><span class="params">()</span></span>;                                                                  <span class="comment">//使用示例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">const</span> string &amp;subStr, vector&lt;<span class="type">int</span>&gt; &amp;next)</span></span>;                              <span class="comment">//获取next向量：值统一减一/整体右移一位的前缀表</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">indexKMP</span><span class="params">(<span class="type">const</span> string &amp;mainStr, <span class="type">const</span> string &amp;subStr, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;next)</span></span>; <span class="comment">// KMP算法 返回主串与子串匹配的第一个位置索引</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数定义————————————————————</span></span><br><span class="line"><span class="comment">//使用示例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useExample</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> string mainStr = <span class="string">&quot;abcde&quot;</span>; <span class="comment">//主串</span></span><br><span class="line">    <span class="type">const</span> string subStr = <span class="string">&quot;cd&quot;</span>;     <span class="comment">//子串</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> subStrSize = subStr.<span class="built_in">size</span>(); <span class="comment">//子串大小</span></span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(subStrSize, <span class="number">-1</span>)</span></span>; <span class="comment">// next向量   为子串大小，初始化值-1</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">getNext</span>(subStr, next); <span class="comment">//获取next向量</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">indexKMP</span>(mainStr, subStr, next) &lt;&lt; endl; <span class="comment">//输出：2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取next向量：值统一减一的前缀表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">const</span> string &amp;subStr, vector&lt;<span class="type">int</span>&gt; &amp;next)</span> <span class="comment">//参数：子串，next向量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;  <span class="comment">//子串中求next值位置的上一位置  主串/后缀的起始位置</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">-1</span>; <span class="comment">//子串中求next值位置的上上一位置    用于定位：因为需要依据next[j]求next[j+1]    子串/前缀的起始位置</span></span><br><span class="line"></span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>; <span class="comment">// next向量第一个位置的值必为-1：不存在最长相等前后缀，最长相等前后缀为0，0 - 1 = -1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; subStr.<span class="built_in">size</span>() - <span class="number">1</span>) <span class="comment">//遍历子串每个位置   求next值 注意：因为是上一个位置，所以需-1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// j == -1：j回退到-1，-1 + 1 = 0，最长相等前后缀的长度为0，不存在最长相等前后缀</span></span><br><span class="line">        <span class="comment">//++i：从主串的下一位置匹配</span></span><br><span class="line">        <span class="comment">//++j：j = -1 + 1 = 0，从子串的第一个位置匹配</span></span><br><span class="line">        <span class="comment">// next[i] = j：得next值0：</span></span><br><span class="line">        <span class="comment">//因为不存在最长相等前后缀；含义：若匹配失败，则从子串的第一个位置0进行匹配</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// subStr[i] == subStr[j]：匹配成功</span></span><br><span class="line">        <span class="comment">//++i：继续匹配主串的下一位置</span></span><br><span class="line">        <span class="comment">//++j：继续匹配子串的下一位置</span></span><br><span class="line">        <span class="comment">// next[i] = j：得next值：</span></span><br><span class="line">        <span class="comment">//因为匹配成功；含义：若匹配失败，则从后缀的j位置匹配（因为存在最长相等前后缀，可定位）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//注意理解：匹配时的i是求next值的位置的上一位置，next[i] = j的++i是求next值的位置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// else：不存在最长相等前后缀，问题转换：进一步理解为模式匹配问题，递归求next[j]得定位</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || subStr[i] == subStr[j])</span><br><span class="line">        &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line"></span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// KMP算法  返回主串与子串匹配的第一个位置索引</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">indexKMP</span><span class="params">(<span class="type">const</span> string &amp;mainStr, <span class="type">const</span> string &amp;subStr, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;next)</span> <span class="comment">//参数：主串，子串，next向量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">//主串的匹配位置</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>; <span class="comment">//子串的匹配位置</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> mainStrSize = mainStr.<span class="built_in">size</span>(); <span class="comment">//主串大小</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> subStrSize = subStr.<span class="built_in">size</span>();   <span class="comment">//子串大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// while (i &lt; mainStr.size() &amp;&amp; j &lt; subStr.size()) //遍历主串和子串 输出错误</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; mainStrSize &amp;&amp; j &lt; subStrSize) <span class="comment">//遍历主串和子串</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// j == -1：子串的匹配位置回溯，匹配主串的下一位置和子串的第一个位置</span></span><br><span class="line">        <span class="comment">// mainStr[i] == subStr[j]：匹配成功，继续匹配主串和子串的下一个位置</span></span><br><span class="line">        <span class="comment">// else：匹配失败，子串的匹配位置依据next向量回溯</span></span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || mainStr[i] == subStr[j])</span><br><span class="line">        &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (j == subStr.<span class="built_in">size</span>()) <span class="comment">//遍历完子串，表明匹配成功</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> i - subStr.<span class="built_in">size</span>(); <span class="comment">//返回主串与子串匹配的第一个位置索引</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//匹配失败</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//返回-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数————————————————————</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">useExample</span>(); <span class="comment">//使用示例</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="KMP改进算法"><a href="#KMP改进算法" class="headerlink" title="KMP改进算法"></a>KMP改进算法</h1><h2 id="核心思想-1"><a href="#核心思想-1" class="headerlink" title="核心思想"></a>核心思想</h2><ul><li>解决子串中匹配失败的字符和回溯位置的字符相同导致的冗余匹配问题</li><li>时间复杂度：O(n+m)。n为主串规模，m为子串&#x2F;nextval数组规模</li><li>空间复杂度：O(m)。m为子串&#x2F;nextval数组规模</li></ul><h2 id="代码模板-2"><a href="#代码模板-2" class="headerlink" title="代码模板"></a>代码模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件————————————————————</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//命名空间————————————————————</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数声明————————————————————</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useExample</span><span class="params">()</span></span>;                                                                     <span class="comment">//使用示例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNextval</span><span class="params">(<span class="type">const</span> string &amp;subStr, vector&lt;<span class="type">int</span>&gt; &amp;nextval)</span></span>;                           <span class="comment">//获取nextval向量</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">indexKMP</span><span class="params">(<span class="type">const</span> string &amp;mainStr, <span class="type">const</span> string &amp;subStr, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;nextval)</span></span>; <span class="comment">// KMP算法 返回主串与子串匹配的第一个位置索引</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数定义————————————————————</span></span><br><span class="line"><span class="comment">//使用示例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useExample</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> string mainStr = <span class="string">&quot;abcde&quot;</span>; <span class="comment">//主串</span></span><br><span class="line">    <span class="type">const</span> string subStr = <span class="string">&quot;cd&quot;</span>;   <span class="comment">//子串</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> subStrSize = subStr.<span class="built_in">size</span>(); <span class="comment">//子串大小</span></span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextval</span><span class="params">(subStrSize, <span class="number">-1</span>)</span></span>; <span class="comment">// nextval向量   为子串大小，初始化值-1</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">getNextval</span>(subStr, nextval); <span class="comment">//获取nextval向量</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">indexKMP</span>(mainStr, subStr, nextval) &lt;&lt; endl; <span class="comment">//输出：2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取nextval向量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNextval</span><span class="params">(<span class="type">const</span> string &amp;subStr, vector&lt;<span class="type">int</span>&gt; &amp;nextval)</span> <span class="comment">//参数：子串，nextval向量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;  <span class="comment">//子串中求nextval值位置的上一位置</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">-1</span>; <span class="comment">//子串中求nextval值位置的上上一位置   用于定位：因为需要依据nextval[j]求nextval[j+1]</span></span><br><span class="line"></span><br><span class="line">    nextval[<span class="number">0</span>] = <span class="number">-1</span>; <span class="comment">// nextval向量第一个位置的值必为-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; subStr.<span class="built_in">size</span>() - <span class="number">1</span>) <span class="comment">//遍历子串每个位置   求nextval值 注意：因为是上一个位置，所以需-1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// j == -1：不存在最长相等前后缀，j回退到-1</span></span><br><span class="line">        <span class="comment">//++i：从主串的下一位置匹配</span></span><br><span class="line">        <span class="comment">//++j：j = -1 + 1 = 0，从子串的第一个位置匹配</span></span><br><span class="line">        <span class="comment">// nextval[i] = j：得nextval值</span></span><br><span class="line">        <span class="comment">//因为不存在最长相等前后缀，若当前位置匹配失败，则从子串的第一个位置0匹配</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// subStr[i] == subStr[j]：匹配成功</span></span><br><span class="line">        <span class="comment">//++i：继续匹配主串的下一位置</span></span><br><span class="line">        <span class="comment">//++j：继续匹配子串的下一位置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//改进内容：</span></span><br><span class="line">        <span class="comment">// subStr[i] != subStr[j]：当前位置的字符和回溯位置的字符不同，当前位置的字符匹配失败时不会导致冗余匹配问题</span></span><br><span class="line">        <span class="comment">// nextval[i] = j：得nextval值</span></span><br><span class="line">        <span class="comment">//因为匹配成功，若当前位置匹配失败，则从后缀的j位置匹配（因为存在最长相等前后缀，可定位）</span></span><br><span class="line">        <span class="comment">// nextval[i] = nextval[j]：得nextval值</span></span><br><span class="line">        <span class="comment">//否则当前位置的字符和回溯位置的字符相同，当前位置的字符匹配失败时会导致冗余匹配问题</span></span><br><span class="line">        <span class="comment">//递归获取当前位置的字符和回溯位置的字符不同时的nextval值</span></span><br><span class="line">        <span class="comment">//算法保证正向获取nextval值，反向只需递归一次，当前位置的字符和回溯位置的字符必不同</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//理解：匹配时的i是求nextval值的位置的上一位置，nextval[i] = j的++i是求nextval值的位置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// else：不存在最长相等前后缀，问题转换：进一步理解为模式匹配问题，递归求nextval[j]得定位</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || subStr[i] == subStr[j])</span><br><span class="line">        &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (subStr[i] != subStr[j])</span><br><span class="line">            &#123;</span><br><span class="line">                nextval[i] = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                nextval[i] = nextval[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            j = nextval[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// KMP算法  返回主串与子串匹配的第一个位置索引</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">indexKMP</span><span class="params">(<span class="type">const</span> string &amp;mainStr, <span class="type">const</span> string &amp;subStr, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;nextval)</span> <span class="comment">//参数：主串，子串，nextval向量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">//主串的匹配位置</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>; <span class="comment">//子串的匹配位置</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> mainStrSize = mainStr.<span class="built_in">size</span>(); <span class="comment">//主串大小</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> subStrSize = subStr.<span class="built_in">size</span>();   <span class="comment">//子串大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// while (i &lt; mainStr.size() &amp;&amp; j &lt; subStr.size()) //遍历主串和子串 输出错误</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; mainStrSize &amp;&amp; j &lt; subStrSize) <span class="comment">//遍历主串和子串</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// j == -1：子串的匹配位置回溯，匹配主串的下一位置和子串的第一个位置</span></span><br><span class="line">        <span class="comment">// mainStr[i] == subStr[j]：匹配成功，继续匹配主串和子串的下一个位置</span></span><br><span class="line">        <span class="comment">// else：匹配失败，子串的匹配位置依据nextval向量回溯</span></span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || mainStr[i] == subStr[j])</span><br><span class="line">        &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            j = nextval[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (j == subStr.<span class="built_in">size</span>()) <span class="comment">//遍历完子串，表明匹配成功</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> i - subStr.<span class="built_in">size</span>(); <span class="comment">//返回主串与子串匹配的第一个位置索引</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//匹配失败</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//返回-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数————————————————————</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">useExample</span>(); <span class="comment">//使用示例</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>不同参考资料中，串模式匹配的描述实现各不相同，但基本思想是一致的。作者使用规范的变量命名、提供详细的步骤解析及使用示例，应用C++语言将其整合成模板，以帮助理解记忆。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《2023版数据结构高分笔记》主编：率辉</li><li>《2023年计算机组成原理考研复习指导》组编：王道论坛</li><li>《大话数据结构》作者：程杰</li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式总结</title>
      <link href="/2022/08/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
      <url>/2022/08/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>设计模式总结。</p><hr><h1 id="面向对象的特性：3点"><a href="#面向对象的特性：3点" class="headerlink" title="面向对象的特性：3点"></a>面向对象的特性：3点</h1><ul><li>封装</li><li>继承</li><li>多态</li></ul><hr><h1 id="编程代码的原则-面向对象的优势：4点"><a href="#编程代码的原则-面向对象的优势：4点" class="headerlink" title="编程代码的原则&#x2F;面向对象的优势：4点"></a>编程代码的原则&#x2F;面向对象的优势：4点</h1><ul><li>可维护</li><li>可复用</li><li>可扩展</li><li>可灵活&#x2F;灵活性好</li></ul><hr><h1 id="统一建模语言（UML）图的基本关系：6种"><a href="#统一建模语言（UML）图的基本关系：6种" class="headerlink" title="统一建模语言（UML）图的基本关系：6种"></a>统一建模语言（UML）图的基本关系：6种</h1><ul><li>继承：实线，三角箭头，指向被继承类</li><li>实现：虚线，三角箭头，指向被实现接口</li><li>依赖：虚线，箭头，指向被依赖者</li><li>关联：实线，箭头，指向被关联者</li><li>聚合：空心菱形，实线箭头，指向被聚合者</li><li>组合：实心菱形，实线箭头，指向被组合者</li></ul><p><strong>继承和实现关系的区别：</strong></p><ul><li>（抽象）类&#x2F;继承和接口&#x2F;实现在一定程度上可相互转换代替</li><li>（抽象）类：抽象类型，对象之间有关系，属于同一类型，使用继承关系。如：雁和鸟，雁是鸟类型</li><li>接口：抽象行为，对象之间无关系，有共同行为，使用实现关系。如：飞机和鸟，都有飞行的行为</li></ul><p><strong>依赖、关联、聚合和组合的区别：</strong><br>依赖：</p><ul><li>表现：方法中的形式参数、局部变量和静态方法调用</li><li>侧重：临时性</li></ul><p>关联：</p><ul><li>表现：方法中的形式参数，类中的成员字段</li><li>侧重：长期性；对象间是平等的，对象了解对象。如：企鹅了解气候</li></ul><p>聚合：</p><ul><li>表现：类中的成员字段</li><li>侧重：长期性；对象间是不平等的，对象包含对象；整体和部分的可分割关系。如：雁群和雁</li></ul><p>组合：</p><ul><li>表现：类中创建、删除的对象（管理对象的生命周期）</li><li>侧重：长期性；对象间是不平等的，对象包含对象；整体和部分的不可分割关系。如：鸟和翅膀</li></ul><p>注意：</p><ul><li>依赖、关联、聚合和组合关系大多依据语义而不是实现进行判断</li></ul><p>弱强程度：</p><ul><li>依赖&lt;关联&lt;聚合&lt;组合</li></ul><hr><h1 id="设计模式的原则：7种"><a href="#设计模式的原则：7种" class="headerlink" title="设计模式的原则：7种"></a>设计模式的原则：7种</h1><p>开放-封闭&#x2F;开-闭原则（OCP）</p><ul><li><p>描述：对扩展开放，对修改关闭</p></li><li><p>应用：可扩展新代码，不可&#x2F;尽量不修改旧代码</p></li></ul><p>依赖倒转&#x2F;置原则（DIP）：</p><ul><li><p>描述：高层模块不应该依赖低层模块，两种模块都应该依赖抽象；抽象不应该依赖细节，细节应该依赖抽象（其中的“不应该”和“应该”是“依赖倒转”的体现）</p></li><li><p>应用：不面向实现编程，面向接口&#x2F;抽象类编程；使用抽象类&#x2F;接口作为变量、参数</p></li></ul><p>单一职责原则（SRP）：</p><ul><li>描述：类的逻辑&#x2F;功能&#x2F;职责单一；引起类变化的原因应该有且仅有一个</li><li>应用：拆分业务对象&#x2F;逻辑&#x2F;功能&#x2F;职责</li></ul><p>最少知识原则&#x2F;迪米特法则（LoD）</p><ul><li><p>描述：类间弱耦合；类间间接而不直接通信</p></li><li><p>应用：尽可能封装类；使用第三者转发类间的调用</p></li></ul><p>里氏代换原则（LSP）</p><ul><li>描述：子类型必须能够代换其父类型；子类可扩展父类功能，不可修改父类功能</li><li>本质：面向对象的多态特性</li><li>应用：使用子类扩展业务逻辑</li></ul><p>接口隔离原则（ISP）：</p><ul><li>描述：客户端不应该依赖不需要的接口；类间关系应该建立在最小的接口上</li><li>应用：依据业务逻辑拆分复杂多用接口为简单专用接口</li></ul><p>合成&#x2F;聚合复用原则（C&#x2F;ARP）</p><ul><li>描述：类间尽量使用依赖、关联、聚合和组合关系，尽量不使用继承关系</li><li>应用：类间尽量使用依赖、关联、聚合和组合关系，尽量不使用继承关系</li></ul><p>设计模式原则的关系（记忆方式）：</p><ul><li>总体规则：开放-封闭&#x2F;开-闭原则（OCP），依赖倒转&#x2F;置原则（DIP）</li><li>设计模式的核心是面向对象</li><li>面向对象的封装：单一职责原则（SRP），最少知识原则&#x2F;迪米特法则（LoD）</li><li>面向对象的继承和多态：里氏代换原则（LSP），接口隔离原则（ISP）</li><li>类间关系的描述——合成复用原则（C&#x2F;ARP）</li></ul><hr><h1 id="设计模式的类型：3种"><a href="#设计模式的类型：3种" class="headerlink" title="设计模式的类型：3种"></a>设计模式的类型：3种</h1><p>依据意图：</p><ul><li>创建型：负责提供创建对象的机制</li><li>结构型：负责将对象组装成较复杂的结构，同时保持结构的灵活和高效</li><li>行为型：负责对象间的高效沟通和职责委派</li></ul><hr><h1 id="创建型设计模式：6种"><a href="#创建型设计模式：6种" class="headerlink" title="创建型设计模式：6种"></a>创建型设计模式：6种</h1><p>单例模式（Singleton）：</p><ul><li>描述：保证一个类仅有一个实例，并提供一个访问它的全局访问点</li><li>关键实现：单例类有：私有静态单例类对象字段A，私有构造方法B，公有静态获取单例类对象方法C。客户端单例类对象调用C-&gt;可能调用B，获得A</li><li>类型：饿汉式，懒汉式</li><li>相关内容：线程安全，双重锁定，静态初始化</li><li><strong>类比：</strong> 木星是唯一的，“木星”、“太阳系最大的行星”和“Jupiter”称谓都是指木星</li></ul><p>简单工厂模式（Simple Factory）：</p><ul><li>关键实现：客户端调用简单工厂类的静态方法：判断并创建产品类对象</li><li>相关内容：反射</li><li>其他：不属于23种GoF设计模式之一。因为违背开放-封闭&#x2F;开-闭原则（OCP）：扩展需要修改简单工厂类：增加产品类对象的判断和创建代码</li><li><strong>类比：</strong> 建造汽车工厂，让汽车工厂生产引擎产品和轮胎产品</li></ul><p> 工厂方法模式（Factory Method）：</p><ul><li>描述：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类</li><li>关键实现：客户端判断并创建具体工厂类对象A，A创建具体产品类对象</li><li>相关内容：反射</li><li><strong>类比：</strong> 建造汽车引擎工厂，让汽车引擎工厂生产引擎产品；建造汽车轮胎工厂，让汽车轮胎工厂生产轮胎产品</li></ul><p>抽象工厂模式（Abstract Factory）：</p><ul><li>描述：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类</li><li>关键实现：工厂和产品表现二&#x2F;多维结构：客户端判断并创建具体工厂类对象A，一个A，可创建多个同系列不同种类的具体产品类对象</li><li>相关内容：反射，配置文件</li><li><strong>类比：</strong> 建造A品牌汽车工厂，让A品牌汽车工厂生产A品牌引擎产品和A品牌轮胎产品；建造B品牌汽车工厂，让B品牌汽车工厂生产B品牌引擎产品和B品牌轮胎产品（系列&#x2F;风格&#x2F;品牌和种类是二维结构）</li></ul><p>原型模式（Prototype）：</p><ul><li>描述：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象</li><li>关键实现：客户端原型类对象调用原型类的克隆方法-&gt;调用原型类的构造方法：参数接收当前原型类对象A（this），创建并返回A的副本</li><li>相关内容：浅拷贝和深拷贝</li><li><strong>类比：</strong> 细胞的有丝分裂&#x2F;克隆</li></ul><p>建造者模式（Builder）：</p><ul><li>描述：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示 </li><li>关键实现：客户端指挥者类对象调用指挥者类的指挥方法：参数接收具体建造者类对象A（建造过程）-&gt;A调用具体建造者类的具体获取产品方法（建造结果）</li><li><strong>类比：</strong> 创建指挥机器（指挥机器封装建造过程的内容和时序：如建造房屋需要建造墙壁和房门，先建造墙壁后建造房门），创建建造机器（建造机器封装产品的各个建造细节：如建造墙壁的方式，建造房门的方式）。让指挥机器建造房屋-&gt;指挥机器指挥房屋建造机器建造房门产品和墙壁产品</li></ul><hr><h1 id="结构型设计模式：7种"><a href="#结构型设计模式：7种" class="headerlink" title="结构型设计模式：7种"></a>结构型设计模式：7种</h1><p>代理模式（Proxy）：</p><ul><li>描述：为其他对象提供一种代理以控制对这个对象的访问</li><li>关键实现：代理类（代理者）与具体服务类（被代理者）继承&#x2F;实现相同的抽象服务类&#x2F;接口。客户端代理类对象调用代理类的方法-&gt;具体服务类对象调用具体服务类的方法（代理过程）</li><li><strong>类比：</strong> 信用卡和现金都能支付，使用信用卡代替现金支付</li></ul><p>适配器模式（Adapter）：</p><ul><li>描述：将一个类的接口转换成客户希望的另外一个接口。使得原本由于接口不兼容而不能一起工作的那些类可以一起工作</li><li>关键实现：需适配类（被适配者）和目标类（适配者）的接口不同，适配器类（中间者）和目标类（适配者）的接口相同。客户端目标类类型的适配器类对象调用适配器类的方法-&gt;需适配类对象调用需适配类的方法（适配过程）</li><li>类型：类适配器模式，对象适配器模式</li><li><strong>类比：</strong> 电源适配器适配不同的源电压和电器，源电压不同电器依然能正常工作</li></ul><p>外观模式（Facade）：</p><ul><li>描述：为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用</li><li>关键实现：客户端外观类对象调用外观类的方法（管理者，搭配子系统类方法的调用内容和时序&#x2F;步骤）-&gt;子系统类对象调用子系统类的方法（被管理者）</li><li><strong>类比：</strong> 安装电源总开关并连接电灯电源开关和空调电源开关，关闭电源总开关可关闭电灯电源和空调电源</li></ul><p> 装饰模式（Decorator）：</p><ul><li>描述：动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更加灵活</li><li>关键实现：装饰类（装饰者）和组件类（被装饰者）有相同接口。客户端具体装饰类对象A调用设置方法：参数接收具体组件类对象B（装饰过程），A调用方法-&gt;B调用具体组件类的方法（固有内容），执行其他内容（装饰内容）</li><li><strong>类比：</strong> 人类穿衣服，可以选择穿毛衣、夹克或者风衣</li></ul><p>组合模式（Composite）：</p><ul><li>描述：将对象组合成树形结构以表示“部分-整体”的层次结构。使得用户对单个对象和组合对象的使用具有一致性</li><li>关键实现：组合类对象（树根）和叶子类对象（树叶）有相同接口A。客户端组合类对象B（树根）调用添加方法：参数接收组合类对象C（树枝）或叶子类对象D（树叶），A调用方法B-&gt;C递归调用B，D调用B</li><li>相关内容：透明方式，安全方式</li><li><strong>类比：</strong> 军事命令依据军队的层次结构传递：司令-&gt;军-&gt;师-&gt;旅-&gt;团-&gt;营-&gt;连-&gt;排-&gt;士兵</li></ul><p>桥接模式（Bridge）：</p><ul><li>描述：将抽象部分与它的实现部分分离，使它们都可以独立地变化</li><li>关键实现：客户端抽象抽象类类型的具体抽象类对象A调用设置方法：参数接收抽象实现类类型的具体实现类对象B，A调用具体抽象类方法-&gt;B调用具体实现类方法</li><li><strong>类比：</strong> A品牌手机安装（不知道软件的实现细节）A品牌通讯录和A品牌游戏。反之，A品牌手机自带实现（知道软件的实现细节，每品牌手机都要自带实现相关软件）A品牌通讯录和A品牌游戏</li></ul><p>享元模式（Flyweight）：</p><ul><li>描述：运用共享技术有效地支持大量大量细粒度的对象</li><li>关键实现：享元类和不共享类有相同接口A。客户端享元工厂类对象调用方法：参数接收内容（键），查找散列&#x2F;哈希表，创建、记录并获取或直接获取享元类对象B（值，共享内容&#x2F;内部状态），B调用方法：参数接收内容（不共享内容&#x2F;外部状态），执行相关操作。不共享类对象（不共享内容&#x2F;外部状态）和B实现类似</li><li><strong>类比：</strong> 相似的网站使用同一服务器资源、系统和实例，依据网站所有者的不同显示不同页面</li></ul><hr><h1 id="行为型设计模式：11种"><a href="#行为型设计模式：11种" class="headerlink" title="行为型设计模式：11种"></a>行为型设计模式：11种</h1><p>模板方法模式（Template Method）：</p><ul><li>描述：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤</li><li>关键实现：客户端抽象类类型的具体类对象调用抽象类的模板方法：定义多个步骤方法的组合内容和执行时序（（算法）模板，不变化行为）-&gt;调用抽象类的步骤方法-&gt;调用具体类的步骤方法（具体步骤实现，变化行为）（面向对象的多态特性）</li><li><strong>类比：</strong> 房屋建造的步骤和时序固定：先打地基，后建墙壁，打地基的方式，墙壁类型的选择不固定</li></ul><p>策略模式（Strategy）：</p><ul><li>描述：定义了算法家族，分别封装起来，让它们之间可以互相替换，让算法的变化，不会影响到使用算法的客户</li><li>关键实现：客户端上下文类对象调用上下文类的方法-&gt;抽象策略类类型的具体策略类对象调用具体策略类的方法（多态特性，同系列不同类型算法）</li><li>相关内容：在上下文类中使用简单工厂模式判断并创建抽象策略类类型的具体策略类对象</li><li><strong>类比：</strong> 陆上交通方式可以选择自行车、公交车或出租车</li></ul><p>职责链模式（Chain of Responsibility）</p><ul><li>描述：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止</li><li>关键实现：客户端抽象处理类类型的具体处理类对象A调用设置抽象处理类类型的具体处理类对象B为字段方法（指定下个处理者），A调用具体处理类的具体处理方法：处理请求（当前处理者有权处理），或B调用具体处理类的具体处理方法(当前处理者无权处理，交付给下个处理者处理）</li><li><strong>类比：</strong> 联系客户服务询问电脑问题，若自动服务的方法无效就转接人工服务</li></ul><p>状态模式（State）：</p><ul><li>描述：当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类</li><li>关键实现：客户端上下文类对象A调用设置方法：参数接收抽象状态类类型的具体状态类对象B（当前状态，设置当前状态），A调用请求方法-&gt;B调用处理方法：参数发送A（this）-&gt;调用其他抽象状态类类型的具体状态类的构造方法创建抽象状态类类型的具体状态类对象C设置A（新状态，设置新状态）</li><li>理解：有上下文类对象A，抽象状态类类型的具体状态类对象B（当前状态）和其他抽象状态类类型的具体状态类对象C（新状态）。A设置当前状态为B：A持有B，A修改状态-&gt;<strong>B处理状态：B持有A-&gt;B设置A的新状态为C：A持有C</strong>（A字段B的改变委托给B修改成C）</li><li>其他：相对复杂的状态转换条件表达式-&gt;相对简单的不同状态类；运行时动态修改状态行为</li><li><strong>类比：</strong> 手机在锁定状态时， 按键解锁，手机在解锁状态时， 按键执行功能</li></ul><p>命令模式（Command）：</p><ul><li>描述：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作</li><li>关键实现：客户端抽象命令类类型的具体命令类对象B调用具体命令类的设置接收者类对象C为字段方法，发送者类对象A调用发送者类的设置抽象命令类类型的具体命令类对象B为字段方法，A调用发送者类的方法-&gt;B调用具体命令类的方法-&gt;C调用接收者类的方法（发送者类委托命令类，命令类委托接收者类；反向创建，正向通知）</li><li>相关内容：有记录、查找、撤销和重做操作的命令表&#x2F;日志</li><li><strong>类比：</strong> 顾客点餐到订单，服务员记录订单并通知厨师，厨师依据订单做餐</li></ul><p>观察者模式（Observer）：</p><ul><li>描述：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新</li><li>关键实现：客户端具体目标类对象A调用状态设置方法（状态改变），A调用通知方法（发送通知）-&gt;遍历抽象观察者类类型的具体观察者类对象B集合字段-&gt;B调用具体观察者类的更新方法（接收通知并自动更新）（目标通知观察者更新过程）</li><li><strong>类比：</strong> 客户订阅报纸，出版社发布新一期报纸时通知客户</li></ul><p>备忘录模式（Memento）：</p><ul><li>描述：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态</li><li>关键实现：客户端发起者类对象A调用创建备忘录方法-&gt;创建备忘录类对象B记录状态-&gt;B保存在管理者类对象C（保存记录），A调用恢复备忘录方法-&gt;从C获取B恢复状态（恢复记录）</li><li>类型：基于嵌套类的实现，基于接口的实现</li><li>相关内容：事务回滚&#x2F;命令模式（Command）的撤销操作-&gt;备忘录模式（Memento）</li><li><strong>类比：</strong> 游戏进度的保存和恢复</li></ul><p>迭代器模式（Iterator）：</p><ul><li>描述：提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示</li><li>关键实现：客户端当前具体集合类对象A调用具体集合类的具体创建迭代器方法创建抽象迭代器类类型的具体迭代器类对象B：参数发送A（this）（一个集合有多个迭代器，每个迭代器都持有集合），B调用具体迭代器类的具体获取起始对象方法和具体获取下个对象方法-&gt;A调用具体集合类的具体获取起始对象方法和具体获取下个对象方法（迭代器从集合中获取起始迭代器和下个迭代器）</li><li>其他：部分编程语言已封装实现迭代&#x2F;遍历接口</li><li><strong>类比：</strong> 旅游向导带领旅客依次参观各个景点</li></ul><p>解释器模式（Interpreter）：</p><ul><li>描述：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子</li><li>关键实现：客户端抽象表达式类类型的非终结符表达式类对象（树枝）调用非终结符表达式类的具体解释方法-&gt;抽象表达式类类型的终结符表达式类对象（树叶）调用具体解释方法：参数接收上下文类对象，执行相关操作（反向创建：先创建树枝，后创建树叶；正向解释：先解释树枝，后解释树叶；可能是树状递归的解释方式）</li><li><strong>类比：</strong> 客户语音命令音箱播放音乐，音箱解释器将语音解释成信息，将信息解释成指令并完成任务</li></ul><p>中介者模式（Mediator）：</p><ul><li>描述：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互</li><li>关键实现：客户端当前具体组件类对象A和其他具体组件类对象C调用抽象组件类的设置抽象中介者类类型的具体中介者类对象为字段方法（组件A和组件C认识中介者B），具体中介者类对象B调用具体中介者类的设置具体组件类对象为字段方法（B认识A和C），A调用具体组件类的具体发送方法：参数接收信息（A发送信息）-&gt;B调用具体中介者类的具体通知方法：参数接收A（this）和信息（A委托B发送通知）-&gt;C调用具体组件类的具体接收方法：参数接收信息（C接收B的通知）</li><li>理解：有组件A，中介者B，组件C。A和C认识B，B认识A和C，A发送信息-&gt;A委托B发送通知-&gt;C接收B的通知</li><li><strong>类比：</strong> 当前用户通过手机和网络发送信息，其他用户通过手机和网络接收信息</li></ul><p>访问者模式（Visitor）：</p><ul><li>描述：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作</li><li>关键实现：客户端对象结构类对象A调用对象结构类的接收方法：参数接收抽象访问者类类型的具体访问者类对象B，遍历抽象元素类类型的具体元素类对象C集合-&gt;C调用具体元素类的接收方法：参数接收B-&gt;B调用具体访问者类的访问方法，参数接收C（this），使用C执行相关操作</li><li>理解：B的访问过程：客户端-&gt;A（第一次分派）-&gt;C-&gt;B（第二次分派），B使用C</li><li>相关内容：双分派</li><li><strong>类比：</strong> 保险推销员依据建筑物类型提供不同保单：为居民楼推销医疗保险，为银行推销失窃保险</li><li>类比理解：稳定的数据结构：医疗保险和失窃保险，变化的算法&#x2F;行为&#x2F;访问者：居民楼和银行。访问者访问：保险推销员依据建筑物类型（第一次分派），提供不同保单（保单中信息和建筑物类型相关）（第二次分派）</li></ul><hr><h1 id="设计模式的记忆方式-总结"><a href="#设计模式的记忆方式-总结" class="headerlink" title="设计模式的记忆方式&#x2F;总结"></a>设计模式的记忆方式&#x2F;总结</h1><p>面向对象特性的体现：</p><ul><li>所有设计模式都基于面向对象，都体现封装特性</li><li>单例模式（Singleton），外观模式（Facade），备忘录模式（Memento）未体现继承和多态特性</li></ul><p>创建型设计模式的简单复杂性：</p><ul><li>相对简单：单例模式（Singleton），简单工厂模式（Simple Factory），原型模式（Prototype）</li><li>相对不简单不复杂：工厂方法模式（Factory Method）</li><li>相对复杂：抽象工厂模式（Abstract Factory），建造者模式（Builder）</li></ul><p>结构型设计模式的简单复杂性：</p><ul><li>相对简单：代理模式（Proxy），适配器模式（Adapter），外观模式（Facade）</li><li>相对不简单不复杂：组合模式（Composite），桥接模式（Bridge）</li><li>相对复杂：装饰模式（Decorator），享元模式（Flyweight）</li></ul><p>行为型设计模式的简单复杂性：</p><ul><li>相对简单：模板方法模式（Template Method），策略模式（Strategy），备忘录模式（Memento）</li><li>相对不简单不复杂：职责链模式（Chain of Responsibility），命令模式（Command），观察者模式（Observer），迭代器模式（Iterator），解释器模式（Interpreter）</li><li>相对复杂：状态模式（State），中介者模式（Mediator），访问者模式（Visitor）</li></ul><p>创建型设计模式的关系：</p><ul><li>三工厂：简单工厂模式（Simple Factory），工厂方法模式（Factory Method），抽象工厂模式（Abstract Factory）</li></ul><p>结构型设计模式的关系：</p><ul><li>结构型设计模式中除享元模式（Flyweight），其他6种设计模式：代理模式（Proxy），适配器模式（Adapter），外观模式（Facade），装饰模式（Decorator），桥接模式（Bridge）的关键实现相似：使用关联、聚合&#x2F;组合关系，职责委托</li><li>外观模式（Facade）侧重搭配不同行为方案；建造者模式（Builder）侧重相同过程建造不同产品</li><li>装饰模式（Decorator）侧重装饰过程不稳定&#x2F;灵活；建造者模式（Builder）侧重建造过程稳定</li><li>享元模式（Flyweight）和单例模式（Singleton）的关键实现类似</li><li>享元模式（Flyweight）侧重实例多个，不可变化；单例模式（Singleton）侧重实例一个，可变化</li></ul><p>行为型设计模式的关系：</p><ul><li>策略模式（Strategy）侧重多样表现的行为；简单工厂模式（Simple Factory）侧重多样实例的创建</li><li>策略模式（Strategy）使用关联、聚合&#x2F;组合关系，职责委托</li><li>策略模式（Strategy）侧重算法系列相同，类型不同；模板方法模式（Template Method）侧重算法过程相同，具体步骤实现不同</li><li>职责链模式（Chain of Responsibility）侧重委托传递；代理模式（Proxy）侧重职责委托</li><li>命令模式（Command）侧重发送者、命令和接收者三者间的委托传递，三者身份&#x2F;职责不同；职责链模式（Chain of Responsibility）侧重多者间的委托传递，多者地位&#x2F;权限不同，职责相似</li><li>观察者模式（Observer）侧重一个通知者发送通知，多个观察者接收通知并自动更新，通知者和观察者的行为关系浅、不相关：只是通知关系；命令模式（Command）侧重发送者、命令和接收者间的职责&#x2F;命令委托传递，三者的行为关系深、相关：为共同完成行为的命令关系</li><li>备忘录模式（Memento）侧重状态的记录和恢复；命令模式（Command）侧重命令的记录和传递</li><li>迭代器模式（Iterator）侧重分离集合对象的遍历行为；职责链模式（Chain of Responsibility）侧重委托的传递和处理</li><li>解释器模式（Interpreter）侧重分离解释行为，可能是树状递归的解释方式；组合模式（Composite）侧重处理组织结构，大多数是树状递归的组织结构</li><li>中介者模式（Mediator）侧重当前组件的消息通过中介者通知其他组件；观察者模式（Observer）侧重通知者的状态发生变化就通知观察者</li><li>访问者模式（Visitor）侧重分离稳定的数据结构和变化的算法&#x2F;行为&#x2F;访问者。算法访问数据结构（第一次分派），依据数据结构执行相关操作（第二次分派）；状态模式（State）侧重状态变化，状态互相知道其他存在；策略模式（Strategy）侧重策略选择，策略互相不知道其他存在</li></ul><hr><h1 id="架构模式简述"><a href="#架构模式简述" class="headerlink" title="架构模式简述"></a>架构模式简述</h1><ul><li>模型视图控制器模式（MVC）是多种设计模式（组合模式（Composite），策略模式（Strategy）和观察者模式（Observer））的综合应用，归为架构模式</li><li>典型三层架构：表示层，业务逻辑层，数据访问层</li><li>客户机&#x2F;服务器（C&#x2F;S）架构，浏览器&#x2F;服务器（B&#x2F;S）架构，客户机&#x2F;服务器（C&#x2F;S）和浏览器&#x2F;服务器（B&#x2F;S）混合架构</li></ul><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>设计模式总结。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《大话设计模式》作者：程杰</li><li><a href="https://refactoringguru.cn/design-patterns">常用设计模式有哪些？ (refactoringguru.cn)</a></li><li><a href="https://blog.csdn.net/m0_62083249/article/details/126137824">设计模式概述_夜悊的博客-CSDN博客</a></li><li><a href="https://blog.csdn.net/m0_62083249/article/details/126052943">创建型设计模式总结_夜悊的博客-CSDN博客</a></li><li><a href="https://blog.csdn.net/m0_62083249/article/details/126156063">结构型设计模式总结_夜悊的博客-CSDN博客</a></li><li><a href="https://blog.csdn.net/m0_62083249/article/details/126137029">行为型设计模式总结_夜悊的博客-CSDN博客</a></li><li><a href="https://blog.csdn.net/qq_31367877/article/details/90980401">依赖、关联、聚合和组合之间区别_木易不是楊的博客-CSDN博客_关联和聚合的区别</a></li><li><a href="https://m.php.cn/faq/470016.html">设计模式六大原则是什么-常见问题-PHP中文网</a></li><li><a href="https://zhuanlan.zhihu.com/p/243262388">GoF设计模式(十五)：Interpreter Pattern 解释器模式 - 知乎 (zhihu.com)</a></li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>行为型设计模式总结</title>
      <link href="/2022/08/21/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
      <url>/2022/08/21/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>行为型设计模式总结。</p><hr><h1 id="模板方法模式（Template-Method）"><a href="#模板方法模式（Template-Method）" class="headerlink" title="模板方法模式（Template Method）"></a>模板方法模式（Template Method）</h1><p>描述：</p><ul><li>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤</li></ul><p>结构：</p><ul><li>抽象类</li><li>具体类——与抽象类是继承关系</li></ul><p>概述：</p><ul><li>抽象类：步骤方法，模板方法</li><li>模板方法：定义多个步骤方法的组合内容和执行时序——（算法）模板，不变化行为</li><li>具体类：重写抽象类的步骤方法——具体步骤实现，变化行为</li><li>客户端：创建抽象类类型的具体类对象，抽象类类型的具体类对象调用抽象类的模板方法</li></ul><p>核心：</p><ul><li>继承</li><li>多态</li><li>模板方法：定义多个步骤方法的组合内容和执行时序——（算法）模板，不变化行为</li><li>具体类重写抽象类的步骤方法——具体步骤实现，变化行为</li><li>算法过程相同，具体步骤实现步骤不同</li><li><strong>类比：</strong> 房屋建造的步骤和时序固定：先打地基，后建墙壁，打地基的方式，墙壁类型的选择不固定</li></ul><hr><h1 id="策略模式（Strategy）"><a href="#策略模式（Strategy）" class="headerlink" title="策略模式（Strategy）"></a>策略模式（Strategy）</h1><p>描述：</p><ul><li>定义了算法家族，分别封装起来，让它们之间可以互相替换，让算法的变化，不会影响到使用算法的客户</li></ul><p>结构：</p><ul><li>抽象策略类</li><li>具体策略类——与抽象策略类是继承关系</li><li>上下文类——与抽象策略类是聚合关系</li></ul><p>概述：</p><ul><li>抽象策略类：抽象方法</li><li>具体策略类：重写抽象策略类的抽象方法为具体方法</li><li>上下文类：抽象策略类类型的具体策略类对象字段，设置抽象策略类类型的具体策略类对象为字段方法，方法</li><li>设置抽象策略类类型的具体策略类对象为字段方法：设置抽象策略类类型的具体策略类对象为字段</li><li>方法：抽象策略类类型的具体策略类对象调用具体策略类的具体方法</li><li>客户端：创建具体策略类对象和上下文类对象，上下文类对象调用设置抽象策略类类型的具体策略类对象为字段方法，调用上下文类的方法</li></ul><p><strong>策略模式（Strategy）和简单工厂模式（Simple Factory）的区别：</strong></p><ul><li>策略模式（Strategy）在客户端创建抽象策略类类型的具体策略类对象和上下文类对象；简单工厂模式（Simple Factory）在客户端简单工厂类的静态方法中判断并创建抽象产品类类型的具体产品类对象</li><li>策略模式（Strategy）侧重多样表现的行为；简单工厂模式（Simple Factory）侧重多样实例的创建</li></ul><p><strong>策略模式（Strategy）和模板方法模式（Template Method）的区别：</strong></p><ul><li>策略模式（Strategy）侧重算法系列相同，类型不同；模板方法模式（Template Method）侧重算法过程相同，具体步骤实现步骤不同</li></ul><p>核心：</p><ul><li>继承</li><li>多态</li><li>算法系列相同，类型不同</li><li><strong>类比：</strong> 陆上交通方式可以选择自行车、公交车或出租车</li></ul><hr><h1 id="职责链模式（Chain-of-Responsibility）"><a href="#职责链模式（Chain-of-Responsibility）" class="headerlink" title="职责链模式（Chain of Responsibility）"></a>职责链模式（Chain of Responsibility）</h1><p>别名：</p><ul><li>责任链模式</li><li>命令链模式（Chain of Command&#x2F;CoR）</li></ul><p>描述：</p><ul><li>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止</li></ul><p>结构：</p><ul><li>抽象处理者类</li><li>具体处理者类——与抽象处理者是继承关系，与抽象处理者是聚合关系</li></ul><p>概述：</p><ul><li>抽象处理者类：抽象处理类类型的具体处理类对象字段</li><li>抽象处理者类：设置抽象处理类类型的具体处理类对象为字段方法，抽象处理方法</li><li>设置抽象处理类类型的具体处理类对象为字段方法：设置抽象处理类类型的具体处理类对象为字段</li><li>具体处理者类：重写抽血处理方法为具体处理方法</li><li>具体处理方法：处理请求——当前处理者有权处理，或抽象处理类类型的具体处理类对象调用具体处理方法——当前处理者无权处理，交付给下个处理者处理</li><li>客户端：创建抽象处理类类型的具体处理类对象，抽象处理类类型的具体处理类对象调用设置抽象处理类类型的具体处理类对象为字段方法——指定下个处理者，抽象处理类类型的具体处理类对象调用具体处理类的具体处理方法</li></ul><p>核心：</p><ul><li>继承</li><li>多态</li><li>职责委托和传递</li><li><strong>类比：</strong> 联系客户服务询问电脑问题，若自动服务的方法无效就转接人工服务</li></ul><hr><h1 id="状态模式（State）"><a href="#状态模式（State）" class="headerlink" title="状态模式（State）"></a>状态模式（State）</h1><p>描述：</p><ul><li>当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类</li></ul><p>结构：</p><ul><li>抽象状态类——与上下文类是关联关系</li><li>具体状态类——与抽象状态类是继承关系</li><li>上下文类——与抽象状态类是聚合关系</li></ul><p>概述：</p><ul><li>抽象状态类：抽象方法</li><li>具体状态类：重写抽象状态类的抽象方法为具体方法</li><li>具体方法：参数接收上下文类对象，调用其他具体状态类的构造方法设置抽象状态类类型的具体状态类对象为上下文类对象的字段——新状态</li><li>上下文类：抽象状态类类型的具体状态类对象字段——当前状态</li><li>上下文类：设置状态方法，处理状态方法</li><li>设置状态方法：参数接收抽象状态类类型的具体状态类对象——设置当前状态</li><li>处理状态方法：抽象状态类类型的具体状态类对象调用具体状态类的方法：参数发送当前上下文类对象（this）——设置新状态</li><li>客户端：创建抽象状态类类型的具体状态类对象——当前状态和上下文类对象，上下文类对象调用设置状态方法——设置当前状态，上下文类对象调用处理状态方法——设置新状态</li></ul><p><strong>状态模式（State）与策略模式（Strategy）的区别：</strong></p><ul><li>状态模式（State）侧重状态变化，状态互相知道其他存在；策略模式（Strategy）侧重策略选择，策略互相不知道其他存在</li></ul><p>核心：</p><ul><li>继承</li><li>多态</li><li>上下文类字段的改变委托给状态类修改</li><li>相对复杂的状态转换条件表达式-&gt;相对简单的不同状态类</li><li>运行时动态修改状态行为</li><li><strong>类比：</strong> 手机在锁定状态时， 按键解锁，手机在解锁状态时， 按键执行功能</li></ul><hr><h1 id="命令模式（Command）"><a href="#命令模式（Command）" class="headerlink" title="命令模式（Command）"></a>命令模式（Command）</h1><p>别名：</p><ul><li>动作模式（Action）</li><li>事务模式（Transaction）</li></ul><p>描述：</p><ul><li>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作</li></ul><p>结构：</p><ul><li>发送者类——与抽象命令类是聚合关系</li><li>抽象命令类</li><li>具体命令类——与抽象命令类是继承关系，与接收者类是关联关系</li><li>接收者类</li></ul><p>概述：</p><ul><li>发送者类：抽象命令类类型的具体命令类对象字段</li><li>发送者类：设置抽象命令类类型的具体命令类对象为字段方法，命令执行方法</li><li>设置抽象命令类类型的具体命令类对象为字段方法：设置抽象命令类类型的具体命令类对象为字段</li><li>命令执行方法：抽象命令类类型的具体命令类对象调用具体命令类的具体执行方法</li><li>抽象命令类：接收者类对象字段</li><li>抽象命令类：设置接收者类对象为字段方法，抽象执行方法</li><li>设置接收者类对象方法：设置接收者类对象为字段</li><li>具体命令类：重写抽象命令类的抽象执行方法为具体执行方法</li><li>具体执行方法：接收者类对象调用接收者类的执行方法</li><li>接收者类：执行方法</li><li>客户端：创建抽象命令类类型的具体命令类对象，创建接收者类对象，抽象命令类类型的具体命令类对象调用具体命令类的设置接收者类对象为字段方法，创建发送者类对象，发送者类对象调用发送者类的设置抽象命令类类型的具体命令类对象为字段方法，发送者类对象调用命令执行方法</li></ul><p>核心：</p><ul><li>继承</li><li>多态</li><li>发送者类委托命令类，命令类委托接收者类</li><li>反向创建，正向通知</li><li><strong>类比：</strong> 顾客点餐到订单，服务员记录订单并通知厨师，厨师依据订单做餐</li></ul><hr><h1 id="观察者模式（Observer）"><a href="#观察者模式（Observer）" class="headerlink" title="观察者模式（Observer）"></a>观察者模式（Observer）</h1><p>别称：</p><ul><li>监听者模式（Listener）</li><li>发布-订阅模式（Publish-Subscriber）</li><li>事件订阅者模式（Event-Subscriber）</li></ul><p>描述：</p><ul><li>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新</li></ul><p>结构：</p><ul><li>抽象目标类——与抽象观察者类是关联关系</li><li>具体目标类——与抽象目标类是继承关系</li><li>抽象观察者类</li><li>具体观察者类——与抽象观察者类是继承关系，与具体目标类是关联关系</li></ul><p>概述：</p><ul><li>抽象目标类：状态字段，状态设置方法，状态获取方法，抽象观察者类类型的具体观察者类对象集合字段，抽象观察者类类型的具体观察者类对象增加方法，抽象观察者类类型的具体观察者类对象减少方法，通知方法</li><li>状态设置方法：设置状态字段</li><li>状态获取方法：获取状态字段</li><li>抽象观察者类类型的具体观察者类对象增加方法：增加抽象观察者类类型的具体观察者类对象到集合字段</li><li>抽象观察者类类型的具体观察者类对象减少方法：减少抽象观察者类类型的具体观察者类对象到集合字段</li><li>通知方法：遍历抽象观察者类类型的具体观察者类对象集合字段，抽象观察者类类型的具体观察者类对象调用具体观察者类的更新方法（发送通知）</li><li>具体目标类可重写抽象目标类的方法</li><li>抽象观察者类：更新方法</li><li>具体观察者类：抽象目标类类型的具体目标类对象字段，设置状态抽象目标类类型的具体目标类对象字段为字段方法，重写抽象观察者类的更新方法为具体观察者类的具体更新方法</li><li>设置状态抽象目标类类型的具体目标类对象字段为字段方法：设置状态抽象目标类类型的具体目标类对象字段为字段</li><li>具体更新方法：抽象目标类类型的具体目标类对象调用具体目标类的状态获取方法（接收通知并自动更新）</li><li>客户端：创建抽象观察者类类型的具体观察者类对象和具体目标类对象，具体目标类对象调用抽象观察者类类型的具体观察者类对象增加方法，具体目标类对象调用状态设置方法（状态改变），具体目标类对象调用通知方法（目标通知观察者更新过程）</li></ul><p>核心：</p><ul><li>继承</li><li>多态</li><li>一个目标类发送通知，多个观察者类接收通知并自动更新</li><li><strong>类比：</strong> 客户订阅报纸，出版社发布新一期报纸时通知客户</li></ul><hr><h1 id="备忘录模式（Memento）"><a href="#备忘录模式（Memento）" class="headerlink" title="备忘录模式（Memento）"></a>备忘录模式（Memento）</h1><p>别名：</p><ul><li>快照模式（Snapshot）</li></ul><p>描述：</p><ul><li>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态</li></ul><p>结构：</p><ul><li>发起者类——与备忘录类是依赖关系</li><li>备忘录类</li><li>管理者类——与备忘录类是聚合关系</li></ul><p>概述：</p><ul><li>发起者：状态字段</li><li>发起者：设置状态方法，获取状态方法，创建备忘录方法，恢复备忘录方法</li><li>设置状态方法：设置状态字段</li><li>获取状态方法：返回状态字段</li><li>创建备忘录方法：参数发送发起者类对象的状态字段，创建备忘录类对象——保存记录</li><li>恢复备忘录方法：参数接收备忘录类对象，调用备忘录类对象的状态获取方法，设置发起者类对象的状态字段为备忘录类对象的状态字段——恢复记录</li><li>备忘录类：状态字段</li><li>备忘录类：设置状态方法，获取状态方法</li><li>设置状态方法：参数接收发起者类对象的状态字段，设置备忘录类对象的状态字段为发起者类对象的状态字段——保存记录</li><li>获取状态方法：返回备忘录类对象的状态字段——恢复记录</li><li>管理者类：备忘录类对象字段</li><li>管理者类：设置备忘录类对象方法，获取备忘录类对象方法</li><li>设置备忘录类对象方法：设置备忘录类对象字段——保存记录</li><li>获取备忘录类对象方法：返回备忘录类对象字段——恢复记录</li><li>客户端：创建发起者类对象，发起者类对象调用设置状态方法，发起者类对象调用创建备忘录方法——保存记录，创建管理者类对象，管理者类对象调用设置备忘录类对象方法——保存记录，发起者类对象调用设置状态方法——状态改变，管理者类对象调用获取备忘录对象方法——恢复记录，发起者类对象调用恢复备忘录方法——恢复记录</li></ul><p>类型：</p><ul><li>基于嵌套类的实现：支持嵌套类的编程语言，如C++、 C#和Java</li><li>基于接口的实现：不支持嵌套类的编程语言，如PHP</li></ul><p>核心：</p><ul><li>客户端发起者类对象A调用创建备忘录方法-&gt;创建备忘录类对象B记录状态-&gt;B保存在管理者类对象C——保存记录</li><li>A调用恢复备忘录方法-&gt;从C获取B恢复状态——恢复记录</li><li><strong>类比：</strong> 游戏进度的保存和恢复</li></ul><hr><h1 id="迭代器模式（Iterator）"><a href="#迭代器模式（Iterator）" class="headerlink" title="迭代器模式（Iterator）"></a>迭代器模式（Iterator）</h1><p>描述：</p><ul><li>提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示</li></ul><p>结构：</p><ul><li>抽象迭代器类</li><li>具体迭代器类——与抽象迭代器类是继承关系，与具体集合类是关联关系</li><li>抽象集合类</li><li>具体集合类——与抽象集合类是继承关系，与具体迭代器类是关联关系</li></ul><p>概述：</p><ul><li>抽象迭代器类：抽象获取起始对象方法，抽象获取下个对象方法</li><li>具体迭代器类：具体集合类对象字段，迭代位置字段</li><li>具体迭代器类：设置具体集合类对象方法，重写抽象获取起始对象方法为具体获取起始对象方法，重写抽象获取下个对象方法为具体获取下个对象方法</li><li>设置具体集合类对象方法：设置具体集合类对象为字段</li><li>具体获取起始对象方法：返回具体集合类对象中的起始对象</li><li>具体获取下个对象方法：依据迭代位置字段返回具体集合类对象中的下个对象</li><li>抽象集合类：抽象创建迭代器方法</li><li>具体集合类：抽象迭代器类类型的具体迭代器类对象集合字段</li><li>具体集合类：重写抽象创建迭代器方法为具体创建迭代器方法</li><li>具体创建迭代器方法：参数发送当前具体集合类对象（this）</li><li>客户端：创建具体集合类对象，具体集合类对象调用具体集合类的具体创建迭代器方法，创建抽象迭代器类类型的具体迭代器类对象（一个集合有多个迭代器，每个迭代器都持有集合），抽象迭代器类类型的具体迭代器类对象调用具体获取起始对象方法和具体获取下个对象方法（迭代器从集合中获取起始迭代器和下个迭代器）</li></ul><p>核心：</p><ul><li>继承</li><li>多态</li><li>分离集合对象的遍历行为</li><li><strong>类比：</strong> 旅游向导带领旅客依次参观各个景点</li></ul><hr><h1 id="解释器模式（Interpreter）"><a href="#解释器模式（Interpreter）" class="headerlink" title="解释器模式（Interpreter）"></a>解释器模式（Interpreter）</h1><p>描述：</p><ul><li>给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子</li></ul><p>结构：</p><ul><li>抽象表达式类——与上下文类是依赖关系</li><li>终结符表达式类——与抽象表达式类是继承关系</li><li>非终结符表达式类——与抽象表达式类是继承关系</li><li>上下文类对象</li></ul><p>概述：</p><ul><li>抽象表达式类：抽象解释方法</li><li>抽象解释方法：参数接收上下文类对象</li><li>终结符表达式类：重写抽象解释方法为具体解释方法</li><li>非终结符表达式类：重写抽象解释方法为具体解释方法</li><li>上下文类：信息字段，设置信息方法，获取信息方法</li><li>设置信息方法：设置信息字段</li><li>获取信息方法：返回信息字段</li><li>客户端：创建上下文类对象，上下文类对象调用设置信息方法，创建抽象表达式类类型的终结符表达式类对象（树叶）和抽象表达式类类型的非终结符表达式类对象（树枝）（反向创建：先创建树枝，后创建树叶），调用抽象表达式类类型的非终结符表达式类对象和抽象表达式类类型的终结符表达式类对象的具体解释方法（正向解释：先解释树枝，后解释树叶；树状递归的解释方式）</li></ul><p>核心：</p><ul><li>继承</li><li>多态</li><li>分离解释行为</li><li>可能是树状递归的解释方式</li><li><strong>类比：</strong> 客户语音命令音箱播放音乐，音箱解释器将语音解释成信息，将信息解释成指令并完成任务</li></ul><hr><h1 id="中介者模式（Mediator）"><a href="#中介者模式（Mediator）" class="headerlink" title="中介者模式（Mediator）"></a>中介者模式（Mediator）</h1><p>别名：</p><ul><li>调停者模式（Intermediary）</li><li>控制器模式（Controller）</li></ul><p>描述：</p><ul><li>用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互</li></ul><p>结构：</p><ul><li>抽象中介者类</li><li>具体中介者类——与抽象中介者类是继承关系，与具体组件者类是关联关系</li><li>抽象组件类——与抽象中介者类是关联关系</li><li>具体组件类：与抽象组件类是继承关系</li></ul><p>概述：</p><ul><li>抽象中介者类：抽象发送方法</li><li>具体中介者类：具体组件类对象字段</li><li>具体中介者类：设置具体组件类对象为字段方法，重写抽象通知方法为具体通知方法</li><li>设置具体组件类对象为字段方法：设置具体组件类对象为字段——中介者认识组件</li><li>具体通知方法：参数接收抽象组件类类型的具体组件类对象和信息，其他抽象组件类类型的具体组件类对象调用具体组件类的接收方法——其他组件接收中介者的通知</li><li>抽象组件类：抽象中介者类类型的具体中介者类对象字段</li><li>抽象组件类：设置抽象中介者类类型的具体中介者类对象为字段方法</li><li>设置抽象中介者类类型的具体中介者类对象为字段方法：设置抽象中介者类类型的具体中介者类对象为字段——组件认识中介者</li><li>具体组件类：具体发送方法，具体接收方法</li><li>具体发送方法：参数接收信息，抽象中介者类类型的具体中介者类对象调用具体中介者类的具体发送方法，参数发送当前具体组件类对象（this）和信息——当前组件委托中介者发送通知</li><li>客户端： 创建具体组件类对象和具体中介者类对象，具体组件类对象调用抽象组件类的设置抽象中介者类类型的具体中介者类对象为字段方法——组件认识中介者，具体中介者类对象调用具体中介者类的设置具体组件类对象为字段方法——中介者认识组件，当前具体组件类对象调用具体组件类的具体发送方法——当前组件委托中介者发送通知，其他组件接收中介者的通知</li></ul><p>核心：</p><ul><li>继承</li><li>多态</li><li><strong>类比：</strong> 当前用户通过手机和网络发送信息，其他用户通过手机和网络接收信息</li></ul><hr><h1 id="访问者模式（Visitor）"><a href="#访问者模式（Visitor）" class="headerlink" title="访问者模式（Visitor）"></a>访问者模式（Visitor）</h1><p>描述：</p><ul><li>表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作</li></ul><p>结构：</p><ul><li>抽象访问者类</li><li>具体访问者类——与抽象访问者类是继承关系</li><li>抽象元素类</li><li>具体元素类——与抽象元素类是继承关系</li><li>对象结构类——与抽象元素类是关联关系</li></ul><p>概述：</p><ul><li>抽象访问者类：抽象访问方法</li><li>具体访问者类：重写抽象访问方法为具体访问方法</li><li>具体访问方法：参数接收具体元素类对象，使用具体元素类对象</li><li>抽象元素类：抽象接收方法</li><li>具体元素类：重写抽象接收方法为具体接收方法</li><li>具体接收方法：参数接收抽象访问者类类型的具体访问者类对象，抽象访问者类类型的具体访问者类对象调用具体访问方法，参数发送当前具体元素类对象（this）——访问者访问</li><li>对象结构类：抽象元素类类型的具体元素类对象集合字段，增加抽象元素类类型的具体元素类对象为字段方法，减少抽象元素类类型的具体元素类对象为字段方法，接收方法</li><li>增加抽象元素类类型的具体元素类对象为字段方法：增加抽象元素类类型的具体元素类对象到集合字段</li><li>减少抽象元素类类型的具体元素类对象为字段方法：从集合字段减少抽象元素类类型的具体元素类对象</li><li>接收方法：参数接收抽象访问者类类型的具体访问者类对象，遍历抽象元素类类型的具体元素类对象集合字段，抽象元素类类型的具体元素类对象调用具体元素类的具体接收方法</li><li>客户端：创建对象结构类对象，创建具体元素类对象，对象结构类对象调用增加抽象元素类类型的具体元素类对象为字段方法，创建具体访问者类对象，对象结构类对象调用对象结构类的接收方法</li></ul><p>核心：</p><ul><li>继承</li><li>多态</li><li>分离稳定的数据结构和变化的算法（访问者）</li><li>双分派：算法访问数据结构（第一次分派），依据数据结构执行相关操作（第二次分派）</li><li><strong>类比：</strong> 保险推销员依据建筑物类型提供不同保单：为居民楼推销医疗保险，为银行推销失窃保险</li><li>类比理解：稳定的数据结构：医疗保险和失窃保险，变化的算法&#x2F;行为&#x2F;访问者：居民楼和银行。访问者访问：保险推销员依据建筑物类型（第一次分派），提供不同保单（保单中信息和建筑物类型相关）（第二次分派）</li></ul><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《大话设计模式》作者：程杰</li><li><a href="https://refactoringguru.cn/design-patterns">常用设计模式有哪些？ (refactoringguru.cn)</a></li><li><a href="https://zhuanlan.zhihu.com/p/243262388">GoF设计模式(十五)：Interpreter Pattern 解释器模式 - 知乎 (zhihu.com)</a></li></ul><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>行为型设计模式总结。</p><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“应用层”学习提纲</title>
      <link href="/2022/08/18/%E2%80%9C%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%9D%E5%AD%A6%E4%B9%A0%E6%8F%90%E7%BA%B2/"/>
      <url>/2022/08/18/%E2%80%9C%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%9D%E5%AD%A6%E4%B9%A0%E6%8F%90%E7%BA%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>计算机网络的知识抽象、晦涩、不易理解并记忆，在此对“应用层”一章中重点知识总结成提纲。</p><hr><h1 id="网络应用模型"><a href="#网络应用模型" class="headerlink" title="网络应用模型"></a>网络应用模型</h1><h2 id="网络应用的模型-模式"><a href="#网络应用的模型-模式" class="headerlink" title="网络应用的模型&#x2F;模式"></a>网络应用的模型&#x2F;模式</h2><ul><li>客户机&#x2F;服务器（C&#x2F;S）模型&#x2F;模式</li><li>对等方到对等方（P2P）模型&#x2F;模式</li></ul><hr><h2 id="基于客户机-服务器（C-S）模型-模式的应用"><a href="#基于客户机-服务器（C-S）模型-模式的应用" class="headerlink" title="基于客户机&#x2F;服务器（C&#x2F;S）模型&#x2F;模式的应用"></a>基于客户机&#x2F;服务器（C&#x2F;S）模型&#x2F;模式的应用</h2><ul><li>全球广域网&#x2F;万维网（Web）</li><li>文件传输协议（FTP）</li><li>远程登陆（TELNET）</li><li>电子邮件</li></ul><hr><h2 id="基于对等方到对等方（P2P）模型-模式的应用"><a href="#基于对等方到对等方（P2P）模型-模式的应用" class="headerlink" title="基于对等方到对等方（P2P）模型&#x2F;模式的应用"></a>基于对等方到对等方（P2P）模型&#x2F;模式的应用</h2><ul><li>PPlive</li><li>Bittorrent</li><li>电驴</li></ul><hr><h1 id="域名系统（DNS）"><a href="#域名系统（DNS）" class="headerlink" title="域名系统（DNS）"></a>域名系统（DNS）</h1><h2 id="域名系统（DNS）概述"><a href="#域名系统（DNS）概述" class="headerlink" title="域名系统（DNS）概述"></a>域名系统（DNS）概述</h2><ul><li>基于用户数据报协议（UDP），端口号：53</li><li>基于客户机&#x2F;服务器（C&#x2F;S）模型&#x2F;模式</li><li>联机分布式的数据库系统</li></ul><hr><h2 id="域名系统（DNS）的组成"><a href="#域名系统（DNS）的组成" class="headerlink" title="域名系统（DNS）的组成"></a>域名系统（DNS）的组成</h2><p>依据概念：</p><ul><li>层次域名空间</li><li>域名服务器</li><li>解析器</li></ul><hr><h2 id="顶级域名（TLD）的类型"><a href="#顶级域名（TLD）的类型" class="headerlink" title="顶级域名（TLD）的类型"></a>顶级域名（TLD）的类型</h2><ul><li>国家&#x2F;地区顶级域名（nTLD）</li><li>通用顶级域名（gTLD）</li><li>基础结构顶级域名&#x2F;反向顶级域名</li></ul><hr><h2 id="域名服务器的类型"><a href="#域名服务器的类型" class="headerlink" title="域名服务器的类型"></a>域名服务器的类型</h2><ul><li>根域名服务器：管理顶级域名：13个集群</li><li>顶级域名服务器：管理二级域名</li><li>授权&#x2F;权限域名服务器：主机登记，保存域名和网际协议（IP）地址的映射；可作为本地域名服务器</li><li>本地域名服务器：主机直接&#x2F;第一个查询</li></ul><hr><h2 id="域名解析的概念"><a href="#域名解析的概念" class="headerlink" title="域名解析的概念"></a>域名解析的概念</h2><ul><li>正向解析：域名-&gt;网际协议（IP）地址</li><li>反向解析：网际协议（IP）地址-&gt;域名</li></ul><hr><h2 id="域名解析的方式"><a href="#域名解析的方式" class="headerlink" title="域名解析的方式"></a>域名解析的方式</h2><ul><li>递归查询：不常用</li><li>递归和迭代结合查询：常用</li></ul><p>注意：域名服务器先查询缓存，后进一步查询；先保存缓存，后返回查询结果</p><hr><h2 id="递归查询的过程"><a href="#递归查询的过程" class="headerlink" title="递归查询的过程"></a>递归查询的过程</h2><p>依据路径：</p><ol><li>主机</li><li>本地域名服务器</li><li>根域名服务器</li><li>顶级域名服务器</li><li>授权&#x2F;权限域名服务器</li><li>顶级域名服务器</li><li>根域名服务器</li><li>本地域名服务器</li><li>主机</li></ol><hr><h2 id="递归和迭代结合查询的过程"><a href="#递归和迭代结合查询的过程" class="headerlink" title="递归和迭代结合查询的过程"></a>递归和迭代结合查询的过程</h2><ol><li>递归查询：主机向本地域名服务器查询，本地域名服务器代替主机进一步查询</li><li>迭代查询：本地域名服务器分别向根域名服务器、顶级域名服务器和授权&#x2F;权威域名服务器查询</li></ol><hr><h2 id="主机-网际协议（IP）地址-介质访问控制（MAC）地址和域名的映射关系"><a href="#主机-网际协议（IP）地址-介质访问控制（MAC）地址和域名的映射关系" class="headerlink" title="主机&#x2F;网际协议（IP）地址&#x2F;介质访问控制（MAC）地址和域名的映射关系"></a>主机&#x2F;网际协议（IP）地址&#x2F;介质访问控制（MAC）地址和域名的映射关系</h2><ul><li>多主机&#x2F;网际协议（IP）地址&#x2F;介质访问控制（MAC）地址——一域名：负载均衡</li><li>一主机&#x2F;网际协议（IP）地址&#x2F;介质访问控制（MAC）地址——多域名：虚拟主机</li></ul><hr><h1 id="文件传输协议（FTP）"><a href="#文件传输协议（FTP）" class="headerlink" title="文件传输协议（FTP）"></a>文件传输协议（FTP）</h1><h2 id="文件传输协议（FTP）概述"><a href="#文件传输协议（FTP）概述" class="headerlink" title="文件传输协议（FTP）概述"></a>文件传输协议（FTP）概述</h2><ul><li>基于传输控制协议（TCP），端口号：20、21和随机（数据连接使用被动模式（PASV））</li><li>基于客户机&#x2F;服务器（C&#x2F;S）模型&#x2F;模式</li></ul><hr><h2 id="文件传输协议（FTP）服务器进程的组成"><a href="#文件传输协议（FTP）服务器进程的组成" class="headerlink" title="文件传输协议（FTP）服务器进程的组成"></a>文件传输协议（FTP）服务器进程的组成</h2><ul><li>一个主进程&#x2F;控制进程：接收请求</li><li>多个从进程&#x2F;数据进程：处理请求</li></ul><hr><h2 id="文件传输协议（FTP）连接的类型"><a href="#文件传输协议（FTP）连接的类型" class="headerlink" title="文件传输协议（FTP）连接的类型"></a>文件传输协议（FTP）连接的类型</h2><ul><li>控制连接：端口号：21；带外传输；最先建立，最后释放</li><li>数据连接：端口号：20和随机（使用被动模式（PASV））</li></ul><hr><h2 id="文件传输协议（FTP）数据连接的工作模式"><a href="#文件传输协议（FTP）数据连接的工作模式" class="headerlink" title="文件传输协议（FTP）数据连接的工作模式"></a>文件传输协议（FTP）数据连接的工作模式</h2><ul><li>主动模式（PORT）：客户机开放随机端口，服务器连接客户机</li><li>被动模式（PASV）：服务器开放随机端口，客户机连接服务器（注意不一定使用20端口号）</li></ul><hr><h1 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h1><h2 id="电子邮件概述"><a href="#电子邮件概述" class="headerlink" title="电子邮件概述"></a>电子邮件概述</h2><ul><li>异步通信</li></ul><hr><h2 id="电子邮件系统的组成"><a href="#电子邮件系统的组成" class="headerlink" title="电子邮件系统的组成"></a>电子邮件系统的组成</h2><ul><li>用户代理（UA）：如Outlook，Foxmail</li><li>协议</li><li>邮件服务器：基于客户机&#x2F;服务器（C&#x2F;S）模型&#x2F;模式</li></ul><p>协议：</p><ul><li>邮件发送协议：如简单邮件传输协议（SMTP）：“推”通信方式</li><li>邮件接收&#x2F;读取协议：如邮局协议版本3（POP3），网际消息访问协议（IMAP）：“拉”通信方式</li><li>基于万维网（WWW）的电子邮件使用超文本传输协议（HTTP）发送和接收</li></ul><hr><h2 id="电子邮件系统的传输过程"><a href="#电子邮件系统的传输过程" class="headerlink" title="电子邮件系统的传输过程"></a>电子邮件系统的传输过程</h2><p>依据路径：</p><ol><li>发件人</li><li>发送端用户代理</li><li>发送端邮件服务器的缓存</li><li>网络</li><li>接收端邮件服务器的收件箱</li><li>接收端用户代理</li><li>收件人</li></ol><hr><h2 id="简单邮件传输协议（SMTP）概述"><a href="#简单邮件传输协议（SMTP）概述" class="headerlink" title="简单邮件传输协议（SMTP）概述"></a>简单邮件传输协议（SMTP）概述</h2><ul><li>基于传输控制协议（TCP），端口号：25</li><li>基于客户机&#x2F;服务器（C&#x2F;S）模型&#x2F;模式</li></ul><hr><h2 id="简单邮件传输协议（SMTP）通信的过程"><a href="#简单邮件传输协议（SMTP）通信的过程" class="headerlink" title="简单邮件传输协议（SMTP）通信的过程"></a>简单邮件传输协议（SMTP）通信的过程</h2><ol><li>连接建立</li><li>邮件传送：命令：MAIL，RCPT，DATA</li><li>连接释放：命令：QUIT</li></ol><hr><h2 id="邮局协议版本3（POP3）概述"><a href="#邮局协议版本3（POP3）概述" class="headerlink" title="邮局协议版本3（POP3）概述"></a>邮局协议版本3（POP3）概述</h2><ul><li>基于传输控制协议（TCP），端口号：110</li><li>基于客户机&#x2F;服务器（C&#x2F;S）模型&#x2F;模式</li></ul><hr><h2 id="邮局协议版本3（POP3）的工作方式"><a href="#邮局协议版本3（POP3）的工作方式" class="headerlink" title="邮局协议版本3（POP3）的工作方式"></a>邮局协议版本3（POP3）的工作方式</h2><ul><li>下载并保留</li><li>下载并删除</li></ul><hr><h2 id="网际消息访问协议（IMAP）的内容"><a href="#网际消息访问协议（IMAP）的内容" class="headerlink" title="网际消息访问协议（IMAP）的内容"></a>网际消息访问协议（IMAP）的内容</h2><ul><li>有关文件夹的操作</li><li>只接收邮件的部分内容</li></ul><hr><h2 id="电子邮件的格式"><a href="#电子邮件的格式" class="headerlink" title="电子邮件的格式"></a>电子邮件的格式</h2><ul><li>电子邮件&#x3D;信封+内容</li><li>内容&#x3D;首部+一个空行+主体</li><li>首部：相对固定</li><li>首部&#x3D;若干首部行</li><li>首部行&#x3D;关键字：如From、To和Subject+冒号+值</li><li>首部行的地址格式：收件人邮箱名&#x2F;用户名@邮箱所在主机的域名</li><li>主体：可变</li></ul><hr><h2 id="多用途网际邮件扩充（MIME）的内容"><a href="#多用途网际邮件扩充（MIME）的内容" class="headerlink" title="多用途网际邮件扩充（MIME）的内容"></a>多用途网际邮件扩充（MIME）的内容</h2><ul><li>增加邮件首部的关键字：5个</li><li>定义邮件内容的格式</li><li>定义传输的编码</li></ul><p>用途：</p><ul><li>简单邮件传输协议（SMTP）只能传输定长：7比特&#x2F;位（b）的ASCII码邮件</li><li>邮局协议版本3（POP3）只能传输ASCII码邮件</li><li>适应用户能传输非ASCII码邮件，如图像、音频和视频</li></ul><hr><h1 id="万维网（WWW）"><a href="#万维网（WWW）" class="headerlink" title="万维网（WWW）"></a>万维网（WWW）</h1><h2 id="万维网（WWW）概述"><a href="#万维网（WWW）概述" class="headerlink" title="万维网（WWW）概述"></a>万维网（WWW）概述</h2><ul><li>基于客户机&#x2F;服务器（C&#x2F;S）模型&#x2F;模式</li><li>联机分布式的信息&#x2F;资源&#x2F;文档存储空间</li><li>网络站点和网页的集合</li><li>被包含于因特网&#x2F;组成因特网</li></ul><hr><h2 id="万维网（WWW）的组成"><a href="#万维网（WWW）的组成" class="headerlink" title="万维网（WWW）的组成"></a>万维网（WWW）的组成</h2><ul><li>超文本标记语言（HTML）</li><li>统一资源定位符（URL）</li><li>超文本传输协议（HTTP）</li></ul><hr><h2 id="统一资源定位符（URL）的格式"><a href="#统一资源定位符（URL）的格式" class="headerlink" title="统一资源定位符（URL）的格式"></a>统一资源定位符（URL）的格式</h2><p>协议:&#x2F;&#x2F;主机:端口&#x2F;路径</p><ul><li>协议：如文件传输协议（FTP），超文本传输协议（HTTP）</li><li>主机：信息&#x2F;资源&#x2F;文档的域名或网际协议（IP）地址</li><li>端口：可省略</li><li>路径：可省略</li></ul><hr><h2 id="获取信息-资源-文档的过程"><a href="#获取信息-资源-文档的过程" class="headerlink" title="获取信息&#x2F;资源&#x2F;文档的过程"></a>获取信息&#x2F;资源&#x2F;文档的过程</h2><ol><li>用户在浏览器点击链接</li><li>浏览器分析链接的统一资源定位符（URL）</li><li>浏览器向域名系统（DNS）请求域名解析</li><li>域名系统（DNS）向浏览器响应域名解析</li><li>浏览器与万维网（WWW）服务器建立连接</li><li>浏览器向万维网（WWW）服务器请求</li><li>万维网（WWW）服务器向浏览器响应</li><li>浏览器与万维网（WWW）服务器释放连接</li><li>浏览器向用户解释&#x2F;渲染并显示信息&#x2F;资源&#x2F;文档</li></ol><hr><h2 id="超文本传输协议（HTTP）概述"><a href="#超文本传输协议（HTTP）概述" class="headerlink" title="超文本传输协议（HTTP）概述"></a>超文本传输协议（HTTP）概述</h2><ul><li>基于传输控制协议（TCP），端口号：80</li><li>面向事务：定义信息&#x2F;资源&#x2F;文档的格式&#x2F;规则</li><li>无连接：每次连接只处理一个请求，处理后断开连接——可使用持久连接</li><li>无状态：每次请求都是一个新的请求——使用Cookie+数据库记录状态</li><li>面向文本：消息格式的字段是ASCII码串</li></ul><hr><h2 id="超文本传输协议（HTTP）的连接方式"><a href="#超文本传输协议（HTTP）的连接方式" class="headerlink" title="超文本传输协议（HTTP）的连接方式"></a>超文本传输协议（HTTP）的连接方式</h2><ul><li>非持久连接（超文本传输协议版本1.0（HTTP&#x2F;1.0））</li><li>持久连接（超文本传输协议版本1.1（HTTP&#x2F;1.1）以上）：非流水线方式，流水线方式</li></ul><hr><h2 id="超文本传输协议（HTTP）消息的类型"><a href="#超文本传输协议（HTTP）消息的类型" class="headerlink" title="超文本传输协议（HTTP）消息的类型"></a>超文本传输协议（HTTP）消息的类型</h2><ul><li>请求：客户机-&gt;服务器</li><li>响应：服务器-&gt;客户机</li></ul><hr><h2 id="超文本传输协议（HTTP）消息的格式"><a href="#超文本传输协议（HTTP）消息的格式" class="headerlink" title="超文本传输协议（HTTP）消息的格式"></a>超文本传输协议（HTTP）消息的格式</h2><p>开始行：请求消息和响应消息不同</p><p>请求消息的开始行&#x2F;请求行：</p><ul><li>方法</li><li>空格</li><li>统一资源定位符（URL）</li><li>空格</li><li>版本</li><li>回车换行</li></ul><p>响应消息的开始行&#x2F;状态行：</p><ul><li>版本</li><li>空格</li><li>状态码</li><li>空格</li><li>短语</li><li>回车换行</li></ul><p>首部行：可有可无</p><ul><li>首部字段名</li><li>冒号</li><li>值</li><li>回车换行</li></ul><p>回车换行&#x2F;空行</p><p>实体主体：可有可无</p><hr><h2 id="应用层的协议"><a href="#应用层的协议" class="headerlink" title="应用层的协议"></a>应用层的协议</h2><ul><li>文件传输协议（FTP）：基于传输控制协议（TCP），端口号：20，21和随机</li><li>远程登录（TELNET）：基于传输控制协议（TCP），端口号：23</li><li>简单邮件传输协议（SMTP）：基于传输控制协议（TCP），端口号：25</li><li>域名系统（DNS）：基于用户数据报协议（UDP），端口号：53</li><li>简单文件传输协议（TFTP）：基于用户数据报协议（UDP），端口号：69</li><li>超文本传输协议（HTTP）：基于传输控制协议（TCP），端口号：80</li><li>邮局协议版本3（POP3）：基于传输控制协议（TCP），端口号：110</li><li>简单网络管理协议（SNMP）：基于用户数据报协议（UDP），端口号：161</li></ul><hr><h2 id="互联网、因特网和万维网（WWW）的关系"><a href="#互联网、因特网和万维网（WWW）的关系" class="headerlink" title="互联网、因特网和万维网（WWW）的关系"></a>互联网、因特网和万维网（WWW）的关系</h2><ul><li>互联网：多个计算机网络按照一定的通信协议相互连接而成的一个大型计算机网络</li><li>因特网：在美国国防部高级研究计划署（ARPA）网上发展而来的世界上最大的全球性互联网络</li><li>万维网（WWW）：联机分布式的信息&#x2F;资源&#x2F;文档存储空间，网络站点和网页的集合</li><li>互联网&gt;因特网&gt;万维网（WWW）</li><li>因特网&#x3D;万维网（WWW）+电子邮件+用户网络&#x2F;新闻组（Usenet）等</li><li>互联网&#x3D;因特网+其他计算机网络等</li></ul><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>计算机网络的知识抽象、晦涩、不易理解并记忆，在此对“应用层”一章中重点知识总结成提纲。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《2023年计算机网络考研复习指导》组编：王道论坛</li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“传输层”学习提纲</title>
      <link href="/2022/08/17/%E2%80%9C%E4%BC%A0%E8%BE%93%E5%B1%82%E2%80%9D%E5%AD%A6%E4%B9%A0%E6%8F%90%E7%BA%B2/"/>
      <url>/2022/08/17/%E2%80%9C%E4%BC%A0%E8%BE%93%E5%B1%82%E2%80%9D%E5%AD%A6%E4%B9%A0%E6%8F%90%E7%BA%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>计算机网络的知识抽象、晦涩、不易理解并记忆，在此对“传输层”一章中重点知识总结成提纲。</p><hr><h1 id="传输层提供的服务"><a href="#传输层提供的服务" class="headerlink" title="传输层提供的服务"></a>传输层提供的服务</h1><h2 id="传输层的功能"><a href="#传输层的功能" class="headerlink" title="传输层的功能"></a>传输层的功能</h2><ul><li>端到端通信（应用进程间的逻辑通信）（网络层是主机到主机通信）</li><li>复用和分用（网络层的复用和分用概念与之不同）</li><li>两种传输层协议：用户数据报协议（UDP）和传输控制协议（TCP）（网络层不能同时实现两种协议）</li><li>差错控制：检测数据报&#x2F;报文段的首部+数据（网络层只检测分组的首部）</li><li>流量控制（传输控制协议（TCP）实现）</li><li>拥塞控制（传输控制协议（TCP）实现）</li></ul><p>注意：</p><ul><li>传输层：端到端通信</li><li>网络层：主机到主机通信</li><li>数据链路层：点到点通信</li></ul><hr><h2 id="传输层、网络层和数据链路层的服务访问点（SAP）"><a href="#传输层、网络层和数据链路层的服务访问点（SAP）" class="headerlink" title="传输层、网络层和数据链路层的服务访问点（SAP）"></a>传输层、网络层和数据链路层的服务访问点（SAP）</h2><ul><li>传输层：端口</li><li>网络层：网际协议（IP）地址</li><li>数据链路层：介质访问控制（MAC）地址</li></ul><hr><h2 id="端口号的类型（依据端口号的范围）"><a href="#端口号的类型（依据端口号的范围）" class="headerlink" title="端口号的类型（依据端口号的范围）"></a>端口号的类型（依据端口号的范围）</h2><p>服务器使用的端口号：</p><ul><li>熟知端口号：0-1023</li><li>登记端口号：1024-49151</li></ul><p>客户端使用的端口号&#x2F;临时端口号：49152-65535</p><hr><h2 id="常用的熟知端口号"><a href="#常用的熟知端口号" class="headerlink" title="常用的熟知端口号"></a>常用的熟知端口号</h2><ul><li>文件传输协议（FTP）：数据连接：20，控制连接：21</li><li>远程登录（TELNET）：23</li><li>简单邮件传输协议（SMTP）：25</li><li>域名系统（DNS）：53</li><li>简单文件传输协议（TFTP）：69</li><li>超文本传输协议（HTTP）：80</li><li>简单网络管理协议（SNMP）：161</li></ul><hr><h2 id="套接字的组成"><a href="#套接字的组成" class="headerlink" title="套接字的组成"></a>套接字的组成</h2><ul><li>端口号——进程</li><li>网际协议（IP）地址——主机</li></ul><hr><h2 id="传输层提供的服务类型"><a href="#传输层提供的服务类型" class="headerlink" title="传输层提供的服务类型"></a>传输层提供的服务类型</h2><ul><li>无连接：用户数据报协议（UDP）</li><li>面向连接：传输控制协议（TCP）</li></ul><hr><h1 id="用户数据报协议（UDP）：面向报文"><a href="#用户数据报协议（UDP）：面向报文" class="headerlink" title="用户数据报协议（UDP）：面向报文"></a>用户数据报协议（UDP）：面向报文</h1><h2 id="用户数据报协议（UDP）的服务"><a href="#用户数据报协议（UDP）的服务" class="headerlink" title="用户数据报协议（UDP）的服务"></a>用户数据报协议（UDP）的服务</h2><p>相对网际协议（IP）服务增加：</p><ul><li>复用和分用</li><li>差错控制</li></ul><hr><h2 id="用户数据报协议（UDP）数据报的格式"><a href="#用户数据报协议（UDP）数据报的格式" class="headerlink" title="用户数据报协议（UDP）数据报的格式"></a>用户数据报协议（UDP）数据报的格式</h2><p>首部：8字节（B）</p><ul><li>源端口号：2字节（B）</li><li>目的端口号：2字节（B）</li><li>长度（首部+数据）：2字节（B）</li><li>校验和（校验用户数据报协议（UDP）数据报的首部+伪首部+数据）：2字节（B）</li></ul><p>数据</p><p>伪首部（只用于计算校验和而临时添加，既不向上递交也不向下传送）：12字节（B）</p><ul><li>源网际协议（IP）地址：4字节（B）</li><li>目的网际协议（IP）地址：4字节（B）</li><li>值0：1字节（B）</li><li>协议：值17：1字节（B）</li><li>用户数据报协议（UDP）数据报的长度：2字节（B）</li></ul><hr><h2 id="基于用户数据报协议（UDP）的应用"><a href="#基于用户数据报协议（UDP）的应用" class="headerlink" title="基于用户数据报协议（UDP）的应用"></a>基于用户数据报协议（UDP）的应用</h2><ul><li>域名系统（DNS）</li><li>简单文件传输协议（TFTP）</li><li>简单网络管理协议（SNMP）</li><li>实时传输协议（RTP）</li><li>客户端&#x2F;服务器模型</li><li>远程过程调用（RPC）</li><li>实时多媒体</li></ul><hr><h1 id="传输控制协议（TCP）：面向字节流"><a href="#传输控制协议（TCP）：面向字节流" class="headerlink" title="传输控制协议（TCP）：面向字节流"></a>传输控制协议（TCP）：面向字节流</h1><h2 id="传输控制协议（TCP）报文段的格式"><a href="#传输控制协议（TCP）报文段的格式" class="headerlink" title="传输控制协议（TCP）报文段的格式"></a>传输控制协议（TCP）报文段的格式</h2><p>首部：</p><ul><li>固定部分：20字节（B）</li><li>可变部分：4字节（B）的整数倍</li></ul><p>固定部分：</p><ul><li>源端口：2字节（B）</li><li>目的端口：2字节（B）</li><li>序号：4字节（B）：本传输控制协议（TCP）报文段的数据的第一个字节的序号</li><li>确认号：4字节（B）：期望传输控制协议（TCP）报文段的数据的第一个字节的序号</li><li>数据偏移&#x2F;首部长度：4比特&#x2F;位（b）：值的基本单位：4字节（B）</li><li>保留：6比特&#x2F;位（b）</li><li>标志位：6比特&#x2F;位（b）</li><li>窗口：2字节（B）</li><li>校验和（首部+数据）：4字节（B）</li><li>紧急指针：2字节（B）</li></ul><p>标志位：</p><ul><li>紧急位URG：1比特&#x2F;位（b）</li><li>确认位ACK：1比特&#x2F;位（b）</li><li>推送位PSH：1比特&#x2F;位（b）</li><li>复位位RST：1比特&#x2F;位（b）</li><li>同步位SYN：1比特&#x2F;位（b）</li><li>终止位FIN：1比特&#x2F;位（b）</li></ul><p>可变部分：</p><ul><li>选项：最大报文段长度（MSS）（数据）</li><li>填充</li></ul><p>数据</p><p>伪首部（只用于计算校验和而临时添加，既不向上递交也不向下传送）：12字节（B）</p><ul><li>源网际协议（IP）地址：4字节（B）</li><li>目的网际协议（IP）地址：4字节（B）</li><li>值0：1字节（B）</li><li>协议：值6：1字节（B）</li><li>传输控制协议（TCP）报文段的长度：2字节（B）</li></ul><hr><h2 id="传输控制协议（TCP）连接管理"><a href="#传输控制协议（TCP）连接管理" class="headerlink" title="传输控制协议（TCP）连接管理"></a>传输控制协议（TCP）连接管理</h2><p>模式：客户机&#x2F;服务器（C&#x2F;S）模式</p><p>过程：</p><ol><li>连接建立（三次握手）</li><li>数据传输</li><li>连接释放（四次挥手）</li></ol><p>注意：连接端点&#x2F;套接字，而不是点、主机和端（应用进程）</p><hr><h2 id="传输控制协议（TCP）连接建立（三次握手）的过程"><a href="#传输控制协议（TCP）连接建立（三次握手）的过程" class="headerlink" title="传输控制协议（TCP）连接建立（三次握手）的过程"></a>传输控制协议（TCP）连接建立（三次握手）的过程</h2><p>注释：</p><ul><li>SYN：同步位</li><li>ACK：确认位</li><li>seq：序号</li><li>ack：确认号</li></ul><ol><li>客户机：SYN&#x3D;1，seq&#x3D;x</li><li>服务器：SYN&#x3D;1，ACK&#x3D;1，seq&#x3D;y，ack&#x3D;x+1</li><li>客户机：ACK&#x3D;1，seq&#x3D;x+1，ack&#x3D;y+1</li></ol><hr><h2 id="传输控制协议（TCP）连接释放（四次挥手）的过程"><a href="#传输控制协议（TCP）连接释放（四次挥手）的过程" class="headerlink" title="传输控制协议（TCP）连接释放（四次挥手）的过程"></a>传输控制协议（TCP）连接释放（四次挥手）的过程</h2><p>注释：</p><ul><li>FIN：终止位</li><li>ACK：确认位</li><li>seq：序号</li><li>ack：确认号</li></ul><ol><li>客户机：FIN&#x3D;1，seq&#x3D;u</li><li>服务器：ACK&#x3D;1，seq&#x3D;v，ack&#x3D;u+1</li><li>服务器：FIN&#x3D;1，ACK&#x3D;1，seq&#x3D;w，ack&#x3D;u+1</li><li>客户机：ACK&#x3D;1，seq&#x3D;u+1，ack&#x3D;w+1</li></ol><hr><h2 id="传输控制协议（TCP）的可靠传输机制"><a href="#传输控制协议（TCP）的可靠传输机制" class="headerlink" title="传输控制协议（TCP）的可靠传输机制"></a>传输控制协议（TCP）的可靠传输机制</h2><ul><li>校验（与用户数据报协议（UDP）的校验机制同）</li><li>序号：对字节（B）编号</li><li>确认（默认是累积确认）：对传输控制协议（TCP）报文段确认</li><li>重传</li></ul><p>重传事件：</p><ul><li>冗余确认（ACK）-&gt;拥塞控制的快重传</li><li>超时</li></ul><hr><h2 id="传输控制协议（TCP）的流量控制机制"><a href="#传输控制协议（TCP）的流量控制机制" class="headerlink" title="传输控制协议（TCP）的流量控制机制"></a>传输控制协议（TCP）的流量控制机制</h2><ul><li>滑动窗口+拥塞控制：发送窗口上限值&#x3D;min[接收窗口（rwnd），拥塞窗口（cwnd）]</li></ul><hr><h2 id="传输控制协议（TCP）的拥塞控制机制-算法"><a href="#传输控制协议（TCP）的拥塞控制机制-算法" class="headerlink" title="传输控制协议（TCP）的拥塞控制机制&#x2F;算法"></a>传输控制协议（TCP）的拥塞控制机制&#x2F;算法</h2><p>慢开始算法中，初始拥塞窗口（cwnd）&#x3D;1&#x3D;最大传输控制协议（TCP）报文段长度（MSS）</p><ul><li>慢开始（指数增大）：拥塞窗口（cwnd）&lt;&#x3D;阈值&#x2F;门限（ssthresh）；拥塞窗口（cwnd）×2</li><li>拥塞避免（加法增大）：拥塞窗口（cwnd）&gt;&#x3D;阈值&#x2F;门限（ssthresh）；拥塞窗口（cwnd）+1</li><li>快重传：接收三个冗余确认（ACK）立即重传，不等待超时</li><li>快恢复</li></ul><p>网络拥塞处理（乘法减小）：</p><ol><li>阈值&#x2F;门限（ssthresh）&#x3D;拥塞窗口（cwnd）÷2</li><li>拥塞窗口（cwnd）&#x3D;1</li><li>执行慢开始算法</li></ol><p>快恢复算法过程：</p><ol><li>阈值&#x2F;门限（ssthresh）&#x3D;拥塞窗口（cwnd）÷2</li><li>拥塞窗口（cwnd）&#x3D;拥塞窗口（cwnd）÷2&#x2F;阈值&#x2F;门限（ssthresh）</li><li>执行拥塞避免算法</li></ol><p>总结：</p><ul><li>冗余确认（ACK）事件：快重传算法+快恢复算法</li><li>超时事件：慢开始算法+拥塞避免算法+网络拥塞处理</li></ul><hr><h2 id="基于传输控制协议（TCP）的应用"><a href="#基于传输控制协议（TCP）的应用" class="headerlink" title="基于传输控制协议（TCP）的应用"></a>基于传输控制协议（TCP）的应用</h2><ul><li>文件传输协议（FTP）</li><li>远程登录（TELNET）</li><li>简单邮件传输协议（SMTP）</li><li>超文本传输协议（HTTP）</li></ul><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>计算机网络的知识抽象、晦涩、不易理解并记忆，在此对“传输层”一章中重点知识总结成提纲。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《2023年计算机网络考研复习指导》组编：王道论坛</li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“网络层”学习提纲</title>
      <link href="/2022/08/16/%E2%80%9C%E7%BD%91%E7%BB%9C%E5%B1%82%E2%80%9D%E5%AD%A6%E4%B9%A0%E6%8F%90%E7%BA%B2/"/>
      <url>/2022/08/16/%E2%80%9C%E7%BD%91%E7%BB%9C%E5%B1%82%E2%80%9D%E5%AD%A6%E4%B9%A0%E6%8F%90%E7%BA%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>计算机网络的知识抽象、晦涩、不易理解并记忆，在此对“网络层”一章中重点知识总结成提纲。</p><hr><h1 id="网络层的功能"><a href="#网络层的功能" class="headerlink" title="网络层的功能"></a>网络层的功能</h1><h2 id="网络层的功能-1"><a href="#网络层的功能-1" class="headerlink" title="网络层的功能"></a>网络层的功能</h2><ul><li>异构网络互联</li><li>路由选择</li><li>分组转发</li><li>拥塞控制</li></ul><hr><h2 id="网络互联中继系统-中间设备的类型"><a href="#网络互联中继系统-中间设备的类型" class="headerlink" title="网络互联中继系统&#x2F;中间设备的类型"></a>网络互联中继系统&#x2F;中间设备的类型</h2><p>依据计算机网络传输控制协议&#x2F;网际协议（TCI&#x2F;IP）模型从上&#x2F;高到下&#x2F;底的层次：</p><ul><li>网络层以上：网关</li><li>网络层：路由器</li><li>数据链路层：网桥，交换机</li><li>物理层：中继器，转发器，集线器</li></ul><hr><h2 id="路由器的功能"><a href="#路由器的功能" class="headerlink" title="路由器的功能"></a>路由器的功能</h2><ul><li>路由选择</li><li>分组转发</li></ul><hr><h2 id="路由表的组成"><a href="#路由表的组成" class="headerlink" title="路由表的组成"></a>路由表的组成</h2><p>至少有：</p><ul><li>目的网络地址</li><li>子网掩码</li><li>下一跳地址</li><li>端口</li></ul><p>还有：</p><ul><li>度量值</li><li>距离</li><li>…</li></ul><hr><h2 id="网络层的层面"><a href="#网络层的层面" class="headerlink" title="网络层的层面"></a>网络层的层面</h2><ul><li>控制层面——路由选择</li><li>数据&#x2F;转发层面——分组转发</li></ul><hr><h2 id="软件定义网络（SDN）的层面"><a href="#软件定义网络（SDN）的层面" class="headerlink" title="软件定义网络（SDN）的层面"></a>软件定义网络（SDN）的层面</h2><ul><li>控制层面——集中式</li><li>数据&#x2F;转发层面——分布式</li></ul><hr><h2 id="拥塞控制的方式"><a href="#拥塞控制的方式" class="headerlink" title="拥塞控制的方式"></a>拥塞控制的方式</h2><ul><li>开环控制——静态，预防</li><li>闭环控制——动态，反馈</li></ul><hr><h2 id="网络层的协议"><a href="#网络层的协议" class="headerlink" title="网络层的协议"></a>网络层的协议</h2><ul><li>网际协议（IP）</li><li>网际&#x2F;因特网组管理协议（IGMP）</li><li>地址解析协议（ARP）</li><li>逆&#x2F;反向地址解析协议（RARP）</li><li>网际控制报文协议（ICMP）</li><li>开放最短路径优先（OSPF）协议</li></ul><p>注意：</p><ul><li>地址解析协议（ARP）工作在网络层，因为需要网际协议（IP）地址信息</li><li>网络地址转换（NAT）工作在传输层，因为需要端口信息</li><li>动态主机配置协议（DHCP）工作在应用层，因为使用客户机&#x2F;服务器（CS）模式；基于用户数据报协议（UDP），因为不知网际协议（IP）地址，无法建立传输控制协议（TCP）连接</li></ul><hr><h1 id="路由算法"><a href="#路由算法" class="headerlink" title="路由算法"></a>路由算法</h1><h2 id="路由算法的类型"><a href="#路由算法的类型" class="headerlink" title="路由算法的类型"></a>路由算法的类型</h2><ul><li>静态&#x2F;非自适应路由算法</li><li>动态&#x2F;自适应算法路由算法</li></ul><hr><h2 id="动态-自适应算法路由算法的类型"><a href="#动态-自适应算法路由算法的类型" class="headerlink" title="动态&#x2F;自适应算法路由算法的类型"></a>动态&#x2F;自适应算法路由算法的类型</h2><p>距离矢量&#x2F;向量路由算法：</p><ul><li>定期发送全局信息（本路由器知道的<strong>所有</strong>信息）给相邻结点</li><li>如：路由信息协议（RIP）</li></ul><p>链路状态路由算法：</p><ul><li>状态改变才发送局部信息（本路由器知道的<strong>相邻的</strong>所有路由器信息）给所有结点&#x2F;泛洪（不是广播）</li><li>使用迪杰斯特拉（Dijkstra）最短路径算法更新信息</li><li>如：开放最短路径优先（OSPF）协议</li></ul><p>路径向量（网络可达性信息，不只是下一跳地址）路由算法：</p><ul><li>状态改变才发送局部信息（状态改变的内容）给相邻结点</li><li>选择较好，而不是最佳路由</li><li>如：边界网关协议（BGP）</li></ul><p><strong>广播和泛洪的区别</strong>：</p><ul><li>广播：都发，自身（端口）也发</li><li>泛洪：除自身（端口）都发</li></ul><hr><h2 id="路由选择协议的类型"><a href="#路由选择协议的类型" class="headerlink" title="路由选择协议的类型"></a>路由选择协议的类型</h2><p>依据路由层次：</p><ul><li>内部网关协议（IGP）&#x2F;域内路由选择：如路由信息协议（RIP）和开放式最短路径优先（OSPF）协议</li><li>外部网关协议（EGP）&#x2F;域间路由选择：如边界网关协议（BGP）</li></ul><hr><h2 id="路由器交付的方式"><a href="#路由器交付的方式" class="headerlink" title="路由器交付的方式"></a>路由器交付的方式</h2><ul><li>直接交付：相同网段，不涉及路由器</li><li>间接交付：不同网段，涉及路由器；包含直接交付</li></ul><hr><h1 id="网际协议版本4（IPv4）"><a href="#网际协议版本4（IPv4）" class="headerlink" title="网际协议版本4（IPv4）"></a>网际协议版本4（IPv4）</h1><h2 id="网际协议版本4（IPv4）分组的格式"><a href="#网际协议版本4（IPv4）分组的格式" class="headerlink" title="网际协议版本4（IPv4）分组的格式"></a>网际协议版本4（IPv4）分组的格式</h2><p>首部：</p><ul><li>固定部分：20字节（B）</li><li>可变部分</li></ul><p>固定部分：</p><ul><li>版本：4比特位（b）</li><li>首部长度：4比特位（b）：内容的基本单位：4字节（B）</li><li>区分服务：8比特位（b）</li><li>总长度：16比特位（b）：内容的基本单位：1字节（B）</li><li>标识：16比特位（b）</li><li>标志：3比特位（b）</li><li>片偏移：13比特位（b）：内容的基本单位：8字节（B）</li><li>生存时间（TTL）：8比特位（b）</li><li>协议：8比特位（b）</li><li>首部校验和：16比特位（b）</li><li>源地址：16比特位（b）</li><li>目的地址：16比特位（b）</li></ul><p>数据：</p><ul><li>0-1480字节（B）——对以太网帧的最大传输单元（MTU）：1500字节（B）- 首部固定部分：20字节（B）</li></ul><hr><h2 id="网际协议版本4（IPv4）分组关于分片的字段"><a href="#网际协议版本4（IPv4）分组关于分片的字段" class="headerlink" title="网际协议版本4（IPv4）分组关于分片的字段"></a>网际协议版本4（IPv4）分组关于分片的字段</h2><ul><li>标识</li><li>标志：更多片（MF），不分片（DF）</li><li>片偏移：单位：8字节（B）</li></ul><hr><h2 id="网际协议版本4（IPv4）地址的类型"><a href="#网际协议版本4（IPv4）地址的类型" class="headerlink" title="网际协议版本4（IPv4）地址的类型"></a>网际协议版本4（IPv4）地址的类型</h2><ul><li>分类：网络号+主机号</li><li>分类+子网划分：网络号+子网号+主机号</li><li>无分类域间路由（CIDR）：网络前缀+主机号</li><li>无分类域间路由（CIDR）+子网划分：网络前缀+子网号+主机号</li></ul><blockquote><p>注意：子网划分和无分类域间路由（CIDR）不同</p></blockquote><hr><h2 id="分类的网际协议版本4（IPv4）地址"><a href="#分类的网际协议版本4（IPv4）地址" class="headerlink" title="分类的网际协议版本4（IPv4）地址"></a>分类的网际协议版本4（IPv4）地址</h2><ul><li>A类：1-126</li><li>B类：128-191</li><li>C类：192-223</li><li>D类：224-239：组播（部分不能作组播地址）</li><li>E类：240-255：保留</li></ul><p>特殊地址：</p><ul><li>主机号全0：本网络</li><li>主机号全1：本网络的广播地址&#x2F;直接广播地址</li><li>127.X.X.X：环回自检地址</li><li>32位全0：0.0.0.0：本网络中的本主机</li><li>32位全1：255.255.255.255：网络广播地址-&gt;本网络的广播地址&#x2F;受限广播地址</li></ul><p>网络地址转换（NAT）的私有网段：</p><ul><li>A类：10.0.0.0 - 10.255.255.255，1个</li><li>B类：172.16.0.0 - 172.<strong>31</strong>.255.255，16个</li><li>C类：192.168.0.0 - 192.168.255.255，256个</li></ul><hr><h2 id="网络地址转换（NAT）的映射项"><a href="#网络地址转换（NAT）的映射项" class="headerlink" title="网络地址转换（NAT）的映射项"></a>网络地址转换（NAT）的映射项</h2><p>四元组：</p><ul><li>私用地址：端口</li><li>公有地址：端口</li></ul><hr><h2 id="网际控制报文协议（ICMP）报文的类型"><a href="#网际控制报文协议（ICMP）报文的类型" class="headerlink" title="网际控制报文协议（ICMP）报文的类型"></a>网际控制报文协议（ICMP）报文的类型</h2><p>差错报告报文：</p><ul><li>路由重定向</li><li>参数问题</li><li>超时</li><li>源点抑制</li><li>终点不可达</li></ul><p>询问报文：</p><ul><li>回送请求和回答报文（常用）</li><li>时间戳请求和回答报文（常用）</li><li>地址掩码请求和回答报文</li><li>路由器询问和通告报文</li></ul><hr><h2 id="网际控制报文协议（ICMP）报文的应用"><a href="#网际控制报文协议（ICMP）报文的应用" class="headerlink" title="网际控制报文协议（ICMP）报文的应用"></a>网际控制报文协议（ICMP）报文的应用</h2><ul><li>分组网间探测（PING）：工作在应用层，直接使用网络层的网际控制报文协议（ICMP），未使用传输层的传输控制协议（TCP）和用户数据报协议（UDP）</li><li>Traceroute（UNIX）&#x2F;Tracert（Windows）：工作在网络层</li></ul><hr><h1 id="网际协议版本6（IPv6）"><a href="#网际协议版本6（IPv6）" class="headerlink" title="网际协议版本6（IPv6）"></a>网际协议版本6（IPv6）</h1><h2 id="解决网际协议（IP）地址耗尽的方式"><a href="#解决网际协议（IP）地址耗尽的方式" class="headerlink" title="解决网际协议（IP）地址耗尽的方式"></a>解决网际协议（IP）地址耗尽的方式</h2><ul><li>网络地址转换（NAT）</li><li>无分类域间路由（CIDR）</li><li>网际协议版本6（IPv6）——根本</li></ul><hr><h2 id="网际协议版本6（IPv6）地址的类型"><a href="#网际协议版本6（IPv6）地址的类型" class="headerlink" title="网际协议版本6（IPv6）地址的类型"></a>网际协议版本6（IPv6）地址的类型</h2><ul><li>单播</li><li>多播</li><li>任播：发送的目的是一组&#x2F;多个，接收只有一个</li></ul><hr><h2 id="网际协议版本4（IPv4）向网际协议版本6（IPv6）过渡的策略"><a href="#网际协议版本4（IPv4）向网际协议版本6（IPv6）过渡的策略" class="headerlink" title="网际协议版本4（IPv4）向网际协议版本6（IPv6）过渡的策略"></a>网际协议版本4（IPv4）向网际协议版本6（IPv6）过渡的策略</h2><ul><li>双协议栈技术：使用两协议</li><li>隧道技术：封装网际协议版本6（IPv6）在网际协议版本4（IPv4）中传输</li></ul><hr><h1 id="路由协议"><a href="#路由协议" class="headerlink" title="路由协议"></a>路由协议</h1><h2 id="路由选择协议的类型-1"><a href="#路由选择协议的类型-1" class="headerlink" title="路由选择协议的类型"></a>路由选择协议的类型</h2><p>依据路由层次：</p><ul><li>内部网关协议（IGP）&#x2F;域内路由选择：如路由信息协议（RIP）和开放式最短路径优先（OSPF）协议</li><li>外部网关协议（EGP）&#x2F;域间路由选择：如边界网关协议（BGP）</li></ul><hr><h2 id="常用的路由选择协议"><a href="#常用的路由选择协议" class="headerlink" title="常用的路由选择协议"></a>常用的路由选择协议</h2><ul><li>路由信息协议（RIP）：距离矢量&#x2F;向量路由选择协议；工作在应用层，基于用户数据报协议（UDP）（端口号：520）</li><li>开放最短路径优先（OSPF）协议：链路状态路由选择协议；工作在网络层</li><li>边界网关协议（BGP）：路径向量路由选择协议（路径较好，不是最佳）；工作在应用层，基于传输控制协议（TCP）</li></ul><hr><h2 id="开放最短路径优先（OSPF）协议分组的类型"><a href="#开放最短路径优先（OSPF）协议分组的类型" class="headerlink" title="开放最短路径优先（OSPF）协议分组的类型"></a>开放最短路径优先（OSPF）协议分组的类型</h2><p>依据基本操作&#x2F;工作方式顺序：</p><ul><li>问候</li><li>数据库描述</li><li>链路状态请求</li><li>链路状态更新</li><li>链路状态确认</li></ul><hr><h2 id="边界网关协议（BGP）协议分组的类型"><a href="#边界网关协议（BGP）协议分组的类型" class="headerlink" title="边界网关协议（BGP）协议分组的类型"></a>边界网关协议（BGP）协议分组的类型</h2><ul><li>打开</li><li>更新</li><li>保活</li><li>通知</li></ul><hr><h2 id="自治系统（AS）路由器的类型"><a href="#自治系统（AS）路由器的类型" class="headerlink" title="自治系统（AS）路由器的类型"></a>自治系统（AS）路由器的类型</h2><ul><li>区域内部路由器</li><li>区域边界路由器</li><li>自治系统（AS）边界路由器</li></ul><hr><h1 id="网际协议（IP）组播"><a href="#网际协议（IP）组播" class="headerlink" title="网际协议（IP）组播"></a>网际协议（IP）组播</h1><h2 id="网际协议（IP）组播的类型"><a href="#网际协议（IP）组播的类型" class="headerlink" title="网际协议（IP）组播的类型"></a>网际协议（IP）组播的类型</h2><ul><li>局域网硬件组播</li><li>因特网组播：包括局域网硬件组播</li></ul><hr><h2 id="组播路由算法的类型"><a href="#组播路由算法的类型" class="headerlink" title="组播路由算法的类型"></a>组播路由算法的类型</h2><ul><li>距离矢量&#x2F;向量路由算法</li><li>链路状态路由算法</li><li>协议无关的组播（PIM）路由算法</li></ul><hr><h1 id="移动网际协议（IP）"><a href="#移动网际协议（IP）" class="headerlink" title="移动网际协议（IP）"></a>移动网际协议（IP）</h1><h2 id="移动网际协议（IP）的功能实体"><a href="#移动网际协议（IP）的功能实体" class="headerlink" title="移动网际协议（IP）的功能实体"></a>移动网际协议（IP）的功能实体</h2><ul><li>移动结点：主&#x2F;本地地址（不变）+辅&#x2F;转交地址（可变）</li><li>归属&#x2F;本地代理：主要负责移动结点接收分组：主&#x2F;本地地址-&gt;辅&#x2F;转交地址</li><li>外埠&#x2F;外部代理：主要负责移动结点发送分组：辅&#x2F;转交地址-&gt;主&#x2F;本地地址</li></ul><hr><h2 id="移动网际协议（IP）的工作过程"><a href="#移动网际协议（IP）的工作过程" class="headerlink" title="移动网际协议（IP）的工作过程"></a>移动网际协议（IP）的工作过程</h2><ol><li>代理发现</li><li>注册：向归属&#x2F;本地代理注册</li><li>分组路由</li><li>注销：向归属&#x2F;本地代理注销</li></ol><p>另：</p><ul><li>移动结点接收分组：其他结点-&gt;归属&#x2F;本地代理-&gt;外埠&#x2F;外部代理-&gt;移动结点</li><li>移动结点发送分组：移动结点-&gt;外埠&#x2F;外部代理-&gt;归属&#x2F;本地代理-&gt;其他结点</li></ul><hr><h1 id="网络层设备"><a href="#网络层设备" class="headerlink" title="网络层设备"></a>网络层设备</h1><h2 id="域的类型"><a href="#域的类型" class="headerlink" title="域的类型"></a>域的类型</h2><ul><li>冲突域</li><li>广播域</li></ul><hr><h2 id="网络层的设备"><a href="#网络层的设备" class="headerlink" title="网络层的设备"></a>网络层的设备</h2><ul><li>路由器</li></ul><hr><h2 id="路由器的功能-1"><a href="#路由器的功能-1" class="headerlink" title="路由器的功能"></a>路由器的功能</h2><ul><li>路由选择：使用路由表</li><li>分组转发：使用转发表</li></ul><hr><h2 id="路由器的组成"><a href="#路由器的组成" class="headerlink" title="路由器的组成"></a>路由器的组成</h2><ul><li>路由选择&#x2F;控制部分：路由选择处理机：路由选择协议-&gt;路由表</li><li>分组转发&#x2F;数据部分：输入端口，交换结构：路由表-&gt;转发表，输出端口</li></ul><p>交换结构交换的方式：</p><ul><li>通过存储器</li><li>通过总线</li><li>通过网络</li></ul><hr><h2 id="路由表的组成-1"><a href="#路由表的组成-1" class="headerlink" title="路由表的组成"></a>路由表的组成</h2><p>至少有：</p><ul><li>目的网络地址</li><li>子网掩码</li><li>下一跳地址</li><li>端口</li></ul><p>还有：</p><ul><li>度量值</li><li>距离</li><li>…</li></ul><hr><h2 id="转发表（不是数据链路层的转发表）的组成"><a href="#转发表（不是数据链路层的转发表）的组成" class="headerlink" title="转发表（不是数据链路层的转发表）的组成"></a>转发表（不是数据链路层的转发表）的组成</h2><ul><li>目的地址</li><li>下一跳地址</li></ul><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>计算机网络的知识抽象、晦涩、不易理解并记忆，在此对“网络层”一章中重点知识总结成提纲。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《2023年计算机网络考研复习指导》组编：王道论坛</li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“数据链路层”学习提纲</title>
      <link href="/2022/08/14/%E2%80%9C%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E2%80%9D%E5%AD%A6%E4%B9%A0%E6%8F%90%E7%BA%B2/"/>
      <url>/2022/08/14/%E2%80%9C%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E2%80%9D%E5%AD%A6%E4%B9%A0%E6%8F%90%E7%BA%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>计算机网络的知识抽象、晦涩、不易理解并记忆，在此对“数据链路层”一章中重点知识总结成提纲。</p><hr><h1 id="数据链路层的功能"><a href="#数据链路层的功能" class="headerlink" title="数据链路层的功能"></a>数据链路层的功能</h1><h2 id="数据链路层的功能-1"><a href="#数据链路层的功能-1" class="headerlink" title="数据链路层的功能"></a>数据链路层的功能</h2><ul><li>为网络层提供服务</li><li>链路管理——主要用于面向连接服务</li><li>组帧（帧定界、帧同步、透明传输）</li><li>流量控制——不是特有功能</li><li>差错控制</li></ul><hr><h2 id="数据链路层为网络层提供的服务类型"><a href="#数据链路层为网络层提供的服务类型" class="headerlink" title="数据链路层为网络层提供的服务类型"></a>数据链路层为网络层提供的服务类型</h2><ul><li>无确认的无连接服务——用于以太网</li><li>有确认的无连接服务——用于无线网</li><li>有确认的面向连接服务（三阶段：数据链路建立，帧传输，数据链路释放）</li></ul><blockquote><p>有面向连接就有确认，不存在无确认的面向连接服务</p></blockquote><hr><h1 id="组帧"><a href="#组帧" class="headerlink" title="组帧"></a>组帧</h1><h2 id="组帧的方式"><a href="#组帧的方式" class="headerlink" title="组帧的方式"></a>组帧的方式</h2><ul><li>字符计数法</li><li>字符填充法</li><li>比特填充法——常用</li><li>违规编码法——常用</li></ul><hr><h1 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h1><h2 id="差错控制的编码类型"><a href="#差错控制的编码类型" class="headerlink" title="差错控制的编码类型"></a>差错控制的编码类型</h2><ul><li>检错编码：奇偶校验码，循环冗余（校验）码（CRC）&#x2F;多项式码</li><li>纠错编码：海明码</li></ul><blockquote><p>注意：循环冗余（校验）码（CRC）&#x2F;多项式码有纠错功能，但数据链路层只用检错功能：帧出错丢弃</p></blockquote><hr><h2 id="差错的类型"><a href="#差错的类型" class="headerlink" title="差错的类型"></a>差错的类型</h2><ul><li>位&#x2F;比特差错</li><li>帧差错</li></ul><hr><h2 id="位-比特差错的控制方式"><a href="#位-比特差错的控制方式" class="headerlink" title="位&#x2F;比特差错的控制方式"></a>位&#x2F;比特差错的控制方式</h2><ul><li>自动重传请求（ARQ）</li><li>前向纠错（FEC）</li></ul><hr><h2 id="帧差错的控制方式"><a href="#帧差错的控制方式" class="headerlink" title="帧差错的控制方式"></a>帧差错的控制方式</h2><ul><li>序号</li><li>定时器</li></ul><hr><h1 id="流量控制和可靠传输机制"><a href="#流量控制和可靠传输机制" class="headerlink" title="流量控制和可靠传输机制"></a>流量控制和可靠传输机制</h1><h2 id="流量控制的方式"><a href="#流量控制的方式" class="headerlink" title="流量控制的方式"></a>流量控制的方式</h2><ul><li>停止-等待&#x2F;停-等协议&#x2F; 滑动窗口协议（发送窗口&#x3D;1，接收窗口&#x3D;1）</li><li>滑动窗口协议</li></ul><hr><h2 id="可靠传输的方式"><a href="#可靠传输的方式" class="headerlink" title="可靠传输的方式"></a>可靠传输的方式</h2><ul><li>确认</li><li>超时重传&#x2F;自动重传请求（ARQ）：停止-等待&#x2F;停-等协议、后退N帧协议（GBN）、选择重传协议（SR）</li></ul><hr><h2 id="流量控制和可靠传输结合的方式"><a href="#流量控制和可靠传输结合的方式" class="headerlink" title="流量控制和可靠传输结合的方式"></a>流量控制和可靠传输结合的方式</h2><blockquote><p>注意：流量控制和可靠传输是不可分割、互相包含的关系</p></blockquote><ul><li>停止-等待&#x2F;停-等协议&#x2F;滑动窗口协议（发送窗口&#x3D;1，接收窗口&#x3D;1）+确认+超时重传&#x2F;自动重传请求（ARQ）的停止-等待&#x2F;停-等协议</li><li>滑动窗口协议（发送窗口&gt;1，接收窗口&#x3D;1）+确认+超时重传&#x2F;自动重传请求（ARQ）的后退N帧协议（GBN）</li><li>滑动窗口协议（发送窗口&gt;1&#x3D;接收窗口&gt;1）+确认+超时重传&#x2F;自动重传请求（ARQ）的选择重传协议（SR）</li></ul><hr><h1 id="介质访问控制"><a href="#介质访问控制" class="headerlink" title="介质访问控制"></a>介质访问控制</h1><h2 id="介质访问控制的方式"><a href="#介质访问控制的方式" class="headerlink" title="介质访问控制的方式"></a>介质访问控制的方式</h2><ul><li>信道划分——静态划分信道——多路复用技术</li><li>随机访问——动态划分信道</li><li>轮询访问——动态划分信道</li></ul><hr><h2 id="信道划分介质访问控制的方式"><a href="#信道划分介质访问控制的方式" class="headerlink" title="信道划分介质访问控制的方式"></a>信道划分介质访问控制的方式</h2><ul><li>频分复用（FDM）</li><li>时分复用（TDM），统计&#x2F;异步时分复用（STDM）</li><li>码分复用（CDM）</li><li>波分复用（WDM）——光的频分复用（FDM）</li></ul><p>实质：信道划分</p><hr><h2 id="随机访问介质访问控制的方式"><a href="#随机访问介质访问控制的方式" class="headerlink" title="随机访问介质访问控制的方式"></a>随机访问介质访问控制的方式</h2><p>随机访问介质访问控制协议&#x2F;争用型协议：</p><ul><li>附加连接在线夏威夷系统（ALOHA）协议</li><li>载波侦听多路访问（CSMA）协议</li><li>载波侦听多路访问&#x2F;碰撞检测（CSMA&#x2F;CD）协议</li><li>载波侦听多路访问&#x2F;碰撞避免（ CSMA&#x2F;CA）协议</li></ul><p>实质：信道争用，广播信道-&gt;点到点信道</p><hr><h2 id="附加连接在线夏威夷系统（ALOHA）协议的类型"><a href="#附加连接在线夏威夷系统（ALOHA）协议的类型" class="headerlink" title="附加连接在线夏威夷系统（ALOHA）协议的类型"></a>附加连接在线夏威夷系统（ALOHA）协议的类型</h2><ul><li>纯附加连接在线夏威夷系统（ALOHA）协议</li><li>时隙附加连接在线夏威夷系统（ALOHA）协议</li></ul><hr><h2 id="附加连接在线夏威夷系统（ALOHA）协议的机制"><a href="#附加连接在线夏威夷系统（ALOHA）协议的机制" class="headerlink" title="附加连接在线夏威夷系统（ALOHA）协议的机制"></a>附加连接在线夏威夷系统（ALOHA）协议的机制</h2><ul><li>确认</li><li>超时等待随机时间重传</li><li>碰撞等待随机时间重传</li></ul><hr><h2 id="载波侦听多路访问（CSMA）协议的类型"><a href="#载波侦听多路访问（CSMA）协议的类型" class="headerlink" title="载波侦听多路访问（CSMA）协议的类型"></a>载波侦听多路访问（CSMA）协议的类型</h2><p>依据侦听方式和侦听到信道忙后的处理方式：</p><ul><li>1-坚持载波侦听多路访问（CSMA）：信道忙，继续侦听；信道空闲，以概率为1发送数据</li><li>非坚持载波侦听多路访问（CSMA）：信道忙，放弃侦听，等待随机时间侦听；信道空闲，发送数据</li><li>p-坚持载波侦听多路访问（CSMA）：信道忙，持续（推迟到下个时隙）侦听；信道空闲，以概率为p发送数据</li></ul><hr><h2 id="载波侦听多路访问（CSMA）协议的机制"><a href="#载波侦听多路访问（CSMA）协议的机制" class="headerlink" title="载波侦听多路访问（CSMA）协议的机制"></a>载波侦听多路访问（CSMA）协议的机制</h2><ul><li>载波侦听</li></ul><hr><h2 id="载波侦听多路访问-碰撞检测（CSMA-CD）协议的机制"><a href="#载波侦听多路访问-碰撞检测（CSMA-CD）协议的机制" class="headerlink" title="载波侦听多路访问&#x2F;碰撞检测（CSMA&#x2F;CD）协议的机制"></a>载波侦听多路访问&#x2F;碰撞检测（CSMA&#x2F;CD）协议的机制</h2><ul><li>载波侦听</li><li>碰撞检测</li></ul><p>概括：</p><ul><li>先听后发</li><li>边听边发：保证最小帧长&gt;&#x3D;数据传输速率×传播时延×2</li><li>冲突停发</li><li>随机重发：截断二进制指数退避算法</li></ul><hr><h2 id="载波侦听多路访问-碰撞避免（-CSMA-CA）协议的机制"><a href="#载波侦听多路访问-碰撞避免（-CSMA-CA）协议的机制" class="headerlink" title="载波侦听多路访问&#x2F;碰撞避免（ CSMA&#x2F;CA）协议的机制"></a>载波侦听多路访问&#x2F;碰撞避免（ CSMA&#x2F;CA）协议的机制</h2><ul><li>载波侦听</li><li>碰撞避免</li></ul><p>概括：</p><ul><li>发前预约</li></ul><p>另：</p><ul><li>帧间间隔（IFS）：短帧间间隔（SIFS），点协调帧间间隔（PIFS），分布式帧间间隔（DIFS）</li><li>退避算法：等待随机时间+进入争用窗口</li><li>自动重传请求（ARQ）</li></ul><hr><h2 id="轮询访问介质访问控制的方式"><a href="#轮询访问介质访问控制的方式" class="headerlink" title="轮询访问介质访问控制的方式-"></a>轮询访问介质访问控制的方式-</h2><ul><li>令牌传递协议</li></ul><p>实质：信道轮询分配</p><hr><h1 id="局域网（LAN）"><a href="#局域网（LAN）" class="headerlink" title="局域网（LAN）"></a>局域网（LAN）</h1><h2 id="电气与电子工程师协会（IEEE）-802协议层-局域网参考模型"><a href="#电气与电子工程师协会（IEEE）-802协议层-局域网参考模型" class="headerlink" title="电气与电子工程师协会（IEEE） 802协议层&#x2F;局域网参考模型"></a>电气与电子工程师协会（IEEE） 802协议层&#x2F;局域网参考模型</h2><p>从高到低：</p><ul><li>逻辑链路控制（LLC）子层</li><li>媒体接入控制（MAC）子层</li><li>物理层</li></ul><hr><h2 id="局域网（LAN）特性的决定要素"><a href="#局域网（LAN）特性的决定要素" class="headerlink" title="局域网（LAN）特性的决定要素"></a>局域网（LAN）特性的决定要素</h2><ul><li>拓扑结构：总线型，星型，环形，总线型和星型结合的复合型</li><li>传输介质：双绞线（主流），铜缆，光纤</li><li>介质访问控制方式（最重要）：载波侦听多路访问&#x2F;碰撞检测（CSMA&#x2F;CD）协议，令牌传递协议</li></ul><hr><h2 id="局域网（LAN）的特殊类型"><a href="#局域网（LAN）的特殊类型" class="headerlink" title="局域网（LAN）的特殊类型"></a>局域网（LAN）的特殊类型</h2><ul><li>以太网：电气与电子工程师协会（IEEE） 802.3；逻辑拓扑：总线形，物理拓扑：星形或拓展星形</li><li>令牌环：电气与电子工程师协会（IEEE） 802.5；逻辑拓扑：环形，物理拓扑：星形</li><li>光纤分布数字接口（FDDI）：：电气与电子工程师协会（IEEE） 802.8；逻辑拓扑：环形，物理拓扑：双环形</li><li>无线局域网：电气与电子工程师协会（IEEE） 802.11</li></ul><hr><h2 id="以太网介质访问控制（MAC）帧的结构"><a href="#以太网介质访问控制（MAC）帧的结构" class="headerlink" title="以太网介质访问控制（MAC）帧的结构"></a>以太网介质访问控制（MAC）帧的结构</h2><p>前导码：8字节（B）：</p><ul><li>前同步码：7字节（B）</li><li>帧开始定界符：1字节（B）</li></ul><p>以太网介质访问控制（MAC）帧：从首部到尾部：</p><ul><li>目的地址：6字节（B）</li><li>源地址：6字节（B）</li><li>类型&#x2F;长度：2字节（B）</li><li>数据：46-1500字节（B）</li><li>可能填充：0-46字节（B）</li><li>帧校验序列（FCS）：4字节（B）</li></ul><p>最大帧长：1518字节（B）</p><hr><h2 id="虚拟局域网（VLAN）的802-1Q介质访问控制（MAC）帧的结构"><a href="#虚拟局域网（VLAN）的802-1Q介质访问控制（MAC）帧的结构" class="headerlink" title="虚拟局域网（VLAN）的802.1Q介质访问控制（MAC）帧的结构"></a>虚拟局域网（VLAN）的802.1Q介质访问控制（MAC）帧的结构</h2><ul><li>目的地址：6字节（B）</li><li>源地址：6字节（B）</li><li>类型&#x2F;长度：2字节（B）</li><li><strong>虚拟局域网（VLAN）标签：4字节（B）</strong></li><li>数据：46-1500字节（B）</li><li>可能填充：0-46字节（B）</li><li>帧校验序列（FCS）：4字节（B）</li></ul><p><strong>最大帧长：1522字节（B）</strong></p><hr><h2 id="无线局域网的类型"><a href="#无线局域网的类型" class="headerlink" title="无线局域网的类型"></a>无线局域网的类型</h2><ul><li>有固定基础设施的无线局域网</li><li>无固定基础设施的移动自组织网（ad hoc）</li></ul><hr><h2 id="无线局域网介质访问控制（MAC）帧的类型"><a href="#无线局域网介质访问控制（MAC）帧的类型" class="headerlink" title="无线局域网介质访问控制（MAC）帧的类型"></a>无线局域网介质访问控制（MAC）帧的类型</h2><ul><li>管理帧</li><li>控制帧</li><li>数据帧</li></ul><hr><h2 id="无线局域网介质访问控制（MAC）数据帧的结构"><a href="#无线局域网介质访问控制（MAC）数据帧的结构" class="headerlink" title="无线局域网介质访问控制（MAC）数据帧的结构"></a>无线局域网介质访问控制（MAC）数据帧的结构</h2><ul><li>首部：30字节（B）</li><li>数据：0-2312字节（B）</li><li>帧校验序列：4字节（B）</li></ul><hr><h1 id="广域网"><a href="#广域网" class="headerlink" title="广域网"></a>广域网</h1><h2 id="串行线路网际协议（SLIP）发展：-点对点协议（PPP）的组成"><a href="#串行线路网际协议（SLIP）发展：-点对点协议（PPP）的组成" class="headerlink" title="串行线路网际协议（SLIP）发展： 点对点协议（PPP）的组成"></a>串行线路网际协议（SLIP）发展： 点对点协议（PPP）的组成</h2><ul><li>链路控制协议（LCP）</li><li>网络控制协议（NCP）</li><li>封装网际协议（IP）分组到串行链路的方法&#x2F;组帧方法</li></ul><hr><h2 id="点对点协议（PPP）帧的结构：面向字节（B）"><a href="#点对点协议（PPP）帧的结构：面向字节（B）" class="headerlink" title="点对点协议（PPP）帧的结构：面向字节（B）"></a>点对点协议（PPP）帧的结构：面向字节（B）</h2><p>从首部到尾部：</p><ul><li>标志（首部）：1字节（B）</li><li>地址：1字节（B）</li><li>控制：1字节（B）</li><li>协议：2字节（B）</li><li>数据：0-1500字节（B）</li><li>帧校验序列(FCS)：2字节（B）</li><li>标志（尾部）：1字节（B）</li></ul><hr><h2 id="点对点协议（PPP）的认证方式"><a href="#点对点协议（PPP）的认证方式" class="headerlink" title="点对点协议（PPP）的认证方式"></a>点对点协议（PPP）的认证方式</h2><ul><li>密码验证协议（PAP）</li><li>挑战握手验证协议（CHAP）</li></ul><hr><h2 id="高级数据链路控制（HDLC）协议帧的类型"><a href="#高级数据链路控制（HDLC）协议帧的类型" class="headerlink" title="高级数据链路控制（HDLC）协议帧的类型"></a>高级数据链路控制（HDLC）协议帧的类型</h2><ul><li>无编号帧</li><li>监督帧</li><li>信息帧</li></ul><hr><h2 id="高级数据链路控制（HDLC）协议帧的结构：面向比特-位（b）"><a href="#高级数据链路控制（HDLC）协议帧的结构：面向比特-位（b）" class="headerlink" title="高级数据链路控制（HDLC）协议帧的结构：面向比特&#x2F;位（b）"></a>高级数据链路控制（HDLC）协议帧的结构：面向比特&#x2F;位（b）</h2><ul><li>标志（首部）：8比特&#x2F;位（b）</li><li>地址：8比特&#x2F;位（b）</li><li>控制：8比特&#x2F;位（b）</li><li>数据：0-1500字节（B）-&gt;0-12 000比特&#x2F;位（b）</li><li>帧校验序列（FCS）：16比特&#x2F;位（b）</li><li>标志（尾部）：8比特&#x2F;位（b）</li></ul><hr><h2 id="高级数据链路控制（HDLC）协议的操作方式"><a href="#高级数据链路控制（HDLC）协议的操作方式" class="headerlink" title="高级数据链路控制（HDLC）协议的操作方式"></a>高级数据链路控制（HDLC）协议的操作方式</h2><ul><li>正常响应模式——同步，非平衡</li><li>异步响应模式——异步，非平衡</li><li>异步平衡模式——异步，平衡</li></ul><hr><h1 id="数据链路层设备"><a href="#数据链路层设备" class="headerlink" title="数据链路层设备"></a>数据链路层设备</h1><h2 id="数据链路层的设备"><a href="#数据链路层的设备" class="headerlink" title="数据链路层的设备"></a>数据链路层的设备</h2><ul><li>网桥——工作在介质访问控制（MAC）子层</li><li>交换机——本质：多端口网桥</li></ul><hr><h2 id="交换机的工作模式"><a href="#交换机的工作模式" class="headerlink" title="交换机的工作模式"></a>交换机的工作模式</h2><ul><li>直通式</li><li>存储转发式</li></ul><hr><h2 id="交换机交换-转发表的组成"><a href="#交换机交换-转发表的组成" class="headerlink" title="交换机交换&#x2F;转发表的组成"></a>交换机交换&#x2F;转发表的组成</h2><p>至少有：</p><ul><li>介质访问控制（MAC）地址</li><li>端口</li></ul><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>计算机网络的知识抽象、晦涩、不易理解并记忆，在此对“数据链路层”一章中重点知识总结成提纲。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《2023年计算机网络考研复习指导》组编：王道论坛</li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>结构型设计模式总结</title>
      <link href="/2022/08/11/%E7%BB%93%E6%9E%84%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
      <url>/2022/08/11/%E7%BB%93%E6%9E%84%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>结构型设计模式总结。</p><hr><h1 id="代理模式（Proxy）"><a href="#代理模式（Proxy）" class="headerlink" title="代理模式（Proxy）"></a>代理模式（Proxy）</h1><p>描述：</p><ul><li>为其他对象提供一种代理以控制对这个对象的访问</li></ul><p>结构：</p><ul><li>抽象服务类</li><li>具体服务类——与抽象服务类是继承关系——被代理者</li><li>代理类——与抽象服务类是继承关系，与具体服务类是关联关系——代理者</li></ul><p><strong>关联关系和聚合关系的区别</strong>：</p><ul><li>语义不同，实现相同</li><li>关联关系：对象间是平等的，侧重了解。如企鹅了解气候</li><li>聚合关系：对象间是不平等的，侧重包含。如雁群包含大雁</li><li><strong>该系列博客对关联关系和聚合关系，语义上尽量用对词，实现上不再区分用词</strong></li></ul><p>概述：</p><ul><li>抽象服务类：抽象方法</li><li>具体服务类：重写抽象服务类的抽象方法为具体方法</li><li>代理类：具体服务类对象——代理</li><li>代理类：重写抽象服务类的抽象方法为具体方法——代理</li><li>具体方法：具体服务类对象调用具体服务类的具体方法——代理过程</li><li>客户端：创建代理类对象（可能需要创建具体服务类对象——显式指明被代理对象），代理类对象调用代理类的具体方法</li></ul><p>核心：</p><ul><li>继承</li><li>多态</li><li>具体服务类——被代理者</li><li>代理类——代理者</li><li>代理类继承与具体服务类相同的抽象服务类——伪装成具体服务类</li><li>代理类对象调用代理类方法，实际上是具体服务类对象调用具体服务类方法——代理过程</li><li>客户端可以只知道代理类，不知道具体服务类</li></ul><hr><h1 id="适配器模式（Adapter）"><a href="#适配器模式（Adapter）" class="headerlink" title="适配器模式（Adapter）"></a>适配器模式（Adapter）</h1><p>别名：</p><ul><li>封装器模式（Wrapper）</li></ul><p>描述：</p><ul><li>将一个类的接口转换成客户希望的另外一个接口。使得原本由于接口不兼容而不能一起工作的那些类可以一起工作</li></ul><p>类型：</p><ul><li>类适配器模式：使用多继承机制： 适配器继承两个类。 只能在支持多继承的编程语言中实现， 如 C++</li><li>对象适配器模式：使用构成原则： 适配器继承一个类， 封装另一个类对象。 所有流行的编程语言都可以实现</li></ul><p>类适配器模式：<br>结构：</p><ul><li>目标类——客户端能够使用的接口——适配者</li><li>需适配类——客户无法使用的接口——被适配者</li><li>适配器类——与目标类是继承关系，与需适配类是继承关系——中间者</li></ul><p>概述：</p><ul><li>目标类：方法</li><li>需适配类：方法</li><li>适配器类：重写目标类的方法，重写需适配类的方法</li><li>客户端：创建目标类类型的适配器类对象，目标类类型的适配器类对象调用目标类的方法、需适配类的方法</li></ul><p>对象适配器模式：<br>结构：</p><ul><li>目标类——客户端能够使用的接口——适配者</li><li>需适配类——客户无法使用的接口——被适配者</li><li>适配器类——与目标类是继承关系，与需适配类是关联关系——中间者</li></ul><p>概述：</p><ul><li>目标类：方法</li><li>需适配类：方法</li><li>适配器类：需适配类对象</li><li>适配器类：设置需适配类对象方法，重写目标类的方法</li><li>设置需适配类对象方法：（创建并）设置需适配类对象为字段</li><li>方法：需适配类对象调用需适配类的方法</li><li>客户端：创建目标类类型的适配器类对象，目标类类型的适配器类对象调用方法</li></ul><p>核心：</p><ul><li>继承</li><li>多态</li><li>目标类——客户端能够使用的接口——适配者</li><li>需适配类——客户无法使用的接口——被适配者</li><li>适配器类——中间者</li><li>适配器类继承目标类——协调适配者</li><li>适配器类通过需适配类对象调用需适配类的方法——协调被适配者——适配过程</li><li>客户端可以只知道适配器类，不知道需适配类</li></ul><hr><h1 id="外观模式（Facade）"><a href="#外观模式（Facade）" class="headerlink" title="外观模式（Facade）"></a>外观模式（Facade）</h1><p>描述：</p><ul><li>为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用</li></ul><p>结构：</p><ul><li>子系统类（多个）——被管理者</li><li>外观类——与子系统类是关联关系——管理者</li></ul><p>概述：</p><ul><li>子系统类：方法</li><li>外观类：子系统类对象</li><li>外观类：设置子系统类对象为方法，搭配方法</li><li>设置子系统类对象为方法：（创建并）设置子系统类对象为字段</li><li>搭配方法：可以使用多个子系统类对象调用子系统类的方法——搭配多种方案</li><li>客户端创建外观类对象，外观类对象调用外观类的方法</li></ul><p>核心：</p><ul><li>关联关系</li><li>子系统类——被管理者</li><li>外观类封装多个子系统类对象和多个子系统类对象调用子系统类的方法</li><li>外观类——管理者，搭配子系统类方法的调用内容和时序&#x2F;步骤</li><li>客户端只知道外观类，不知道子系统类</li></ul><hr><h1 id="装饰模式（Decorator）"><a href="#装饰模式（Decorator）" class="headerlink" title="装饰模式（Decorator）"></a>装饰模式（Decorator）</h1><p>别名：</p><ul><li>装饰者模式</li><li>装饰器模式</li><li>包装器模式（Wrapper）</li></ul><p>描述：</p><ul><li>动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更加灵活</li></ul><p>结构：</p><ul><li>抽象组件类</li><li>具体组件类——与抽象组件类是继承关系——被装饰者</li><li>抽象装饰类——与抽象组件类是继承关系，与抽象组件类是聚合关系</li><li>具体装饰类——与抽象装饰类是继承关系——被装饰者、装饰者</li></ul><p>概述：</p><ul><li>抽象组件类：抽象方法</li><li>具体组件类：重写抽象组件类的抽象方法为具体方法</li><li>抽象装饰类：设置抽象组件类类型的具体组件类对象或抽象组件类类型的具体装饰类对象方法，重写抽象组件类的抽象方法为具体方法</li><li>设置抽象组件类类型的具体组件类对象或抽象组件类类型的具体装饰类对象方法：（创建并）设置抽象组件类类型的具体组件类对象或抽象组件类类型的具体装饰类对象为字段</li><li>具体装饰类：重写抽象装饰类的具体方法为具体方法</li><li>具体方法：调用抽象组件类类型的具体组件类对象的具体组件类的具体方法或抽象组件类类型的具体装饰类对象的具体装饰类的具体方法</li><li>客户端创建具体组件类对象，创建具体装饰类对象，具体装饰类对象调用设置抽象组件类类型的具体组件类对象或抽象组件类类型的具体装饰类对象方法，具体装饰类对象调用具体装饰类的具体方法</li></ul><p>核心：</p><ul><li>继承</li><li>多态</li><li>装饰，嵌套</li><li>具体组件类——被装饰者</li><li>具体装饰类——被装饰者、装饰者</li><li>设置抽象组件类类型的具体组件类对象或抽象组件类类型的具体装饰类对象方法——装饰者包装被装饰者</li><li>具体组件类的具体方法——被装饰者的固有内容</li><li>具体装饰类的具体方法：调用被装饰者的具体方法——被装饰者的固有内容，装饰者的具体方法——装饰者的包装内容，搭配固有和包装的内容、时序&#x2F;步骤</li></ul><hr><h1 id="组合模式（Composite）"><a href="#组合模式（Composite）" class="headerlink" title="组合模式（Composite）"></a>组合模式（Composite）</h1><p>别名：</p><ul><li>对象树模式（Object Tree）</li></ul><p>描述：</p><ul><li>将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性</li></ul><p>结构：</p><ul><li>组件类</li><li>叶子类——与组件类是继承关系——树叶</li><li>组合类——与组件类是继承关系，与组件类是聚合关系——树枝</li></ul><p>概述：</p><ul><li>组件类：抽象执行方法</li><li>叶子类：重写组件类的抽象执行方法为具体执行方法</li><li>组合类：组件类类型的叶子类对象或组件类类型的组合类对象集合</li><li>组合类：重写组件类的抽象执行方法为具体执行方法</li><li>组合类：添加组件方法，移除组件方法，具体执行方法</li><li>添加组件方法：添加组件类类型的叶子类对象或组件类类型的组合类对象到集合</li><li>移除组件方法：移除集合中组件类类型的叶子类对象或组件类类型的组合类对象</li><li>具体执行方法：遍历组件类类型的叶子类对象或组件类类型的组合类对象集合，对象调用具体执行方法</li><li>客户端：创建组合类对象——树根，创建组合类对象——树枝，创建叶子类对象——树叶，树枝调用添加组件方法——添加树枝或树叶，树根调用添加组件方法——添加树枝或树叶，树根调用具体执行方法</li></ul><p>核心：</p><ul><li>继承</li><li>多态</li><li>树状嵌套递归对象结构</li><li>客户端以相同方式处理简单和复杂元素&#x2F;一致地使用单个和组合对象</li></ul><p>其他：</p><ul><li>透明方式：组件类有管理子对象的方法，如：添加组件方法、删除组件方法，组合类、叶子类的行为一致；叶子类继承和实现该些方法没有意义，违反接口隔离原则（ISP）</li><li>安全方式：组件类没有管理子对象的方法，组合类有管理子对象的方法</li></ul><hr><h1 id="桥接模式（Bridge）"><a href="#桥接模式（Bridge）" class="headerlink" title="桥接模式（Bridge）"></a>桥接模式（Bridge）</h1><p>描述：</p><ul><li>将抽象部分与它的实现部分分离，使它们都可以独立地变化</li></ul><p>结构：</p><ul><li>抽象实现类</li><li>具体实现类——与抽象实现类是继承关系</li><li>抽象抽象类——与抽象实现类是聚合关系</li><li>具体抽象类——与抽象抽象类是继承关系</li></ul><p>概述：</p><ul><li>抽象实现类：抽象方法</li><li>具体实现类：重写抽象实现类的抽象方法为具体方法</li><li>抽象抽象类：抽象实现类类型的具体实现类对象</li><li>抽象抽象类：设置抽象实现类类型的具体实现类对象方法，抽象执行方法</li><li>具体抽象类：重写抽象抽象类的抽象执行方法为具体执行方法</li><li>具体执行方法：抽象实现类类型的具体实现类对象调用具体实现类的具体方法</li><li>客户端：创建抽象抽象类类型的具体抽象类对象，抽象实现类类型的具体实现类对象，抽象抽象类类型的具体抽象类对象调用设置抽象实现类类型的具体实现类对象方法，抽象抽象类类型的具体抽象类对象调用具体执行方法</li></ul><p>核心：</p><ul><li>继承</li><li>多态</li><li>多维结构</li><li>合成聚合原则（C&#x2F;ARP），聚合&#x2F;组合</li><li>拆分抽象和实现，使用聚合&#x2F;组合关系桥接</li><li>抽象：不是指抽象类和接口，指一个独立维度&#x2F;类层次，如手机品牌类型</li><li>实现：不是指具体类和实现类，指一个独立维度&#x2F;类层次，如手机软件类型</li><li>聚合&#x2F;组合：手机品牌类对象持有手机软件类对象</li><li>桥接方式：手机品牌类对象通过手机软件类对象使用手机软件类的字段、方法，不必知道手机软件类的状态、行为——核心</li><li>无桥接方式：使用继承：每个手机品牌类有手机软件类，类的数量呈树状结构几何递增，难以维护</li></ul><hr><h1 id="享元模式（Flyweight）"><a href="#享元模式（Flyweight）" class="headerlink" title="享元模式（Flyweight）"></a>享元模式（Flyweight）</h1><p>别称：</p><ul><li>缓存模式（Cache）</li></ul><p>描述：</p><ul><li>运用共享技术有效地支持大量大量细粒度的对象</li></ul><p>结构：</p><ul><li>抽象享元类</li><li>具体享元类——与抽象享元类是继承关系——共享内容</li><li>具体不共享类——与抽象享元类是继承关系——不共享内容</li><li>享元工厂类——与抽象享元类是聚合关系</li></ul><p>概述：</p><ul><li>抽象享元类：抽象方法</li><li>具体享元类：重写抽象享元类的抽象方法为具体方法</li><li>具体不共享类：重写抽象享元类的抽象方法为具体方法</li><li>享元工厂类：抽象享元类类型的具体享元类对象或抽象享元类类型的不共享类对象表</li><li>享元工厂类：添加抽象享元类类型的具体享元类对象或抽象享元类类型的不共享类对象方法，返回抽象享元类类型的具体享元类对象或抽象享元类类型的不共享类对象方法</li><li>添加抽象享元类类型的具体享元类对象或抽象享元类类型的不共享类对象方法：（创建并）添加抽象享元类类型的具体享元类对象或抽象享元类类型的不共享类对象到表——要用才创建</li><li>返回抽象享元类类型的具体享元类对象或抽象享元类类型的不共享类对象方法：查表，若无创建对象，若有返回——没有才创建</li><li>客户端：创建享元工厂类对象，享元工厂类对象调用返回抽象享元类类型的具体享元类对象或抽象享元类类型的不共享类对象方法，以创建抽象享元类类型的具体享元类对象或抽象享元类类型的不共享类对象，抽象享元类类型的具体享元类对象调用具体享元类的具体方法，象享元类类型的不共享类对象调用不共享类的具体方法</li></ul><p>核心：</p><ul><li>继承</li><li>多态</li><li>不共享类，外部状态——不共享内容</li><li>共享类，内部状态——共享内容</li><li>共享资源、代码和实例</li><li>客户端传递外部状态给享元工厂类和享元类，实现不共享内容和共享内容的整合</li><li>拆分和整合共享内容和不共享内容</li></ul><hr><h1 id="记忆"><a href="#记忆" class="headerlink" title="记忆"></a>记忆</h1><ul><li>代理模式（Proxy）：代理。代理者和被代理者接口相同，能代理。类比：快递员帮花店店员送花</li><li>适配器模式（Adapter）：适配。适配者和被适配者接口不同，不能代理，只能适配。类比：电源适配器适配不同电压源和电器</li><li>外观模式（Facade）：管理，搭配多种方案。类似代理模式（Proxy）：客户端委托任务给外观类对象，外观类对象委托任务给多个子系统类对象。但委托者和被委托者无继承、多态：无相同接口，不能代换；有关联关系：委托者只负责管理、委托任务。类比：狼王指挥狼群</li><li>装饰模式（Decorator）：装饰，嵌套，搭配固有和包装的内容、时序&#x2F;步骤。类似外观模式（Facade）。类比：给物品包装盒子</li><li>组合模式（Composit）：树状嵌套递归对象结构。客户端以相同方式处理简单和复杂元素&#x2F;一致地使用单个和组合对象。类似装饰模式（Decorator）。类比：处理物品和包装物品盒子的方式一致</li><li>桥接模式（Bridge）：多维结构，拆分抽象和实现，使用聚合&#x2F;组合关系桥接。抽象和实现是两个独立维度，接口不同。类似代理模式（Proxy），避免组合模式（Composit）的树状结构。类比：不同手机品牌安装不同手机软件</li><li>享元模式（Flyweight）：拆分和整合共享内容和不共享内容。类比：类似的商业网站使用同一服务器资源、代码和实例，依据网站所有者的不同具有不同的行为</li></ul><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《大话设计模式》作者：程杰</li><li><a href="https://refactoringguru.cn/design-patterns">常用设计模式有哪些？ (refactoringguru.cn)</a></li></ul><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>结构型设计模式总结。</p><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建型设计模式总结</title>
      <link href="/2022/08/09/%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
      <url>/2022/08/09/%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>创建型设计模式总结。</p><hr><h1 id="单例模式（Singleton）"><a href="#单例模式（Singleton）" class="headerlink" title="单例模式（Singleton）"></a>单例模式（Singleton）</h1><p>别名：</p><ul><li>单件模式</li></ul><p>描述：</p><ul><li>保证一个类仅有一个实例，并提供一个访问它的全局访问点</li></ul><p>结构：</p><ul><li>单例类</li></ul><p>概述：</p><ul><li>单例类：私有静态单例类对象</li><li>单例类：私有构造方法</li><li>单例类：公有静态获取单例类对象方法</li><li>公有静态获取单例类对象方法：判断是否存在私有静态单例类对象，若是则返回该对象；若无则调用私有构造方法创建再返回对象</li><li>客户端：调用单例类的公有静态获取单例类对象方法获得单例类对象</li></ul><p>核心：</p><ul><li>私有静态单例类对象</li><li>私有构造方法</li><li>公有静态获取单例类对象方法</li></ul><p>类型：</p><ul><li>饿汉式：单例类编译时创建单例类对象（不管用不用都提前创建）。线程安全</li><li>懒汉式：程序运行时创建单例类对象（用了才创建）。线程不安全，需要双重锁定</li></ul><hr><h1 id="简单工厂模式（Simple-Factory）"><a href="#简单工厂模式（Simple-Factory）" class="headerlink" title="简单工厂模式（Simple Factory）"></a>简单工厂模式（Simple Factory）</h1><p>结构：</p><ul><li>抽象产品类&#x2F;接口</li><li>具体产品类——与抽象产品类&#x2F;接口是继承&#x2F;实现关系</li><li>简单工厂类——与抽象产品类是依赖关系</li></ul><p><strong>注意</strong>：</p><ul><li>抽象类&#x2F;继承和接口&#x2F;实现在一定程度上可相互转换代替</li><li>抽象类：抽象对象，对象之间有关系，属于同一类，可继承：如鸟和雁</li><li>接口：抽象行为，对象之间无关系，有共同的行为：如鸟和飞机，都会飞</li><li><strong>该系列博客不再区分抽象类和接口、抽象方法和虚方法的用词</strong></li></ul><p>概述：</p><ul><li>抽象产品类：抽象&#x2F;虚方法</li><li>具体产品类：重写抽象产品类的抽象方法为具体方法</li><li>简单工厂类：静态方法创建抽象产品类类型的具体产品类对象</li><li>客户端：调用简单工厂类的静态方法创建抽象产品类类型的具体产品类对象，使用抽象产品类类型的具体产品类对象调用具体产品类的具体方法</li></ul><p>核心：</p><ul><li>继承</li><li>多态</li><li>静态方法创建对象</li></ul><p><strong>面向对象三大特性的体现</strong>：</p><ul><li>封装：类</li><li>继承：具体产品类——与抽象产品类是继承关系</li><li>多态：具体产品类：重写抽象产品类的抽象方法为具体方法、抽象产品类类型的具体产品类对象调用具体产品类的具体方法</li><li><strong>该系列博客不再描述面向对象三大特性的体现</strong></li></ul><p>其他：</p><ul><li>简单工厂模式属于设计模式，不属于23种GoF设计模式之一，因为违背开放-封闭原则，扩展需要修改简单工厂类：增加创建产品类对象逻辑判断、创建代码</li></ul><hr><h1 id="工厂方法模式（Factory-Method）"><a href="#工厂方法模式（Factory-Method）" class="headerlink" title="工厂方法模式（Factory Method）"></a>工厂方法模式（Factory Method）</h1><p>别名：</p><ul><li>虚拟构造函数模式（Virtual Constructor）</li></ul><p>描述：</p><ul><li>定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类</li></ul><p>结构：</p><ul><li>抽象产品类</li><li>具体产品类——与抽象产品类是继承关系</li><li>抽象创建者类&#x2F;接口——与抽象产品类是依赖关系</li><li>具体创建者类——与抽象创建者类是继承关系</li></ul><p>概述：</p><ul><li>抽象产品类：抽象方法 </li><li>具体产品类：重写抽象产品类的抽象方法为具体方法</li><li>抽象创建者类：抽象方法</li><li>具体创建者类：重写抽象创建者类的抽象方法为具体方法</li><li>具体创建者类的具体方法：创建抽象产品类类型的具体产品类对象</li><li>客户端：创建抽象创建者类类型的具体创建者类对象，调用抽象创建者类类型的具体创建者类对象的具体方法创建抽象产品类类型的具体产品类对象，调用抽象产品类类型的具体产品类对象的具体方法</li></ul><p>核心：</p><ul><li>继承</li><li>多态</li><li>创建抽象类类型的具体类对象：创建者类对象和产品类对象</li></ul><p>简单工厂模式和工厂方法模式的区别：</p><ul><li>简单工厂模式：在简单工厂类的静态方法逻辑判断，创建产品类对象</li><li>工厂方法模式：在客户端逻辑判断，创建工厂类对象，再创建产品类对象</li><li>工厂方法模式克服简单工厂模式的缺陷：违背开放-封闭原则。扩展需要增加具体工厂类</li></ul><hr><h1 id="抽象工厂模式（Abstract-Factory）"><a href="#抽象工厂模式（Abstract-Factory）" class="headerlink" title="抽象工厂模式（Abstract Factory）"></a>抽象工厂模式（Abstract Factory）</h1><p>描述：</p><ul><li>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类</li></ul><p>结构：</p><ul><li>抽象产品类（一个或多个）</li><li>具体产品类（一个或多个）——与抽象产品类是继承关系</li><li>抽象工厂类</li><li>具体工厂类——与抽象工厂类是继承关系，与具体产品类是依赖关系</li></ul><p>概述：</p><ul><li>抽象产品类：抽象方法。多个抽象产品类有多种不同的实现：如桌子和椅子</li><li>具体产品类：重写抽象产品类的抽象方法为具体方法。多个具体产品类有多种不同的实现：如桌面和桌腿</li><li>抽象工厂类：抽象方法</li><li>具体工厂类：重写抽象工厂类的抽象方法为具体方法</li><li>具体工厂类的具体方法：能够创建“性质&#x2F;风格&#x2F;系列”相同，种类不同的产品：如维多利亚风格和现代风格</li><li>客户端：创建抽象工厂类类型的具体工厂类对象，调用抽象工厂类类型的具体工厂类对象的具体工厂类方法创建抽象产品类类型的具体产品类对象</li></ul><p>核心：</p><ul><li>二维以上结构：维多利亚风格工厂创建维多利亚风格的桌子的桌面和桌腿产品，现代风格工厂创建现代风格的桌子的桌面和桌腿产品，椅子同理。维度：产品风格，产品类型</li><li>继承</li><li>多态</li><li>创建具体工厂类对象，创建具体产品类对象</li></ul><p><strong>抽象工厂模式和简单工厂模式、工厂方法模式的区别</strong>：</p><ul><li>多维结构</li><li>创建一个具体工厂类对象，可创建多个同系列不同种类的具体产品类对象</li></ul><hr><h1 id="原型模式（Prototype）"><a href="#原型模式（Prototype）" class="headerlink" title="原型模式（Prototype）"></a>原型模式（Prototype）</h1><p>别名：</p><ul><li>克隆模式（Clone）</li></ul><p>描述：</p><ul><li>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象</li></ul><p>结构：</p><ul><li>抽象原型类</li><li>具体原型类——与抽象原型类是继承关系——被克隆者&#x2F;原型、克隆者</li></ul><p>概述：</p><ul><li>抽象原型类：抽象克隆方法</li><li>具体原型类：重写抽象原型类的抽象克隆方法为具体克隆方法</li><li>具体克隆方法：创建并返回抽象原型类类型的当前具体原型类对象的副本</li><li>客户端：创建具体原型类对象——被克隆者，具体原型类对象调用具体原型类的具体克隆方法创建的具体原型类对象——克隆者</li></ul><p>核心：</p><ul><li>继承</li><li>多态</li><li>原型类的克隆方法创建并返回原型类对象的副本</li></ul><p>其他：</p><ul><li>注意克隆方法中的浅拷贝和深拷贝问题</li></ul><hr><h1 id="建造者模式（Builder）"><a href="#建造者模式（Builder）" class="headerlink" title="建造者模式（Builder）"></a>建造者模式（Builder）</h1><p>别名：</p><ul><li>生成器模式</li></ul><p>描述：</p><ul><li>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</li></ul><p>结构：</p><ul><li>产品类</li><li>抽象建造者类</li><li>具体建造者类——与抽象建造者类是继承关系，与产品类是依赖关系</li><li>指挥者类——与抽象建造者类是聚合关系</li></ul><p>概述：</p><ul><li>产品类：方法</li><li>抽象建造者类：抽象建造方法和抽象获取产品方法</li><li>具体建造者类：产品类对象</li><li>具体建造者类：重写抽象建造者类的抽象建造方法和抽象获取产品方法为具体建造方法和具体获取产品方法</li><li>具体建造方法：产品类对象调用产品类的方法</li><li>具体获取产品方法：返回产品类对象</li><li>指挥者类：通过方法设置并持有抽象建造者类类型的具体建造者类对象、抽象建造者类类型的具体建造者类对象调用具体建造者类的具体建造方法</li><li>客户端：创建抽象建造者类类型的具体建造者类对象，将抽象建造者类类型的具体建造者类对象作为参数创建指挥者类对象，指挥者类对象调用指挥者类方法——建造过程，抽象建造者类类型的具体建造者类对象调用具体获取产品方法——建造结果</li></ul><p>核心：</p><ul><li>继承</li><li>多态</li><li>创建建造者类对象，再创建指挥者类对象，指挥者类对象调用指挥者类方法——建造过程，具体建造者类对象调用具体获取产品方法——建造结果</li><li>建造者类封装产品的各个建造细节：如建造桌面和建造桌腿；指挥者类封装建造过程的内容和时序：如建造桌子总要建造桌面和桌腿，先建造桌面后建造桌腿；建造过程：调用指挥者类的方法，建造结果：调用产品类的方法——分离创建和表示逻辑</li></ul><hr><h1 id="记忆"><a href="#记忆" class="headerlink" title="记忆"></a>记忆</h1><ul><li>单例模式（Singleton）：简单</li><li>简单工厂模式（Simple Factory）、工厂方法模式（Factory Method）、抽象工厂模式（Abstract Factory）：三工厂</li><li>原型模式（Prototype）：克隆</li><li>建造者模式（Builder）：分离创建和表示逻辑</li></ul><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>创建型设计模式总结。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《大话设计模式》作者：程杰</li><li><a href="https://refactoringguru.cn/design-patterns">常用设计模式有哪些？ (refactoringguru.cn)</a></li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>顺序循环队列和链队列的C/C++语言描述实现模板</title>
      <link href="/2022/08/08/%E9%A1%BA%E5%BA%8F%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E5%92%8C%E9%93%BE%E9%98%9F%E5%88%97%E7%9A%84C_C++%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E5%AE%9E%E7%8E%B0%E6%A8%A1%E6%9D%BF/"/>
      <url>/2022/08/08/%E9%A1%BA%E5%BA%8F%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E5%92%8C%E9%93%BE%E9%98%9F%E5%88%97%E7%9A%84C_C++%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E5%AE%9E%E7%8E%B0%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>数据结构中顺序循环队列和链队列的C&#x2F;C++语言描述实现模板，有详细的步骤解析及使用示例。</p><hr><h1 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h1><ul><li><a href="https://github.com/yezhening/Programming-examples">yezhening&#x2F;Programming-examples: 编程实例 (github.com)</a></li><li><a href="https://gitee.com/yezhening/Programming-examples">Programming-examples: 编程实例 (gitee.com)</a></li></ul><hr><h1 id="sqQueue-cpp（顺序循环队列）"><a href="#sqQueue-cpp（顺序循环队列）" class="headerlink" title="sqQueue.cpp（顺序循环队列）"></a>sqQueue.cpp（顺序循环队列）</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件————————————————————</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//命名空间————————————————————</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//宏————————————————————</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100 <span class="comment">//队列的最大大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型————————————————————</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType; <span class="comment">//数据的（数据）类型 依据数据的实际类型定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体</span></span><br><span class="line"><span class="comment">//顺序循环队列</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">SqQueue</span></span><br><span class="line">&#123;</span><br><span class="line">    ElemType data[MaxSize]; <span class="comment">//数据</span></span><br><span class="line">    <span class="type">int</span> front;              <span class="comment">//队头指针  定义为指向队头元素位置  出队：先出后移</span></span><br><span class="line">    <span class="type">int</span> rear;               <span class="comment">//队尾指针  定义为指向队尾元素位置的下一个位置  入队：先入后移</span></span><br><span class="line">&#125; SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数声明————————————————————</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_example</span><span class="params">()</span></span>;                             <span class="comment">//使用示例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(SqQueue &amp;sqQueue)</span></span>;                    <span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">enQueue</span><span class="params">(SqQueue &amp;sqQueue, ElemType elem)</span></span>;  <span class="comment">//入队</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">deQueue</span><span class="params">(SqQueue &amp;sqQueue, ElemType &amp;elem)</span></span>; <span class="comment">//出队</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数————————————————————</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">use_example</span>(); <span class="comment">//使用示例</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数定义————————————————————</span></span><br><span class="line"><span class="comment">//使用示例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_example</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建</span></span><br><span class="line">    SqQueue sqQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">init</span>(sqQueue);</span><br><span class="line">    cout &lt;&lt; sqQueue.front &lt;&lt; endl; <span class="comment">//输出：0</span></span><br><span class="line">    cout &lt;&lt; sqQueue.rear &lt;&lt; endl;  <span class="comment">//输出：0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//入队</span></span><br><span class="line">    ElemType elem1 = <span class="number">100</span>;</span><br><span class="line">    ElemType elem2 = <span class="number">200</span>;</span><br><span class="line">    ElemType elem3 = <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">enQueue</span>(sqQueue, elem1);</span><br><span class="line">    <span class="built_in">enQueue</span>(sqQueue, elem2);</span><br><span class="line">    <span class="built_in">enQueue</span>(sqQueue, elem3); <span class="comment">//元素在栈中的排列：100，200，300</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//出队</span></span><br><span class="line">    ElemType elem4 = <span class="number">0</span>;</span><br><span class="line">    ElemType elem5 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">deQueue</span>(sqQueue, elem4);</span><br><span class="line">    <span class="built_in">deQueue</span>(sqQueue, elem5);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; elem4 &lt;&lt; endl; <span class="comment">//输出：100</span></span><br><span class="line">    cout &lt;&lt; elem5 &lt;&lt; endl; <span class="comment">//输出：200</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(SqQueue &amp;sqQueue)</span> <span class="comment">//参数：队列</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//定义队头指针和队尾指针指向索引/位置0为队空</span></span><br><span class="line">    sqQueue.front = <span class="number">0</span>;</span><br><span class="line">    sqQueue.rear = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="comment">//时间复杂度：O(1)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">enQueue</span><span class="params">(SqQueue &amp;sqQueue, ElemType elem)</span> <span class="comment">//参数：队列，元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((sqQueue.rear + <span class="number">1</span>) % MaxSize == sqQueue.front) <span class="comment">//队满</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sqQueue.data[sqQueue.rear] = elem;           <span class="comment">//元素入队</span></span><br><span class="line">    sqQueue.rear = (sqQueue.rear + <span class="number">1</span>) % MaxSize; <span class="comment">//队尾指针循环+1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="comment">//时间复杂度：O(1)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">deQueue</span><span class="params">(SqQueue &amp;sqQueue, ElemType &amp;elem)</span> <span class="comment">//参数：队列，元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sqQueue.front == sqQueue.rear) <span class="comment">//队空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    elem = sqQueue.data[sqQueue.front];            <span class="comment">//获取、保存元素</span></span><br><span class="line">    sqQueue.front = (sqQueue.front + <span class="number">1</span>) % MaxSize; <span class="comment">//队头指针循环+1   元素出队</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="linkQueue-cpp（链队列）"><a href="#linkQueue-cpp（链队列）" class="headerlink" title="linkQueue.cpp（链队列）"></a>linkQueue.cpp（链队列）</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件————————————————————</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//命名空间————————————————————</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型————————————————————</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType; <span class="comment">//数据的（数据）类型 依据数据的实际类型定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体</span></span><br><span class="line"><span class="comment">//链队列结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkNode</span></span><br><span class="line">&#123;</span><br><span class="line">    ElemType data;         <span class="comment">//数据</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LinkNode</span> *next; <span class="comment">//指针</span></span><br><span class="line">&#125; LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链队列</span></span><br><span class="line"><span class="comment">//因为需要保存两个结点指针，所以新定义结构体封装</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkQueue</span></span><br><span class="line">&#123;</span><br><span class="line">    LinkNode *front; <span class="comment">//队头结点指针</span></span><br><span class="line">    LinkNode *rear;  <span class="comment">//队尾结点指针</span></span><br><span class="line">&#125; LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数声明————————————————————</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_example</span><span class="params">()</span></span>;                                 <span class="comment">//使用示例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(LinkQueue &amp;linkQueue)</span></span>;                    <span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">enQueue</span><span class="params">(LinkQueue &amp;linkQueue, ElemType elem)</span></span>;  <span class="comment">//入队</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">deQueue</span><span class="params">(LinkQueue &amp;linkQueue, ElemType &amp;elem)</span></span>; <span class="comment">//出队</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数————————————————————</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">use_example</span>(); <span class="comment">//使用示例</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数定义————————————————————</span></span><br><span class="line"><span class="comment">//使用示例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_example</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建</span></span><br><span class="line">    LinkQueue linkQueue; <span class="comment">//队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">init</span>(linkQueue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入队</span></span><br><span class="line">    ElemType elem1 = <span class="number">100</span>;</span><br><span class="line">    ElemType elem2 = <span class="number">200</span>;</span><br><span class="line">    ElemType elem3 = <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">enQueue</span>(linkQueue, elem1);</span><br><span class="line">    <span class="built_in">enQueue</span>(linkQueue, elem2);</span><br><span class="line">    <span class="built_in">enQueue</span>(linkQueue, elem3); <span class="comment">//元素在栈中的排列：100，200，300</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//出队</span></span><br><span class="line">    ElemType elem4 = <span class="number">0</span>;</span><br><span class="line">    ElemType elem5 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">deQueue</span>(linkQueue, elem4);</span><br><span class="line">    <span class="built_in">deQueue</span>(linkQueue, elem5);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; elem4 &lt;&lt; endl; <span class="comment">//输出：100</span></span><br><span class="line">    cout &lt;&lt; elem5 &lt;&lt; endl; <span class="comment">//输出：200</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(LinkQueue &amp;linkQueue)</span> <span class="comment">//参数：队列</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    linkQueue.front = linkQueue.rear = (LinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode)); <span class="comment">//创建头结点   队列的队头、尾结点指针指向头结点</span></span><br><span class="line">    linkQueue.front-&gt;next = <span class="literal">nullptr</span>;                                         <span class="comment">//头结点的指针指向空   即：linkQueue.rear-&gt;next = nullptr;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="comment">//时间复杂度：O(1)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">enQueue</span><span class="params">(LinkQueue &amp;linkQueue, ElemType elem)</span> <span class="comment">//参数：队列，元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkNode *newNode; <span class="comment">//新结点指针</span></span><br><span class="line"></span><br><span class="line">    newNode = (LinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode)); <span class="comment">//创建新结点</span></span><br><span class="line"></span><br><span class="line">    newNode-&gt;data = elem; <span class="comment">//初始化新结点的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//入队</span></span><br><span class="line">    linkQueue.rear-&gt;next = newNode;</span><br><span class="line">    linkQueue.rear = newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="comment">//时间复杂度：O(1)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">deQueue</span><span class="params">(LinkQueue &amp;linkQueue, ElemType &amp;elem)</span> <span class="comment">//参数：队列，元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (linkQueue.front == linkQueue.rear) <span class="comment">//队空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LinkNode *tempNode = <span class="literal">nullptr</span>; <span class="comment">//临时结点指针</span></span><br><span class="line"></span><br><span class="line">    elem = linkQueue.front-&gt;next-&gt;data; <span class="comment">//获取、保存数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//出队</span></span><br><span class="line">    tempNode = linkQueue.front-&gt;next;</span><br><span class="line">    linkQueue.front-&gt;next = tempNode-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//易漏边界条件：如果除头结点只剩一个元素，该元素出队后，将队尾结点指针指向队头指针指向的头结点</span></span><br><span class="line">    <span class="keyword">if</span> (linkQueue.rear == tempNode)</span><br><span class="line">    &#123;</span><br><span class="line">        linkQueue.rear = linkQueue.front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(tempNode); <span class="comment">//释放结点空间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>不同参考资料中，顺序循环队列和链队列的描述实现各不相同，但基本思想是一致的。作者使用规范的变量命名、提供详细的步骤解析及使用示例，应用C&#x2F;C++语言将其整合成模板，以帮助理解记忆。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《2023版数据结构高分笔记》主编：率辉</li><li>《2023年计算机组成原理考研复习指导》组编：王道论坛</li><li>《大话数据结构》作者：程杰</li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>顺序栈和链栈的C/C++语言描述实现模板</title>
      <link href="/2022/08/07/%E9%A1%BA%E5%BA%8F%E6%A0%88%E5%92%8C%E9%93%BE%E6%A0%88%E7%9A%84C_C++%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E5%AE%9E%E7%8E%B0%E6%A8%A1%E6%9D%BF/"/>
      <url>/2022/08/07/%E9%A1%BA%E5%BA%8F%E6%A0%88%E5%92%8C%E9%93%BE%E6%A0%88%E7%9A%84C_C++%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E5%AE%9E%E7%8E%B0%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>数据结构中顺序栈和链栈的C&#x2F;C++语言描述实现模板，有详细的步骤解析及使用示例。</p><hr><h1 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h1><ul><li><a href="https://github.com/yezhening/Programming-examples">yezhening&#x2F;Programming-examples: 编程实例 (github.com)</a></li><li><a href="https://gitee.com/yezhening/Programming-examples">Programming-examples: 编程实例 (gitee.com)</a></li></ul><hr><h1 id="sqStack-cpp（顺序栈）"><a href="#sqStack-cpp（顺序栈）" class="headerlink" title="sqStack.cpp（顺序栈）"></a>sqStack.cpp（顺序栈）</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件————————————————————</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//命名空间————————————————————</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//宏————————————————————</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100 <span class="comment">//栈的最大大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型————————————————————</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType; <span class="comment">//数据的（数据）类型 依据数据的实际类型定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体</span></span><br><span class="line"><span class="comment">//顺序栈</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">SqStack</span></span><br><span class="line">&#123;</span><br><span class="line">    ElemType data[MaxSize]; <span class="comment">//数据</span></span><br><span class="line">    <span class="type">int</span> topPointer;         <span class="comment">//栈顶指针</span></span><br><span class="line">    <span class="comment">//注意：定义为指向栈顶位置而不是栈顶位置的后一位置</span></span><br><span class="line">    <span class="comment">//值是索引，取值范围：-1——MaxSize-1，可作为判断栈空和栈满条件</span></span><br><span class="line">&#125; SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数声明————————————————————</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_example</span><span class="params">()</span></span>;                         <span class="comment">//使用示例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(SqStack &amp;sqStack)</span></span>;                <span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(SqStack &amp;sqStack, ElemType elem)</span></span>; <span class="comment">//入栈</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(SqStack &amp;sqStack, ElemType &amp;elem)</span></span>; <span class="comment">//出栈</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数————————————————————</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">use_example</span>(); <span class="comment">//使用示例</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数定义————————————————————</span></span><br><span class="line"><span class="comment">//使用示例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_example</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建</span></span><br><span class="line">    SqStack sqStack;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">init</span>(sqStack);</span><br><span class="line">    cout &lt;&lt; sqStack.topPointer &lt;&lt; endl; <span class="comment">//输出：-1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//入栈</span></span><br><span class="line">    ElemType elem1 = <span class="number">100</span>;</span><br><span class="line">    ElemType elem2 = <span class="number">200</span>;</span><br><span class="line">    ElemType elem3 = <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">push</span>(sqStack, elem1);</span><br><span class="line">    <span class="built_in">push</span>(sqStack, elem2);</span><br><span class="line">    <span class="built_in">push</span>(sqStack, elem3); <span class="comment">//元素在栈中的排列：100，200，300</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//出栈</span></span><br><span class="line">    ElemType elem4 = <span class="number">0</span>;</span><br><span class="line">    ElemType elem5 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pop</span>(sqStack, elem4);</span><br><span class="line">    <span class="built_in">pop</span>(sqStack, elem5);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; elem4 &lt;&lt; endl; <span class="comment">//输出：300</span></span><br><span class="line">    cout &lt;&lt; elem5 &lt;&lt; endl; <span class="comment">//输出：200</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(SqStack &amp;sqStack)</span> <span class="comment">//参数：栈</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sqStack.topPointer = <span class="number">-1</span>; <span class="comment">//栈顶指针的值，即索引为-1，不存在元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈</span></span><br><span class="line"><span class="comment">//时间复杂度：O(1)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(SqStack &amp;sqStack, ElemType elem)</span> <span class="comment">//参数：栈，元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//注意：判断合法条件</span></span><br><span class="line">    <span class="keyword">if</span> (sqStack.topPointer == MaxSize - <span class="number">1</span>) <span class="comment">//栈满</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ++sqStack.topPointer;                    <span class="comment">//栈顶指针+1</span></span><br><span class="line">    sqStack.data[sqStack.topPointer] = elem; <span class="comment">//元素入栈</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="comment">//时间复杂度：O(1)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(SqStack &amp;sqStack, ElemType &amp;elem)</span> <span class="comment">//参数：栈，元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sqStack.topPointer == <span class="number">-1</span>) <span class="comment">//栈空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    elem = sqStack.data[sqStack.topPointer]; <span class="comment">//获取、保存元素</span></span><br><span class="line">    --sqStack.topPointer;                    <span class="comment">//栈顶指针-1   元素出栈</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="linkStack-cpp（链栈）"><a href="#linkStack-cpp（链栈）" class="headerlink" title="linkStack.cpp（链栈）"></a>linkStack.cpp（链栈）</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件————————————————————</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//命名空间————————————————————</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型————————————————————</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType; <span class="comment">//数据的（数据）类型 依据数据的实际类型定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体</span></span><br><span class="line"><span class="comment">//链栈结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkNode</span></span><br><span class="line">&#123;</span><br><span class="line">    ElemType data;         <span class="comment">//数据</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LinkNode</span> *next; <span class="comment">//指针</span></span><br><span class="line">&#125; LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数声明————————————————————</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_example</span><span class="params">()</span></span>;                        <span class="comment">//使用示例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(LinkNode *&amp;head)</span></span>;                <span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(LinkNode *&amp;head, ElemType elem)</span></span>; <span class="comment">//入栈</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(LinkNode *&amp;head, ElemType &amp;elem)</span></span>; <span class="comment">//出栈</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数————————————————————</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">use_example</span>(); <span class="comment">//使用示例</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数定义————————————————————</span></span><br><span class="line"><span class="comment">//使用示例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_example</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建</span></span><br><span class="line">    LinkNode *head; <span class="comment">//头结点指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">init</span>(head);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入栈</span></span><br><span class="line">    ElemType elem1 = <span class="number">100</span>;</span><br><span class="line">    ElemType elem2 = <span class="number">200</span>;</span><br><span class="line">    ElemType elem3 = <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">push</span>(head, elem1);</span><br><span class="line">    <span class="built_in">push</span>(head, elem2);</span><br><span class="line">    <span class="built_in">push</span>(head, elem3); <span class="comment">//元素在栈中的排列：100，200，300</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//出栈</span></span><br><span class="line">    ElemType elem4 = <span class="number">0</span>;</span><br><span class="line">    ElemType elem5 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pop</span>(head, elem4);</span><br><span class="line">    <span class="built_in">pop</span>(head, elem5);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; elem4 &lt;&lt; endl; <span class="comment">//输出：300</span></span><br><span class="line">    cout &lt;&lt; elem5 &lt;&lt; endl; <span class="comment">//输出：200</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(LinkNode *&amp;head)</span> <span class="comment">//参数：头结点指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = (LinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode)); <span class="comment">//创建头结点   头结点指针指向头结点</span></span><br><span class="line">    head-&gt;next = <span class="literal">nullptr</span>;                        <span class="comment">//头结点的指针指向空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈</span></span><br><span class="line"><span class="comment">//时间复杂度：O(1)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(LinkNode *&amp;head, ElemType elem)</span> <span class="comment">//参数：头结点指针，元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkNode *newNode; <span class="comment">//新结点指针</span></span><br><span class="line"></span><br><span class="line">    newNode = (LinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode)); <span class="comment">//创建新结点</span></span><br><span class="line"></span><br><span class="line">    newNode-&gt;data = elem; <span class="comment">//初始化新结点的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//入栈</span></span><br><span class="line">    newNode-&gt;next = head-&gt;next;</span><br><span class="line">    head-&gt;next = newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="comment">//时间复杂度：O(1)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(LinkNode *&amp;head, ElemType &amp;elem)</span> <span class="comment">//参数：头结点指针，元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head-&gt;next == <span class="literal">nullptr</span>) <span class="comment">//栈空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LinkNode *tempNode = <span class="literal">nullptr</span>; <span class="comment">//临时结点指针</span></span><br><span class="line"></span><br><span class="line">    elem = head-&gt;next-&gt;data; <span class="comment">//获取、保存数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//出栈</span></span><br><span class="line">    tempNode = head-&gt;next;</span><br><span class="line">    head-&gt;next = tempNode-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(tempNode); <span class="comment">//释放结点空间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>不同参考资料中，顺序栈和链栈的描述实现各不相同，但基本思想是一致的。作者使用规范的变量命名、提供详细的步骤解析及使用示例，应用C&#x2F;C++语言将其整合成模板，以帮助理解记忆。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《2023版数据结构高分笔记》主编：率辉</li><li>《2023年计算机组成原理考研复习指导》组编：王道论坛</li><li>《大话数据结构》作者：程杰</li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式概述</title>
      <link href="/2022/08/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/"/>
      <url>/2022/08/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>设计模式概述。</p><hr><h1 id="编程代码的原则-面向对象的优势：4点"><a href="#编程代码的原则-面向对象的优势：4点" class="headerlink" title="编程代码的原则&#x2F;面向对象的优势：4点"></a>编程代码的原则&#x2F;面向对象的优势：4点</h1><ul><li>可维护</li><li>可复用</li><li>可扩展</li><li>可灵活&#x2F;灵活性好</li></ul><hr><h1 id="统一建模语言（UML）图的基本关系：6种"><a href="#统一建模语言（UML）图的基本关系：6种" class="headerlink" title="统一建模语言（UML）图的基本关系：6种"></a>统一建模语言（UML）图的基本关系：6种</h1><ul><li>继承：实线，三角箭头，指向被继承类</li><li>实现：虚线，三角箭头，指向被实现接口</li><li>依赖：虚线，箭头，指向被依赖者</li><li>关联：实线，箭头，指向被关联者</li><li>聚合：空心菱形，实线箭头，指向被聚合者</li><li>组合：实心菱形，实线箭头，指向被组合者</li></ul><p>依赖和关联、聚合、组合的区别：</p><ul><li>依赖表现：局部变量，方法形参，静态方法调用</li><li>关联、聚合、组合表现：一个类持有另一个类对象（的引用）作为成员</li></ul><p>依赖、关联、聚合和组合关系的弱强程度：依赖&lt;关联&lt;聚合&lt;组合</p><hr><h1 id="设计模式的原则：7种"><a href="#设计模式的原则：7种" class="headerlink" title="设计模式的原则：7种"></a>设计模式的原则：7种</h1><h2 id="开放-封闭-开-闭原则（OCP）"><a href="#开放-封闭-开-闭原则（OCP）" class="headerlink" title="开放-封闭&#x2F;开-闭原则（OCP）"></a>开放-封闭&#x2F;开-闭原则（OCP）</h2><p>描述：</p><ul><li>针对软件实体：类、模块和函数等：对扩展是开放的，对更改是封闭的</li></ul><p>应用：</p><ul><li>实现业务逻辑时，可扩展&#x2F;增加新的代码，不可更改&#x2F;不修改旧的代码</li></ul><hr><h2 id="依赖倒转-置原则（DIP）"><a href="#依赖倒转-置原则（DIP）" class="headerlink" title="依赖倒转&#x2F;置原则（DIP）"></a>依赖倒转&#x2F;置原则（DIP）</h2><p>描述：</p><ul><li>高层模块不应该依赖底层模块，两种模块都应该依赖抽象</li><li>抽象不应该依赖细节</li><li>细节应该依赖抽象</li></ul><blockquote><p>其中的“不应该”、“应该”是“依赖倒转”的体现</p></blockquote><p>应用：</p><ul><li>不面向实现编程，面向接口&#x2F;抽象类编程</li><li>使用抽象类&#x2F;接口作为变量、参数</li></ul><hr><h2 id="单一职责原则（SRP）"><a href="#单一职责原则（SRP）" class="headerlink" title="单一职责原则（SRP）"></a>单一职责原则（SRP）</h2><p>描述：</p><ul><li>类的逻辑&#x2F;功能&#x2F;职责单一</li><li>引起类变化的原因应该有且仅有一个</li></ul><p>应用：</p><ul><li>拆分业务对象、逻辑</li></ul><hr><h2 id="最少知识原则-迪米特法则（LOD）"><a href="#最少知识原则-迪米特法则（LOD）" class="headerlink" title="最少知识原则&#x2F;迪米特法则（LOD）"></a>最少知识原则&#x2F;迪米特法则（LOD）</h2><p>描述：</p><ul><li>类间弱耦合</li></ul><p>应用：</p><ul><li>尽可能封装类</li></ul><hr><h2 id="里氏代换原则（LSP）"><a href="#里氏代换原则（LSP）" class="headerlink" title="里氏代换原则（LSP）"></a>里氏代换原则（LSP）</h2><p>描述：</p><ul><li>子&#x2F;派生类型必须能够代换其父&#x2F;基类型</li><li>子类可以扩展父类的功能，但不能改变父类的功能</li><li>本质：面向对象的多态</li></ul><p>应用：</p><ul><li>使用子类扩展业务逻辑</li></ul><hr><h2 id="接口隔离原则（ISP）"><a href="#接口隔离原则（ISP）" class="headerlink" title="接口隔离原则（ISP）"></a>接口隔离原则（ISP）</h2><p>描述：</p><ul><li>客户端不应该依赖不需要的接口</li><li>类间的关系应该建立在最小的接口上</li></ul><p>应用：</p><ul><li>依据业务逻辑拆分复杂多用接口为简单专用接口</li></ul><hr><h2 id="合成-聚合复用原则（C-ARP）"><a href="#合成-聚合复用原则（C-ARP）" class="headerlink" title="合成&#x2F;聚合复用原则（C&#x2F;ARP）"></a>合成&#x2F;聚合复用原则（C&#x2F;ARP）</h2><p>描述：</p><ul><li>类间尽量使用依赖、关联、聚合和组合关系，不使用继承关系</li></ul><p>应用：</p><ul><li>类间尽量使用依赖、关联、聚合和组合关系，不使用继承关系</li></ul><hr><h1 id="设计模式原则的关系（记忆方式）"><a href="#设计模式原则的关系（记忆方式）" class="headerlink" title="设计模式原则的关系（记忆方式）"></a>设计模式原则的关系（记忆方式）</h1><ul><li>总体规则——开放-封闭&#x2F;开-闭原则（OCP）、依赖倒转&#x2F;置原则（DIP）</li><li>设计模式的核心是面向对象</li><li>面向对象的封装——单一职责原则（SRP）、最少知识原则&#x2F;迪米特法则（LOD）</li><li>面向对象的继承、多态——里氏代换原则（LSP）、接口隔离原则（ISP）</li><li>类间的关系描述——合成复用原则（CRP）</li></ul><hr><h1 id="设计模式的类型：3种"><a href="#设计模式的类型：3种" class="headerlink" title="设计模式的类型：3种"></a>设计模式的类型：3种</h1><p>依据意图：</p><ul><li>创建型：负责提供创建对象的机制</li><li>结构型：负责将对象组装成较复杂的结构</li><li>行为型：负责对象间的高效沟通和职责委派</li></ul><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>设计模式概述。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《大话设计模式》作者：程杰</li><li><a href="https://refactoringguru.cn/design-patterns">常用设计模式有哪些？ (refactoringguru.cn)</a></li><li><a href="https://m.php.cn/faq/470016.html">设计模式六大原则是什么-常见问题-PHP中文网</a></li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“物理层”学习提纲</title>
      <link href="/2022/07/30/%E2%80%9C%E7%89%A9%E7%90%86%E5%B1%82%E2%80%9D%E5%AD%A6%E4%B9%A0%E6%8F%90%E7%BA%B2/"/>
      <url>/2022/07/30/%E2%80%9C%E7%89%A9%E7%90%86%E5%B1%82%E2%80%9D%E5%AD%A6%E4%B9%A0%E6%8F%90%E7%BA%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>计算机网络的知识抽象、晦涩、不易理解并记忆，在此对“物理层”一章中重点知识总结成提纲。</p><hr><h1 id="通信基础"><a href="#通信基础" class="headerlink" title="通信基础"></a>通信基础</h1><h2 id="物理层的基本概念"><a href="#物理层的基本概念" class="headerlink" title="物理层的基本概念"></a>物理层的基本概念</h2><ul><li>数据、信号、码元</li><li>速率&#x2F;数据率&#x2F;数据传输速率、比特率&#x2F;信息速率&#x2F;信息传输速率、波特率&#x2F;码元传输速率&#x2F;波形速率&#x2F;符号速率&#x2F;调制速率、带宽</li><li>奈奎斯特定理&#x2F;奈氏准则、香农定理</li><li>调制、编码</li><li>信源、信道、信宿</li><li>电路交换、报文交换、分组交换</li><li>数据报、虚电路</li></ul><hr><h2 id="数据-信号的类型"><a href="#数据-信号的类型" class="headerlink" title="数据&#x2F;信号的类型"></a>数据&#x2F;信号的类型</h2><ul><li>模拟</li><li>数字</li></ul><p>另：</p><ul><li>基带信号</li><li>频带&#x2F;宽带信号</li></ul><hr><h2 id="数据的传输方式"><a href="#数据的传输方式" class="headerlink" title="数据的传输方式"></a>数据的传输方式</h2><ul><li>串行</li><li>并行</li></ul><hr><h2 id="模拟数据调制为模拟信号的方式"><a href="#模拟数据调制为模拟信号的方式" class="headerlink" title="模拟数据调制为模拟信号的方式"></a>模拟数据调制为模拟信号的方式</h2><p>可使用技术：</p><ul><li>频分复用（FDM）</li><li>时分复用（TDM）</li><li>码分复用（CDM）</li><li>空分复用（SDM）</li></ul><hr><h2 id="模拟数据编码为数字信号的方式"><a href="#模拟数据编码为数字信号的方式" class="headerlink" title="模拟数据编码为数字信号的方式"></a>模拟数据编码为数字信号的方式</h2><p>脉冲编码调制（PCM）的过程：</p><ol><li>采样</li><li>量化</li><li>编码</li></ol><hr><h2 id="数字数据调制为模拟信号的方式"><a href="#数字数据调制为模拟信号的方式" class="headerlink" title="数字数据调制为模拟信号的方式"></a>数字数据调制为模拟信号的方式</h2><ul><li>幅移键控（ASK）</li><li>频移键控（FSK）</li><li>（绝对）相移键控（PSK）</li><li>相对&#x2F;差分相移键控（DPSK）</li><li>正交振幅调制（QAM）</li></ul><hr><h2 id="数字数据编码为数字信号的方式"><a href="#数字数据编码为数字信号的方式" class="headerlink" title="数字数据编码为数字信号的方式"></a>数字数据编码为数字信号的方式</h2><ul><li>归零编码（RZ）</li><li>非归零编码（NRZ）</li><li>反向非归零编码（NRZI）——USB 2.0使用</li><li>曼彻斯特编码——以太网使用</li><li>差分曼彻斯特编码</li><li>4B&#x2F;5B编码</li></ul><hr><h2 id="通信系统的组成"><a href="#通信系统的组成" class="headerlink" title="通信系统的组成"></a>通信系统的组成</h2><ul><li>信源</li><li>信道</li><li>信宿</li><li>…</li></ul><hr><h2 id="信道的类型"><a href="#信道的类型" class="headerlink" title="信道的类型"></a>信道的类型</h2><p>依据传输信号类型：</p><ul><li>模拟信道</li><li>数字信道</li></ul><p>依据传输介质：</p><ul><li>有线信道</li><li>无线信道</li></ul><hr><h2 id="通信的交互方式"><a href="#通信的交互方式" class="headerlink" title="通信的交互方式"></a>通信的交互方式</h2><p>依据方向、时序：</p><ul><li>单工</li><li>半双工</li><li>全双工</li></ul><p>依据时序：</p><ul><li>同步：全网同步，准同步</li><li>异步</li></ul><hr><h2 id="数据交换的方式"><a href="#数据交换的方式" class="headerlink" title="数据交换的方式"></a>数据交换的方式</h2><ul><li>电路交换</li><li>报文交换</li><li>分组交换</li></ul><hr><h2 id="电路交换的过程"><a href="#电路交换的过程" class="headerlink" title="电路交换的过程"></a>电路交换的过程</h2><ol><li>连接建立</li><li>数据传输</li><li>连接释放</li></ol><hr><h2 id="分组交换中虚电路方式通信的过程"><a href="#分组交换中虚电路方式通信的过程" class="headerlink" title="分组交换中虚电路方式通信的过程"></a>分组交换中虚电路方式通信的过程</h2><ol><li>虚电路建立</li><li>数据传输</li><li>虚电路释放</li></ol><hr><h1 id="传输介质-媒体"><a href="#传输介质-媒体" class="headerlink" title="传输介质&#x2F;媒体"></a>传输介质&#x2F;媒体</h1><h2 id="传输介质-媒体的类型"><a href="#传输介质-媒体的类型" class="headerlink" title="传输介质&#x2F;媒体的类型"></a>传输介质&#x2F;媒体的类型</h2><p>依据有无导向：</p><ul><li>导向传输介质&#x2F;媒体</li><li>非导向传输介质&#x2F;媒体</li></ul><p>依据有无线：</p><ul><li>有线传输介质&#x2F;媒体</li><li>无线传输介质&#x2F;媒体</li></ul><hr><h2 id="传输介质-媒体实例"><a href="#传输介质-媒体实例" class="headerlink" title="传输介质&#x2F;媒体实例"></a>传输介质&#x2F;媒体实例</h2><ul><li>双绞线：屏蔽双绞线（STP），非屏蔽双绞线（UTP）</li><li>同轴电缆：50Ω同轴电缆&#x2F;基带同轴电缆，75Ω同轴电缆&#x2F;宽带&#x2F;频带同轴电缆</li><li>光导纤维&#x2F;光纤：单模光纤，多模光纤</li><li>无线电波</li><li>微波</li><li>红外线</li><li>激光</li></ul><hr><h2 id="物理层接口的特性"><a href="#物理层接口的特性" class="headerlink" title="物理层接口的特性"></a>物理层接口的特性</h2><ul><li>机械特性</li><li>电气特性</li><li>功能特性</li><li>过程&#x2F;规程特性</li></ul><hr><h1 id="物理层设备"><a href="#物理层设备" class="headerlink" title="物理层设备"></a>物理层设备</h1><h2 id="物理层设备实例"><a href="#物理层设备实例" class="headerlink" title="物理层设备实例"></a>物理层设备实例</h2><ul><li>转发器</li><li>中继器</li><li>集线器（Hub）</li></ul><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>计算机网络的知识抽象、晦涩、不易理解并记忆，在此对“物理层”一章中重点知识总结成提纲。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《2023年计算机网络考研复习指导》组编：王道论坛</li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“计算机网络体系结构”学习提纲</title>
      <link href="/2022/07/29/%E2%80%9C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E2%80%9D%E5%AD%A6%E4%B9%A0%E6%8F%90%E7%BA%B2/"/>
      <url>/2022/07/29/%E2%80%9C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E2%80%9D%E5%AD%A6%E4%B9%A0%E6%8F%90%E7%BA%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>计算机网络的知识抽象、晦涩、不易理解并记忆，在此对“计算机网络体系结构”一章中重点知识总结成提纲。</p><hr><h1 id="计算机网络概述"><a href="#计算机网络概述" class="headerlink" title="计算机网络概述"></a>计算机网络概述</h1><h2 id="计算机网络的概念"><a href="#计算机网络的概念" class="headerlink" title="计算机网络的概念"></a>计算机网络的概念</h2><ul><li>广义观点</li><li>资源共享观点</li><li>用户透明性观点</li></ul><hr><h2 id="计算机网络的组成"><a href="#计算机网络的组成" class="headerlink" title="计算机网络的组成"></a>计算机网络的组成</h2><p>依据结构部分：</p><ul><li>硬件</li><li>软件</li><li>协议</li></ul><p>依据提供功能：</p><ul><li>通信子网</li><li>资源子网</li></ul><p>依据工作方式：</p><ul><li>核心部分</li><li>边缘部分</li></ul><hr><h2 id="计算机网络的功能"><a href="#计算机网络的功能" class="headerlink" title="计算机网络的功能"></a>计算机网络的功能</h2><ul><li>数据通信——最基本功能</li><li>资源共享</li><li>提高可靠性</li><li>负载均衡</li><li>分布式处理</li></ul><hr><h2 id="计算机网络的资源"><a href="#计算机网络的资源" class="headerlink" title="计算机网络的资源"></a>计算机网络的资源</h2><ul><li>硬件</li><li>软件</li><li>数据</li></ul><hr><h2 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a>计算机网络的分类</h2><p>依据分布范围：</p><ul><li>个人区域网（PAN）&#x2F;无线个人区域网（WPAN）</li><li>局域网（LAN）</li><li>城域网（MAN）</li><li>广域网（WAN）&#x2F;远程网</li></ul><p>依据传输技术：</p><ul><li>广播式网络</li><li>点对点网络</li></ul><p>依据拓扑结构：</p><ul><li>总线形</li><li>星形</li><li>环形</li><li>网状形</li></ul><p>依据使用者：</p><ul><li>公用网&#x2F;公众网</li><li>专用网</li></ul><p>依据交换技术：</p><ul><li>电路交换网络</li><li>报文交换网络&#x2F;存储-转发网络</li><li>分组交换网络&#x2F;包交换网络</li></ul><p>依据传输介质：</p><ul><li>有线网</li><li>无线网</li></ul><hr><h2 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h2><ul><li>数据率&#x2F;速率&#x2F;数据传输速率&#x2F;比特率</li><li>（信道）带宽——单位为比特&#x2F;秒（b&#x2F;s）而不是赫兹（Hz）</li><li>时延&#x3D;传输&#x2F;发送时延+排队时延+处理时延+传播时延</li><li>时延带宽积&#x2F;以比特为单位的链路长度&#x3D;信道带宽×传播时延</li><li>往返时延（RTT）</li><li>吞吐量</li><li>信道利用率</li></ul><hr><h2 id="计算机网络的标准化工作"><a href="#计算机网络的标准化工作" class="headerlink" title="计算机网络的标准化工作"></a>计算机网络的标准化工作</h2><blockquote><p>注意：因特网的所有标准都以征求评议文档（RFC）的形式在因特网上发布；征求评议文档（RFC）不一定是因特网标准</p></blockquote><p>征求评议文档（RFC）上升为因特网标准需要经过的阶段：</p><ol><li>因特网草案</li><li>建议标准——成为征求评议文档（RFC）</li><li>草案标准</li><li>因特网标准</li></ol><p>部分国际上负责制定和实施相关网络标准的标准化组织：</p><ul><li>国际标准化组织（ISO）</li><li>国际电信联盟（ITU）</li><li>国际电气电子工程师协会（IEEE）</li></ul><hr><h1 id="计算机网络体系结构与参考模型"><a href="#计算机网络体系结构与参考模型" class="headerlink" title="计算机网络体系结构与参考模型"></a>计算机网络体系结构与参考模型</h1><h2 id="协议数据单元（PDU）的组成"><a href="#协议数据单元（PDU）的组成" class="headerlink" title="协议数据单元（PDU）的组成"></a>协议数据单元（PDU）的组成</h2><ul><li>协议控制信息（PCI）</li><li>服务数据单元（SDU）</li></ul><p>第n层协议数据单元（PDU）的组成关系：n-PCI + n-SDU &#x3D; n-PDU &#x3D; (n-1)-SDU</p><hr><h2 id="计算机网络各层次协议数据单元（PDU）的名称"><a href="#计算机网络各层次协议数据单元（PDU）的名称" class="headerlink" title="计算机网络各层次协议数据单元（PDU）的名称"></a>计算机网络各层次协议数据单元（PDU）的名称</h2><ul><li>应用层：消息</li><li>传输层：段&#x2F;报</li><li>网络层：分组</li><li>数据链路层：帧</li><li>物理层：比特</li></ul><hr><h2 id="网络协议的组成"><a href="#网络协议的组成" class="headerlink" title="网络协议的组成"></a>网络协议的组成</h2><ul><li>语法</li><li>语义</li><li>时序&#x2F;同步</li></ul><hr><h2 id="开放式系统互联参考模型（OSI-RM）中服务原语的类型"><a href="#开放式系统互联参考模型（OSI-RM）中服务原语的类型" class="headerlink" title="开放式系统互联参考模型（OSI&#x2F;RM）中服务原语的类型"></a>开放式系统互联参考模型（OSI&#x2F;RM）中服务原语的类型</h2><ul><li>请求</li><li>指示</li><li>响应</li><li>证实</li></ul><hr><h2 id="计算机网络服务的类型"><a href="#计算机网络服务的类型" class="headerlink" title="计算机网络服务的类型"></a>计算机网络服务的类型</h2><p>依据是否有连接：</p><ul><li>无连接服务</li><li>面向连接服务</li></ul><p>依据是否可靠：</p><ul><li>不可靠服</li><li>可靠服务</li></ul><p>依据是否有应答：</p><ul><li>无应答服务</li><li>有应答服务</li></ul><hr><h2 id="开放式系统互联参考模型（OSI-RM）的结构"><a href="#开放式系统互联参考模型（OSI-RM）的结构" class="headerlink" title="开放式系统互联参考模型（OSI&#x2F;RM）的结构"></a>开放式系统互联参考模型（OSI&#x2F;RM）的结构</h2><p>从上&#x2F;高层到下&#x2F;底层：</p><ul><li>应用层</li><li>表示层</li><li>会话层</li><li>传输&#x2F;运输层</li><li>网络&#x2F;网际&#x2F;IP层</li><li>数据链路层</li><li>物理层</li></ul><blockquote><p>高三层统称为资源子网，低三层统称为通信子网</p></blockquote><hr><h2 id="传输控制协议-网际协议（TCI-IP）模型的结构"><a href="#传输控制协议-网际协议（TCI-IP）模型的结构" class="headerlink" title="传输控制协议&#x2F;网际协议（TCI&#x2F;IP）模型的结构"></a>传输控制协议&#x2F;网际协议（TCI&#x2F;IP）模型的结构</h2><p>从上&#x2F;高层到下&#x2F;底层：</p><ul><li>应用层</li><li>传输层</li><li>网际层</li><li>网络接口层</li></ul><hr><h2 id="综合模型的结构"><a href="#综合模型的结构" class="headerlink" title="综合模型的结构"></a>综合模型的结构</h2><p>从上&#x2F;高层到下&#x2F;底层：</p><ul><li>应用层</li><li>传输层</li><li>网际层</li><li>数据链路层</li><li>物理层</li></ul><hr><h2 id="综合模型中各层提供的服务访问点（SAP）"><a href="#综合模型中各层提供的服务访问点（SAP）" class="headerlink" title="综合模型中各层提供的服务访问点（SAP）"></a>综合模型中各层提供的服务访问点（SAP）</h2><ul><li>应用层：用户界面</li><li>传输层：端口号</li><li>网络层：网络&#x2F;IP地址</li><li>数据链路层：网卡&#x2F;MAC地址</li><li>物理层：网卡接口</li></ul><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>计算机网络的知识抽象、晦涩、不易理解并记忆，在此对“计算机网络体系结构”一章中重点知识总结成提纲。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《2023年计算机网络考研复习指导》组编：王道论坛</li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“数据的表示和运算”学习提纲</title>
      <link href="/2022/07/28/%E2%80%9C%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97%E2%80%9D%E5%AD%A6%E4%B9%A0%E6%8F%90%E7%BA%B2/"/>
      <url>/2022/07/28/%E2%80%9C%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97%E2%80%9D%E5%AD%A6%E4%B9%A0%E6%8F%90%E7%BA%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>计算机组成原理的知识抽象、晦涩、不易理解并记忆，在此对“数据的表示和运算”一章中重点知识总结成提纲。其中不包括数据的表示和运算：如原、反、补码表示和定、浮点数运算等内容。</p><hr><h1 id="基本运算部件"><a href="#基本运算部件" class="headerlink" title="基本运算部件"></a>基本运算部件</h1><ul><li>一位全加器（FA）</li><li>串行进位&#x2F;行波进位加法器</li><li>并行进位&#x2F;先行进位&#x2F;超前进位加法器</li><li>带标志加法器（符号&#x2F;和标志：SF，进位&#x2F;借位标志：CF，零标志：ZF，溢出标志：OF）</li><li>算术逻辑单元（ALU）</li></ul><hr><h1 id="C语言中的部分强制类型转换规则"><a href="#C语言中的部分强制类型转换规则" class="headerlink" title="C语言中的部分强制类型转换规则"></a>C语言中的部分强制类型转换规则</h1><ul><li>无、有符号数的转换：二进制数的位值不变，解释位的方式改变</li><li>长字长转换为短字长：低位赋值，高位截断</li><li>短字长转换为长字长：若原数字是无符号整数，则进行零扩展；若原数字是有符号整数，则进行符号扩展</li></ul><hr><h1 id="数据的存储排列方式"><a href="#数据的存储排列方式" class="headerlink" title="数据的存储排列方式"></a>数据的存储排列方式</h1><blockquote><p>人类习惯的数据阅读方式：左高位，右低位</p></blockquote><ul><li>小端方式——最低有效字节（LSB）在前&#x2F;左&#x2F;地址定位在最低有效字节（LSB）&#x2F;一个字的低位字节存放在内存中该字区域的低地址处；常见于网络</li><li>大端方式——最高有效字节（MSB）在前&#x2F;左&#x2F;地址定位在最高有效字节（MSB）&#x2F;一个字的高位字节存放在内存中该字区域的低地址处；常见于主机</li><li>边界对齐方式</li></ul><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>计算机组成原理的知识抽象、晦涩、不易理解并记忆，在此对“数据的表示和运算”一章中重点知识总结成提纲。其中不包括数据的表示和运算：如原、反、补码表示和定、浮点数运算等内容。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《2023年计算机组成原理考研复习指导》组编：王道论坛</li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“输入/输出（I/O）设备管理”学习提纲</title>
      <link href="/2022/07/27/%E2%80%9C%E8%BE%93%E5%85%A5_%E8%BE%93%E5%87%BA%EF%BC%88I_O%EF%BC%89%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%E2%80%9D%E5%AD%A6%E4%B9%A0%E6%8F%90%E7%BA%B2/"/>
      <url>/2022/07/27/%E2%80%9C%E8%BE%93%E5%85%A5_%E8%BE%93%E5%87%BA%EF%BC%88I_O%EF%BC%89%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%E2%80%9D%E5%AD%A6%E4%B9%A0%E6%8F%90%E7%BA%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>操作系统的知识抽象、晦涩、不易理解并记忆，在此对“输入&#x2F;输出（I&#x2F;O）设备管理”一章中重点知识总结成提纲。</p><hr><h1 id="输入-输出（I-O）设备管理概述"><a href="#输入-输出（I-O）设备管理概述" class="headerlink" title="输入&#x2F;输出（I&#x2F;O）设备管理概述"></a>输入&#x2F;输出（I&#x2F;O）设备管理概述</h1><h2 id="输入-输出（I-O）设备管理的功能"><a href="#输入-输出（I-O）设备管理的功能" class="headerlink" title="输入&#x2F;输出（I&#x2F;O）设备管理的功能"></a>输入&#x2F;输出（I&#x2F;O）设备管理的功能</h2><ul><li>状态跟踪</li><li>设备控制</li><li>设备分配</li><li>设备存取</li></ul><hr><h2 id="设备的类型"><a href="#设备的类型" class="headerlink" title="设备的类型"></a>设备的类型</h2><p>依据信息交换的单位：</p><ul><li>块设备。如磁盘</li><li>字符设备。如交互式终端机、打印机</li></ul><p>依据传输速率：</p><ul><li>低速设备。如键盘、鼠标</li><li>中速设备。如激光打印机</li><li>高速设备。如磁盘机、光盘机</li></ul><hr><h2 id="输入-输出（I-O）接口的组成"><a href="#输入-输出（I-O）接口的组成" class="headerlink" title="输入&#x2F;输出（I&#x2F;O）接口的组成"></a>输入&#x2F;输出（I&#x2F;O）接口的组成</h2><blockquote><p>输入&#x2F;输出（I&#x2F;O）接口又称输入&#x2F;输出（I&#x2F;O）控制器、设备控制器</p></blockquote><ul><li>与中央处理器（CPU）的接口</li><li>输入&#x2F;输出（I&#x2F;O）逻辑</li><li>与设备的接口</li></ul><hr><h2 id="输入-输出（I-O）接口的功能"><a href="#输入-输出（I-O）接口的功能" class="headerlink" title="输入&#x2F;输出（I&#x2F;O）接口的功能"></a>输入&#x2F;输出（I&#x2F;O）接口的功能</h2><ul><li>接收和识别中央处理器（CPU）发送的命令</li><li>地址识别</li><li>差错控制</li><li>数据缓冲</li><li>数据交换</li><li>标识和报告设备的状态</li></ul><hr><h2 id="应用程序输入-输出（I-O）接口的类型"><a href="#应用程序输入-输出（I-O）接口的类型" class="headerlink" title="应用程序输入&#x2F;输出（I&#x2F;O）接口的类型"></a>应用程序输入&#x2F;输出（I&#x2F;O）接口的类型</h2><ul><li>块设备接口</li><li>字符设备接口</li><li>网络设备接口</li><li>同步阻塞&#x2F;非阻塞接口</li></ul><hr><h2 id="输入-输出（I-O）端口的组成"><a href="#输入-输出（I-O）端口的组成" class="headerlink" title="输入&#x2F;输出（I&#x2F;O）端口的组成"></a>输入&#x2F;输出（I&#x2F;O）端口的组成</h2><blockquote><p>输入&#x2F;输出（I&#x2F;O）端口指输入&#x2F;输出（I&#x2F;O）接口中可被中央处理器（CPU）直接访问的寄存器</p></blockquote><ul><li>控制寄存器</li><li>状态寄存器</li><li>数据寄存器</li></ul><hr><h2 id="输入-输出（I-O）端口的编址方式"><a href="#输入-输出（I-O）端口的编址方式" class="headerlink" title="输入&#x2F;输出（I&#x2F;O）端口的编址方式"></a>输入&#x2F;输出（I&#x2F;O）端口的编址方式</h2><ul><li>统一编址&#x2F;内存映射输入&#x2F;输出（I&#x2F;O）</li><li>独立编址</li></ul><hr><h2 id="输入-输出（I-O）的控制方式"><a href="#输入-输出（I-O）的控制方式" class="headerlink" title="输入&#x2F;输出（I&#x2F;O）的控制方式"></a>输入&#x2F;输出（I&#x2F;O）的控制方式</h2><ul><li>程序直接控制方式</li><li>中断驱动方式</li><li>直接存储器访问（DMA）方式</li><li>通道控制方式</li></ul><hr><h2 id="直接存储器访问（DMA）控制器的组成"><a href="#直接存储器访问（DMA）控制器的组成" class="headerlink" title="直接存储器访问（DMA）控制器的组成"></a>直接存储器访问（DMA）控制器的组成</h2><ul><li>命令&#x2F;状态寄存器（CR）</li><li>存储器地址寄存器（MAR）</li><li>数据计数器（DC）</li><li>数据寄存器（DR）</li></ul><hr><h2 id="输入-输出（I-O）软件的层次结构"><a href="#输入-输出（I-O）软件的层次结构" class="headerlink" title="输入&#x2F;输出（I&#x2F;O）软件的层次结构"></a>输入&#x2F;输出（I&#x2F;O）软件的层次结构</h2><ul><li>用户层——用户层输入&#x2F;输出（I&#x2F;O）软件</li><li>设备独立&#x2F;无关层——设备独立&#x2F;无关性软件&#x2F;系统调用处理程序</li><li>设备驱动层——设备驱动程序</li><li>中断处理层——中断处理程序</li><li>硬件层——设备控制器、设备</li></ul><hr><h1 id="设备独立-无关性软件"><a href="#设备独立-无关性软件" class="headerlink" title="设备独立&#x2F;无关性软件"></a>设备独立&#x2F;无关性软件</h1><h2 id="磁盘高速缓存在内存中的设计方式"><a href="#磁盘高速缓存在内存中的设计方式" class="headerlink" title="磁盘高速缓存在内存中的设计方式"></a>磁盘高速缓存在内存中的设计方式</h2><ul><li>大小固定的单独空间</li><li>未利用的空间作缓冲区</li></ul><hr><h2 id="缓冲技术的功能"><a href="#缓冲技术的功能" class="headerlink" title="缓冲技术的功能"></a>缓冲技术的功能</h2><ul><li>解决基本数据单元大小&#x2F;数据粒度不匹配的问题</li><li>缓和中央处理器（CPU）和输入&#x2F;输出（I&#x2F;O）设备间速度不匹配的矛盾</li><li>减少对中央处理器（CPU）的中断频率，放宽对中央处理器（CPU）中断响应时间的限制</li><li>提高中央处理器（CPU）与输入&#x2F;输出（I&#x2F;O）设备间的并行性</li></ul><hr><h2 id="缓冲技术的实现方式"><a href="#缓冲技术的实现方式" class="headerlink" title="缓冲技术的实现方式"></a>缓冲技术的实现方式</h2><ul><li>硬件缓冲器</li><li>内存中的缓冲区</li></ul><hr><h2 id="缓冲技术的分类"><a href="#缓冲技术的分类" class="headerlink" title="缓冲技术的分类"></a>缓冲技术的分类</h2><p>依据缓冲器&#x2F;区的数量：</p><ul><li>单缓冲</li><li>双缓冲</li><li>循环缓冲</li><li>缓冲池</li></ul><hr><h2 id="设备分配的数据结构"><a href="#设备分配的数据结构" class="headerlink" title="设备分配的数据结构"></a>设备分配的数据结构</h2><ul><li>系统设备表（SDT）</li><li>设备控制表（DCT）</li><li>控制器控制表（COCT）</li><li>通道控制表（CHCT）</li></ul><hr><h2 id="设备分配的考虑因素"><a href="#设备分配的考虑因素" class="headerlink" title="设备分配的考虑因素"></a>设备分配的考虑因素</h2><ul><li>固有属性</li><li>独立性</li><li>安全性</li><li>分配算法</li></ul><hr><h2 id="设备分配的方式"><a href="#设备分配的方式" class="headerlink" title="设备分配的方式"></a>设备分配的方式</h2><p>依据设备的类型：</p><ul><li>独占分配</li><li>共享分配</li><li>虚拟分配</li></ul><p>依据分配算法：</p><ul><li>静态分配</li><li>动态分配：先来先服务（FCFS）、优先级分配算法等</li></ul><p>依据安全性：</p><ul><li>不安全分配</li><li>安全分配</li></ul><hr><h2 id="设备分配的过程"><a href="#设备分配的过程" class="headerlink" title="设备分配的过程"></a>设备分配的过程</h2><ol><li>设备分配</li><li>设备控制器分配</li><li>通道分配</li></ol><hr><h2 id="设备分配的改进方式"><a href="#设备分配的改进方式" class="headerlink" title="设备分配的改进方式"></a>设备分配的改进方式</h2><ul><li>增加设备的独立&#x2F;无关性——对设备</li><li>考虑多通路情况——对控制器、通道</li></ul><hr><h2 id="逻辑设备表（LUT）的设计方式"><a href="#逻辑设备表（LUT）的设计方式" class="headerlink" title="逻辑设备表（LUT）的设计方式"></a>逻辑设备表（LUT）的设计方式</h2><ul><li>系统逻辑设备表（LUT）——每系统一个</li><li>用户逻辑设备表（LUT）——每用户一个</li></ul><hr><h1 id="磁盘和固态硬盘"><a href="#磁盘和固态硬盘" class="headerlink" title="磁盘和固态硬盘"></a>磁盘和固态硬盘</h1><h2 id="磁盘驱动器的组成"><a href="#磁盘驱动器的组成" class="headerlink" title="磁盘驱动器的组成"></a>磁盘驱动器的组成</h2><ul><li>主轴</li><li>磁盘组</li><li>磁头臂</li><li>输入&#x2F;输出（I&#x2F;O）电子设备</li></ul><hr><h2 id="磁盘的概念"><a href="#磁盘的概念" class="headerlink" title="磁盘的概念"></a>磁盘的概念</h2><ul><li>磁头</li><li>磁盘</li><li>磁盘面</li><li>磁道</li><li>磁道间隙</li><li>扇区&#x2F;盘块</li><li>扇区&#x2F;盘块间隙</li><li>柱面——对磁盘组</li><li>分区——一个或多个柱面</li></ul><blockquote><p>磁盘可寻址的最小单位：扇区&#x2F;盘块<br>决定磁盘能存储的物理块数量：磁盘面数量、磁道数量、扇区&#x2F;盘块数量<br>磁盘地址表示：柱面号、磁盘面号、扇区&#x2F;盘块号</p></blockquote><hr><h2 id="磁盘的类型"><a href="#磁盘的类型" class="headerlink" title="磁盘的类型"></a>磁盘的类型</h2><ul><li>固定头磁盘</li><li>活动头磁盘</li><li>固定盘磁盘</li><li>可换盘磁盘</li></ul><hr><h2 id="磁盘初始化的过程"><a href="#磁盘初始化的过程" class="headerlink" title="磁盘初始化的过程"></a>磁盘初始化的过程</h2><ol><li>物理&#x2F;低级格式化——分扇区&#x2F;盘块</li><li>分区——一个或多个柱面</li><li>逻辑&#x2F;高级格式化——创建文件系统</li></ol><hr><h2 id="磁盘读写操作的时间"><a href="#磁盘读写操作的时间" class="headerlink" title="磁盘读写操作的时间"></a>磁盘读写操作的时间</h2><ul><li>寻找&#x2F;寻道时间</li><li>（旋转）延迟时间</li><li>（数据）传输时间</li></ul><hr><h2 id="磁盘的调度算法"><a href="#磁盘的调度算法" class="headerlink" title="磁盘的调度算法"></a>磁盘的调度算法</h2><ul><li>先来先服务（FCFS）算法</li><li>最短寻找&#x2F;寻道时间优先（SSTF）算法</li><li>扫描（SCAN）&#x2F;电梯调度算法</li><li>循环扫描（CSCAN）算法</li></ul><hr><h2 id="提高磁盘输入-输出（I-O）速度的方法"><a href="#提高磁盘输入-输出（I-O）速度的方法" class="headerlink" title="提高磁盘输入&#x2F;输出（I&#x2F;O）速度的方法"></a>提高磁盘输入&#x2F;输出（I&#x2F;O）速度的方法</h2><ul><li>提前读</li><li>延迟写</li><li>虚拟盘</li></ul><hr><h2 id="固态硬盘（SSD）磨损均衡技术的类型"><a href="#固态硬盘（SSD）磨损均衡技术的类型" class="headerlink" title="固态硬盘（SSD）磨损均衡技术的类型"></a>固态硬盘（SSD）磨损均衡技术的类型</h2><ul><li>动态磨损均衡</li><li>静态磨损均衡——更先进</li></ul><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>操作系统的知识抽象、晦涩、不易理解并记忆，在此对“输入&#x2F;输出（I&#x2F;O）设备管理”一章中重点知识总结成提纲。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《2023年操作系统考研复习指导》组编：王道论坛</li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“文件管理”学习提纲</title>
      <link href="/2022/07/24/%E2%80%9C%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E2%80%9D%E5%AD%A6%E4%B9%A0%E6%8F%90%E7%BA%B2/"/>
      <url>/2022/07/24/%E2%80%9C%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E2%80%9D%E5%AD%A6%E4%B9%A0%E6%8F%90%E7%BA%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>操作系统的知识抽象、晦涩、不易理解并记忆，在此对“文件管理”一章中重点知识总结成提纲。</p><hr><h1 id="文件系统基础"><a href="#文件系统基础" class="headerlink" title="文件系统基础"></a>文件系统基础</h1><h2 id="文件的类型"><a href="#文件的类型" class="headerlink" title="文件的类型"></a>文件的类型</h2><p>依据文件的逻辑结构：</p><ul><li>无结构文件——对字符流</li><li>有结构文件——对记录（顺序文件，索引文件，顺序索引文件，直接&#x2F;散列文件）</li></ul><p>依据文件的物理结构：</p><ul><li>连续文件——类比顺序表</li><li>链接文件——类比链表</li><li>索引文件</li></ul><p>依据UNIX操作系统的文件类型：</p><ul><li>普通文件——存数据</li><li>目录文件——存文件控制块（FCB）&#x2F;索引节点（inode）、数据</li><li>特殊文件——块设备文件，字符设备文件</li><li>符号链接文件</li><li>管道文件</li><li>命名管道文件</li><li>套接字文件</li></ul><hr><h2 id="文件的属性"><a href="#文件的属性" class="headerlink" title="文件的属性"></a>文件的属性</h2><ul><li>名称</li><li>类型</li><li>大小</li><li>位置</li><li>权限</li><li>创建者</li><li>创建时间、上次次修改时间</li><li>所有者</li><li>…</li></ul><hr><h2 id="文件的基本操作"><a href="#文件的基本操作" class="headerlink" title="文件的基本操作"></a>文件的基本操作</h2><ul><li>创建</li><li>删除</li><li>写</li><li>读</li><li>重定位</li><li>截断</li><li>打开</li><li>关闭</li><li>…</li></ul><hr><h2 id="文件保护的方式"><a href="#文件保护的方式" class="headerlink" title="文件保护的方式"></a>文件保护的方式</h2><ul><li>口令</li><li>密码</li><li>访问控制</li></ul><hr><h2 id="文件分配的方法（对外存-磁盘空间）"><a href="#文件分配的方法（对外存-磁盘空间）" class="headerlink" title="文件分配的方法（对外存&#x2F;磁盘空间）"></a>文件分配的方法（对外存&#x2F;磁盘空间）</h2><ul><li>连续分配——有外部碎片</li><li>链接分配——可能有内部碎片（显式链接：用文件分配表（FAT），隐式链接）</li><li>索引分配——无外部碎片（用索引块）</li><li>混合分配</li></ul><hr><h2 id="文件共享的方式"><a href="#文件共享的方式" class="headerlink" title="文件共享的方式"></a>文件共享的方式</h2><p>静态共享：</p><ul><li>硬链接——共享索引结点</li><li>软链接&#x2F;符号链接——共享符号&#x2F;文件路径字符串</li></ul><p>动态共享</p><hr><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="目录文件的结构"><a href="#目录文件的结构" class="headerlink" title="目录文件的结构"></a>目录文件的结构</h2><ul><li>单级目录结构</li><li>两级目录结构：主文件目录（MFD）、用户文件目录（UFD）</li><li>树形目录结构</li><li>无环图目录结构</li></ul><hr><h2 id="目录文件的实现"><a href="#目录文件的实现" class="headerlink" title="目录文件的实现"></a>目录文件的实现</h2><ul><li>线性表——线性查找</li><li>散列&#x2F;哈希表——散列&#x2F;哈希查找</li></ul><hr><h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><h2 id="文件系统的结构"><a href="#文件系统的结构" class="headerlink" title="文件系统的结构"></a>文件系统的结构</h2><p>从高到低层：</p><ul><li>应用程序</li><li>逻辑文件系统</li><li>文件组织模块</li><li>基本文件系统</li><li>输入&#x2F;输出（I&#x2F;O）控制</li><li>设备</li></ul><hr><h2 id="文件系统的组成"><a href="#文件系统的组成" class="headerlink" title="文件系统的组成"></a>文件系统的组成</h2><ul><li>文件管理软件</li><li>文件管理所需的数据结构</li><li>被管理文件</li></ul><hr><h2 id="文件系统的布局"><a href="#文件系统的布局" class="headerlink" title="文件系统的布局"></a>文件系统的布局</h2><p>从大到小：</p><ul><li>磁盘</li><li>主引导记录（MBR）（在第0号扇区），分区表，各个分区</li><li>对活动分区：引导块（在第1块，无第0块；可能有操作系统），超级块，空闲空间管理信息，多个i结点（inode），文件</li></ul><hr><h2 id="文件系统在内存中的结构"><a href="#文件系统在内存中的结构" class="headerlink" title="文件系统在内存中的结构"></a>文件系统在内存中的结构</h2><ul><li>安装表</li><li>分区、文件目录的缓存</li><li>系统打开文件表</li><li>进程打开文件表</li></ul><hr><h2 id="外存空闲空间的管理方法"><a href="#外存空闲空间的管理方法" class="headerlink" title="外存空闲空间的管理方法"></a>外存空闲空间的管理方法</h2><ul><li>空闲表法</li><li>空闲链表法（空闲盘区链；空闲盘块链）</li><li>成组链接法</li><li>位示图法</li></ul><hr><h2 id="Linux操作系统的虚拟文件系统（VFS）对象模型"><a href="#Linux操作系统的虚拟文件系统（VFS）对象模型" class="headerlink" title="Linux操作系统的虚拟文件系统（VFS）对象模型"></a>Linux操作系统的虚拟文件系统（VFS）对象模型</h2><ul><li>超级块对象——对文件系统</li><li>索引结点对象——对文件</li><li>目录项对象——对目录项</li><li>文件对象——对进程打开的文件</li></ul><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>操作系统的知识抽象、晦涩、不易理解并记忆，在此对“文件管理”一章中重点知识总结成提纲。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《2023年操作系统考研复习指导》组编：王道论坛</li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“内存管理”学习提纲</title>
      <link href="/2022/07/23/%E2%80%9C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E2%80%9D%E5%AD%A6%E4%B9%A0%E6%8F%90%E7%BA%B2/"/>
      <url>/2022/07/23/%E2%80%9C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E2%80%9D%E5%AD%A6%E4%B9%A0%E6%8F%90%E7%BA%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>操作系统的知识抽象、晦涩、不易理解并记忆，在此对“内存管理”一章中重点知识总结成提纲。</p><hr><h1 id="内存管理概念"><a href="#内存管理概念" class="headerlink" title="内存管理概念"></a>内存管理概念</h1><h2 id="内存管理的目的"><a href="#内存管理的目的" class="headerlink" title="内存管理的目的"></a>内存管理的目的</h2><ul><li>提高内存利用率</li><li>方便用户</li></ul><hr><h2 id="内存管理的功能"><a href="#内存管理的功能" class="headerlink" title="内存管理的功能"></a>内存管理的功能</h2><ul><li>地址转换</li><li>内存保护</li><li>内存分配与回收</li><li>内存共享</li><li>内存扩充</li></ul><hr><h2 id="源程序转换为执行程序（在内存中）的过程"><a href="#源程序转换为执行程序（在内存中）的过程" class="headerlink" title="源程序转换为执行程序（在内存中）的过程"></a>源程序转换为执行程序（在内存中）的过程</h2><ol><li>编译</li><li>链接（静态链接，装入时动态链接，运行时动态链接）</li><li>装入（绝对装入，可重定位装入&#x2F;静态重定位，动态运行时装入&#x2F;动态重定位）</li></ol><hr><h2 id="进程的内存映像组成"><a href="#进程的内存映像组成" class="headerlink" title="进程的内存映像组成"></a>进程的内存映像组成</h2><p>从高到低地址：</p><ul><li>操作系统内核区&#x2F;用户代码不可见区&#x2F;环境变量区</li><li>栈区</li><li>共享函数库的存储映射区</li><li>堆区</li><li>数据区</li><li>代码区</li><li>未使用区</li></ul><hr><h2 id="内存保护的方法"><a href="#内存保护的方法" class="headerlink" title="内存保护的方法"></a>内存保护的方法</h2><ul><li>在中央处理器（CPU）中使用一对访问地址上、下限寄存器</li><li>使用限长&#x2F;界地址寄存器和重定位&#x2F;基地址寄存器</li></ul><hr><h2 id="内存连续分配的方式"><a href="#内存连续分配的方式" class="headerlink" title="内存连续分配的方式"></a>内存连续分配的方式</h2><ul><li>单一连续分配——有内部碎片</li><li>固定分区分配（分区大小相同，分区大小不同）——有内部碎片</li><li>可变&#x2F;动态分区分配——有外部碎片</li></ul><hr><h2 id="可变-动态分区分配策略"><a href="#可变-动态分区分配策略" class="headerlink" title="可变&#x2F;动态分区分配策略"></a>可变&#x2F;动态分区分配策略</h2><ul><li>首次适应（FF）算法</li><li>邻近适应（NF）&#x2F;循环首次适应算法</li><li>最佳适应（BF）算法</li><li>最坏适应（WF）算法</li></ul><hr><h2 id="内存非连续分配的方式"><a href="#内存非连续分配的方式" class="headerlink" title="内存非连续分配的方式"></a>内存非连续分配的方式</h2><ul><li>分页存储管理——有内部碎片</li><li>分段存储管理——有外部碎片</li><li>段页式存储管理——有内部碎片</li></ul><hr><h2 id="分页存储管理的类型（分段、段页式同理）"><a href="#分页存储管理的类型（分段、段页式同理）" class="headerlink" title="分页存储管理的类型（分段、段页式同理）"></a>分页存储管理的类型（分段、段页式同理）</h2><ul><li>基本分页存储管理</li><li>请求分页存储管理</li></ul><hr><h2 id="分页存储管理的相关概念"><a href="#分页存储管理的相关概念" class="headerlink" title="分页存储管理的相关概念"></a>分页存储管理的相关概念</h2><ul><li>页&#x2F;页面</li><li>页框&#x2F;页帧</li><li>块&#x2F;盘块</li><li>逻辑、物理地址结构</li><li>页表、页表项</li><li>基本地址变换机构 </li><li>有快表&#x2F;相联存储器（TLB）的地址变换机构</li><li>多级页表</li></ul><hr><h2 id="分段存储管理的相关概念"><a href="#分段存储管理的相关概念" class="headerlink" title="分段存储管理的相关概念"></a>分段存储管理的相关概念</h2><ul><li>段</li><li>逻辑、物理地址结构</li><li>段表</li><li>地址变换机构</li></ul><blockquote><p>注意：一个进程中，只能有一个段表，可能有多个页表</p></blockquote><hr><h2 id="内存扩充的方法"><a href="#内存扩充的方法" class="headerlink" title="内存扩充的方法"></a>内存扩充的方法</h2><ul><li>覆盖技术——对同一个程序或进程</li><li>交换&#x2F;对换技术——对不同作业、程序或进程</li><li>虚拟内存技术</li></ul><blockquote><p>注意：覆盖技术过时，使用虚拟内存技术代替</p></blockquote><hr><h2 id="虚拟内存容量应满足的条件"><a href="#虚拟内存容量应满足的条件" class="headerlink" title="虚拟内存容量应满足的条件"></a>虚拟内存容量应满足的条件</h2><ul><li>虚拟内存的实际容量&lt;&#x3D;内存容量+外存容量</li><li>虚拟内存的最大容量&lt;&#x3D;计算机地址位数能容纳的最大容量</li></ul><hr><h1 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h1><h2 id="局部性原理的表现形式"><a href="#局部性原理的表现形式" class="headerlink" title="局部性原理的表现形式"></a>局部性原理的表现形式</h2><ul><li>时间局部性——对指令、数据</li><li>空间局部性——对存储单元</li></ul><hr><h2 id="虚拟存储器的特征"><a href="#虚拟存储器的特征" class="headerlink" title="虚拟存储器的特征"></a>虚拟存储器的特征</h2><ul><li>多次性</li><li>对换&#x2F;离散性</li><li>虚拟性</li></ul><hr><h2 id="虚拟内存技术的实现方式"><a href="#虚拟内存技术的实现方式" class="headerlink" title="虚拟内存技术的实现方式"></a>虚拟内存技术的实现方式</h2><ul><li>请求分页存储管理</li><li>请求分段存储管理</li><li>请求段页式存储管理</li></ul><hr><h2 id="支持虚拟内存技术的硬件"><a href="#支持虚拟内存技术的硬件" class="headerlink" title="支持虚拟内存技术的硬件"></a>支持虚拟内存技术的硬件</h2><ul><li>内存、外存</li><li>地址变换机构</li><li>页&#x2F;段表机制</li><li>缺页&#x2F;段中断机构</li></ul><hr><h2 id="请求分页存储管理的相关概念"><a href="#请求分页存储管理的相关概念" class="headerlink" title="请求分页存储管理的相关概念"></a>请求分页存储管理的相关概念</h2><ul><li>地址变换机构</li><li>页表机制</li><li>缺页中断机构</li></ul><hr><h2 id="请求分页存储管理的内存分配、置换策略"><a href="#请求分页存储管理的内存分配、置换策略" class="headerlink" title="请求分页存储管理的内存分配、置换策略"></a>请求分页存储管理的内存分配、置换策略</h2><blockquote><p>驻留集：页框&#x2F;页帧集合</p></blockquote><ul><li>固定分配，局部置换</li><li>可变分配，全局置换</li><li>可变分配，局部置换</li></ul><hr><h2 id="请求分页存储管理的内存固定分配算法"><a href="#请求分页存储管理的内存固定分配算法" class="headerlink" title="请求分页存储管理的内存固定分配算法"></a>请求分页存储管理的内存固定分配算法</h2><ul><li>平均分配算法</li><li>按比例分配算法</li><li>优先权分配算法</li></ul><hr><h2 id="请求分页存储管理的调页策略-时机（何时）"><a href="#请求分页存储管理的调页策略-时机（何时）" class="headerlink" title="请求分页存储管理的调页策略&#x2F;时机（何时）"></a>请求分页存储管理的调页策略&#x2F;时机（何时）</h2><ul><li>预调页策略——运行前</li><li>请求调页策略——运行时</li></ul><hr><h2 id="请求分页存储管理的调页区域（何地）"><a href="#请求分页存储管理的调页区域（何地）" class="headerlink" title="请求分页存储管理的调页区域（何地）"></a>请求分页存储管理的调页区域（何地）</h2><ul><li>外存的文件区</li><li>外存的对换区</li><li>内存</li></ul><hr><h2 id="请求分页存储管理的页面置换算法（怎样）"><a href="#请求分页存储管理的页面置换算法（怎样）" class="headerlink" title="请求分页存储管理的页面置换算法（怎样）"></a>请求分页存储管理的页面置换算法（怎样）</h2><ul><li>最佳（OPT）置换算法——无法实现</li><li>先进先出（FIFO）置换算法——会出现Belady异常</li><li>最近最久未使用（LRU）置换算法</li><li>最近未使用（NRU）&#x2F;时钟（CLOCK）置换算法、改进型时钟（CLOCK）置换算法</li></ul><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>操作系统的知识抽象、晦涩、不易理解并记忆，在此对“内存管理”一章中重点知识总结成提纲。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《2023年操作系统考研复习指导》组编：王道论坛</li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“进程与线程”学习提纲</title>
      <link href="/2022/07/21/%E2%80%9C%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E2%80%9D%E5%AD%A6%E4%B9%A0%E6%8F%90%E7%BA%B2/"/>
      <url>/2022/07/21/%E2%80%9C%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E2%80%9D%E5%AD%A6%E4%B9%A0%E6%8F%90%E7%BA%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>操作系统的知识抽象、晦涩、不易理解并记忆，在此对“进程与线程”一章中重点知识总结成提纲。</p><hr><h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><h2 id="进程的特征"><a href="#进程的特征" class="headerlink" title="进程的特征"></a>进程的特征</h2><ul><li>动态性（基本特征）</li><li>并发性</li><li>独立性</li><li>异步性</li><li>结构性</li></ul><hr><h2 id="进程-进程实体-进程映像的组成"><a href="#进程-进程实体-进程映像的组成" class="headerlink" title="进程&#x2F;进程实体&#x2F;进程映像的组成"></a>进程&#x2F;进程实体&#x2F;进程映像的组成</h2><ul><li>进程控制块（PCB）（核心）</li><li>程序段</li><li>数据段</li></ul><p>或：</p><ul><li>数据栈段，存放临时变量</li><li>数据堆段，存放动态分配存储区</li><li>正文段，存放常量、赋值变量和二进制代码</li></ul><hr><h2 id="进程控制块（PCB）的内容"><a href="#进程控制块（PCB）的内容" class="headerlink" title="进程控制块（PCB）的内容"></a>进程控制块（PCB）的内容</h2><p>进程描述信息：</p><ul><li>进程标识符（PID）</li><li>用户标识符（UID）</li></ul><p>进程控制和管理信息：</p><ul><li>进程当前状态</li><li>进程优先级</li><li>代码运行的入口地址</li><li>程序的外存储器地址</li><li>进入内&#x2F;主存储器（MM）的时间</li><li>处理机的占用时间</li><li>信号量的使用情况</li></ul><p>资源分配清单：</p><ul><li>堆栈段指针</li><li>数据段指针</li><li>代码段指针</li><li>所打开文件的描述符列表</li><li>所使用输入&#x2F;输出（I&#x2F;O）设备的信息</li></ul><p>处理机相关信息&#x2F;上下文：</p><ul><li>控制寄存器值</li><li>地址寄存器值</li><li>通用寄存器（GR）值</li><li>标志寄存器值</li><li>状态字寄存器值</li></ul><hr><h2 id="进程-进程控制块（PCB）的组织方式"><a href="#进程-进程控制块（PCB）的组织方式" class="headerlink" title="进程&#x2F;进程控制块（PCB）的组织方式"></a>进程&#x2F;进程控制块（PCB）的组织方式</h2><ul><li>链接方式（队列）</li><li>索引方式（表）</li></ul><hr><h2 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h2><ul><li>创建态</li><li>就绪态</li><li>运行态</li><li>阻塞态</li><li>结束态</li></ul><blockquote><p>挂起态：在进程调度中定义的特殊状态</p></blockquote><hr><h2 id="进程-原语创建的过程"><a href="#进程-原语创建的过程" class="headerlink" title="进程&#x2F;原语创建的过程"></a>进程&#x2F;原语创建的过程</h2><ol><li>分配一个唯一的进程标识号（PID），申请空白的进程控制块（PCB）</li><li>分配运行所需资源</li><li>初始化进程控制块（PCB），填入用于控制和管理进程的信息</li><li>置为就绪态，插入就绪队列</li></ol><hr><h2 id="引发进程结束的事件"><a href="#引发进程结束的事件" class="headerlink" title="引发进程结束的事件"></a>引发进程结束的事件</h2><ul><li>正常结束</li><li>异常结束</li><li>外界干预</li></ul><hr><h2 id="进程-原语结束的过程"><a href="#进程-原语结束的过程" class="headerlink" title="进程&#x2F;原语结束的过程"></a>进程&#x2F;原语结束的过程</h2><ol><li>根据进程标识符（PID）检索进程控制块（PCB），读取状态信息</li><li>若处于运行态，结束运行，释放处理机资源</li><li>若有子孙进程，结束子孙进程</li><li>释放所有资源，归还给父进程或操作系统（OS）</li><li>从所在队列&#x2F;表中删除进程控制块（PCB）</li></ol><hr><h2 id="进程-原语阻塞的过程"><a href="#进程-原语阻塞的过程" class="headerlink" title="进程&#x2F;原语阻塞的过程"></a>进程&#x2F;原语阻塞的过程</h2><ol><li>根据进程标识符（PID）检索进程控制块（PCB），读取状态信息</li><li>若处于运行态，保护现场，暂停运行，释放处理机资源</li><li>置为阻塞态，插入阻塞队列</li></ol><hr><h2 id="进程-原语唤醒的过程"><a href="#进程-原语唤醒的过程" class="headerlink" title="进程&#x2F;原语唤醒的过程"></a>进程&#x2F;原语唤醒的过程</h2><ol><li>根据进程标识符（PID）检索进程控制块（PCB），读取状态信息</li><li>置为就绪态，插入就绪队列</li></ol><hr><h2 id="进程不能调度-切换的情况"><a href="#进程不能调度-切换的情况" class="headerlink" title="进程不能调度&#x2F;切换的情况"></a>进程不能调度&#x2F;切换的情况</h2><ul><li>原子操作</li><li>访问临界区</li><li>中断处理过程</li></ul><hr><h2 id="进程的通信方式"><a href="#进程的通信方式" class="headerlink" title="进程的通信方式"></a>进程的通信方式</h2><p>低级：</p><ul><li>PV操作</li></ul><p>高级：</p><ul><li>共享内存（低级：共享数据结构，高级：共享存储区）</li><li>消息队列（直接通信，间接通信）（应用最广泛）</li><li>管道（共享内存的发展，消息队列的特殊方式）</li><li>命名管道（先进先出FIFO）</li><li>信号</li><li>信号量</li><li>套接字（Socket）</li></ul><hr><h2 id="线程控制块（TCB）的组成"><a href="#线程控制块（TCB）的组成" class="headerlink" title="线程控制块（TCB）的组成"></a>线程控制块（TCB）的组成</h2><ul><li>线程标识符</li><li>寄存器：程序计数器（PC）、状态寄存器、通用寄存器（GR）</li><li>线程状态</li><li>线程优先级</li><li>线程专有存储区</li><li>堆栈指针</li></ul><hr><h2 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h2><ul><li>内核级线程&#x2F;内核支持的线程（KLT）</li><li>用户级线程（ULT）</li><li>组合方式</li></ul><hr><h2 id="线程库的实现方式"><a href="#线程库的实现方式" class="headerlink" title="线程库的实现方式"></a>线程库的实现方式</h2><ul><li>在用户空间提供一个没有内核支持的库</li><li>提供一个由操作系统支持的内核级的库</li></ul><hr><h2 id="多线程模型的类型-内核级线程和用户级线程的对应关系"><a href="#多线程模型的类型-内核级线程和用户级线程的对应关系" class="headerlink" title="多线程模型的类型&#x2F;内核级线程和用户级线程的对应关系"></a>多线程模型的类型&#x2F;内核级线程和用户级线程的对应关系</h2><ul><li>一对一</li><li>一对多</li><li>多对多（内核级线程数&lt;&#x3D;用户级线程数）</li></ul><hr><h1 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h1><h2 id="调度的层次"><a href="#调度的层次" class="headerlink" title="调度的层次"></a>调度的层次</h2><ul><li>高级调度&#x2F;作业调度</li><li>中级调度&#x2F;内存调度</li><li>低级调度&#x2F;进程调度</li></ul><hr><h2 id="调度算法性能的评价指标"><a href="#调度算法性能的评价指标" class="headerlink" title="调度算法性能的评价指标"></a>调度算法性能的评价指标</h2><ul><li>响应时间</li><li>等待时间</li><li>周转时间（平均周转时间、带权周转时间、平均带权周转时间）</li><li>中央处理器（CPU）利用率</li><li>系统吞吐量</li></ul><hr><h2 id="调度程序-调度器的组成"><a href="#调度程序-调度器的组成" class="headerlink" title="调度程序&#x2F;调度器的组成"></a>调度程序&#x2F;调度器的组成</h2><ul><li>排队器</li><li>分派器</li><li>上下文切换器</li></ul><hr><h2 id="进程不能调度-切换的情况-1"><a href="#进程不能调度-切换的情况-1" class="headerlink" title="进程不能调度&#x2F;切换的情况"></a>进程不能调度&#x2F;切换的情况</h2><ul><li>原子操作</li><li>访问临界区</li><li>中断处理过程</li></ul><hr><h2 id="进程可以调度-切换的情况"><a href="#进程可以调度-切换的情况" class="headerlink" title="进程可以调度&#x2F;切换的情况"></a>进程可以调度&#x2F;切换的情况</h2><ul><li>调度条件产生，当前进程无法继续运行</li><li>自陷或中断处理结束后，返回原进程的用户态程序执行现场前，调度条件产生</li></ul><hr><h2 id="进程的调度方式"><a href="#进程的调度方式" class="headerlink" title="进程的调度方式"></a>进程的调度方式</h2><ul><li>可抢占&#x2F;剥夺调度方式</li><li>不可抢占&#x2F;剥夺调度方式</li></ul><hr><h2 id="线程的调度类型"><a href="#线程的调度类型" class="headerlink" title="线程的调度类型"></a>线程的调度类型</h2><ul><li>内核级线程调度</li><li>用户级线程调度</li></ul><hr><h2 id="典型的调度算法"><a href="#典型的调度算法" class="headerlink" title="典型的调度算法"></a>典型的调度算法</h2><ul><li>先来先服务（FCFS）调度算法</li><li>短作业&#x2F;进程&#x2F;线程优先（SJF）调度算法</li><li>优先级调度算法（适用于实时系统）</li></ul><blockquote><p>算法类型：可抢占&#x2F;剥夺式，不可抢占&#x2F;剥夺式<br>优先级类型：静态，动态<br>优先级原则：系统进程&gt;用户进程，交互型进程&gt;非交互型进程，输入&#x2F;输出（I&#x2F;O）型进程&gt;计算型进程</p></blockquote><ul><li>高响应比优先调度算法（适用于作业调度、分时系统）</li></ul><blockquote><p>响应比&#x3D;（等待时间+要求服务时间）&#x2F;要求服务时间</p></blockquote><ul><li>时间片轮转调度算法（适用于分时系统）</li><li>多级队列调度算法（适用于分时系统）</li><li>多级反馈队列调度算法（适用于分时系统）</li></ul><hr><h2 id="进程切换的过程"><a href="#进程切换的过程" class="headerlink" title="进程切换的过程"></a>进程切换的过程</h2><blockquote><p>注意：进程&#x2F;（处理器&#x2F;中央处理器（CPU））上下文切换只能发生在内核态</p></blockquote><ol><li>挂起一个进程，保存（处理器&#x2F;中央处理器（CPU））上下文：程序计数器（PC）和寄存器内容</li><li>更新进程控制块（PCB）内容</li><li>将进程控制块（PCB）插入相应队列：就绪、阻塞等队列</li><li>选择另一个进程执行，更新其进程控制块（PCB）内容</li><li>跳转到新进程进程控制块（PCB）中程序计数器（PC）内容指向的位置执行</li><li>新进程执行完毕，恢复旧进程的（处理器&#x2F;中央处理器（CPU））上下文</li></ol><hr><h1 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h1><h2 id="临界资源的访问过程"><a href="#临界资源的访问过程" class="headerlink" title="临界资源的访问过程"></a>临界资源的访问过程</h2><ol><li>进入区</li><li>临界区&#x2F;段</li><li>退出区</li><li>剩余区</li></ol><hr><h2 id="同步访问临界资源遵循的准则"><a href="#同步访问临界资源遵循的准则" class="headerlink" title="同步访问临界资源遵循的准则"></a>同步访问临界资源遵循的准则</h2><ul><li>空闲让进</li><li>忙则等待</li><li>有限等待</li><li>让权等待</li></ul><hr><h2 id="互斥访问临界资源的方法"><a href="#互斥访问临界资源的方法" class="headerlink" title="互斥访问临界资源的方法"></a>互斥访问临界资源的方法</h2><p>硬件实现方法&#x2F;低级方法&#x2F;元方法：</p><ul><li>中断屏蔽法</li><li>硬件指令法</li></ul><p>软件实现方法：</p><ul><li>单标志法</li><li>先检查双标志法</li><li>后检查双标志法</li><li>Peterson’s算法</li></ul><hr><h2 id="信号量的类型"><a href="#信号量的类型" class="headerlink" title="信号量的类型"></a>信号量的类型</h2><ul><li>整型信号量</li><li>记录型信号量</li></ul><p>或：</p><ul><li>资源量</li><li>互斥量</li></ul><hr><h2 id="管程的组成"><a href="#管程的组成" class="headerlink" title="管程的组成"></a>管程的组成</h2><ul><li>名称</li><li>局部共享数据结构——数据&#x2F;资源描述</li><li>设置局部共享数据结构初始值的语句</li><li>条件变量</li><li>操作共享数据结构的过程&#x2F;函数——操作描述</li></ul><hr><h2 id="经典同步互斥问题"><a href="#经典同步互斥问题" class="headerlink" title="经典同步互斥问题"></a>经典同步互斥问题</h2><ul><li>生产者-消费者问题</li><li>读者-写者问题</li><li>哲学家进餐问题</li><li>吸烟者问题</li></ul><hr><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><h2 id="死锁产生的原因"><a href="#死锁产生的原因" class="headerlink" title="死锁产生的原因"></a>死锁产生的原因</h2><ul><li>系统资源的竞争——资源竞争</li><li>进程的推进顺序非法——资源等待</li></ul><hr><h2 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a>死锁产生的必要条件</h2><ul><li>互斥条件</li><li>不可剥夺条件</li><li>请求保持条件</li><li>循环等待条件</li></ul><blockquote><p>注意：只要任意一个条件不成立，就不会产生死锁</p></blockquote><hr><h2 id="死锁的处理策略"><a href="#死锁的处理策略" class="headerlink" title="死锁的处理策略"></a>死锁的处理策略</h2><ul><li>死锁预防</li><li>死锁避免</li><li>死锁检测和解除</li></ul><hr><h2 id="死锁预防的方法"><a href="#死锁预防的方法" class="headerlink" title="死锁预防的方法"></a>死锁预防的方法</h2><ul><li>破坏互斥条件——不容易破坏</li><li>破坏不可剥夺条件——可剥夺资源法</li><li>破坏请求保持条件——预先静态分配法</li><li>破坏循环等待条件——顺序资源分配法</li></ul><hr><h2 id="死锁避免的方法"><a href="#死锁避免的方法" class="headerlink" title="死锁避免的方法"></a>死锁避免的方法</h2><p>核心：系统处于安全状态</p><blockquote><p>注意：若系统处于安全状态，则可避免死锁；若系统处于不安全状态，则可能产生死锁</p></blockquote><ul><li>银行家算法（包括安全性算法）</li></ul><hr><h2 id="死锁检测和解除的方法"><a href="#死锁检测和解除的方法" class="headerlink" title="死锁检测和解除的方法"></a>死锁检测和解除的方法</h2><p>死锁检测：</p><ul><li>简化资源分配图&#x2F;判断死锁定理</li></ul><p>死锁解除：</p><ul><li>资源剥夺法（被动释放资源）</li><li>进程回退法（主动释放资源）</li><li>撤销进程法（可依据进程优先级、撤销进程的代价）</li></ul><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>操作系统的知识抽象、晦涩、不易理解并记忆，在此对“进程与线程”一章中重点知识总结成提纲。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《2023年操作系统考研复习指导》组编：王道论坛</li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“输入/输出（I/O）系统”学习提纲</title>
      <link href="/2022/07/15/%E2%80%9C%E8%BE%93%E5%85%A5_%E8%BE%93%E5%87%BA%EF%BC%88I_O%EF%BC%89%E7%B3%BB%E7%BB%9F%E2%80%9D%E5%AD%A6%E4%B9%A0%E6%8F%90%E7%BA%B2/"/>
      <url>/2022/07/15/%E2%80%9C%E8%BE%93%E5%85%A5_%E8%BE%93%E5%87%BA%EF%BC%88I_O%EF%BC%89%E7%B3%BB%E7%BB%9F%E2%80%9D%E5%AD%A6%E4%B9%A0%E6%8F%90%E7%BA%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>计算机组成原理的知识抽象、晦涩、不易理解并记忆，在此对“输入&#x2F;输出（I&#x2F;O）系统”一章中重点知识总结成提纲。</p><hr><h1 id="输入-输出（I-O）系统的组成"><a href="#输入-输出（I-O）系统的组成" class="headerlink" title="输入&#x2F;输出（I&#x2F;O）系统的组成"></a>输入&#x2F;输出（I&#x2F;O）系统的组成</h1><ul><li>输入&#x2F;输出（I&#x2F;O）硬件</li><li>输入&#x2F;输出（I&#x2F;O）软件</li></ul><hr><h1 id="输入-输出（I-O）系统的控制方式"><a href="#输入-输出（I-O）系统的控制方式" class="headerlink" title="输入&#x2F;输出（I&#x2F;O）系统的控制方式"></a>输入&#x2F;输出（I&#x2F;O）系统的控制方式</h1><ul><li>程序查询方式</li><li>程序中断方式</li><li>直接存储器访问（DMA）方式</li><li>通道方式</li></ul><hr><h1 id="程序查询方式的过程"><a href="#程序查询方式的过程" class="headerlink" title="程序查询方式的过程"></a>程序查询方式的过程</h1><p>对中央处理器（CPU）：</p><ol><li>执行初始化程序，预置传送参数（计数器参数和数据首地址）</li><li>向输入&#x2F;输出（I&#x2F;O）接口发送命令字，启动输入&#x2F;输出（I&#x2F;O）设备</li><li>从输入&#x2F;输出（I&#x2F;O）接口接收输入&#x2F;输出（I&#x2F;O）设备的状态信息</li><li>不断查询输入&#x2F;输出（I&#x2F;O）设备的状态，直到设备准备就绪</li><li>与输入&#x2F;输出（I&#x2F;O）设备传送一次数据</li><li>修改传送参数（计数器参数和数据首地址）</li><li>判断数据传送是否结束（计数器参数是否归零），若未结束（未归零）则转第3步；若结束（归零）则结束相应程序</li></ol><hr><h1 id="中断技术-系统的功能"><a href="#中断技术-系统的功能" class="headerlink" title="中断技术&#x2F;系统的功能"></a>中断技术&#x2F;系统的功能</h1><ul><li>实现中央处理器（CPU）和输入&#x2F;输出（I&#x2F;O）设备的并行工作</li><li>实现处理硬件故障和软件错误</li><li>实现应用程序和操作系统的切换（软中断）</li><li>实现人机交互</li><li>实现多道程序、分时操作</li><li>实现实时处理</li><li>实现多处理器系统中各处理器之间的信息交流和任务切换</li></ul><hr><h1 id="中断的流程"><a href="#中断的流程" class="headerlink" title="中断的流程"></a>中断的流程</h1><ol><li>中断请求</li><li>中断响应</li><li>中断处理</li></ol><hr><h1 id="中央处理器（CPU）响应中断的条件"><a href="#中央处理器（CPU）响应中断的条件" class="headerlink" title="中央处理器（CPU）响应中断的条件"></a>中央处理器（CPU）响应中断的条件</h1><ul><li>中央处理器（CPU）允许中断&#x2F;开中断（不可屏蔽中断、异常不受限制）（中断屏蔽触发器置位）</li><li>一条指令执行完毕（异常不受限制），且无更紧迫的任务</li><li>中断源有中断请求（中断请求触发器、中断允许触发器置位）</li></ul><hr><h1 id="中断的优先级"><a href="#中断的优先级" class="headerlink" title="中断的优先级"></a>中断的优先级</h1><blockquote><p>中断优先级&#x3D;中断响应优先级（不易改变）+中断处理优先级（可由中断屏蔽字动态改变）</p></blockquote><ul><li>不可屏蔽中断&gt;内部异常&gt;可屏蔽中断</li><li>内部异常中，硬件故障&gt;软件中断</li><li>直接存储器访问（DMA）&gt;输入&#x2F;输出（I&#x2F;O）设备</li><li>输入&#x2F;输出（I&#x2F;O）设备中，高速设备&gt;低速设备，输入设备&gt;输出设备，实时设备&gt;普通设备</li></ul><hr><h1 id="中断识别的类型"><a href="#中断识别的类型" class="headerlink" title="中断识别的类型"></a>中断识别的类型</h1><ul><li>向量中断（硬件向量法）</li><li>非向量中断（软件查询法）</li></ul><hr><h1 id="向量中断-硬件向量法的过程"><a href="#向量中断-硬件向量法的过程" class="headerlink" title="向量中断&#x2F;硬件向量法的过程"></a>向量中断&#x2F;硬件向量法的过程</h1><ol><li>识别中断源</li><li>获取中断类型号</li><li>计算中断向量地址</li><li>依据中断向量地址从中断向量表中获取中断服务程序的入口地址（间接寻址）</li></ol><hr><h1 id="单重中断的响应、处理过程"><a href="#单重中断的响应、处理过程" class="headerlink" title="单重中断的响应、处理过程"></a>单重中断的响应、处理过程</h1><ol><li>关中断</li><li>保存断点（硬件实现）</li><li>寻址中断服务程序</li><li>保存现场（软件实现）</li><li>执行中断服务程序</li><li>恢复现场和屏蔽字</li><li>开中断</li><li>中断返回</li></ol><blockquote><p>注意：中断的断点是下一条指令的地址，异常的断点是当前指令的地址<br>第1-3步由硬件&#x2F;中断隐指令实现，4-8步由软件&#x2F;中断服务程序实现</p></blockquote><hr><h1 id="中央处理器（CPU）能够多重中断的条件"><a href="#中央处理器（CPU）能够多重中断的条件" class="headerlink" title="中央处理器（CPU）能够多重中断的条件"></a>中央处理器（CPU）能够多重中断的条件</h1><ul><li>中断服务程序中提前设置开中断指令</li><li>优先级高的中断源有权中断优先级低的中断源</li></ul><hr><h1 id="多重中断的响应、处理过程"><a href="#多重中断的响应、处理过程" class="headerlink" title="多重中断的响应、处理过程"></a>多重中断的响应、处理过程</h1><ol><li>关中断</li><li>保存断点（硬件实现）</li><li>寻址中断服务程序</li><li>保存现场和屏蔽字（软件实现）</li><li>开中断（允许多重中断&#x2F;中断嵌套）</li><li>执行中断服务程序</li><li>关中断</li><li>恢复现场和屏蔽字</li><li>开中断</li><li>中断返回</li></ol><blockquote><p>第1-3步由硬件&#x2F;中断隐指令实现，4-10步由软件&#x2F;中断服务程序实现</p></blockquote><hr><h1 id="直接存储器访问（DMA）控制器（DMAC）的组成"><a href="#直接存储器访问（DMA）控制器（DMAC）的组成" class="headerlink" title="直接存储器访问（DMA）控制器（DMAC）的组成"></a>直接存储器访问（DMA）控制器（DMAC）的组成</h1><ul><li>直接存储器访问（DMA）请求触发器</li><li>控制&#x2F;状态逻辑电路</li><li>主存储器（MM）地址计数器</li><li>传送长度计数器</li><li>数据缓冲寄存器（DBR）</li><li>中断机构</li></ul><hr><h1 id="直接存储器访问（DMA）控制器（DMAC）的工作过程"><a href="#直接存储器访问（DMA）控制器（DMAC）的工作过程" class="headerlink" title="直接存储器访问（DMA）控制器（DMAC）的工作过程"></a>直接存储器访问（DMA）控制器（DMAC）的工作过程</h1><ol><li>接收输入&#x2F;输出（I&#x2F;O）设备的直接存储器访问（DMA）请求（狭义）</li><li>向中央处理器（CPU）发送总线请求</li><li>中央处理器（CPU）响应总线请求，向直接存储器访问（DMA）控制器（DMAC）发送总线响应信号</li><li>接管总线控制权，进入直接存储器访问（DMA）操作周期</li><li>确定传送数据的主存储器地址和传送长度，自动修改地址和长度计数</li><li>规定数据在主存储器和输入&#x2F;输出（I&#x2F;O）设备的传送方向，发送读写等控制信号，执行数据传送操作</li><li>向中央处理器（CPU）报告直接存储器访问（DMA）操作结束</li></ol><blockquote><p>广义直接存储器访问（DMA）请求&#x3D;输入&#x2F;输出（I&#x2F;O）设备向直接存储器访问（DMA）控制器（DMAC）发送的直接存储器访问（DMA）请求（狭义）+直接存储器访问（DMA）控制器（DMAC）向中央处理器（CPU）发送的总线请求</p></blockquote><hr><h1 id="直接存储器访问（DMA）的传送方式"><a href="#直接存储器访问（DMA）的传送方式" class="headerlink" title="直接存储器访问（DMA）的传送方式"></a>直接存储器访问（DMA）的传送方式</h1><ul><li>停止中央处理器（CPU）访存</li><li>中央处理器（CPU）和直接存储器访问（DMA）交替访存</li><li>周期挪用&#x2F;窃取</li></ul><hr><h1 id="直接存储器访问（DMA）的数据传送过程"><a href="#直接存储器访问（DMA）的数据传送过程" class="headerlink" title="直接存储器访问（DMA）的数据传送过程"></a>直接存储器访问（DMA）的数据传送过程</h1><ol><li>预处理</li><li>数据传送</li><li>后处理</li></ol><hr><h1 id="外部设备举例"><a href="#外部设备举例" class="headerlink" title="外部设备举例"></a>外部设备举例</h1><p>输入设备：</p><ul><li>键盘</li><li>鼠标</li></ul><p>输出设备：</p><ul><li>显示器</li></ul><blockquote><p>存在显示存储器（VRAM）</p></blockquote><ul><li>打印机</li></ul><p>外部存储器（辅存）：</p><ul><li>磁表面存储器（磁盘、磁带、磁鼓存储器）</li><li>光盘存储器</li><li>固态硬盘（SSD）</li></ul><hr><h1 id="输入-输出（I-O）接口的功能"><a href="#输入-输出（I-O）接口的功能" class="headerlink" title="输入&#x2F;输出（I&#x2F;O）接口的功能"></a>输入&#x2F;输出（I&#x2F;O）接口的功能</h1><ul><li>地址译码和设备选择</li><li>通信联络控制</li><li>数据缓冲</li><li>信号格式转换</li><li>控制命令和状态信息传送</li></ul><p>或：</p><ul><li>设备选址</li><li>命令传送</li><li>数据传送</li><li>输入&#x2F;输出（I&#x2F;O）设备的工作状态反馈</li></ul><hr><h1 id="输入-输出（I-O）接口的分类"><a href="#输入-输出（I-O）接口的分类" class="headerlink" title="输入&#x2F;输出（I&#x2F;O）接口的分类"></a>输入&#x2F;输出（I&#x2F;O）接口的分类</h1><p>按数据传送方式（输入&#x2F;输出（I&#x2F;O）接口和外部设备一侧）：</p><ul><li>串行接口</li><li>并行接口</li></ul><blockquote><p>因为中央处理器（CPU）速度快，所以输入&#x2F;输出（I&#x2F;O）接口和主机一侧一定是并行接口</p></blockquote><p>按主机访问输入&#x2F;输出（I&#x2F;O）设备的控制方式：</p><ul><li>程序查询接口</li><li>程序中断接口</li><li>直接存储器访问（DMA）接口</li><li>通道接口</li></ul><p>按功能选择的灵活性：</p><ul><li>可编程接口</li><li>不可编程接口</li></ul><hr><h1 id="输入-输出（I-O）接口的结构"><a href="#输入-输出（I-O）接口的结构" class="headerlink" title="输入&#x2F;输出（I&#x2F;O）接口的结构"></a>输入&#x2F;输出（I&#x2F;O）接口的结构</h1><ul><li>内部接口（输入&#x2F;输出（I&#x2F;O）接口和主机一侧）</li><li>外部接口（输入&#x2F;输出（I&#x2F;O）接口和外部设备一侧）</li><li>控制逻辑电路</li><li>状态&#x2F;控制寄存器</li><li>数据缓冲寄存器（DBR）</li><li>设备选择电路</li><li>命令寄存器和命令译码器</li></ul><hr><h1 id="输入-输出（I-O）端口的组成"><a href="#输入-输出（I-O）端口的组成" class="headerlink" title="输入&#x2F;输出（I&#x2F;O）端口的组成"></a>输入&#x2F;输出（I&#x2F;O）端口的组成</h1><blockquote><p>注意：输入&#x2F;输出（I&#x2F;O）端口指接口电路中可以被中央处理器（CPU）直接访问、进行读&#x2F;写的寄存器；输入&#x2F;输出（I&#x2F;O）接口&#x3D;若干输入&#x2F;输出（I&#x2F;O）端口+控制逻辑电路</p></blockquote><ul><li>控制端口，只写</li><li>状态端口，只读</li><li>数据端口，可读写</li></ul><hr><h1 id="输入-输出（I-O）端口的编址方式"><a href="#输入-输出（I-O）端口的编址方式" class="headerlink" title="输入&#x2F;输出（I&#x2F;O）端口的编址方式"></a>输入&#x2F;输出（I&#x2F;O）端口的编址方式</h1><ul><li>（与存储器）统一编址&#x2F;存储器映射方式</li><li>（与存储器）独立编址&#x2F;输入&#x2F;输出（I&#x2F;O）映射方式</li></ul><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>计算机组成原理的知识抽象、晦涩、不易理解并记忆，在此对“输入&#x2F;输出（I&#x2F;O）系统”一章中重点知识总结成提纲。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《2023年计算机组成原理考研复习指导》组编：王道论坛</li><li>哔哩哔哩平台《王道计算机考研 计算机组成原理》视频课</li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“总线”学习提纲</title>
      <link href="/2022/07/13/%E2%80%9C%E6%80%BB%E7%BA%BF%E2%80%9D%E5%AD%A6%E4%B9%A0%E6%8F%90%E7%BA%B2/"/>
      <url>/2022/07/13/%E2%80%9C%E6%80%BB%E7%BA%BF%E2%80%9D%E5%AD%A6%E4%B9%A0%E6%8F%90%E7%BA%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>计算机组成原理的知识抽象、晦涩、不易理解并记忆，在此对“总线”一章中重点知识总结成提纲。</p><hr><h1 id="总线的特点"><a href="#总线的特点" class="headerlink" title="总线的特点"></a>总线的特点</h1><ul><li>分时</li><li>共享</li></ul><hr><h1 id="总线所连接设备的分类"><a href="#总线所连接设备的分类" class="headerlink" title="总线所连接设备的分类"></a>总线所连接设备的分类</h1><ul><li>主设备（有总线控制权）</li><li>从设备（无总线控制权）</li></ul><hr><h1 id="总线的特性"><a href="#总线的特性" class="headerlink" title="总线的特性"></a>总线的特性</h1><ul><li>机械特性。如尺寸，形状，管脚数，排列顺序</li><li>电气特性。如信号的传输方向，有效的电平范围</li><li>功能特性。如线的功能</li><li>时间特性。如信号和时序的关系</li></ul><hr><h1 id="总线的分类"><a href="#总线的分类" class="headerlink" title="总线的分类"></a>总线的分类</h1><p> 依据功能：</p><ul><li>片内总线</li><li>系统总线（依据传输的信息：控制总线，地址总线，数据总线）</li><li>输入&#x2F;输出（I&#x2F;O）总线</li><li>通信总线&#x2F;外部总线</li></ul><p>依据时序控制方式：</p><ul><li>同步总线</li><li>异步总线</li></ul><p>依据数据传输格式：</p><ul><li>串行总线</li><li>并行总线</li></ul><hr><h1 id="系统总线的结构"><a href="#系统总线的结构" class="headerlink" title="系统总线的结构"></a>系统总线的结构</h1><ul><li>单总线结构（控制总线，地址总线，数据总线）</li><li>双总线结构（存储器总线&#x2F;主存总线，输入&#x2F;输出（I&#x2F;O）总线）</li><li>三总线结构（存储器总线&#x2F;主存总线，输入&#x2F;输出（I&#x2F;O）总线，直接存储器访问（DMA）总线）</li><li>四总线结构（中央处理器（CPU）总线，系统总线，高速总线，低速&#x2F;扩充总线）</li></ul><hr><h1 id="总线标准的分类"><a href="#总线标准的分类" class="headerlink" title="总线标准的分类"></a>总线标准的分类</h1><ul><li>系统总线标准</li><li>设备总线标准</li><li>局部总线标准</li></ul><hr><h1 id="常见的总线标准"><a href="#常见的总线标准" class="headerlink" title="常见的总线标准"></a>常见的总线标准</h1><ul><li>工业标准体系结构（ISA）</li><li>扩展的工业标准体系结构（EISA）</li><li>视频电子标准协会（VESA）</li><li>外部设备互连（PCI）</li><li>加速图形接口（AGP）</li><li>高速外部设备互连（PCI-E&#x2F;PCI-Express）</li><li>RS-232C</li><li>通用串行总线（USB）</li><li>个人电脑存储卡国际协会（PCMCIA）</li><li>集成设备电路（IDE）&#x2F;高级技术附件（ATA）</li><li>串行高级技术附件（SATA）</li><li>小型计算机系统接口（SCSI）</li></ul><hr><h1 id="总线的性能指标"><a href="#总线的性能指标" class="headerlink" title="总线的性能指标"></a>总线的性能指标</h1><ul><li>总线时钟周期</li><li>总线传输周期</li><li>总线时钟频率</li><li>总线工作频率</li><li>总线宽度&#x2F;总线位宽</li><li>总线带宽&#x2F;总线最大数据传输率</li><li>总线复用</li><li>信号线数</li></ul><blockquote><p>主要：总线带宽&#x3D;总线频率×总线宽度</p></blockquote><hr><h1 id="总线仲裁的分类"><a href="#总线仲裁的分类" class="headerlink" title="总线仲裁的分类"></a>总线仲裁的分类</h1><p>集中仲裁方式：</p><ul><li>链式查询方式</li><li>计数器定时查询方式</li><li>独立请求方式</li></ul><p>分布仲裁方式</p><hr><h1 id="总线事务的过程-阶段-操作"><a href="#总线事务的过程-阶段-操作" class="headerlink" title="总线事务的过程&#x2F;阶段&#x2F;操作"></a>总线事务的过程&#x2F;阶段&#x2F;操作</h1><ol><li>请求</li><li>仲裁</li><li>寻址</li><li>传输</li><li>释放</li></ol><hr><h1 id="总线的定时方式"><a href="#总线的定时方式" class="headerlink" title="总线的定时方式"></a>总线的定时方式</h1><ul><li>同步定时方式</li><li>异步定时方式</li><li>半同步定时方式</li><li>分离式定时方式</li></ul><hr><h1 id="异步定时方式的分类"><a href="#异步定时方式的分类" class="headerlink" title="异步定时方式的分类"></a>异步定时方式的分类</h1><p>依据通信请求和响应信号的撤销是否互锁：</p><ul><li>不互锁方式</li><li>半互锁方式</li><li>全互锁方式</li></ul><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>计算机组成原理的知识抽象、晦涩、不易理解并记忆，在此对“总线”一章中重点知识总结成提纲。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《2023年计算机组成原理考研复习指导》组编：王道论坛</li><li>哔哩哔哩平台《王道计算机考研 计算机组成原理》视频课</li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“中央处理器（CPU）”学习提纲</title>
      <link href="/2022/06/10/%E2%80%9C%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8%EF%BC%88CPU%EF%BC%89%E2%80%9D%E5%AD%A6%E4%B9%A0%E6%8F%90%E7%BA%B2/"/>
      <url>/2022/06/10/%E2%80%9C%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8%EF%BC%88CPU%EF%BC%89%E2%80%9D%E5%AD%A6%E4%B9%A0%E6%8F%90%E7%BA%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>计算机组成原理的知识抽象、晦涩、不易理解并记忆，在此对“中央处理器（CPU）”一章中重点知识总结成提纲。</p><hr><h1 id="中央处理器（CPU）的组成"><a href="#中央处理器（CPU）的组成" class="headerlink" title="中央处理器（CPU）的组成"></a>中央处理器（CPU）的组成</h1><ul><li>中央处理器（CPU）&#x3D;控制单元（CU）+算术逻辑单元（ALU）+寄存器+中断系统</li><li>中央处理器（CPU）&#x3D;控制器+运算器</li></ul><h2 id="控制器的组成"><a href="#控制器的组成" class="headerlink" title="控制器的组成"></a>控制器的组成</h2><ul><li>程序计数器（PC）</li><li>指令寄存器（IR）</li><li>指令译码器</li><li>时序系统</li><li>微操作信号发生器</li><li>存储器地址寄存器（MAR）</li><li>存储器数据寄存器（MDR）</li><li>…</li></ul><h2 id="运算器的组成"><a href="#运算器的组成" class="headerlink" title="运算器的组成"></a>运算器的组成</h2><ul><li>算术逻辑单元（ALU）</li><li>通用寄存器组</li><li>暂存寄存器</li><li>程序状态字寄存器（PSW）</li><li>移位器</li><li>计数器（CT）</li><li>…</li></ul><p>其中，通用寄存器组包括：</p><ul><li>累加寄存器（ACC；16位：AX；32位：EAX）</li><li>基地址寄存器（BR；16位：BX；32位：EBX）</li><li>计数寄存器&#x2F;程序计数器（PC；16位：CX；32位：ECX）</li><li>数据寄存器（（M）DR；16位：DX；32位：EDX）</li><li>变址寄存器（IX，区别于指令寄存器（IR）；ESI，EDI共两个）</li><li>堆栈基指针（寄存器）（BP；32位：EBP）</li><li>堆栈顶指针（寄存器）（SP；32位：ESP）</li></ul><hr><h1 id="中央处理器（CPU）的功能"><a href="#中央处理器（CPU）的功能" class="headerlink" title="中央处理器（CPU）的功能"></a>中央处理器（CPU）的功能</h1><ul><li>指令控制（控制器功能）</li><li>操作控制</li><li>时间控制</li><li>中断处理</li><li>数据加工（运算器功能）</li></ul><hr><h1 id="指令周期的组成"><a href="#指令周期的组成" class="headerlink" title="指令周期的组成"></a>指令周期的组成</h1><ul><li>指令周期&#x3D;若干机器周期（CPU周期）</li><li>机器周期&#x3D;若干时钟周期（τ周期&#x2F;节拍）</li></ul><p>或（按时间顺序）：</p><ul><li>取指周期（获取指令+分析指令）</li><li>间址周期（获取操作数的有效地址；可无）<br> 执行周期（执行指令；可无）</li><li>中断周期（处理中断；可无）</li></ul><hr><h1 id="指令周期的数据流"><a href="#指令周期的数据流" class="headerlink" title="指令周期的数据流"></a>指令周期的数据流</h1><h2 id="取指周期：获取指令"><a href="#取指周期：获取指令" class="headerlink" title="取指周期：获取指令"></a>取指周期：获取指令</h2><ol><li>程序计数器（PC）的指令地址-&gt;存储器地址寄存器（MAR）-&gt;地址总线-&gt;主存储器（MM）</li><li>控制单元（CU）的读控制信号-&gt;控制总线-&gt;主存储器（MM）</li><li>主存储器（MM）的指令-&gt;数据总线-&gt;存储器数据寄存器（MDR）-&gt;指令寄存器（IR）</li></ol><blockquote><p>指令寄存器（IR）的指令操作码-&gt;控制单元（CU）<br>4. 控制单元（CU）的控制信号-&gt;程序计数器（PC）+1</p></blockquote><h2 id="间址周期：获取操作数有效地址"><a href="#间址周期：获取操作数有效地址" class="headerlink" title="间址周期：获取操作数有效地址"></a>间址周期：获取操作数有效地址</h2><p>以一次间址为示例：</p><ol><li>指令寄存器（IR）或存储器数据寄存器（MDR）的指令地址码-&gt;存储器地址寄存器（MAR）-&gt;地址总线-&gt;主存储器（MM）</li><li>控制单元（CU）的读控制信号-&gt;控制总线-&gt;主存储器（MM）</li><li>主存储器（MM）的指令地址-&gt;数据总线-&gt;存储器数据寄存器（MDR）</li></ol><h2 id="执行周期：获取操作数"><a href="#执行周期：获取操作数" class="headerlink" title="执行周期：获取操作数"></a>执行周期：获取操作数</h2><p>不同指令类型，获取操作数的操作不同，无统一数据流向。</p><h2 id="中断周期：处理中断请求，保存程序断点"><a href="#中断周期：处理中断请求，保存程序断点" class="headerlink" title="中断周期：处理中断请求，保存程序断点"></a>中断周期：处理中断请求，保存程序断点</h2><p>以在堆栈保存程序断点；先修改栈顶指针，后保存数据的进栈操作为示例：</p><ol><li>控制单元（CU）的控制信号-&gt;堆栈顶指针（寄存器）（SP；32位：ESP）-1</li><li>堆栈顶指针（寄存器）（SP；32位：ESP）的指令地址-&gt;存储器地址寄存器（MAR）-&gt;地址总线-&gt;主存储器（MM）</li><li>控制单元（CU）的写命令-&gt;控制总线-&gt;主存储器（MM）</li><li>程序计数器（PC）的指令地址-&gt;存储器数据寄存器（MDR）-&gt;数据总线-&gt;主存储器（MM）</li><li>控制单元（CU）的中断服务程序入口地址-&gt;程序计数器（PC）</li></ol><hr><h1 id="指令的执行方案"><a href="#指令的执行方案" class="headerlink" title="指令的执行方案"></a>指令的执行方案</h1><ul><li>单指令周期方案</li><li>多指令周期方案</li><li>流水线方案</li></ul><hr><h1 id="数据通路的基本结构"><a href="#数据通路的基本结构" class="headerlink" title="数据通路的基本结构"></a>数据通路的基本结构</h1><p>在中央处理器（CPU）内部：</p><ul><li>总线结构（单总线、多总线）</li><li>专用数据通路结构</li></ul><hr><h1 id="控制器的功能"><a href="#控制器的功能" class="headerlink" title="控制器的功能"></a>控制器的功能</h1><ul><li>从主存储器（MM）中获取一条指令，并指出下一条指令在主存储器（MM）中的地址</li><li>对指令进行译码或测试，产生相应的操作控制信号，以启动规定的动作</li><li>指挥并控制中央处理器（CPU）、主存储器（MM）、输入和输出设备之间的数据流动方向</li></ul><hr><h1 id="控制器的分类（根据产生微操作控制信号的方式）"><a href="#控制器的分类（根据产生微操作控制信号的方式）" class="headerlink" title="控制器的分类（根据产生微操作控制信号的方式）"></a>控制器的分类（根据产生微操作控制信号的方式）</h1><ul><li>硬布线控制器（组合逻辑控制器）</li><li>微程序控制器</li></ul><blockquote><p>相同点：程序计数器（PC），指令寄存器（IR）。<br>不同点：确定和表示指令执行步骤的方法，产生控制各部件运行所需控制信号的方案。</p></blockquote><hr><h1 id="控制单元（CU）的输入来源"><a href="#控制单元（CU）的输入来源" class="headerlink" title="控制单元（CU）的输入来源"></a>控制单元（CU）的输入来源</h1><ul><li>指令译码器根据指令操作码译码产生的指令信息</li><li>节拍发生器根据机器周期产生的时钟周期信号</li><li>程序状态字寄存器根据执行单元反馈信息存储的状态标志</li><li>控制总线的控制信号。如中断请求、直接存储器访问（DMA）请求</li></ul><hr><h1 id="中央处理器（CPU）的控制方式"><a href="#中央处理器（CPU）的控制方式" class="headerlink" title="中央处理器（CPU）的控制方式"></a>中央处理器（CPU）的控制方式</h1><ul><li>同步控制方式</li><li>异步控制方式</li><li>联合控制方式（大部分同步，小部分异步）</li></ul><hr><h1 id="硬布线控制器设计步骤"><a href="#硬布线控制器设计步骤" class="headerlink" title="硬布线控制器设计步骤"></a>硬布线控制器设计步骤</h1><ol><li>分析指令周期中取值、间址、执行和中断周期的微操作序列</li><li>选择中央处理器（CPU）的控制方式</li><li>安排微操作序列执行时序</li><li>设计电路</li></ol><p>其中设计电路包括：</p><p>（1）列微操作序列的操作时间表<br>（2）写微操作序列的最简表达式<br>（3）画微操作序列的电路逻辑图</p><hr><h1 id="微程序设计的机器指令组成"><a href="#微程序设计的机器指令组成" class="headerlink" title="微程序设计的机器指令组成"></a>微程序设计的机器指令组成</h1><ul><li>一条机器指令编写成一个微程序</li><li>微程序&#x3D;若干微指令</li><li>微指令&#x3D;若干微命令&#x2F;微操作</li><li>微命令时微操作的控制信号，微操作是微命令的执行过程</li></ul><blockquote><p>将微指令类比指令，存在微地址、微操作码、微地址码、微周期等概念。</p></blockquote><hr><h1 id="微程序控制器的组成"><a href="#微程序控制器的组成" class="headerlink" title="微程序控制器的组成"></a>微程序控制器的组成</h1><ul><li>微地址形成部件</li><li>顺序逻辑单元</li><li>控制&#x2F;微存储器地址寄存器（CMAR）</li><li>地址译码器</li><li>控制存储器（CM）</li><li>控制&#x2F;微存储器数据寄存器（CMDR&#x2F;μIR）</li></ul><hr><h1 id="微程序控制器的工作过程"><a href="#微程序控制器的工作过程" class="headerlink" title="微程序控制器的工作过程"></a>微程序控制器的工作过程</h1><ol><li>获取机器指令</li><li>获取机器指令对应微程序的入口地址</li><li>获取微指令</li><li>执行微指令</li><li>获取下一条微指令或下一条机器指令</li></ol><hr><h1 id="微指令的编码-控制方式"><a href="#微指令的编码-控制方式" class="headerlink" title="微指令的编码&#x2F;控制方式"></a>微指令的编码&#x2F;控制方式</h1><ul><li>直接编方式</li><li>字段直接编码方式</li><li>字段间接编码方式&#x2F;隐式编码方式</li><li>混合编码</li></ul><hr><h1 id="微指令的地址形成方式"><a href="#微指令的地址形成方式" class="headerlink" title="微指令的地址形成方式"></a>微指令的地址形成方式</h1><ul><li>机器指令的操作码产生</li><li>微指令的微地址码&#x2F;下地址产生（断定方式）</li><li>增量计数器法产生（自增1）</li><li>分支转移产生</li><li>测试网络产生</li><li>硬件产生</li><li>外部输入产生</li></ul><hr><h1 id="微指令的格式"><a href="#微指令的格式" class="headerlink" title="微指令的格式"></a>微指令的格式</h1><ul><li>水平型微指令</li><li>垂直型微指令</li><li>混合型微指令</li></ul><hr><h1 id="微程序控制器的设计步骤"><a href="#微程序控制器的设计步骤" class="headerlink" title="微程序控制器的设计步骤"></a>微程序控制器的设计步骤</h1><p>核心：编写微程序</p><ol><li>分析指令周期中取值、间址、执行和中断周期的微命令&#x2F;操作序列</li><li>根据微命令&#x2F;操作和时钟周期设计微指令</li><li>确定微指令格式</li><li>编码微指令</li></ol><hr><h1 id="微程序设计的分类"><a href="#微程序设计的分类" class="headerlink" title="微程序设计的分类"></a>微程序设计的分类</h1><ul><li>静态微程序设计</li><li>动态微程序设计</li><li>毫微微程序设计</li></ul><hr><h1 id="中断（广义中断）的分类"><a href="#中断（广义中断）的分类" class="headerlink" title="中断（广义中断）的分类"></a>中断（广义中断）的分类</h1><ul><li>中断（广义中断）&#x3D;中断（狭义中断；外中断）+异常&#x2F;例外&#x2F;陷入（内中断）</li><li>外中断（硬件中断）&#x3D;可屏蔽中断+不可屏蔽中断</li><li>内中断（不可屏蔽中断）&#x3D;故障+自陷&#x2F;陷阱&#x2F;陷入（软件中断&#x2F;程序性异常）+终止（硬件中断）</li></ul><p>或：</p><ul><li>外中断&#x3D;外设请求（如I&#x2F;O操作完成）+人工干预（如用户强行终止进程）</li><li>内中断&#x3D;自愿中断+强迫中断</li><li>自愿中断，指令中断（如系统调用时使用陷入&#x2F;访管&#x2F;Trap指令）</li><li>强迫中断&#x3D;硬件故障（如缺页）+软件中断（如整数除以0）</li></ul><hr><h1 id="外中断事件"><a href="#外中断事件" class="headerlink" title="外中断事件"></a>外中断事件</h1><ul><li>输入&#x2F;输出（I&#x2F;O）设备处理。如键盘输入，打印机缺纸</li><li>特殊事件。如用户按退出Esc键，定时器计数时间到</li><li>紧急硬件故障。如电源掉电</li></ul><blockquote><p>缓存（Cache）缺失<br>直接存储器访问（DMA）传送结束</p></blockquote><hr><h1 id="内中断事件"><a href="#内中断事件" class="headerlink" title="内中断事件"></a>内中断事件</h1><p>故障：</p><ul><li>地址越界</li><li>非法操作码</li><li>缺段或缺页</li><li>溢出。如运算溢出，栈溢出</li><li>整数除以0</li></ul><p>自陷：</p><ul><li>系统调用</li><li>条件自陷指令</li><li>断点设置（x86机器中）</li><li>单步跟踪（x86机器中）</li></ul><p>终止：</p><ul><li>控制器错误</li><li>存储器校验错误</li><li>总线错误</li></ul><blockquote><p>存储保护错误</p></blockquote><hr><h1 id="中断（广义中断）的响应过程"><a href="#中断（广义中断）的响应过程" class="headerlink" title="中断（广义中断）的响应过程"></a>中断（广义中断）的响应过程</h1><ol><li>关中断</li><li>保存断点和程序状态</li><li>识别中断（广义中断）并转到相应的处理程序</li></ol><hr><h1 id="提高中央处理器（CPU）效率的方式"><a href="#提高中央处理器（CPU）效率的方式" class="headerlink" title="提高中央处理器（CPU）效率的方式"></a>提高中央处理器（CPU）效率的方式</h1><ul><li>时间上并行：流水线技术</li><li>空间上并行：超标量处理机</li></ul><hr><h1 id="指令的执行过程（另一种角度：指令流水线）"><a href="#指令的执行过程（另一种角度：指令流水线）" class="headerlink" title="指令的执行过程（另一种角度：指令流水线）"></a>指令的执行过程（另一种角度：指令流水线）</h1><ol><li>取指（IF）</li><li>译码&#x2F;读寄存器（ID）</li><li>执行&#x2F;计算地址（EX）</li><li>访存（MEM）</li><li>写回（WB）</li></ol><hr><h1 id="流水寄存器存储的信息"><a href="#流水寄存器存储的信息" class="headerlink" title="流水寄存器存储的信息"></a>流水寄存器存储的信息</h1><ul><li>数据通路的数据</li><li>控制部件的控制信号</li></ul><hr><h1 id="流水线冒险的分类和处理方式"><a href="#流水线冒险的分类和处理方式" class="headerlink" title="流水线冒险的分类和处理方式"></a>流水线冒险的分类和处理方式</h1><ul><li>结构冒险（资源冲突）</li><li>数据冒险（数据冲突）：读后写相关，写后读相关，写后写相关</li><li>控制冒险（控制冲突）</li></ul><hr><h1 id="流水线冒险的处理方式"><a href="#流水线冒险的处理方式" class="headerlink" title="流水线冒险的处理方式"></a>流水线冒险的处理方式</h1><p>结构冒险（资源冲突）：</p><ul><li>暂停相关指令</li><li>资源重复配置</li></ul><p>数据冒险（数据冲突）：读后写相关，写后读相关，写后写相关：</p><ul><li>暂停相关指令</li><li>数据旁路技术</li><li>编译优化（调整指令顺序）</li></ul><p>控制冒险（控制冲突）：</p><ul><li>分支预测</li><li>预取多方向的指令</li><li>加快和提前形成条件码</li><li>提高转移方向的猜准率</li></ul><hr><h1 id="流水线的性能指标"><a href="#流水线的性能指标" class="headerlink" title="流水线的性能指标"></a>流水线的性能指标</h1><ul><li>吞吐率</li><li>加速比</li><li>效率</li></ul><hr><h1 id="流水线的分类"><a href="#流水线的分类" class="headerlink" title="流水线的分类"></a>流水线的分类</h1><p>根据使用的硬件级别：</p><ul><li>部件功能级流水线</li><li>处理器级流水线</li><li>处理器间流水线</li></ul><p>根据实现功能的个数：</p><ul><li>单功能流水线</li><li>多功能流水线</li></ul><p>根据同一时间内各流水段&#x2F;功能段实现功能的连接方式：</p><ul><li>静态流水线（相同功能）</li><li>动态流水线（不同功能）</li></ul><p>根据各流水段&#x2F;功能段间有无反馈信号：</p><ul><li>线性流水线（无）</li><li>非线性流水线（有）</li></ul><hr><h1 id="高级流水线技术"><a href="#高级流水线技术" class="headerlink" title="高级流水线技术"></a>高级流水线技术</h1><ul><li>超长指令字技术&#x2F;静态多发射技术</li><li>超标量流水线技术&#x2F;动态多发射技术</li><li>超流水线技术</li></ul><hr><h1 id="计算机体系结构的分类（从指令、数据流数量的角度）"><a href="#计算机体系结构的分类（从指令、数据流数量的角度）" class="headerlink" title="计算机体系结构的分类（从指令、数据流数量的角度）"></a>计算机体系结构的分类（从指令、数据流数量的角度）</h1><ul><li>单指令流单数据流（SISD）结构</li><li>单指令流多数据流（SIMD）结构</li><li>多指令流单数据流（MISD）结构</li><li>多指令流多数据流（MIMD）结构</li></ul><hr><h1 id="硬件多线程的实现方式"><a href="#硬件多线程的实现方式" class="headerlink" title="硬件多线程的实现方式"></a>硬件多线程的实现方式</h1><ul><li>粗粒度多线程</li><li>细粒度多线程</li><li>同时多线程（SMT）</li></ul><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>计算机组成原理的知识抽象、晦涩、不易理解并记忆，在此对“中央处理器（CPU）”一章中重点知识总结成提纲。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《2023年计算机组成原理考研复习指导》组编：王道论坛</li><li>哔哩哔哩平台《王道计算机考研 计算机组成原理》视频课</li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“计算机系统概述”学习提纲</title>
      <link href="/2022/06/02/%E2%80%9C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0%E2%80%9D%E5%AD%A6%E4%B9%A0%E6%8F%90%E7%BA%B2/"/>
      <url>/2022/06/02/%E2%80%9C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0%E2%80%9D%E5%AD%A6%E4%B9%A0%E6%8F%90%E7%BA%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>操作系统的知识抽象、晦涩、不易理解并记忆，在此对“计算机系统概述”一章中重点知识总结成提纲。</p><hr><h1 id="计算机系统分层（另一种视角）"><a href="#计算机系统分层（另一种视角）" class="headerlink" title="计算机系统分层（另一种视角）"></a>计算机系统分层（另一种视角）</h1><p>从上&#x2F;高到下&#x2F;低&#x2F;底层：</p><ul><li>用户</li><li>应用程序</li><li>操作系统</li><li>硬件</li></ul><hr><h1 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h1><ul><li>并发</li><li>共享（互斥共享；同时访问）</li></ul><blockquote><p>注意：宏观上的“同时”，微观上可能并行或并发。<br>并发和共享是操作系统两个最基本的特征。</p></blockquote><ul><li>虚拟（时分复用技术：虚拟处理器；空分复用技术：虚拟存储器，虚拟外部设备）</li><li>异步</li></ul><hr><h1 id="操作系统的功能"><a href="#操作系统的功能" class="headerlink" title="操作系统的功能"></a>操作系统的功能</h1><p>管理计算机系统资源：</p><ul><li>处理机管理</li><li>存储器管理</li><li>文件管理</li><li>设备管理</li></ul><p>提供用户与计算机硬件系统间接口：</p><ul><li>作为接口（命令接口&#x3D;联机命令接口&#x2F;交互式命令接口+脱机命令接口&#x2F;批处理命令接口；<strong>程序接口&#x2F;广义指令&#x2F;系统调用</strong>；图形接口&#x2F;图形用户界面&#x2F;GUI）</li></ul><blockquote><p>图形接口是调用系统调用实现的功能，本质还是使用程序接口。</p></blockquote><p>扩充计算机资源：</p><ul><li>扩充机器（裸机硬件+操作系统等软件-&gt;虚拟机）</li></ul><hr><h1 id="操作系统的发展历程"><a href="#操作系统的发展历程" class="headerlink" title="操作系统的发展历程"></a>操作系统的发展历程</h1><p>从早到晚依次为：</p><ul><li>手工操作阶段（无操作系统）</li><li>脱机&#x2F;批处理阶段（出现操作系统；单道批处理系统+多道程序技术-&gt;多道批处理系统）</li><li>分时操作系统（分时技术）</li><li>实时操作系统（在某个时间限制内完成某些紧急任务而不需要时间片排队；硬实时系统+软实时系统）</li><li>网络操作系统</li><li>分布式操作系统</li><li>个人计算机操作系统（目前使用最广泛）</li></ul><blockquote><p>其他操作系统类型：嵌入式操作系统、服务器操作系统、智能手机操作系统等。</p></blockquote><hr><h1 id="中央处理器（CPU）的运行模式-工作状态"><a href="#中央处理器（CPU）的运行模式-工作状态" class="headerlink" title="中央处理器（CPU）的运行模式&#x2F;工作状态"></a>中央处理器（CPU）的运行模式&#x2F;工作状态</h1><ul><li>内核程序，运行在内核态（管态，核心态），可执行特权、非特权指令</li><li>应用程序，运行在用户态（目态），可执行非特权指令</li></ul><blockquote><p>注意：内核态不可执行陷入&#x2F;访管&#x2F;Trap指令。<br>使用程序状态字寄存器中的一位二进制数标识中央处理器（CPU）的运行模式&#x2F;工作状态。</p></blockquote><hr><h1 id="操作系统内核的内容"><a href="#操作系统内核的内容" class="headerlink" title="操作系统内核的内容"></a>操作系统内核的内容</h1><p>两部分：</p><ul><li>与硬件相关的模块</li><li>运行频率高的程序</li></ul><p>四方面：</p><ul><li>时钟管理</li><li>中断机制</li></ul><blockquote><p>注意：中断机制中只有少部分功能属于内核</p></blockquote><ul><li>原语：是一类程序</li><li>系统控制的数据结构和处理（进程、存储器和设备管理）</li></ul><blockquote><p>注意：<br>不同操作系统内核的内容可能不同。<br>操作系统&#x3D;内核部分+非内核部分。</p></blockquote><hr><h1 id="特权指令的内容类型"><a href="#特权指令的内容类型" class="headerlink" title="特权指令的内容类型"></a>特权指令的内容类型</h1><ul><li>时钟操作</li><li>中断操作</li><li>原语操作</li><li>系统调用操作（广义指令）</li></ul><blockquote><p>用户态-&gt;内核态：陷入&#x2F;访管&#x2F;Trap指令，不是特权指令。<br>内核态-&gt;用户态：一般是中断返回指令，是特权指令。</p></blockquote><p>或：</p><ul><li>有关操作I&#x2F;O设备</li><li>有关访问程序状态</li><li>有关存取特殊寄存器</li><li>其他</li></ul><hr><h1 id="中断（广义中断）-中断和异常的分类"><a href="#中断（广义中断）-中断和异常的分类" class="headerlink" title="中断（广义中断）&#x2F;中断和异常的分类"></a>中断（广义中断）&#x2F;中断和异常的分类</h1><ul><li>中断（广义中断）&#x2F;中断和异常&#x3D;中断（狭义中断；外中断）+异常&#x2F;例外&#x2F;陷入（内中断）</li><li>外中断（硬件中断）&#x3D;可屏蔽中断+不可屏蔽中断</li><li>内中断（不可屏蔽中断）&#x3D;故障+自陷（软件中断）+终止（硬件中断）</li></ul><p>或：</p><ul><li>外中断&#x3D;外设请求（如I&#x2F;O操作完成）+人工干预（如用户强行终止进程）</li><li>内中断&#x3D;自愿中断+强迫中断</li><li>自愿中断，指令中断（如系统调用时使用陷入&#x2F;访管&#x2F;Trap指令）</li><li>强迫中断&#x3D;硬件故障（如缺页）+软件中断（如整数除以0）</li></ul><hr><h1 id="系统调用的分类（按功能）"><a href="#系统调用的分类（按功能）" class="headerlink" title="系统调用的分类（按功能）"></a>系统调用的分类（按功能）</h1><ul><li>进程控制</li><li>进程通信</li><li>内存管理</li><li>文件管理</li><li>设备管理</li></ul><hr><h1 id="用户态切换为内核态的常见原因-关键词"><a href="#用户态切换为内核态的常见原因-关键词" class="headerlink" title="用户态切换为内核态的常见原因&#x2F;关键词"></a>用户态切换为内核态的常见原因&#x2F;关键词</h1><p>大部分与中断和异常有关：</p><ul><li>时钟中断</li><li>I&#x2F;O处理</li><li>非法操作码（如整数除以零）</li><li>地址越界</li><li>运算溢出</li><li>虚拟内存系统的缺页处理</li><li>陷入指令</li><li>系统调用</li></ul><hr><h1 id="操作系统的体系结构-内核架构"><a href="#操作系统的体系结构-内核架构" class="headerlink" title="操作系统的体系结构&#x2F;内核架构"></a>操作系统的体系结构&#x2F;内核架构</h1><ul><li>宏内核&#x2F;单内核&#x2F;大内核</li><li>微内核</li><li>混合内核（相对于纯粹宏内核、微内核的概念）</li></ul><blockquote><p>基于宏内核的有：Windows，Linux，macOS，Android、iOS等。<br>基于微内核的有：Fuchsia，鸿蒙OS等。<br>注意：目前主流的操作系统大多基于混合内核。</p></blockquote><hr><h1 id="基于微内核架构操作系统的组成及功能"><a href="#基于微内核架构操作系统的组成及功能" class="headerlink" title="基于微内核架构操作系统的组成及功能"></a>基于微内核架构操作系统的组成及功能</h1><p>操作系统&#x3D;微内核+若干服务器（进程）</p><blockquote><p>服务器进程、客户（机）进程运行在用户态，通过微内核在内核态提供的消息传递机制实现交互。</p></blockquote><h2 id="微内核的功能"><a href="#微内核的功能" class="headerlink" title="微内核的功能"></a>微内核的功能</h2><ul><li>与硬件处理紧密相关的部分</li><li>一些较基本的功能</li><li>客户（机）和服务器之间的通信</li></ul><p>或：</p><ul><li>进程（线程）管理</li><li>低级存储器管理</li><li>中断和陷入处理</li></ul><h2 id="服务器（进程）的功能"><a href="#服务器（进程）的功能" class="headerlink" title="服务器（进程）的功能"></a>服务器（进程）的功能</h2><ul><li>进程（线程）管理</li><li>存储器管理</li><li>文件管理</li><li>设备管理</li><li>…</li></ul><blockquote><p>微内核架构采用“机制+策略分离”原理构造操作系统：<br>将进程、存储器、文件和设备管理等功能一分为二，属于“机制”的小部分放在微内核，如进程调度机制；属于“策略”的大部分放在服务器（进程），如进程调度策略。</p></blockquote><hr><h1 id="宏内核的优、缺点"><a href="#宏内核的优、缺点" class="headerlink" title="宏内核的优、缺点"></a>宏内核的优、缺点</h1><p>优点：高性能。</p><p>缺点：代码庞大，结构复杂、混乱，维护困难。</p><hr><h1 id="微内核的优、缺点"><a href="#微内核的优、缺点" class="headerlink" title="微内核的优、缺点"></a>微内核的优、缺点</h1><p>优点：代码微小，结构清晰，维护简单。</p><ul><li>扩展性和灵活性</li><li>可靠性和安全性</li><li>可移植性</li><li>分布式计算</li></ul><p>缺点：低性能（因为需要频繁在内核态和用户态之间切换）。</p><hr><h1 id="虚拟机管理程序的类型"><a href="#虚拟机管理程序的类型" class="headerlink" title="虚拟机管理程序的类型"></a>虚拟机管理程序的类型</h1><ul><li>第一类<strong>虚拟机管理程序</strong>。裸金属架构，类比系统软件&#x2F;操作系统，向上层提供若干<strong>虚拟机</strong></li></ul><blockquote><p>注意：<br>虚拟机（进程）运行在用户态。<br>虚拟机中的操作系统（进程）认为自身运行在内核态（虚拟内核态），实际运行在用户态。<br>虚拟机中的用户（进程）运行在用户态。</p></blockquote><ul><li>第二类虚拟机管理程序。寄居架构，类比应用软件，如VMware Workstation</li></ul><hr><h1 id="操作系统的设计方式"><a href="#操作系统的设计方式" class="headerlink" title="操作系统的设计方式"></a>操作系统的设计方式</h1><ul><li>分层法</li><li>模块化</li><li>内核架构（宏内核，微内核，混合内核）</li><li>虚拟化技术（两类虚拟机管理程序，虚拟机）</li><li>分区（分配资源）</li><li>外核（一种为虚拟机分配资源的程序，运行在内核态）</li><li>…</li></ul><hr><h1 id="操作系统的引导过程"><a href="#操作系统的引导过程" class="headerlink" title="操作系统的引导过程"></a>操作系统的引导过程</h1><ol><li>激活中央处理器（CPU）：激活的中央处理器（CPU）读取只读存储器（ROM）中的引导（boot）程序，执行基本输入&#x2F;输出系统（BIOS）的指令——引导&#x2F;自举程序</li><li>硬件自检：有故障中止启动，无故障正常启动</li><li>加载存储设备（硬盘等）的相关内容：基本输入&#x2F;输出系统（BIOS）获取启动顺序，基本输入&#x2F;输出系统（BIOS）根据启动顺序将控制权转移给相关硬盘，中央处理器（CPU）根据启动顺序将硬盘中引导扇区的内容加载到主存储器（MM）中——硬盘&#x2F;可引导盘</li><li>加载主引导记录（MBR）</li><li>加载活动分区：主引导记录（MBR）扫描硬盘分区表，识别并加载活动分区——分区&#x2F;活动分区</li><li>加载分区引导记录（PBR）——扇区</li><li>加载启动管理器（引导操作系统的程序）：分区引导记录（PBR）识别并加载启动管理器——根目录、启动管理器（引导操作系统的程序）</li><li>加载操作系统</li></ol><blockquote><p>硬盘&#x3D;若干分区。<br>分区&#x3D;若干扇区。<br>扇区&#x3D;若干目录、文件&#x2F;程序。</p></blockquote><blockquote><p>硬盘&#x3D;引导盘+非引导盘。需要识别并加载可引导盘。<br>分区&#x3D;活动分区+非活动分区。需要识别并加载活动分区：通过主引导记录（MBR）中的硬盘分区表。<br>活动分区的第一个扇区是分区引导记录（PBR）。需要识别并加载第一个扇区<br>第一个扇区的根目录保存有启动管理器（引导操作系统的程序）。需要识别（并加载）根目录、启动管理器（引导操作系统的程序）：通过分区引导记录（PBR）</p></blockquote><p>或按照识别（并加载）的过程：</p><ol><li>引导&#x2F;自举程序</li><li>（硬件自检）</li><li>硬盘&#x2F;可引导盘</li><li>分区&#x2F;活动分区：通过主引导记录（MBR）中的硬盘分区表</li><li>扇区&#x2F;第一个扇区&#x2F;分区引导记录（PBR）</li><li>根目录、启动管理器（引导操作系统的程序）：通过分区引导记录（PBR）</li><li>操作系统</li></ol><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>操作系统的知识抽象、晦涩、不易理解并记忆，在此对“计算机系统概述”一章中重点知识总结成提纲。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《2023年操作系统考研复习指导》组编：王道论坛</li><li>哔哩哔哩平台《王道计算机考研 操作系统》视频课</li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“指令系统”学习提纲</title>
      <link href="/2022/05/24/%E2%80%9C%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E2%80%9D%E5%AD%A6%E4%B9%A0%E6%8F%90%E7%BA%B2/"/>
      <url>/2022/05/24/%E2%80%9C%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E2%80%9D%E5%AD%A6%E4%B9%A0%E6%8F%90%E7%BA%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>计算机组成原理的知识抽象、晦涩、不易理解并记忆，在此对“指令系统”一章中重点知识<strong>总结成提纲</strong>。</p><hr><h1 id="指令系统的组成"><a href="#指令系统的组成" class="headerlink" title="指令系统的组成"></a>指令系统的组成</h1><p>组件由大到小（大包含小）依次为：</p><ul><li>指令集</li><li>指令</li><li>操作码+地址码（寻址特征+形式&#x2F;有效地址）</li><li>二进制代码</li></ul><hr><h1 id="指令的格式"><a href="#指令的格式" class="headerlink" title="指令的格式"></a>指令的格式</h1><ul><li>零地址指令</li><li>一地址指令</li><li>二地址指令</li><li>三地址指令</li><li>四地址指令</li></ul><p>或：</p><ul><li>定长操作码指令</li><li>扩展操作码指令</li></ul><hr><h1 id="指令的操作类型"><a href="#指令的操作类型" class="headerlink" title="指令的操作类型"></a>指令的操作类型</h1><ul><li>数据传送类型</li><li>算术和逻辑运算类型</li><li>移位类型</li><li>转移类型</li><li>输入输出类型</li></ul><p>或：</p><ul><li>数据传送类型</li><li>运算类型（算术和逻辑运算类型+移位类型）</li><li>程序控制类型</li><li>输入输出类型</li></ul><hr><h1 id="寻址方式的类型"><a href="#寻址方式的类型" class="headerlink" title="寻址方式的类型"></a>寻址方式的类型</h1><ul><li>指令寻址</li><li>数据寻址</li></ul><hr><h1 id="指令寻址的方式"><a href="#指令寻址的方式" class="headerlink" title="指令寻址的方式"></a>指令寻址的方式</h1><ul><li>顺序寻址</li><li>跳跃寻址</li></ul><hr><h1 id="数据寻址的方式"><a href="#数据寻址的方式" class="headerlink" title="数据寻址的方式"></a>数据寻址的方式</h1><p>名词注释：</p><ul><li>有效地址：EA</li><li>地址&#x2F;地址码：A</li><li>（A）：地址A中的值</li><li>寄存器：R</li><li>程序计数器：PC</li><li>基址寄存器：BR</li><li>变址寄存器：IX</li><li>堆栈指针：SP</li></ul><table><thead><tr><th>数据寻址方式</th><th>有效地址（EA）</th></tr></thead><tbody><tr><td>隐含寻址</td><td>EA为程序指定</td></tr><tr><td>立即（数）寻址</td><td>A为操作数</td></tr><tr><td>直接寻址</td><td>EA&#x3D;A</td></tr><tr><td>间接寻址（一次或多次）</td><td>EA&#x3D;（A）（一次）</td></tr><tr><td>寄存器寻址（寄存器在中央处理器（CPU）中）</td><td>EA&#x3D;R</td></tr><tr><td>寄存器间接寻址</td><td>EA&#x3D;（R）（一次）</td></tr><tr><td>相对寻址</td><td>EA&#x3D;（PC）+A</td></tr><tr><td>基址寻址</td><td>EA&#x3D;（BR）+A</td></tr><tr><td>变址寻址</td><td>EA&#x3D;（IX）+A</td></tr><tr><td>堆栈寻址</td><td>EA&#x3D;SP</td></tr></tbody></table><hr><h1 id="x86处理器中的寄存器"><a href="#x86处理器中的寄存器" class="headerlink" title="x86处理器中的寄存器"></a>x86处理器中的寄存器</h1><p>共8个32位的通用寄存器：</p><ul><li>累加器（ACC；16位：AX；32位：EAX）</li><li>基地址寄存器（BR；16位：BX；32位：EBX）</li><li>计数寄存器&#x2F;程序计数器（PC；16位：CX；32位：ECX）</li><li>数据寄存器（（M）DR；16位：DX；32位：EDX）</li><li>变址寄存器（IX，区别于指令寄存器（IR）；ESI，EDI共两个）</li><li>堆栈基指针（寄存器）（BP；32位：EBP）</li><li>堆栈顶指针（寄存器）（SP；32位：ESP）</li></ul><blockquote><p>除堆栈基指针（寄存器）（BP）和堆栈顶指针（寄存器）（SP），其他寄存器的用途比较任意</p></blockquote><hr><h1 id="汇编指令的格式"><a href="#汇编指令的格式" class="headerlink" title="汇编指令的格式"></a>汇编指令的格式</h1><ul><li>AT&amp;T格式</li><li>Intel格式</li></ul><hr><h1 id="常用汇编指令"><a href="#常用汇编指令" class="headerlink" title="常用汇编指令"></a>常用汇编指令</h1><h2 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h2><ul><li>mov：移动</li><li>push：入栈</li><li>pop：出栈</li></ul><h2 id="算术和逻辑运算指令"><a href="#算术和逻辑运算指令" class="headerlink" title="算术和逻辑运算指令"></a>算术和逻辑运算指令</h2><ul><li>add：加法</li><li>sub：减法</li><li>inc：自增1</li><li>dec：自减1</li><li>imul：乘法</li><li>idiv：除法</li><li>and：逻辑与</li><li>or：逻辑或</li><li>xor：逻辑异或</li><li>not：取反</li><li>neg：取负</li><li>shl：逻辑左移</li><li>shr：逻辑右移</li></ul><h2 id="控制流指令"><a href="#控制流指令" class="headerlink" title="控制流指令"></a>控制流指令</h2><ul><li>jmp：无条件跳转</li><li>je：相等条件跳转</li><li>jne：不相等条件跳转</li><li>jz：结果为0条件跳转</li><li>jg：大于条件跳转</li><li>jge：大于等于条件跳转</li><li>jl：小于条件跳转</li><li>jle：小于等于条件跳转</li><li>cmp：值比较</li><li>test：逐位与比较</li><li>call：调用</li><li>ret：返回</li></ul><hr><h1 id="过程-函数调用执行步骤（汇编、机器级底层表示）"><a href="#过程-函数调用执行步骤（汇编、机器级底层表示）" class="headerlink" title="过程&#x2F;函数调用执行步骤（汇编、机器级底层表示）"></a>过程&#x2F;函数调用执行步骤（汇编、机器级底层表示）</h1><ol><li>调用者将入口参数（实参）保存在<strong>被调用者能够访问的地方</strong></li></ol><blockquote><p>调用者保存寄存器：累加器（ACC；16位：AX；32位：EAX）、计数寄存器&#x2F;程序计数器（PC；16位：CX；32位：ECX）、数据寄存器（（M）DR；16位：DX；32位：EDX）。被调用者可以访问。<br>2. 调用者将返回地址保存到<strong>被调用者能够访问的地方</strong>，将控制转移到被调用者<br>3. 被调用者保存调用者的现场（通用寄存器（GR）中的内容），为自身的非静态局部变量分配空间<br>4. 执行被调用者过程<br>5. 被调用者恢复调用者的现场，将返回结果保存在<strong>调用者能够访问的地方</strong>，释放非静态局部变量所占空间</p></blockquote><blockquote><p>被调用者保存寄存器：基地址寄存器（BR；16位：BX；32位：EBX）、变址寄存器（IX，区别于指令寄存器（IR）；ESI，EDI共两个）。调用者可以访问。<br>6. 被调用者从<strong>被调用者能够访问的地方</strong>取出返回地址（能够返回到调用者的地址），将控制转移到调用者</p></blockquote><hr><h1 id="过程-函数栈帧"><a href="#过程-函数栈帧" class="headerlink" title="过程&#x2F;函数栈帧"></a>过程&#x2F;函数栈帧</h1><p>假设存在过程&#x2F;函数A调用B，B调用C，分别称为：调用者（A），当前调用者（B），被调用者（C）。<br>则对过程&#x2F;函数B的栈帧，从高到低地址依次为：</p><ul><li>返回调用者（A）地址</li></ul><blockquote><p>从堆栈基指针（寄存器）（BP；32位：EBP）中获取返回调用者（A）地址并压栈。<br>将返回当前调用者（B）地址保存在堆栈基指针（寄存器）（BP；32位：EBP）。<br>即更新堆栈基指针（寄存器）（BP；32位：EBP）中保存的值。</p></blockquote><ul><li>局部变量</li></ul><blockquote><p>定义局部变量时分配空间并压栈。<br>初始化、赋值时从寄存器中获取值并保存到栈中。</p></blockquote><ul><li>参数</li></ul><blockquote><p>依据高级语言的函数调用语句，将被调用者（C）所需的参数按从右到左的顺序压栈</p></blockquote><ul><li>返回当前调用者（B）地址</li></ul><blockquote><p>将返回当前调用者（B）地址保存在堆栈顶指针（寄存器）（SP；32位：ESP）中</p></blockquote><blockquote><p>注意：<br>存在因内存对齐而分配，却可能未被使用的空间。<br>存在不作为被调用者参数，在将寄存器中的值赋值给局部变量前需要保存的寄存器初始值的空间。</p></blockquote><p><strong>总之，过程&#x2F;函数栈帧概念、图解众说纷纭，核心在于知道栈帧中保存的内容和过程&#x2F;函数调用过程，不必深究从高到低地址一一对应的所保存内容。</strong></p><hr><h1 id="指令系统的类型"><a href="#指令系统的类型" class="headerlink" title="指令系统的类型"></a>指令系统的类型</h1><ul><li>复杂指令系统计算机（CISC）。如x86架构的计算机</li><li>精简指令系统计算机（RISC）。如ARM、MIPS架构的计算机</li></ul><hr><h1 id="机器标志位"><a href="#机器标志位" class="headerlink" title="机器标志位"></a>机器标志位</h1><p>由中央处理器（CPU）中相应的条件码&#x2F;标志位寄存器存储：</p><ul><li>CF：进、借位标志</li><li>ZF：零标志</li><li>NF&#x2F;SF：负数&#x2F;符号标志</li><li>OF：溢出标志</li></ul><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>计算机组成原理的知识抽象、晦涩、不易理解并记忆，在此对“指令系统”一章中重点知识<strong>总结成提纲</strong>。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《2023年计算机组成原理考研复习指导》组编：王道论坛</li><li>哔哩哔哩平台《王道计算机考研 计算机组成原理》视频课</li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“存储系统”学习笔记</title>
      <link href="/2022/05/19/%E2%80%9C%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E2%80%9D%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/05/19/%E2%80%9C%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E2%80%9D%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>计算机组成原理的知识抽象、晦涩、不易理解并记忆，在此对“存储系统”一章中重点知识<strong>总结成提纲</strong>。</p><hr><h1 id="存储器的分类（按存取方式）"><a href="#存储器的分类（按存取方式）" class="headerlink" title="存储器的分类（按存取方式）"></a>存储器的分类（按存取方式）</h1><h2 id="1-随机存储器（RAM）"><a href="#1-随机存储器（RAM）" class="headerlink" title="1. 随机存储器（RAM）"></a>1. 随机存储器（RAM）</h2><ul><li>静态随机存储器（SRAM）<br>示例：高速缓冲存储器（Cache）(缓存)</li><li>动态随机存储器（DRAM）<br>示例：主存储器（MM）（主存&#x2F;内存）</li></ul><h2 id="2-只读存储器（ROM）"><a href="#2-只读存储器（ROM）" class="headerlink" title="2. 只读存储器（ROM）"></a>2. 只读存储器（ROM）</h2><p>示例：</p><ul><li>掩模式只读存储器（MROM）</li><li>一次可编程只读存储器（PROM）</li><li>可擦除可编程只读存储器（EPROM）<br>电可擦除可编程只读存储器（EEPROM）<br>紫外线可擦除可编程只读存储器（UVEPROM）</li><li>闪速存储器（Flash）</li><li>固态硬盘（SSD）</li></ul><p>注意：</p><ul><li>广义只读：随机取，不能存</li><li>狭义只读：随机存取</li><li>目前的只读存储器（ROM）基本都是狭义只读，具有非易失、随机存取的特性。但存取速度比随机存取存储器（RAM）慢，仍不可用只读存储器（ROM）完全代替随机存取存储器（RAM）</li></ul><h2 id="3-串行访问存储器"><a href="#3-串行访问存储器" class="headerlink" title="3. 串行访问存储器"></a>3. 串行访问存储器</h2><ul><li>顺序存取存储器（SAM）<br>示例：磁带</li><li>直接存取存储器（DAM）<br>示例：磁盘，只读型光盘存储器（CD-ROM）（光盘）</li></ul><hr><h1 id="存储器的组成"><a href="#存储器的组成" class="headerlink" title="存储器的组成"></a>存储器的组成</h1><p>组件由大到小（大包含小）依次为：</p><ul><li>计算机系统&#x3D;计算机硬件系统+计算机软件系统</li><li>计算机硬件系统&#x3D;存储器+控制器+运算器+输入设备+输出设备</li><li>存储器&#x3D;主存储器（内存储器）（MM）+辅助存储器（外存储器）+高速和缓冲处理器（Cache）</li><li>主存储器&#x3D;地址寄存器（MAR）+存储体+数据寄存器（MDR）+时序控制逻辑</li><li>存储体（存储矩阵）&#x3D;若干存储单元</li><li>存储单元&#x3D;若干存储元件</li><li>每个存储元件存储一位二进制代码</li></ul><blockquote><p>注意：现代计算机的地址寄存器（MAR）和数据寄存器（MDR）在中央处理器（CPU）中</p></blockquote><ul><li>主存储器（MM）使用动态随机存储器（DRAM）+只读存储器（ROM）</li><li>高速缓冲处理器（Cache）使用静态随机存储器（SRAM）</li></ul><hr><h1 id="存储系统的多级层次"><a href="#存储系统的多级层次" class="headerlink" title="存储系统的多级层次"></a>存储系统的多级层次</h1><p>组件从上往下金字塔结构依次为：</p><ul><li>中央处理器（CPU）（不是存储器）</li><li>寄存器</li><li>高速缓冲处理器（Cache）</li><li>主存储器（MM）</li><li>辅存储器</li></ul><hr><h1 id="多模块存储器的类型"><a href="#多模块存储器的类型" class="headerlink" title="多模块存储器的类型"></a>多模块存储器的类型</h1><ul><li>单体多字存储器</li><li>多体并行存储器（高位交叉编址+低位交叉编址）</li></ul><hr><h1 id="主存储器（MM）与中央处理器（CPU）连接的接口"><a href="#主存储器（MM）与中央处理器（CPU）连接的接口" class="headerlink" title="主存储器（MM）与中央处理器（CPU）连接的接口"></a>主存储器（MM）与中央处理器（CPU）连接的接口</h1><ul><li>地址总线</li><li>数据总线</li><li>片选线</li><li>读&#x2F;写控制线（1根或2根）</li></ul><hr><h1 id="主存储器（MM）容量的扩展方式"><a href="#主存储器（MM）容量的扩展方式" class="headerlink" title="主存储器（MM）容量的扩展方式"></a>主存储器（MM）容量的扩展方式</h1><ul><li>位扩展法</li><li>字扩展法</li><li>位字扩展法</li></ul><hr><h1 id="片选信号的产生方式"><a href="#片选信号的产生方式" class="headerlink" title="片选信号的产生方式"></a>片选信号的产生方式</h1><ul><li>线选法（有n个信号&#x2F;片用n根）</li><li>译码片选法（有n个信号&#x2F;片用log以2为底的n根）</li></ul><hr><h1 id="磁盘存储器的组成"><a href="#磁盘存储器的组成" class="headerlink" title="磁盘存储器的组成"></a>磁盘存储器的组成</h1><p>组件由大到小（大包含小）依次为：</p><ul><li>磁盘</li><li>盘片&#x2F;盘组</li><li>盘面</li><li>磁道</li><li>扇区&#x2F;块（磁盘读写的最小单位）</li></ul><blockquote><p>另一个角度的概念：柱面</p></blockquote><ul><li>地址&#x3D;磁盘号+盘面号+磁道号+扇区号</li><li>平均存取时间&#x3D;寻道时间（找磁道）+旋转时间（找扇区）+传输时间（传数据）</li></ul><hr><h1 id="磁盘阵列的类型"><a href="#磁盘阵列的类型" class="headerlink" title="磁盘阵列的类型"></a>磁盘阵列的类型</h1><ul><li>RAID0：无冗余和无校验的磁盘阵列</li><li>RAID1：镜像磁盘阵列</li><li>RAID2：海明码纠错的磁盘阵列</li><li>RAID3：位交叉奇偶校验的磁盘阵列</li><li>RAID4：块交叉奇偶校验的磁盘阵列</li><li>RAID5：无独立校验的奇偶校验的磁盘阵列</li><li>…</li></ul><hr><h1 id="主存储器（MM）和高速缓冲处理器（Cache）的映射方式"><a href="#主存储器（MM）和高速缓冲处理器（Cache）的映射方式" class="headerlink" title="主存储器（MM）和高速缓冲处理器（Cache）的映射方式"></a>主存储器（MM）和高速缓冲处理器（Cache）的映射方式</h1><ul><li>全相联映射</li><li>直接映射</li><li>组相联映射</li></ul><hr><h1 id="高速缓冲处理器（Cache）中主存储器（MM）块的替换算法"><a href="#高速缓冲处理器（Cache）中主存储器（MM）块的替换算法" class="headerlink" title="高速缓冲处理器（Cache）中主存储器（MM）块的替换算法"></a>高速缓冲处理器（Cache）中主存储器（MM）块的替换算法</h1><ul><li>随机（RAND）算法</li><li>先进先出（FIFO）算法</li><li>近期最少使用（LRU）算法</li><li>最不经常使用（LFU）算法</li></ul><hr><h1 id="高速缓冲处理器（Cache）的写策略"><a href="#高速缓冲处理器（Cache）的写策略" class="headerlink" title="高速缓冲处理器（Cache）的写策略"></a>高速缓冲处理器（Cache）的写策略</h1><p>命中高速缓冲处理器（Cache）：</p><ul><li>全写法</li><li>回写法</li></ul><p>不命中高速缓冲处理器（Cache）：</p><ul><li>写分配法</li><li>非写分配法</li></ul><blockquote><p>搭配使用：全写法+非写分配法；回写法+写分配法</p></blockquote><hr><h1 id="虚拟存储器类型"><a href="#虚拟存储器类型" class="headerlink" title="虚拟存储器类型"></a>虚拟存储器类型</h1><ul><li>页式虚拟存储器</li><li>段式虚拟存储器</li><li>段页式虚拟存储器</li></ul><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>计算机组成原理的知识抽象、晦涩、不易理解并记忆，在此对“存储系统”一章中重点知识<strong>总结成提纲</strong>。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《2023年计算机组成原理考研复习指导》组编：王道论坛</li><li>哔哩哔哩平台《王道计算机考研 计算机组成原理》视频课</li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Visual Studio+Qt软件安装及环境配置过程和无法设置Qt路径的解决方案</title>
      <link href="/2022/05/11/Visual%20Studio+Qt%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%8F%8A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B%E5%92%8C%E6%97%A0%E6%B3%95%E8%AE%BE%E7%BD%AEQt%E8%B7%AF%E5%BE%84%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2022/05/11/Visual%20Studio+Qt%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%8F%8A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B%E5%92%8C%E6%97%A0%E6%B3%95%E8%AE%BE%E7%BD%AEQt%E8%B7%AF%E5%BE%84%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>文章记录Visual Studio+Qt软件安装及环境配置过程，介绍无法设置Qt路径的解决方案</li><li><strong>作者在操作三天三夜后的成功案例和血泪教训…</strong></li></ul><hr><h1 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h1><ul><li>联想拯救者Y7000笔记本电脑</li><li>Windows10操作系统</li></ul><hr><h1 id="安装哪个版本的Qt、Visual-Studio和Qt-VS-Tools（Visual-Studio上的Qt插件）"><a href="#安装哪个版本的Qt、Visual-Studio和Qt-VS-Tools（Visual-Studio上的Qt插件）" class="headerlink" title="安装哪个版本的Qt、Visual Studio和Qt VS Tools（Visual Studio上的Qt插件）?"></a>安装哪个版本的Qt、Visual Studio和Qt VS Tools（Visual Studio上的Qt插件）?</h1><p>作者曾安装并搭配过的版本：</p><ul><li>Visual Studio2019+Qt5.14.2+Qt VS Tools2.4.3</li><li>Visual Studio2019+Qt5.14.2+Qt VS Tools2.5.1</li><li>Visual Studio2019+Qt5.14.2+Qt VS Tools2.5.2</li><li>Visual Studio2019+Qt5.14.2+Qt VS Tools2.6.0</li><li>Visual Studio2019+Qt5.14.2+Qt VS Tools2.7.1</li><li>Visual Studio2019+Qt5.14.2+Qt VS Tools2.7.2</li><li>Visual Studio2019+Qt5.14.2+Qt VS Tools2.8.1</li><li>Visual Studio2022+Qt5.14.2+Qt VS Tools2.8.1（只有Qt VS Tools2.8.1有对应Visual Studio2022的.vsix文件）</li><li>Visual Studio2022+Qt6.6.4（好像是6.6.4，或者是6.4.0）+Qt VS Tools2.8.1</li></ul><p>重点考虑在Visual Studio中无法设置Qt路径，兼顾考虑版本性能、稳定性、兼容性等问题，<strong>成功案例的安装版本如下：</strong></p><ul><li>Visual Studio2019</li><li>Qt5.14.2</li><li>Qt VS Tools2.4.3</li></ul><hr><h1 id="Qt5-14-2"><a href="#Qt5-14-2" class="headerlink" title="Qt5.14.2"></a>Qt5.14.2</h1><p>教程请见作者的这篇文章：<a href="https://editor.csdn.net/md/?articleId=124651849">Qt5.14.2版本安装教程</a></p><hr><h1 id="Visual-Studio2019"><a href="#Visual-Studio2019" class="headerlink" title="Visual Studio2019"></a>Visual Studio2019</h1><h2 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h2><p><a href="https://my.visualstudio.com/Downloads?q=visual%20studio%202019&wt.mc_id=o~msft~vscom~older-downloads">Downloads - Visual Studio Subscriptions Portal</a></p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><img src="/../img/vs_qt/0f838ae658114146a99139e46e470670.png"></p><ul><li>选择：Visual Studio Community 2019 (version 16.11)</li><li>需要注意的参数：1.社区版，2.版本号，3.操作系统位数</li><li>有其他需求的可自选</li><li>点击Download下载.exe可执行文件</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul><li>根据安装引导程序进行即可。安装步骤简单，不再过多截图</li></ul><p><img src="/../img/vs_qt/08a9778460564e58a6d44384d4c7cac7.png"></p><ul><li>组件选择：使用C++的桌面开发</li><li>有其他需求的可自选</li><li>注意安装路径（不建议安装在C盘）</li></ul><hr><h1 id="Qt-VS-Tools2-4-3（Visual-Studio上的Qt插件）"><a href="#Qt-VS-Tools2-4-3（Visual-Studio上的Qt插件）" class="headerlink" title="Qt VS Tools2.4.3（Visual Studio上的Qt插件）"></a>Qt VS Tools2.4.3（Visual Studio上的Qt插件）</h1><h2 id="官网-1"><a href="#官网-1" class="headerlink" title="官网"></a>官网</h2><p><a href="https://download.qt.io/archive/vsaddin/">Index of &#x2F;archive&#x2F;vsaddin (qt.io)</a></p><h2 id="下载-1"><a href="#下载-1" class="headerlink" title="下载"></a>下载</h2><p><img src="/../img/vs_qt/2263c07994bd4d31b0662211323ba544.png"></p><ul><li>点击qt-vsaddin-msvc2019-2.4.3.vsix下载文件</li></ul><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><ul><li>根据安装引导程序进行即可。安装步骤简单，不再过多截图</li><li>注意：需关闭Visual Studio 2019</li></ul><p><img src="/../img/vs_qt/908a4401b98c4d8fa4b29d643d372fb5.png"></p><ul><li>打开Visual Studio 2019</li><li>点击上方导航栏的扩展（X）选项</li><li>存在Qt VS Tools，表明安装成功</li></ul><hr><h1 id="运行第一个Qt程序"><a href="#运行第一个Qt程序" class="headerlink" title="运行第一个Qt程序"></a>运行第一个Qt程序</h1><p><img src="/../img/vs_qt/6d0186a7b5ec4386823b6f345c0513e4.png"></p><ul><li>鼠标悬停在Qt VS Tools选项上</li><li>点击Qt Options选项</li></ul><p><img src="/../img/vs_qt/d471a72474404a71904f5c8c7d43a3fc.png"></p><ul><li>点击Add添加Qt路径</li><li>Name：可自定义</li><li>Path：下载Qt时指定组件的msvc文件夹</li><li>点击ok</li></ul><p><img src="/../img/vs_qt/6dd94c5752c04a09aad5024bdbb9c820.png"></p><ul><li>点击上方导航栏的文件（F）选项</li><li>点击新建（N）选项</li><li>点击项目（P）选项</li></ul><p><img src="/../img/vs_qt/6d9295d58f13467290614e637a6a99e0.png"></p><ul><li>在右上方搜索框输入qt搜索Qt项目</li><li>点击Qt GUI Application选项</li><li>点击下一步（N）</li></ul><p><img src="/../img/vs_qt/ddf29167d2104e7e8ef2c55f0ece2cff.png"></p><ul><li>指定项目存放路径</li><li>点击创建（C）</li></ul><p><img src="/../img/vs_qt/20635782964e4a72adff2917ecb4f9ed.png"></p><ul><li>点击Next &gt;</li></ul><p><img src="/../img/vs_qt/894a35f1b06f408098e56842c89f927b.png"></p><ul><li>默认选项</li><li>有其他需求的可自选</li><li>点击Next &gt;</li></ul><p><img src="/../img/vs_qt/6aacf3318e724bb898aef970a9294d6e.png"></p><ul><li>默认选项</li><li>有其他需求的可自选</li><li>点击Finish</li></ul><p><img src="/../img/vs_qt/3f494cb7a0074cf0ab8b6897e1803ee2.png"></p><ul><li>Ctrl+F5运行程序</li></ul><p><img src="/../img/vs_qt/2a29617a35724d4885732df3c2531fcf.png"></p><ul><li>运行成功√</li></ul><hr><h1 id="无法设置Qt路径的解决方案"><a href="#无法设置Qt路径的解决方案" class="headerlink" title="无法设置Qt路径的解决方案"></a>无法设置Qt路径的解决方案</h1><h2 id="报错信息"><a href="#报错信息" class="headerlink" title="报错信息"></a>报错信息</h2><p><img src="/../img/vs_qt/072ddc61020e48408166613b7baa448f.png"></p><ul><li>Error reading VS project settings</li><li>Stacktrace（堆栈跟踪）显示的是Qt VS Tools即插件的问题（此前作者一直没有仔细读报错信息，以为是Visual Studio和Qt版本不匹配的问题）</li></ul><h2 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h2><ul><li>将Qt VS Tools从高往低版本不断安装、设置Qt路径和卸载直到成功</li><li>可以发现Qt VS Tools2.8.1报错信息会出现上图的…行号：93文字；Qt VS Tools2.7.2——2.5.1没有上图的…行号：93文字</li><li>可以发现Qt VS Tools2.8.1——2.5.1和2.4.3设置Qt路径的界面不同、创建项目时的选项名称不同（Qt Widgets Application和Qt GUI Application）</li><li>可以大胆猜测，Qt VS Tools2.8.1，2.7.2——2.5.1，2.4.3三个版本存在一定差异</li><li>作者其实是追求使用高、新版本软件的，无奈只能向下兼容，退而求其次选择较低版本</li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ul><li>使用Qt VS Tools2.4.3版本</li><li>而Qt VS Tools2.4.3版本只有Visual Studio2015、2017和2019版本的.vsix文件，所以使用最高的Visual Studio2019版本</li><li>Qt版本的选择原因已在教程中阐述。可能可以使用Qt6版本，作者未测试过</li></ul><hr><h1 id="针对无法设置Qt路径的必要配置"><a href="#针对无法设置Qt路径的必要配置" class="headerlink" title="针对无法设置Qt路径的必要配置"></a>针对无法设置Qt路径的必要配置</h1><p><img src="/../img/vs_qt/4054f2b929834dc0960a1d17c665831a.png"></p><ul><li>点击上方导航栏的扩展（X）选项</li><li>点击管理扩展（M）选项</li></ul><p><img src="/../img/vs_qt/e0d0953910a54b3aa41a8d563b2eb3a0.png"></p><ul><li>点击左栏的已安装选项卡</li><li>点击中栏的Qt Visual Studio Tools插件</li><li>取消勾选右栏的自动更新此扩展（因为无法设置Qt路径是Qt VS Tools插件版本的问题）</li><li>点击右下方的关闭（C）</li></ul><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>文章记录Visual Studio+Qt软件安装及环境配置过程，介绍无法设置Qt路径的解决方案</li><li>**作者在操作三天三夜后的成功案例和血泪教训…**，在此将经验分享给大家~</li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/block999123/article/details/119912647">VS2015+QT插件，新建项目出现error reading VS project settings_RuoChengWang的博客-CSDN博客_vs2015无法新建项目</a></p>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt5.14.2版本安装教程</title>
      <link href="/2022/05/08/Qt5.14.2%E7%89%88%E6%9C%AC%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
      <url>/2022/05/08/Qt5.14.2%E7%89%88%E6%9C%AC%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Qt5.14.2版本安装教程。</p><hr><h1 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h1><ul><li>联想拯救者Y7000笔记本电脑</li><li>Windows10操作系统</li></ul><hr><h1 id="官方下载网址"><a href="#官方下载网址" class="headerlink" title="官方下载网址"></a>官方下载网址</h1><p><a href="https://download.qt.io/archive/qt/5.14/5.14.2/">Index of &#x2F;archive&#x2F;qt&#x2F;5.14&#x2F;5.14.2</a></p><hr><h1 id="为什么不安装更高的版本？"><a href="#为什么不安装更高的版本？" class="headerlink" title="为什么不安装更高的版本？"></a>为什么不安装更高的版本？</h1><ul><li>类比Linux操作系统、MySQL数据库等软件，虽然高版本一般性能更佳，但可能存在不稳定、不与低版本或其他软件兼容等不可预知的问题</li><li>从Qt5.15.0版本开始，对开源用户，Qt官方不再提供独立的安装文件</li></ul><p>Qt5.14.2版本的下载界面：<br><img src="/../img/qt/e1ae9421a7654ab98ccc288ee853cdd6.png"><br>Qt5.15.0版本的下载界面：<br><img src="/../img/qt/8e83b66ffd7f43639d6c9fc51736cc1e.png"><br>对比两图可以看到，Qt5.15.0版本没有提供下载的.exe文件。</p><hr><h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p><img src="/../img/qt/410f9b06f1a9479da2c272f3cec28371.png"><br>点击.exe文件进行下载。</p><hr><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><img src="/../img/qt/59ba4f5d1cca43c6bbdaeaf8b57c723c.png"></p><ul><li>下载完成后，点击在文件夹中显示</li></ul><p><img src="/../img/qt/4c9d3145b308419a89e42ae1d0a30ac5.png"></p><ul><li>双击安装包安装</li></ul><p><img src="/../img/qt/38ed540a77b547a0b95a28d2b8020694.png"></p><ul><li>点击Next</li></ul><p><img src="/../img/qt/9b12167d040248a2bfeaf5f1ef286599.png"></p><ul><li>填写Qt账号（若没有账号需注册）</li><li>点击Next</li></ul><p><img src="/../img/qt/8c153ca7e65e4d029c87bdceee543546.png"></p><ul><li>勾选已阅读并同意使用开源Qt的义务</li><li>点击下一步（N）</li></ul><p><img src="/../img/qt/a52f299c60bc4d4f818ffcd9cc06f2c2.png"></p><ul><li>点击下一步（N）</li></ul><p><img src="/../img/qt/b4f06e77b30f44e79b5ab58e044e6acd.png"></p><ul><li>在需要存放安装文件的磁盘下（不建议安装在C盘）创建相应的文件夹（规范命名，不以中文命名）</li><li>点击浏览</li><li>指定安装文件夹</li><li>点击下一步（N）</li></ul><p><img src="/../img/qt/599e7a61852f41a98fcaab8846e6b6d3.png"></p><p><img src="/../img/qt/9d9a2932c3eb4ddda5760d199ea7215f.png"></p><ul><li>点开Qt 5.14.2</li><li>勾选相应组件（需要搭配Visual Studio使用需勾选MSVC…；MinGW是Windows操作系统下的C语言编译器库；若不清楚位数建议32、64位都勾选；若清楚并有对其他组件的需求可自定义勾选其他组件）</li><li>其他组件默认（已勾选的保持勾选，未勾选的保持未勾选）</li><li>点击下一步（N）</li></ul><p><img src="/../img/qt/d71164b80a9e461a87637862106f740f.png"></p><ul><li>勾选已阅读并同意许可协议</li><li>点击下一步（N）</li></ul><p><img src="/../img/qt/72ddcb8539bb4e28bccda2b36292bd79.png"></p><ul><li>点击下一步（N）</li></ul><p><img src="/../img/qt/bbaa9e2045794ac1ac9cc4c9d3414b73.png"></p><ul><li>点击安装（I）</li></ul><p><img src="/../img/qt/70a1ff0e6833428b90db6041bf75206f.png"></p><ul><li>等待安装</li></ul><p><img src="/../img/qt/f9867401bf574bb2ad816ee4552fe5d1.png"></p><ul><li>点击完成（F）</li></ul><hr><h1 id="Qt-Creator界面"><a href="#Qt-Creator界面" class="headerlink" title="Qt Creator界面"></a>Qt Creator界面</h1><p><img src="/../img/qt/bc19be756fdb49f980d9f1e72188c454.png"></p><hr><h1 id="创建Qt-Creator的桌面快捷方式"><a href="#创建Qt-Creator的桌面快捷方式" class="headerlink" title="创建Qt Creator的桌面快捷方式"></a>创建Qt Creator的桌面快捷方式</h1><p><img src="/../img/qt/6cb74911a344410ab0f5ca4da7c28464.png"></p><ul><li>点击桌面左下角任务栏的搜索按钮</li></ul><p><img src="/../img/qt/75b996b5690142f48ce02fc6fb0a7c54.png"></p><ul><li>输入Qt Creator</li><li>点击打开文件位置</li></ul><p><img src="/../img/qt/3ef99042c40641e3848865fa37b8ac98.png"></p><ul><li>右键点击Qt Creator 4.11.1（Community）</li><li>点击创建快捷方式（S）</li></ul><p><img src="/../img/qt/84734df27e9c4969a1e44859e32fce8f.png"></p><ul><li>将快捷方式拖到桌面</li></ul><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Qt5.14.2版本安装教程。</p><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li><strong>感谢参考资料的作者&#x2F;博主</strong></li><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.cnblogs.com/xyf327/p/15006500.html#:~:text=%E4%BA%8C%EF%BC%8C%E6%89%93%E5%BC%80VS%E5%AE%89%E8%A3%85Qt%E6%8F%92%E4%BB%B6%20%E9%80%89%E6%8B%A9%E8%8F%9C%E5%8D%95%E6%A0%8F%E7%9A%84%20%E6%89%A9%E5%B1%95-%3E%E7%AE%A1%E7%90%86%E6%89%A9%E5%B1%95%EF%BC%8C%E8%BE%93%E5%85%A5Qt%E6%90%9C%E7%B4%A2%EF%BC%8C%E7%84%B6%E5%90%8E%E4%B8%8B%E8%BD%BDQt%20Visual%20Studio%20Tools%EF%BC%88%E4%B8%8B%E8%BD%BD%E7%81%B0%E5%B8%B8%E7%9A%84%E9%93%B6%E6%9D%8F%EF%BC%8C%E6%85%A2%E7%9A%84%E6%AD%BB~%E8%BF%98%E4%B8%8D%E4%B8%80%E5%AE%9A%E8%83%BD%E4%B8%8B%E8%BD%BD%EF%BC%89,%E5%A6%82%E6%9E%9C%E5%AE%9E%E5%9C%A8%E4%B8%8D%E8%83%BD%E5%BF%8D%E5%8F%97%E8%BF%99%E9%BE%9F%E9%80%9F%EF%BC%8C%E5%92%B1%E4%BB%AC%E6%9D%A5%E5%88%AB%E7%9A%84%E5%8A%9E%E6%B3%95%20%E5%85%88%E5%88%B0Qt%E5%AE%98%E7%BD%91%E4%B8%8B%E8%BD%BD%E5%AF%B9%E4%BA%8E%E7%89%88%E6%9C%AC%E7%9A%84%E6%8F%92%E4%BB%B6%EF%BC%8C%E6%88%91%E8%BF%99%E9%87%8C%E6%98%AFVs2019%EF%BC%9Ahttps://download.qt.io/official_releases/vsaddin/2.4.1/%20%E5%A6%82%E6%9E%9C%E8%B7%B3%E5%88%B0%E5%A6%82%E4%B8%8B%E9%A1%B5%E9%9D%A2%EF%BC%8C%E9%80%89%E6%8B%A9%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E9%95%9C%E5%83%8F%E6%BA%90%E4%B8%8B%E8%BD%BD%E5%8D%B3%E5%8F%AF%E3%80%82%20%E4%B8%89%EF%BC%8C%E5%AE%89%E8%A3%85VSIX%20%28%E5%8D%B3%E4%B8%8A%E9%9D%A2%E4%B8%8B%E8%BD%BD%E7%9A%84%E9%82%A3%E4%B8%AA%E6%8F%92%E4%BB%B6%29%20%E5%A6%82%E6%9E%9C%E6%98%AF%E9%80%9A%E8%BF%87Vs%E4%B8%8B%E8%BD%BD%E7%9A%84%EF%BC%8C%E4%BC%9A%E8%87%AA%E5%8A%A8%E5%AE%89%E8%A3%85%E3%80%82">QT从入门到入土（一）——Qt5.14.2安装教程和VS2019环境配置</a></p>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>静态链表的C++语言描述实现模板</title>
      <link href="/2022/04/27/%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8%E7%9A%84C++%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E5%AE%9E%E7%8E%B0%E6%A8%A1%E6%9D%BF/"/>
      <url>/2022/04/27/%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8%E7%9A%84C++%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E5%AE%9E%E7%8E%B0%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>数据结构中静态链表的C++语言描述实现模板，有详细的步骤解析及使用示例。</p><hr><h1 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h1><ul><li><a href="https://github.com/yezhening/Programming-examples">yezhening&#x2F;Programming-examples: 编程实例 (github.com)</a></li><li><a href="https://gitee.com/yezhening/Programming-examples">Programming-examples: 编程实例 (gitee.com)</a></li></ul><hr><h1 id="sLinkList-cpp"><a href="#sLinkList-cpp" class="headerlink" title="sLinkList.cpp"></a>sLinkList.cpp</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件————————————————————</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//宏————————————————————</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 100 <span class="comment">//最大大小</span></span></span><br><span class="line"><span class="comment">//为防止插入数据时溢出，通常数组建立得大一些</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型————————————————————</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ELEM_TYPE; <span class="comment">//数据的（数据）类型 依据数据的实际类型定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体</span></span><br><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="comment">//静态链表/数组</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    ELEM_TYPE data;    <span class="comment">//数据</span></span><br><span class="line">    <span class="type">int</span> cur;           <span class="comment">//游标 存储直接后继位置的数组下标</span></span><br><span class="line">&#125; SLinkList[MAX_SIZE]; <span class="comment">//结构体数组</span></span><br><span class="line"><span class="comment">//数组中存在未被使用和已使用的位置/结点</span></span><br><span class="line"><span class="comment">//约定：</span></span><br><span class="line"><span class="comment">//数组的第一个和最后一个位置不存数据</span></span><br><span class="line"><span class="comment">//数组的第一个位置（数组下标为0）的游标存储未被使用位置中第一个位置的数组下标</span></span><br><span class="line"><span class="comment">//当数组位置的游标无直接后继位置时，存储数组下标0</span></span><br><span class="line"><span class="comment">//数组的最后一个位置（数组下标为MAX_SIZE-1）存储已被使用位置中第一个位置的数组下标  类比单链表的头结点</span></span><br><span class="line"><span class="comment">//数组为空时，数组的最后一个位置（数组下标为MAX_SIZE-1）存储数组下标0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数声明————————————————————</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_example</span><span class="params">()</span></span>;                                               <span class="comment">//使用示例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_list</span><span class="params">(SLinkList &amp;sLinkList)</span></span>;                             <span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_length</span><span class="params">(SLinkList sLinkList)</span></span>;                              <span class="comment">//获取表长</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">allot</span><span class="params">(SLinkList &amp;sLinkList)</span></span>;                                  <span class="comment">//分配</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">insert_list</span><span class="params">(SLinkList &amp;sLinkList, <span class="type">int</span> posi, ELEM_TYPE elem)</span></span>; <span class="comment">//插入</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">(SLinkList &amp;sLinkList, <span class="type">int</span> del_cur)</span></span>;                  <span class="comment">//释放</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">delete_list</span><span class="params">(SLinkList &amp;sLinkList, <span class="type">int</span> posi)</span></span>;                 <span class="comment">//删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(SLinkList sLinkList)</span></span>;                               <span class="comment">//遍历</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数————————————————————</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">use_example</span>(); <span class="comment">//使用示例</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数定义————————————————————</span></span><br><span class="line"><span class="comment">//使用示例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_example</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建</span></span><br><span class="line">    SLinkList sLinkList;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">init_list</span>(sLinkList);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入  默认成功，未接收返回值</span></span><br><span class="line">    <span class="built_in">insert_list</span>(sLinkList, <span class="number">1</span>, <span class="number">300</span>);</span><br><span class="line">    <span class="built_in">insert_list</span>(sLinkList, <span class="number">1</span>, <span class="number">200</span>);</span><br><span class="line">    <span class="built_in">insert_list</span>(sLinkList, <span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="comment">//元素在数组中排列：300，200，100</span></span><br><span class="line">    <span class="comment">//元素在链表中排列：100，200，300</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; sLinkList[i].data &lt;&lt; endl; <span class="comment">//输出：300，200，100</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> move_cur; <span class="comment">//移动游标</span></span><br><span class="line"></span><br><span class="line">    move_cur = MAX_SIZE - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) <span class="comment">//遍历</span></span><br><span class="line">    &#123;</span><br><span class="line">        move_cur = sLinkList[move_cur].cur; <span class="comment">//移动移动游标</span></span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; sLinkList[move_cur].data &lt;&lt; endl; <span class="comment">//输出：100，200，300</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sLinkList[move_cur].cur == <span class="number">0</span>) <span class="comment">//移动游标到数组的最后一个位置，输出数据后退出</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取表长</span></span><br><span class="line">    <span class="type">int</span> length; <span class="comment">//表长</span></span><br><span class="line"></span><br><span class="line">    length = <span class="built_in">get_length</span>(sLinkList); <span class="comment">//获取表长</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; length &lt;&lt; endl; <span class="comment">//输出：3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除  默认成功，未接收返回值</span></span><br><span class="line">    <span class="built_in">delete_list</span>(sLinkList, <span class="number">2</span>); <span class="comment">//删除</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意：</span></span><br><span class="line">    <span class="comment">//删除只是修改元素删除位置的前一个位置的游标存储的数组下标，并将元素删除位置置为未被使用位置</span></span><br><span class="line">    <span class="comment">//是在逻辑上删除，但在物理上元素删除位置仍存储原数据</span></span><br><span class="line">    <span class="comment">//元素在数组中排列：300，200，100</span></span><br><span class="line">    <span class="comment">//元素在链表中排列：100，300</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; sLinkList[i].data &lt;&lt; endl; <span class="comment">//输出：300，200，100</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历</span></span><br><span class="line">    <span class="built_in">traverse</span>(sLinkList); <span class="comment">//遍历 输出：100，300</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数定义————————————————————</span></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_list</span><span class="params">(SLinkList &amp;sLinkList)</span> <span class="comment">//参数：数组（还未形成静态链表）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_SIZE; i++) <span class="comment">//遍历各数组位置</span></span><br><span class="line">    &#123;</span><br><span class="line">        sLinkList[i].cur = i + <span class="number">1</span>; <span class="comment">//游标存储数组下一位置的数组下标</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//由代码逻辑，初始化后若直接使用插入操作，一般按照数组下标1-MAX_SIZE-1的位置依次插入元素</span></span><br><span class="line"></span><br><span class="line">    sLinkList[MAX_SIZE - <span class="number">1</span>].cur = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//遍历后数组最后一个位置的游标存储：sLinkList[MAX_SIZE-1].cur = MAX_SIZE</span></span><br><span class="line">    <span class="comment">//约定：数组为空时，数组的最后一个位置（数组下标为MAX_SIZE-1）存储数组下标0</span></span><br><span class="line">    <span class="comment">//修改数组最后一个位置的游标存储</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取表长</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_length</span><span class="params">(SLinkList sLinkList)</span> <span class="comment">//参数：数组    返回值：表长</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> length = <span class="number">0</span>; <span class="comment">//表长</span></span><br><span class="line">    <span class="type">int</span> move_cur;   <span class="comment">//移动游标   当前数组位置的数组下标</span></span><br><span class="line"></span><br><span class="line">    move_cur = sLinkList[MAX_SIZE - <span class="number">1</span>].cur; <span class="comment">//初始化移动游标    存储数组已被使用位置中第一个位置的数组下标</span></span><br><span class="line">    <span class="comment">//约定：数组的最后一个位置（数组下标为MAX_SIZE-1）存储已被使用位置中第一个位置的数组下标  类比单链表的头结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (move_cur != <span class="number">0</span>) <span class="comment">//遍历</span></span><br><span class="line">    &#123;</span><br><span class="line">        move_cur = sLinkList[move_cur].cur; <span class="comment">//更新移动游标   存储数组已被使用位置中下一个位置的数组下标</span></span><br><span class="line"></span><br><span class="line">        length++; <span class="comment">//表长+1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> length; <span class="comment">//返回表长</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态链表需要模拟动态链表的存储空间分配，需要时申请</span></span><br><span class="line"><span class="comment">//思路：将数组中未被使用的位置链成链表，需要时取第一个位置，记录游标存储下一个未被使用的位置</span></span><br><span class="line"><span class="comment">//分配</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">allot</span><span class="params">(SLinkList &amp;sLinkList)</span> <span class="comment">//参数：数组    返回值：数组未被使用位置中第一个位置的数组下标</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> posi; <span class="comment">//数组未被使用位置中第一个位置的数组下标</span></span><br><span class="line"></span><br><span class="line">    posi = sLinkList[<span class="number">0</span>].cur; <span class="comment">//获取数组未被使用位置中第一个位置的数组下标</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//约定：数组的第一个位置（数组下标为0）的游标存储未被使用位置中第一个位置的数组下标</span></span><br><span class="line">    <span class="comment">//约定：当数组位置的游标无直接后继位置时，存储数组下标0</span></span><br><span class="line">    <span class="comment">//从数组的第一个位置（数组下标为0）的游标获取未被使用位置中第一个位置的数组下标</span></span><br><span class="line">    <span class="comment">//若存在数组未被使用位置中第一个位置，值&gt;0，不存在，值==0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//数组未被使用位置中第一个位置的游标存储数组未被使用位置中第二个位置或者0（已不存在数组未被使用位置）</span></span><br><span class="line">    <span class="comment">//修改数组的第一个位置（数组下标为0）的游标存储下一个数组未被使用位置的数组下标</span></span><br><span class="line">    <span class="keyword">if</span> (sLinkList[<span class="number">0</span>].cur != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sLinkList[<span class="number">0</span>].cur = sLinkList[posi].cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> posi; <span class="comment">//返回数组未被使用位置中第一个位置的数组下标</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="comment">//参数：数组，元素插入的位置，元素 返回值：操作失败返回false，成功返回true</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">insert_list</span><span class="params">(SLinkList &amp;sLinkList, <span class="type">int</span> posi, ELEM_TYPE elem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> length; <span class="comment">//表长</span></span><br><span class="line"></span><br><span class="line">    length = <span class="built_in">get_length</span>(sLinkList); <span class="comment">//获取表长</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (posi &lt; <span class="number">1</span> || posi &gt; length + <span class="number">1</span>) <span class="comment">//元素插入的位置不合法</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//元素的合法插入位置为数组已被使用位置的第一个位置到最后一个位置的后一个位置</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> unused_cur; <span class="comment">//数组未被使用位置中第一个位置的数组下标</span></span><br><span class="line"></span><br><span class="line">    unused_cur = <span class="built_in">allot</span>(sLinkList); <span class="comment">//获取数组未被使用位置中第一个位置的数组下标</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//约定：数组的第一个位置（数组下标为0）的游标存储未被使用位置中第一个位置的数组下标</span></span><br><span class="line">    <span class="comment">//约定：当数组位置的游标无直接后继位置时，存储数组下标0</span></span><br><span class="line">    <span class="comment">// allot()从数组的第一个位置（数组下标为0）的游标获取未被使用位置中第一个位置的数组下标</span></span><br><span class="line">    <span class="comment">//若存在数组未被使用位置中第一个位置，值&gt;0，不存在，值==0</span></span><br><span class="line">    <span class="keyword">if</span> (unused_cur != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sLinkList[unused_cur].data = elem; <span class="comment">//赋值数据域</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//插入需要修改数组位置的游标域  类比链表的插入</span></span><br><span class="line">        <span class="type">int</span> move_cur; <span class="comment">//移动游标    当前数组位置的数组下标</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//需要查找当前元素插入位置的前一个位置和后一个位置</span></span><br><span class="line">        <span class="comment">//约定：数组的最后一个位置（数组下标为MAX_SIZE-1）存储已被使用位置中第一个位置的数组下标  类比单链表的头结点</span></span><br><span class="line">        <span class="comment">//从数组的最后一个位置（数组下标为MAX_SIZE-1）按照游标存储的数组下标依次遍历1-posi-1个位置</span></span><br><span class="line">        move_cur = MAX_SIZE - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= posi - <span class="number">1</span>; i++) <span class="comment">//遍历  查找当前元素插入位置的前一个位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            move_cur = sLinkList[move_cur].cur; <span class="comment">//移动移动游标</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历后，move_cur是元素插入位置的前一个位置的数组下标</span></span><br><span class="line"></span><br><span class="line">        sLinkList[unused_cur].cur = sLinkList[move_cur].cur;</span><br><span class="line">        <span class="comment">// 1.链接当前元素插入位置的后一个位置</span></span><br><span class="line">        <span class="comment">//当前元素插入位置的游标存储的是当前元素插入位置的前一个位置的游标存储的数组下标</span></span><br><span class="line">        <span class="comment">//类比s-&gt;next=p-&gt;next;</span></span><br><span class="line"></span><br><span class="line">        sLinkList[move_cur].cur = unused_cur;</span><br><span class="line">        <span class="comment">// 2.链接当前元素插入位置的前一个位置</span></span><br><span class="line">        <span class="comment">//当前元素插入位置的前一个位置的游标存储的是当前元素插入位置的的数组下标</span></span><br><span class="line">        <span class="comment">//类比p-&gt;next=s;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">(SLinkList &amp;sLinkList, <span class="type">int</span> del_cur)</span> <span class="comment">//参数：数组，元素删除的位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//约定：数组的第一个位置（数组下标为0）的游标存储未被使用位置中第一个位置的数组下标</span></span><br><span class="line">    <span class="comment">//思路：头插法</span></span><br><span class="line">    sLinkList[del_cur].cur = sLinkList[<span class="number">0</span>].cur; <span class="comment">//元素删除位置的游标记录数组未使用位置中第一个位置的数组下标</span></span><br><span class="line"></span><br><span class="line">    sLinkList[<span class="number">0</span>].cur = del_cur; <span class="comment">//数组的第一个位置（数组下标为0）的游标记录元素删除位置的数组下标</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="comment">//注意：</span></span><br><span class="line"><span class="comment">//删除只是修改元素删除位置的前一个位置的游标存储的数组下标，并将元素删除位置置为未被使用位置</span></span><br><span class="line"><span class="comment">//是在逻辑上删除，但在物理上元素删除位置仍存储原数据</span></span><br><span class="line"><span class="comment">//参数：数组，元素删除的位置    返回值：操作失败返回false，成功返回true</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">delete_list</span><span class="params">(SLinkList &amp;sLinkList, <span class="type">int</span> posi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> length; <span class="comment">//表长</span></span><br><span class="line"></span><br><span class="line">    length = <span class="built_in">get_length</span>(sLinkList); <span class="comment">//获取表长</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (posi &lt; <span class="number">1</span> || posi &gt; length) <span class="comment">//元素删除的位置不合法</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//元素的合法删除位置为数组已被使用位置的第一个位置到最后一个位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除需要修改数组位置的游标域  类比链表的删除</span></span><br><span class="line">    <span class="type">int</span> move_cur; <span class="comment">//移动游标    当前数组位置的数组下标</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要查找元素删除位置的前一个位置和后一个位置</span></span><br><span class="line">    <span class="comment">//约定：数组的最后一个位置（数组下标为MAX_SIZE-1）存储已被使用位置中第一个位置的数组下标  类比单链表的头结点</span></span><br><span class="line">    <span class="comment">//从数组的最后一个位置（数组下标为MAX_SIZE-1）按照游标存储的数组下标依次遍历1-posi-1个位置</span></span><br><span class="line">    move_cur = MAX_SIZE - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= posi - <span class="number">1</span>; i++) <span class="comment">//遍历  查找元素删除位置的前一个位置</span></span><br><span class="line">    &#123;</span><br><span class="line">        move_cur = sLinkList[move_cur].cur; <span class="comment">//移动移动游标</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历后，move_cur是元素删除位置的前一个位置的数组下标</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> del_cur; <span class="comment">//元素删除位置的数组下标</span></span><br><span class="line"></span><br><span class="line">    del_cur = sLinkList[move_cur].cur;</span><br><span class="line">    <span class="comment">//使用元素删除位置的前一个位置的数组下标定位元素删除位置的前一个位置</span></span><br><span class="line">    <span class="comment">//使用元素删除位置的游标定位元素删除位置的数组下标</span></span><br><span class="line"></span><br><span class="line">    sLinkList[move_cur].cur = sLinkList[del_cur].cur;</span><br><span class="line">    <span class="comment">//链接当前元素删除位置的前一个位置和后一个位置</span></span><br><span class="line">    <span class="comment">//使用元素删除位置的前一个位置的数组下标定位元素删除位置的前一个位置</span></span><br><span class="line">    <span class="comment">//使用元素删除位置的的数组下标定位元素删除位置</span></span><br><span class="line">    <span class="comment">//使用元素删除位置的的游标定位元素删除位置的后一个位置</span></span><br><span class="line">    <span class="comment">//使用元素删除位置的前一个位置的游标记录元素删除位置的后一个位置</span></span><br><span class="line">    <span class="comment">//类比：p-&gt;next=p-&gt;next-&gt;next;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">release</span>(sLinkList, del_cur); <span class="comment">//释放空间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(SLinkList sLinkList)</span> <span class="comment">//参数：数组</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> move_cur; <span class="comment">//移动游标</span></span><br><span class="line"></span><br><span class="line">    move_cur = MAX_SIZE - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) <span class="comment">//遍历</span></span><br><span class="line">    &#123;</span><br><span class="line">        move_cur = sLinkList[move_cur].cur; <span class="comment">//移动移动游标</span></span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; sLinkList[move_cur].data &lt;&lt; endl; <span class="comment">//输出：100，200，300</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sLinkList[move_cur].cur == <span class="number">0</span>) <span class="comment">//移动游标到数组的最后一个位置，输出数据后退出</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>静态链表是为给没有指针的高级语言设计的一种实现单链表的方法</li><li>静态链表的操作在链表的基础上多了一层抽象、不易理解。<strong>作者也极难选择用词，以能够将其含义通俗易懂的表述出来，还望理解</strong></li><li>许多参考资料中往往只有对静态链表定义的代码示例，少有对操作的代码示例。静态链表少有使用，但其设计思想是巧妙的。我们需理解学习，扩展思维的同时也以备不时之需</li><li>作者使用规范的变量命名、提供详细的步骤解析及使用示例，应用C++语言将其整合成模板，以帮助理解记忆。</li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>《大话数据结构》作者：程杰</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单链表的C_C++语言描述实现模板</title>
      <link href="/2022/04/26/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84C_C++%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E5%AE%9E%E7%8E%B0%E6%A8%A1%E6%9D%BF/"/>
      <url>/2022/04/26/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84C_C++%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E5%AE%9E%E7%8E%B0%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>数据结构中单链表的C&#x2F;C++语言描述实现模板，有详细的步骤解析及使用示例。</p><hr><h1 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h1><ul><li><a href="https://github.com/yezhening/Programming-examples">yezhening&#x2F;Programming-examples: 编程实例 (github.com)</a></li><li><a href="https://gitee.com/yezhening/Programming-examples">Programming-examples: 编程实例 (gitee.com)</a></li></ul><hr><h1 id="linkList-cpp"><a href="#linkList-cpp" class="headerlink" title="linkList.cpp"></a>linkList.cpp</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件————————————————————</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型————————————————————</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ELEM_TYPE; <span class="comment">//数据的（数据）类型 依据数据的实际类型定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体</span></span><br><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="comment">//结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span></span><br><span class="line">&#123;</span><br><span class="line">    ELEM_TYPE data;     <span class="comment">//数据</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LNode</span> *next; <span class="comment">//指向直接后继结点的指针</span></span><br><span class="line">&#125; LNode;</span><br><span class="line"><span class="comment">// struct LNode：结构体数据类型的名称</span></span><br><span class="line"><span class="comment">//如创建一个结点的语句：struct LNode node;</span></span><br><span class="line"><span class="comment">//若结构体数据类型内存在指向该结构体的指针数据类型，则必须完整命名结构体数据类型的名称</span></span><br><span class="line"><span class="comment">//如结点结构体LNode内存在指向该结构体的指针数据类型next，则命名语句为：typedef struct LNode而不是typedef struct</span></span><br><span class="line"><span class="comment">// LNode：typedef给结构体数据类型起的别名，可简化语句</span></span><br><span class="line"><span class="comment">//如创建一个结点的语句：LNode node;</span></span><br><span class="line"><span class="comment">//结构体数据类型的名称和别名尽量一致，以方便记忆、使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数声明————————————————————</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_example</span><span class="params">()</span></span>;                                                  <span class="comment">//使用示例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">create_list_head</span><span class="params">(LNode *&amp;head, ELEM_TYPE value[], <span class="type">int</span> count)</span></span>;   <span class="comment">//创建  头插法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">create_list_tail</span><span class="params">(LNode *&amp;head, ELEM_TYPE value[], <span class="type">int</span> count)</span></span>;   <span class="comment">//创建  尾插法</span></span><br><span class="line"><span class="function">LNode *<span class="title">find_node</span><span class="params">(LNode *head, ELEM_TYPE elem)</span></span>;                       <span class="comment">//按值查找</span></span><br><span class="line"><span class="function">LNode *<span class="title">get_node</span><span class="params">(LNode *head, <span class="type">int</span> i)</span></span>;                                 <span class="comment">//按序查找</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert_node</span><span class="params">(LNode *&amp;head, <span class="type">int</span> posi, LNode *node)</span></span>;               <span class="comment">//插入  前插</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert_node_exten</span><span class="params">(LNode *&amp;head, <span class="type">int</span> posi, LNode *node)</span></span>;         <span class="comment">//插入  扩展：前插转后插</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">delele_node</span><span class="params">(LNode *&amp;head, <span class="type">int</span> posi)</span></span>;                            <span class="comment">//删除  前删</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">delele_node_exten</span><span class="params">(LNode *&amp;head, <span class="type">int</span> posi)</span></span>;                      <span class="comment">//删除  前删转后删</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_length</span><span class="params">(LNode *head)</span></span>;                                         <span class="comment">//获取表长</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear_list</span><span class="params">(LNode *&amp;head)</span></span>;                                       <span class="comment">//清空</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_list_increase</span><span class="params">(LNode *head1, LNode *head2, LNode *&amp;head3)</span></span>; <span class="comment">//合并两递增表成递增表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_list_reduce</span><span class="params">(LNode *head1, LNode *head2, LNode *&amp;head3)</span></span>;   <span class="comment">//合并两递增表成递减表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数————————————————————</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">use_example</span>(); <span class="comment">//使用示例</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数定义————————————————————</span></span><br><span class="line"><span class="comment">//使用示例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_example</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LNode</span> *head; <span class="comment">//头指针，指向头结点或第一个结点</span></span><br><span class="line">    <span class="comment">//或LNode *head;</span></span><br><span class="line">    <span class="comment">//一般头指针变量名为链表表名    这里用head见明知意，表示是头指针</span></span><br><span class="line"></span><br><span class="line">    ELEM_TYPE value[<span class="number">3</span>]; <span class="comment">//数据数组</span></span><br><span class="line">    value[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line">    value[<span class="number">1</span>] = <span class="number">200</span>;</span><br><span class="line">    value[<span class="number">2</span>] = <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">create_list_tail</span>(head, value, <span class="number">3</span>); <span class="comment">//创建    尾插法  元素在表中的排列：100，200，300</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//按值查找</span></span><br><span class="line">    LNode *node; <span class="comment">//结点指针</span></span><br><span class="line"></span><br><span class="line">    node = <span class="built_in">find_node</span>(head, <span class="number">100</span>); <span class="comment">//按值查找</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; node-&gt;data &lt;&lt; endl; <span class="comment">//输出：100</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//按序查找</span></span><br><span class="line">    node = <span class="built_in">get_node</span>(head, <span class="number">2</span>); <span class="comment">//按序查找</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; node-&gt;data &lt;&lt; endl; <span class="comment">//输出：200</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入  前插</span></span><br><span class="line">    node = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode)); <span class="comment">//创建新结点   结点指针指向新结点</span></span><br><span class="line">    node-&gt;data = <span class="number">400</span>;                      <span class="comment">//初始化新结点的数据域</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">insert_node</span>(head, <span class="number">3</span>, node); <span class="comment">//插入 前插 元素在表中的排列：100，200，400，300</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入  扩展：前插转后插</span></span><br><span class="line">    node = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode)); <span class="comment">//创建新结点   结点指针指向新结点</span></span><br><span class="line">    node-&gt;data = <span class="number">500</span>;                      <span class="comment">//初始化新结点的数据域</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">insert_node_exten</span>(head, <span class="number">3</span>, node); <span class="comment">//插入    扩展：前插转后插    元素在表中的排列：100，200，500，400，300</span></span><br><span class="line"></span><br><span class="line">    LNode *p;       <span class="comment">//移动结点指针</span></span><br><span class="line">    p = head-&gt;next; <span class="comment">//初始化移动结点指针 指向第一个结点（头结点的下一个结点）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) <span class="comment">//遍历</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; p-&gt;data &lt;&lt; endl; <span class="comment">//输出：100，200，500，400，300</span></span><br><span class="line"></span><br><span class="line">        p = p-&gt;next; <span class="comment">//移动结点指针</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除  前删</span></span><br><span class="line">    <span class="built_in">delele_node</span>(head, <span class="number">3</span>); <span class="comment">//删除  前删  元素在表中的排列：100，200，400，300</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除  前删转后删</span></span><br><span class="line">    <span class="built_in">delele_node_exten</span>(head, <span class="number">3</span>); <span class="comment">//删除  前删转后删  元素在表中的排列：100，200，300</span></span><br><span class="line"></span><br><span class="line">    p = head-&gt;next; <span class="comment">//初始化移动结点指针 指向第一个结点（头结点的下一个结点）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) <span class="comment">//遍历</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; p-&gt;data &lt;&lt; endl; <span class="comment">//输出：100，200，300</span></span><br><span class="line"></span><br><span class="line">        p = p-&gt;next; <span class="comment">//移动结点指针</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取表长</span></span><br><span class="line">    <span class="type">int</span> list_length = <span class="number">0</span>; <span class="comment">//表长</span></span><br><span class="line"></span><br><span class="line">    list_length = <span class="built_in">get_length</span>(head);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; list_length &lt;&lt; endl; <span class="comment">//输出：3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//清空</span></span><br><span class="line">    <span class="built_in">clear_list</span>(head);</span><br><span class="line"></span><br><span class="line">    list_length = <span class="built_in">get_length</span>(head);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; list_length &lt;&lt; endl; <span class="comment">//输出：0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并两递增表成递增表</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LNode</span> *head1; <span class="comment">//递增表1的头指针，指向头结点或第一个结点</span></span><br><span class="line"></span><br><span class="line">    ELEM_TYPE value1[<span class="number">3</span>]; <span class="comment">//数据数组1</span></span><br><span class="line">    value1[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line">    value1[<span class="number">1</span>] = <span class="number">300</span>;</span><br><span class="line">    value1[<span class="number">2</span>] = <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">create_list_tail</span>(head1, value1, <span class="number">3</span>); <span class="comment">//创建    尾插法  元素在表中的排列：100，300，500</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LNode</span> *head2; <span class="comment">//递增表2的头指针，指向头结点或第一个结点</span></span><br><span class="line"></span><br><span class="line">    ELEM_TYPE value2[<span class="number">3</span>]; <span class="comment">//数据数组2</span></span><br><span class="line">    value2[<span class="number">0</span>] = <span class="number">200</span>;</span><br><span class="line">    value2[<span class="number">1</span>] = <span class="number">400</span>;</span><br><span class="line">    value2[<span class="number">2</span>] = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">create_list_tail</span>(head2, value2, <span class="number">3</span>); <span class="comment">//创建    尾插法  元素在表中的排列：200，400，600</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LNode</span> *head3; <span class="comment">//新递增表的头指针，指向头结点或第一个结点</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">merge_list_increase</span>(head1, head2, head3); <span class="comment">//合并两递增表成递增表</span></span><br><span class="line"></span><br><span class="line">    p = head3-&gt;next;  <span class="comment">//移动结点指针    指向新递增表的第一个结点</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) <span class="comment">//遍历</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; p-&gt;data &lt;&lt; endl; <span class="comment">//输出：100，200，300，400，500，600</span></span><br><span class="line"></span><br><span class="line">        p = p-&gt;next; <span class="comment">//移动结点指针</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并两递增表成递减少表</span></span><br><span class="line">    <span class="built_in">create_list_tail</span>(head1, value1, <span class="number">3</span>); <span class="comment">//创建    尾插法  元素在表中的排列：100，300，500</span></span><br><span class="line">    <span class="built_in">create_list_tail</span>(head2, value2, <span class="number">3</span>); <span class="comment">//创建    尾插法  元素在表中的排列：200，400，600</span></span><br><span class="line">    <span class="built_in">clear_list</span>(head3);                  <span class="comment">//清空</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">merge_list_reduce</span>(head1, head2, head3); <span class="comment">//合并两递增表成递减表</span></span><br><span class="line"></span><br><span class="line">    p = head3-&gt;next;  <span class="comment">//移动结点指针    指向新递减表的第一个结点</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) <span class="comment">//遍历</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; p-&gt;data &lt;&lt; endl; <span class="comment">//输出：600，500，400，300，200，100</span></span><br><span class="line"></span><br><span class="line">        p = p-&gt;next; <span class="comment">//移动结点指针</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数定义————————————————————</span></span><br><span class="line"><span class="comment">//创建  头插法</span></span><br><span class="line"><span class="comment">//时间复杂度：O(n)</span></span><br><span class="line"><span class="comment">//注意：参数使用*&amp;，指向指针的引用数据类型</span></span><br><span class="line"><span class="comment">//若只使用*，指针数据类型，在函数体中并未进行解引用调用修改*head的值，使用malloc()修改的是head的值</span></span><br><span class="line"><span class="comment">//所以是值拷贝，函数返回后数据丢失。地址拷贝需要引用数据类型的配合</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">create_list_head</span><span class="params">(LNode *&amp;head, ELEM_TYPE value[], <span class="type">int</span> count)</span> <span class="comment">//参数：头指针，数据数组，数据数量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode)); <span class="comment">//创建头结点，头指针指向头结点</span></span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;                     <span class="comment">//初始化头结点的指针域</span></span><br><span class="line"></span><br><span class="line">    LNode *node; <span class="comment">//新结点指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) <span class="comment">//循环创建链表</span></span><br><span class="line">    &#123;</span><br><span class="line">        node = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode)); <span class="comment">//创建新结点，新结点指针指向新结点</span></span><br><span class="line">        node-&gt;data = value[i];                 <span class="comment">//初始化新结点的数据域</span></span><br><span class="line"></span><br><span class="line">        node-&gt;next = head-&gt;next; <span class="comment">//初始化新结点的指针域</span></span><br><span class="line">        head-&gt;next = node;</span><br><span class="line">        <span class="comment">//插入到链表的头结点和前一新结点之间</span></span><br><span class="line">        <span class="comment">//链表描述：头结点-&gt;当前新结点-&gt;前一新结点-&gt;...-&gt;空</span></span><br><span class="line">        <span class="comment">//若无头结点：head=node;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建  尾插法</span></span><br><span class="line"><span class="comment">//时间复杂度：O(n)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">create_list_tail</span><span class="params">(LNode *&amp;head, ELEM_TYPE value[], <span class="type">int</span> count)</span> <span class="comment">//参数：头指针，数据数组，数据数量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode)); <span class="comment">//创建头结点，头指针指向头结点</span></span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;                     <span class="comment">//初始化头结点的指针域</span></span><br><span class="line"></span><br><span class="line">    LNode *tail; <span class="comment">//尾指针，尾指针始终指向最后一个结点</span></span><br><span class="line">    tail = head; <span class="comment">//初始化尾指针  指向最后一个结点（头结点）</span></span><br><span class="line"></span><br><span class="line">    LNode *node; <span class="comment">//新结点指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) <span class="comment">//循环创建链表</span></span><br><span class="line">    &#123;</span><br><span class="line">        node = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode)); <span class="comment">//创建新结点，新结点指针指向新结点</span></span><br><span class="line">        node-&gt;data = value[i];                 <span class="comment">//初始化新结点的数据域</span></span><br><span class="line"></span><br><span class="line">        tail-&gt;next = node; <span class="comment">//插入到链表的头结点和前一新结点之间</span></span><br><span class="line">        tail = tail-&gt;next; <span class="comment">//移动尾指针</span></span><br><span class="line">        <span class="comment">//或者tail=node;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tail-&gt;next = <span class="literal">NULL</span>; <span class="comment">//尾指针指向空   创建完成</span></span><br><span class="line">    <span class="comment">//链表描述：头结点-&gt;...-&gt;前一新结点-&gt;当前新结点-&gt;空</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按值查找</span></span><br><span class="line"><span class="comment">//时间复杂度：O(n)</span></span><br><span class="line"><span class="function">LNode *<span class="title">find_node</span><span class="params">(LNode *head, ELEM_TYPE elem)</span> <span class="comment">//参数：头指针，元素  返回值：结点指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LNode *p;       <span class="comment">//移动结点指针</span></span><br><span class="line">    p = head-&gt;next; <span class="comment">//初始化移动结点指针 指向第一个结点（头结点的下一个结点）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) <span class="comment">//遍历</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;data == elem) <span class="comment">//匹配</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">//退出查找</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p = p-&gt;next; <span class="comment">//若不匹配，移动结点指针</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p; <span class="comment">//若找到返回结点指针，否则返回空指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按序查找</span></span><br><span class="line"><span class="comment">//时间复杂度：O(n)</span></span><br><span class="line"><span class="function">LNode *<span class="title">get_node</span><span class="params">(LNode *head, <span class="type">int</span> i)</span> <span class="comment">//参数：头指针，元素查找的位置   返回值：结点指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LNode *p;       <span class="comment">//移动结点指针</span></span><br><span class="line">    p = head-&gt;next; <span class="comment">//初始化移动结点指针 指向第一个结点（头结点的下一个结点）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span>) <span class="comment">//不存在负数的位置</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">//返回空指针</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="comment">//第0个位置是头结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> head; <span class="comment">//返回头指针</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++) <span class="comment">//遍历</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">NULL</span>) <span class="comment">//不匹配</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;next; <span class="comment">//移动结点指针</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//匹配</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">//退出查找</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p; <span class="comment">//若找到返回结点指针，否则返回空指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入  前插</span></span><br><span class="line"><span class="comment">//时间复杂度：O(n)</span></span><br><span class="line"><span class="comment">//因为需遍历找到元素插入位置之前的结点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert_node</span><span class="params">(LNode *&amp;head, <span class="type">int</span> posi, LNode *node)</span> <span class="comment">//参数：头指针，元素插入的位置，结点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LNode *p;                     <span class="comment">//移动结点指针</span></span><br><span class="line">    p = <span class="built_in">get_node</span>(head, posi - <span class="number">1</span>); <span class="comment">//初始化移动结点指针 指向第posi-1个位置的结点</span></span><br><span class="line"></span><br><span class="line">    node-&gt;next = p-&gt;next; <span class="comment">//插入 在第posi-1个位置的结点之后，占据第posi个位置，在原第posi个位置的结点之前</span></span><br><span class="line">    p-&gt;next = node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入  扩展：前插转后插</span></span><br><span class="line"><span class="comment">//时间复杂度：O(1)</span></span><br><span class="line"><span class="comment">//直接在元素插入位置之后的结点插入，再交换结点数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert_node_exten</span><span class="params">(LNode *&amp;head, <span class="type">int</span> posi, LNode *node)</span> <span class="comment">//参数：头指针，元素插入的位置，结点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LNode *p;                 <span class="comment">//移动结点指针</span></span><br><span class="line">    p = <span class="built_in">get_node</span>(head, posi); <span class="comment">//初始化移动结点指针 指向第posi个位置的结点</span></span><br><span class="line"></span><br><span class="line">    node-&gt;next = p-&gt;next; <span class="comment">//插入 在第posi个位置的结点之后</span></span><br><span class="line">    p-&gt;next = node;</span><br><span class="line"></span><br><span class="line">    ELEM_TYPE temp; <span class="comment">//临时数据</span></span><br><span class="line"></span><br><span class="line">    temp = p-&gt;data; <span class="comment">//交换第posi个位置的结点和新结点的数据</span></span><br><span class="line">    p-&gt;data = node-&gt;data;</span><br><span class="line">    node-&gt;data = temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除  前删</span></span><br><span class="line"><span class="comment">//时间复杂度：O(n)</span></span><br><span class="line"><span class="comment">//因为需遍历找到元素删除位置之前的结点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">delele_node</span><span class="params">(LNode *&amp;head, <span class="type">int</span> posi)</span> <span class="comment">//参数：头指针，元素删除的位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LNode *p;                     <span class="comment">//移动结点指针</span></span><br><span class="line">    p = <span class="built_in">get_node</span>(head, posi - <span class="number">1</span>); <span class="comment">//初始化移动结点指针 指向第posi-1个位置的结点</span></span><br><span class="line"></span><br><span class="line">    LNode *q;    <span class="comment">//被删结点指针</span></span><br><span class="line">    q = p-&gt;next; <span class="comment">//初始化被删结点指针 指向第posi个位置的结点</span></span><br><span class="line"></span><br><span class="line">    p-&gt;next = q-&gt;next; <span class="comment">//修改指针指向   第posi-1个位置的结点的指针指向第posi+1个位置的结点</span></span><br><span class="line">    <span class="comment">//或者p-&gt;next=p-&gt;next-&gt;next;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(q); <span class="comment">//删除被删结点指针指向的结点，释放内存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除  前删转后删</span></span><br><span class="line"><span class="comment">//时间复杂度：O(1)</span></span><br><span class="line"><span class="comment">//交换结点数据，直接删除元素删除位置之后的结点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">delele_node_exten</span><span class="params">(LNode *&amp;head, <span class="type">int</span> posi)</span> <span class="comment">//参数：头指针，元素删除的位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LNode *p;                 <span class="comment">//移动结点指针</span></span><br><span class="line">    p = <span class="built_in">get_node</span>(head, posi); <span class="comment">//初始化移动结点指针 指向第posi个位置的结点</span></span><br><span class="line"></span><br><span class="line">    LNode *q;    <span class="comment">//被删结点指针</span></span><br><span class="line">    q = p-&gt;next; <span class="comment">//初始化被删结点指针 指向第posi+1个位置的结点</span></span><br><span class="line"></span><br><span class="line">    p-&gt;data = q-&gt;data; <span class="comment">//交换第posi个位置和第posi+1个位置结点的数据 此时需删除的是第posi+1个位置的结点</span></span><br><span class="line">    <span class="comment">//或者p-&gt;data=p-&gt;next-&gt;data</span></span><br><span class="line">    p-&gt;next = q-&gt;next; <span class="comment">//修改指针指向   第posi个位置的结点的指针指向第posi+2个位置的结点</span></span><br><span class="line">    <span class="comment">//或者p-&gt;next=p-&gt;next-&gt;next;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(q); <span class="comment">//删除被删结点指针指向的结点，释放内存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取表长</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_length</span><span class="params">(LNode *head)</span> <span class="comment">//参数：头指针  返回值：表长</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LNode *p;       <span class="comment">//移动结点指针</span></span><br><span class="line">    p = head-&gt;next; <span class="comment">//初始化移动结点指针 指向第一个结点（头结点的下一个结点）</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> length = <span class="number">0</span>; <span class="comment">//表长</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) <span class="comment">//遍历 有结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        length++;    <span class="comment">//表长递增</span></span><br><span class="line">        p = p-&gt;next; <span class="comment">//移动指针</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> length; <span class="comment">//返回表长</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear_list</span><span class="params">(LNode *&amp;head)</span> <span class="comment">//参数：头指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LNode *p;       <span class="comment">//被删结点指针</span></span><br><span class="line">    p = head-&gt;next; <span class="comment">//初始化被删结点指针 指向第一个结点（头结点的下一个结点）</span></span><br><span class="line"></span><br><span class="line">    LNode *q; <span class="comment">//记录结点指针 指向被删结点的下一个结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) <span class="comment">//遍历    有结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        q = p-&gt;next; <span class="comment">//记录被删结点的下一个结点</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(p); <span class="comment">//删除被删结点指针指向的结点，释放内存</span></span><br><span class="line"></span><br><span class="line">        p = q; <span class="comment">//移动指针    指向下一个被删结点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>; <span class="comment">//头结点的指针域置空 当退出遍历时已无数据结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//合并两递增表成递增表</span></span><br><span class="line"><span class="comment">//思路：遍历两递增表，比较结点的数值域数据，使用尾插法创建新递增表</span></span><br><span class="line"><span class="comment">//参数：递增表1的头指针，递增表2的头指针，新递增表的头指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_list_increase</span><span class="params">(LNode *head1, LNode *head2, LNode *&amp;head3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LNode *p;        <span class="comment">//移动结点指针1</span></span><br><span class="line">    p = head1-&gt;next; <span class="comment">//初始化移动结点指针1 指向递增表1的第一个结点（头结点的下一个结点）</span></span><br><span class="line"></span><br><span class="line">    LNode *q;        <span class="comment">//移动结点指针2</span></span><br><span class="line">    q = head2-&gt;next; <span class="comment">//初始化移动结点指针2 指向递增表2的第一个结点（头结点的下一个结点）</span></span><br><span class="line">    <span class="built_in">free</span>(head2);     <span class="comment">//释放递增表2的头结点  因为已用移动结点指针2记录递增表2的第一个结点，数据不会丢失</span></span><br><span class="line"></span><br><span class="line">    head3 = head1;      <span class="comment">//初始化新递增表的头指针 指向递增表1的头结点，用递增表1的头结点作为新递增表的头结点</span></span><br><span class="line">    head3-&gt;next = <span class="literal">NULL</span>; <span class="comment">//初始化新递增表头结点的指针域，置空  因为已用移动结点指针1记录递增表1的第一个结点，数据不会丢失</span></span><br><span class="line"></span><br><span class="line">    LNode *tail;  <span class="comment">//新递增表的尾指针    始终指向新递增表的终端结点</span></span><br><span class="line">    tail = head3; <span class="comment">//初始化新递增表的尾指针  初始时新递增表为空，尾指针指向头结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((p != <span class="literal">NULL</span>) &amp;&amp; (q != <span class="literal">NULL</span>)) <span class="comment">//遍历两递增表</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;data &lt;= q-&gt;data) <span class="comment">//比较结点的数值域数据</span></span><br><span class="line">        &#123;</span><br><span class="line">            tail-&gt;next = p; <span class="comment">//将数据域数值小的结点插入新递增表表尾</span></span><br><span class="line"></span><br><span class="line">            p = p-&gt;next;       <span class="comment">//递增表1的当前结点已插入新递增表，更新移动结点指针1</span></span><br><span class="line">            tail = tail-&gt;next; <span class="comment">//更新新递增表的尾指针  始终指向新递增表的终端结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//同理</span></span><br><span class="line">        &#123;</span><br><span class="line">            tail-&gt;next = q;</span><br><span class="line"></span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//可以没有，因为最后还要将未插入的结点插入新递增表表尾，未插入结点的终端结点指针域为空</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) <span class="comment">//若递增表2插入完成，递增表1还有未插入结点，则将剩余结点插入新递增表尾部</span></span><br><span class="line">    &#123;</span><br><span class="line">        tail-&gt;next = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (q != <span class="literal">NULL</span>) <span class="comment">//若递增表1合并完成，递增表2还有未插入结点，则将剩余结点插入新递增表尾部</span></span><br><span class="line">    &#123;</span><br><span class="line">        tail-&gt;next = q;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//合并两递增表成递减表</span></span><br><span class="line"><span class="comment">//思路：遍历两递增表，比较结点的数值域数据，使用头插法创建新递减表</span></span><br><span class="line"><span class="comment">//参数：递增表1的头指针，递增表2的头指针，新递增表的头指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_list_reduce</span><span class="params">(LNode *head1, LNode *head2, LNode *&amp;head3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LNode *p;        <span class="comment">//移动结点指针1</span></span><br><span class="line">    p = head1-&gt;next; <span class="comment">//初始化移动结点指针1 指向递增表1的第一个结点（头结点的下一个结点）</span></span><br><span class="line"></span><br><span class="line">    LNode *q;        <span class="comment">//移动结点指针2</span></span><br><span class="line">    q = head2-&gt;next; <span class="comment">//初始化移动结点指针2 指向递增表2的第一个结点（头结点的下一个结点）</span></span><br><span class="line">    <span class="built_in">free</span>(head2);     <span class="comment">//释放递增表2的头结点  因为已用移动结点指针2记录递增表2的第一个结点，数据不会丢失</span></span><br><span class="line"></span><br><span class="line">    head3 = head1;      <span class="comment">//初始化新递减表的头指针 指向递增表1的头结点，用递增表1的头结点作为新递减表的头结点</span></span><br><span class="line">    head3-&gt;next = <span class="literal">NULL</span>; <span class="comment">//初始化新递减表头结点的指针域  因为已用移动结点指针1记录递增表1的第一个结点，数据不会丢失</span></span><br><span class="line"></span><br><span class="line">    LNode *temp; <span class="comment">//临时结点指针 指向当前要插入新递减表表头的结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((p != <span class="literal">NULL</span>) &amp;&amp; (q != <span class="literal">NULL</span>)) <span class="comment">//遍历两递增表</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;data &lt;= q-&gt;data) <span class="comment">//比较结点的数值域数据</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp = p;    <span class="comment">//将临时结点指针指向数据域数值小的结点</span></span><br><span class="line">            p = p-&gt;next; <span class="comment">//递增表1的当前结点已被临时结点指针记录，更新移动结点指针1</span></span><br><span class="line"></span><br><span class="line">            temp-&gt;next = head3-&gt;next; <span class="comment">//将临时结点指针指向头结点的下一个结点</span></span><br><span class="line">            head3-&gt;next = temp;       <span class="comment">//将头指针指向当前要插入新递减表表头的结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//同理</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp = q;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line"></span><br><span class="line">            temp-&gt;next = head3-&gt;next;</span><br><span class="line">            head3-&gt;next = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) <span class="comment">//若递增表2插入完成，递增表1还有未插入结点，则取剩余结点一个个插入新递减表表头</span></span><br><span class="line">    &#123;</span><br><span class="line">        temp = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line"></span><br><span class="line">        temp-&gt;next = head3-&gt;next;</span><br><span class="line">        head3-&gt;next = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (q != <span class="literal">NULL</span>) <span class="comment">//若递增表1插入完成，递增表2还有未插入结点，则取剩余结点一个个插入新递减表表头</span></span><br><span class="line">    &#123;</span><br><span class="line">        temp = q;</span><br><span class="line">        q = q-&gt;next;</span><br><span class="line"></span><br><span class="line">        temp-&gt;next = head3-&gt;next;</span><br><span class="line">        head3-&gt;next = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>不同参考资料中，单链表的描述实现各不相同，但基本思想是一致的。作者使用规范的变量命名、提供详细的步骤解析及使用示例，应用C&#x2F;C++语言将其整合成模板，以帮助理解记忆。</p><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《2023版数据结构高分笔记》主编：率辉</li><li>《2023年计算机组成原理考研复习指导》组编：王道论坛</li><li>《大话数据结构》作者：程杰</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>顺序表的C_C++语言描述实现模板</title>
      <link href="/2022/04/23/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84C_C++%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E5%AE%9E%E7%8E%B0%E6%A8%A1%E6%9D%BF/"/>
      <url>/2022/04/23/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84C_C++%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E5%AE%9E%E7%8E%B0%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>数据结构中顺序表的C&#x2F;C++语言描述实现模板，有详细的步骤解析及使用示例。</p><hr><h1 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h1><ul><li><a href="https://github.com/yezhening/Programming-examples">yezhening&#x2F;Programming-examples: 编程实例 (github.com)</a></li><li><a href="https://gitee.com/yezhening/Programming-examples">Programming-examples: 编程实例 (gitee.com)</a></li></ul><hr><h1 id="sqList-cpp"><a href="#sqList-cpp" class="headerlink" title="sqList.cpp"></a>sqList.cpp</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件————————————————————</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//宏————————————————————</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 100 <span class="comment">//最大大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型————————————————————</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ELEM_TYPE; <span class="comment">//数据的（数据）类型 依据数据的实际类型定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体</span></span><br><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    ELEM_TYPE data[MAX_SIZE]; <span class="comment">//数据</span></span><br><span class="line">    <span class="type">int</span> length;               <span class="comment">//当前长度</span></span><br><span class="line">    <span class="comment">//最大大小&gt;=当前长度</span></span><br><span class="line">&#125; SqList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数声明————————————————————</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_example</span><span class="params">()</span></span>;                                          <span class="comment">//使用示例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_list</span><span class="params">(SqList &amp;sqList)</span></span>;                              <span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">insert_elem</span><span class="params">(SqList &amp;sqList, <span class="type">int</span> posi, ELEM_TYPE elem)</span></span>;  <span class="comment">//插入</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">delete_elem</span><span class="params">(SqList &amp;sqList, <span class="type">int</span> posi, ELEM_TYPE &amp;elem)</span></span>; <span class="comment">//删除</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_elem</span><span class="params">(SqList sqList, ELEM_TYPE elem)</span></span>;                <span class="comment">//按值查找</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">get_elem</span><span class="params">(SqList sqList, <span class="type">int</span> posi, ELEM_TYPE &amp;elem)</span></span>;     <span class="comment">//按序查找</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数————————————————————</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">use_example</span>(); <span class="comment">//使用示例</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数定义————————————————————</span></span><br><span class="line"><span class="comment">//使用示例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_example</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建</span></span><br><span class="line">    SqList sqList;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">init_list</span>(sqList);</span><br><span class="line">    cout &lt;&lt; sqList.length &lt;&lt; endl; <span class="comment">//输出：0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入</span></span><br><span class="line">    ELEM_TYPE ins_elem1 = <span class="number">100</span>;</span><br><span class="line">    ELEM_TYPE ins_elem3 = <span class="number">300</span>;</span><br><span class="line">    ELEM_TYPE ins_elem2 = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">insert_elem</span>(sqList, <span class="number">1</span>, ins_elem1);</span><br><span class="line">    <span class="built_in">insert_elem</span>(sqList, <span class="number">2</span>, ins_elem3);</span><br><span class="line">    <span class="built_in">insert_elem</span>(sqList, <span class="number">2</span>, ins_elem2); <span class="comment">//元素在表中的排列：100，200，300</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除</span></span><br><span class="line">    ELEM_TYPE del_elem = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">delete_elem</span>(sqList, <span class="number">2</span>, del_elem); <span class="comment">//元素在表中的排列：100，300</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; del_elem &lt;&lt; endl; <span class="comment">//输出：200</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//按值查找</span></span><br><span class="line">    <span class="type">int</span> fin_posi = <span class="number">0</span>;</span><br><span class="line">    ELEM_TYPE fin_elem = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    fin_posi = <span class="built_in">find_elem</span>(sqList, fin_elem);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; fin_posi &lt;&lt; endl; <span class="comment">//输出：1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取元素</span></span><br><span class="line">    ELEM_TYPE ge_elem = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">get_elem</span>(sqList, <span class="number">2</span>, ge_elem);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ge_elem &lt;&lt; endl; <span class="comment">//输出：300</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_list</span><span class="params">(SqList &amp;sqList)</span> <span class="comment">//参数：表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sqList.length = <span class="number">0</span>; <span class="comment">//当前长度为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：元素的位置=数组下标+1</span></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="comment">//时间复杂度：O(n)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">insert_elem</span><span class="params">(SqList &amp;sqList, <span class="type">int</span> posi, ELEM_TYPE elem)</span> <span class="comment">// 参数：表，元素的插入位置，元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (posi &lt; <span class="number">1</span> || posi &gt; sqList.length + <span class="number">1</span>) <span class="comment">//元素的插入位置不合法</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//元素的合法插入位置为表的第一个位置到最后一个位置的后一个位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sqList.length == MAX_SIZE) <span class="comment">//表满</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判决条件可以是：&gt;=</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = sqList.length; i &gt;= posi; i--) <span class="comment">//元素移动位置</span></span><br><span class="line">    &#123;</span><br><span class="line">        sqList.data[i] = sqList.data[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//临界条件不容易理解</span></span><br><span class="line">    <span class="comment">//需移动length-posi+1个元素</span></span><br><span class="line"></span><br><span class="line">    sqList.data[posi - <span class="number">1</span>] = elem; <span class="comment">//插入</span></span><br><span class="line">    sqList.length++;              <span class="comment">//表长增加</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="comment">//时间复杂度：O(n)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">delete_elem</span><span class="params">(SqList &amp;sqList, <span class="type">int</span> posi, ELEM_TYPE &amp;elem)</span> <span class="comment">// 参数：表，元素的删除位置，元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (posi &lt; <span class="number">1</span> || posi &gt; sqList.length) <span class="comment">//元素的删除位置不合法</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//元素的合法删除位置为表的第一个位置到最后一个位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sqList.length == <span class="number">0</span>) <span class="comment">//表空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    elem = sqList.data[posi - <span class="number">1</span>]; <span class="comment">//获取删除的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = posi; i &lt; sqList.length; i++) <span class="comment">//元素移动位置</span></span><br><span class="line">    &#123;</span><br><span class="line">        sqList.data[i - <span class="number">1</span>] = sqList.data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//临界条件不容易理解</span></span><br><span class="line">    <span class="comment">//需移动length-posi个元素</span></span><br><span class="line"></span><br><span class="line">    sqList.length--; <span class="comment">//表长减少</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按值查找</span></span><br><span class="line"><span class="comment">//时间复杂度：O(n)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_elem</span><span class="params">(SqList sqList, ELEM_TYPE elem)</span> <span class="comment">//参数：表，元素   返回值：元素在表中的位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sqList.length; i++) <span class="comment">//遍历表</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (sqList.data[i] == elem) <span class="comment">//查找到</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按序查找</span></span><br><span class="line"><span class="comment">//时间复杂度：O(1)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">get_elem</span><span class="params">(SqList sqList, <span class="type">int</span> posi, ELEM_TYPE &amp;elem)</span> <span class="comment">// 参数：表，元素的获取位置，元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (posi &lt; <span class="number">1</span> || posi &gt; sqList.length) <span class="comment">//元素的查找位置不合法</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//元素的合法查找位置为表的第一个位置到最后一个位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sqList.length == <span class="number">0</span>) <span class="comment">//表空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    elem = sqList.data[posi - <span class="number">1</span>]; <span class="comment">//获取元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="不同的定义形式"><a href="#不同的定义形式" class="headerlink" title="不同的定义形式"></a>不同的定义形式</h1><p>数组数据类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ELEM_TYPE; <span class="comment">//数据的（数据）类型 依据数据的实际类型定义</span></span><br><span class="line"></span><br><span class="line">ElEM_TYPE sqList[MAX_SIZE]; <span class="comment">//数据</span></span><br><span class="line"><span class="type">int</span> length; <span class="comment">//当前长度</span></span><br></pre></td></tr></table></figure><p>静态结构体数据类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 100 <span class="comment">//最大大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ELEM_TYPE; <span class="comment">//数据的（数据）类型 依据数据的实际类型定义 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    ELEM_TYPE data[MAX_SIZE]; <span class="comment">//数据</span></span><br><span class="line">    <span class="type">int</span> length;               <span class="comment">//当前长度</span></span><br><span class="line">    <span class="comment">//最大大小&gt;=当前长度</span></span><br><span class="line">&#125; SqList;</span><br></pre></td></tr></table></figure><p>动态结构体数据类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 100 <span class="comment">//最大大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    ELEM_TYPE *data; <span class="comment">//数据</span></span><br><span class="line">    <span class="type">int</span> length; <span class="comment">//当前长度</span></span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化数据</span></span><br><span class="line">L.data=(ELEM_TYPE*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ELEM_TYPE)*MAX_SIZE); </span><br></pre></td></tr></table></figure><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>不同参考资料中，顺序表的描述实现各不相同，但基本思想是一致的。作者使用规范的变量命名、提供详细的步骤解析及使用示例，应用C&#x2F;C++语言将其整合成模板，以帮助理解记忆。</p><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li><strong>如果文章对你有帮助，请点个赞或加个粉丝吧，你的支持就是作者的动力~</strong></li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《2023版数据结构高分笔记》主编：率辉</li><li>《2023年计算机组成原理考研复习指导》组编：王道论坛</li><li>《大话数据结构》作者：程杰</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“计算机系统概述”学习笔记</title>
      <link href="/2022/04/21/%E2%80%9C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0%E2%80%9D%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/04/21/%E2%80%9C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0%E2%80%9D%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>计算机组成原理的知识抽象、晦涩、不易理解并记忆，在此对“计算机系统概述”一章中字长和字、翻译和编译等部分相似概念<strong>进行比较区分，并总结记忆方法</strong>。</p><hr><h1 id="字、机器字长-字长、存储字长、指令字长和数据字长"><a href="#字、机器字长-字长、存储字长、指令字长和数据字长" class="headerlink" title="字、机器字长&#x2F;字长、存储字长、指令字长和数据字长"></a>字、机器字长&#x2F;字长、存储字长、指令字长和数据字长</h1><p>字：</p><ul><li><strong>表示</strong>被处理信息的单位</li><li>度量数据类型的宽度</li><li>存储字：一个存储单元中二进制代码的组合</li><li>指令字：一个指令中二进制代码的组合</li><li>示例：某机器定义一个字为<strong>16位</strong></li></ul><p>机器字长&#x2F;字长：</p><ul><li>计算机进行一次<strong>整数</strong>运算所能处理的二进制数据的位数</li><li>中央处理器（CPU）用于整数运算的<strong>数据通路</strong>的宽度</li><li>机器字长&#x3D;中央处理器CPU内部用于整数运算的运算器位数和通用寄存器（GPR）宽度</li><li>反映计算机<strong>处理</strong>信息的能力。字长越长，数据的表示范围越大，计算机的计算精度越高</li><li>示例：某<strong>64位</strong>机器。这里的“64位”指的是机器字长</li></ul><blockquote><p>数据通路：数据流经的路径和路径上的部件，主要是进行数据存储、传输和运算的部件。如算术逻辑单元（ALU）和通用寄存器，<strong>浮点</strong>寄存器则不是</p></blockquote><p>存储字长：</p><ul><li>一个存储单元中所存储二进制代码的位数</li></ul><p>指令字长：</p><ul><li>一个指令字所包含二进制代码的位数</li></ul><p>数据字长：</p><ul><li>数据总线一次能并行传送信息的位数</li><li>可能与数据寄存器（MDR）位数不同</li></ul><blockquote><p>区别：字是<strong>表示</strong>数据的单位，机器字长是计算机&#x2F;中央处理器（CPU）一次能<strong>处理</strong>的数据的单位，其他字长是相应字所表示数据的二进制代码的位数</p></blockquote><hr><h1 id="存储器组成"><a href="#存储器组成" class="headerlink" title="存储器组成"></a>存储器组成</h1><p>组件由大到小（大包含小）依次为：</p><ul><li>计算机系统&#x3D;计算机硬件系统+计算机软件系统</li><li>计算机硬件系统&#x3D;存储器+控制器+运算器+输入设备+输出设备</li><li>存储器&#x3D;主存储器（内存储器）+辅助存储器（外存储器）</li><li>主存储器&#x3D;地址寄存器（MAR）+存储体+数据寄存器（MDR）+时序控制逻辑</li><li>存储体&#x3D;若干存储单元</li><li>存储单元&#x3D;若干存储元件</li><li>每个存储元件存储一位二进制代码</li></ul><blockquote><p>注意：现代计算机的地址寄存器（MAR）和数据寄存器（MDR）在中央处理器（CPU）中</p></blockquote><hr><h1 id="运算器组成"><a href="#运算器组成" class="headerlink" title="运算器组成"></a>运算器组成</h1><ul><li>算术逻辑单元（ALU）</li><li>累加器（ACC）</li><li>乘商寄存器（MQ）</li><li>操作数寄存器（X）</li><li>变址寄存器（IX）</li><li>基址寄存器（BR）</li><li>程序状态寄存器（PSW）（标志寄存器）</li><li>…</li></ul><blockquote><p>其中， 算术逻辑单元（ALU）、累加器（ACC）、乘商寄存器（MQ）和操作数寄存器（X）是必须具备的</p></blockquote><hr><h1 id="控制器组成"><a href="#控制器组成" class="headerlink" title="控制器组成"></a>控制器组成</h1><ul><li>程序计数器（PC）</li><li>指令寄存器（IR）</li><li>控制单元（CU）</li></ul><hr><h1 id="计算机系统的层次结构"><a href="#计算机系统的层次结构" class="headerlink" title="计算机系统的层次结构"></a>计算机系统的层次结构</h1><ul><li>第一级：微程序机器层（微指令系统）：硬件执行微指令</li><li>第二级：传统机器语言层（用机器语言的机器）：微程序解释机器指令</li><li>第三级：操作系统层（操作系统机器）：机器语言解释操作系统</li><li>第四级：汇编语言层（汇编语言机器）：汇编程序翻译成机器语言程序</li><li>第五级：高级语言层（高级语言机器）：编译程序翻译成汇编语言程序</li><li>第六级：应用程序层</li><li>…</li></ul><blockquote><p>注意： 计算机系统的层次结构目前尚无统一标准</p></blockquote><hr><h1 id="指令执行过程"><a href="#指令执行过程" class="headerlink" title="指令执行过程"></a>指令执行过程</h1><ol start="0"><li>程序执行前，先将程序第一条指令的地址存到程序计数器（PC）中</li><li>从程序计数器（PC）中取指令</li><li>对指令译码；计算下条指令地址</li><li>根据指令，取操作数并执行</li><li>将操作结果存到存储器中</li></ol><hr><h1 id="指令详细数据流向"><a href="#指令详细数据流向" class="headerlink" title="指令详细数据流向"></a>指令详细数据流向</h1><p>1.从程序计数器（PC）中取指令：PC-&gt;MAR-&gt;M-&gt;MDR-&gt;IR</p><ul><li>从程序计数器（PC）中取<strong>指令地址</strong></li></ul><blockquote><p>注意：程序计数器（PC）中存放的是将执行指令的地址，实际指令应从主存储器获取。概括指令执行过程时常用“从程序计数器（PC）中取<strong>指令</strong>”简化过程</p></blockquote><ul><li>将程序计数器（PC）中的指令地址传输给地址寄存器（MAR）</li><li>将地址寄存器（MAR）中的指令地址传输给地址线——准备1</li><li>控制器将读信号传输给读&#x2F;写信号线——准备2</li><li>主存储器根据地址线上的指令地址和读信号，从指定存储单元取<strong>指令</strong></li><li>主存储器将指令传输到数据线</li><li>数据线将指令传输到数据寄存器（MDR）</li><li>数据寄存器（MDR）将指令传输到指令寄存器（IR）</li></ul><p>2.对指令译码；计算下条指令地址：IR-&gt;CU；(PC)+1-&gt;PC</p><ul><li>控制器根据指令寄存器（IR）中指令的<strong>操作码</strong>，生成相应的控制信号，传输到不同的执行部件</li><li>程序计数器（PC）计算下条指令地址</li></ul><p>3.根据指令，取操作数并执行：IR-&gt;MAR-&gt;M-&gt;MDR-&gt;ACC</p><ul><li>从指令寄存器（IR）中取指令的<strong>地址码</strong></li><li>将指令寄存器（IR）中指令的地址码传输到地址寄存器（MAR）</li><li>将地址寄存器（MAR）中指令的地址码传输到地址线——准备1</li><li>控制器将读信号传输给读&#x2F;写信号线——准备2</li><li>主存储器根据地址线上的指令地址和读信号，从指定存储单元取<strong>操作数</strong></li><li>主存储器将操作数传输到数据线</li><li>数据线将操作数传输到数据寄存器（MDR）</li><li>数据寄存器（MDR）将操作数传输到相应的运算寄存器中，如累加器（ACC）</li></ul><p>4.将操作结果存到存储器中</p><blockquote><p>注意观察1、3步骤，PC-&gt;MAR-&gt;地址线-&gt;M-&gt;数据线-&gt;MDR-&gt;取地址或操作数-&gt;IR或相应的运算寄存器，这一过程是基本的</p></blockquote><hr><h1 id="源程序翻译成可执行文件的过程"><a href="#源程序翻译成可执行文件的过程" class="headerlink" title="源程序翻译成可执行文件的过程"></a>源程序翻译成可执行文件的过程</h1><ul><li>预处理：文件名.c -&gt; 文件名.i。结果是源程序，文本文件</li><li>编译：文件名.i -&gt; 文件名.s。结果是汇编程序，文本文件</li><li>汇编：文件名.s -&gt; 文件名.o。结果是可重定位目标程序，二进制文件</li><li>连接：文件名.o -&gt; 文件名。结果是可执行程序，二进制文件</li></ul><hr><h1 id="翻译、编译和解释和汇编程序"><a href="#翻译、编译和解释和汇编程序" class="headerlink" title="翻译、编译和解释和汇编程序"></a>翻译、编译和解释和汇编程序</h1><p>翻译程序有两种：</p><ul><li>编译程序</li><li>解释程序</li></ul><p>编译程序：</p><ul><li>作用阶段：源程序翻译成<strong>可执行程序</strong>前——运行前</li><li>将高级语言源程序一次全部翻译成可执行程序</li><li>只要源程序未改动，就无须再一次翻译，可直接运行可执行程序</li></ul><blockquote><p>注意：这里“编译程序”的“编译”概念是对“源程序翻译成可执行文件的过程”的概括</p></blockquote><p>解释程序：</p><ul><li>作用阶段： 源程序边翻译边运行——运行时</li><li>将高级语言源程序的一条语句翻译成对应的机器语言，并立即执行</li><li>不生成可执行程序</li></ul><p>汇编程序：</p><ul><li>将汇编语言源程序翻译成机器语言程序</li></ul><blockquote><p>区分：</p><ul><li>编译程序：高级语言程序-&gt;机器语言程序</li><li>汇编程序：汇编语言程序-&gt;机器语言程序</li></ul></blockquote><hr><h1 id="地址寄存器（MAR）和数据寄存器（MDR）的位数"><a href="#地址寄存器（MAR）和数据寄存器（MDR）的位数" class="headerlink" title="地址寄存器（MAR）和数据寄存器（MDR）的位数"></a>地址寄存器（MAR）和数据寄存器（MDR）的位数</h1><p>地址寄存器（MAR）的位数：</p><ul><li>主存储器的存储体中存储单元的个数</li><li>程序计数器（PC）的长度</li><li>指令的地址码长度（指令&#x3D;地址码+操作码）</li></ul><blockquote><p>记忆：<strong>地址</strong>寄存器（MAR）存放指令的地址，用于寻址。存储单元、程序计数器（PC）和指令的地址码都与地址相关</p></blockquote><p>数据寄存器（MDR）的位数：</p><ul><li>存储字长</li><li>存储在一个存储单元中的二进制代码位数</li></ul><blockquote><p>记忆：<strong>数据</strong>寄存器（MDR）用于暂存数据。存储字长与数据相关</p></blockquote><h1 id="中央处理器（CPU）的时间性能指标"><a href="#中央处理器（CPU）的时间性能指标" class="headerlink" title="中央处理器（CPU）的时间性能指标"></a>中央处理器（CPU）的时间性能指标</h1><p> 中央处理器（CPU）时钟周期&#x2F;<strong>时钟周期</strong>：</p><ul><li>执行指令的一个<strong>动作&#x2F;步骤</strong>至少需要的<strong>时间</strong></li><li>中央处理器（CPU）最小的时间单位</li><li>中央处理器（CPU）始终频域&#x2F;主频的倒数</li></ul><p>每条指令的时钟周期数（CPI）&#x2F;<strong>指令周期</strong>:</p><ul><li>执行一条<strong>指令</strong>需要的中央处理器（CPU）时钟周期<strong>数</strong></li><li>对一台机器或一个程序，指机器或程序指令集中所有指令执行需要的平均中央处理器（CPU）时钟周期数</li></ul><p> 中央处理器（CPU）执行时间：</p><ul><li>运行一个<strong>程序</strong>需要的<strong>时间</strong></li><li>中央处理器（CPU）时钟周期数×中央处理器（CPU）时钟周期</li><li>（指令条数×每条指令的时钟周期数（CPI））×中央处理器（CPU）时钟周期</li></ul><blockquote><p>公式记忆：单位时间个数×单位时间<br>公式扩展：</p><ul><li>中央处理器（CPU）时钟周期&#x3D;1÷中央处理器（CPU）始终频域&#x2F;主频</li><li>中央处理器（CPU）时钟周期数&#x3D;指令条数×每条指令的时钟周期数（CPI）</li></ul></blockquote><blockquote><p>记忆：概念描述的对象由小到大：指令的一个<strong>动作&#x2F;步骤</strong>，<strong>指令</strong>，<strong>程序</strong></p></blockquote><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>计算机组成原理的知识抽象、晦涩、不易理解并记忆。建议学习时结合示例，分别或集中对比相似概念，在理解的基础上<strong>使用自己的语言</strong>（因为在不同资料对同一个概念描述的用词不同，容易造成误解）总结区分、记忆技巧。</p><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li>作者：夜悊</li><li>版权所有，转载请注明出处，谢谢~</li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>《2023年计算机组成原理考研复习指导》组编：王道论坛</p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>指针、引用和常量的关系</title>
      <link href="/2022/04/17/%E6%8C%87%E9%92%88%E3%80%81%E5%BC%95%E7%94%A8%E5%92%8C%E5%B8%B8%E9%87%8F%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
      <url>/2022/04/17/%E6%8C%87%E9%92%88%E3%80%81%E5%BC%95%E7%94%A8%E5%92%8C%E5%B8%B8%E9%87%8F%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>指针、引用和常量的关系因为不同位置、能够相互嵌套（套娃）而异常复杂。文章简要介绍它们的区别，并总结区分技巧。</p><hr><h1 id="指针和引用"><a href="#指针和引用" class="headerlink" title="指针和引用"></a>指针和引用</h1><h2 id="指针是对象，引用不是对象"><a href="#指针是对象，引用不是对象" class="headerlink" title="指针是对象，引用不是对象"></a>指针是对象，引用不是对象</h2><blockquote><p>对象的概念宽泛，不易理解。在此可以理解为变量，一个变量是一个对象</p></blockquote><ul><li>指针不必须初始化</li><li>引用<strong>只是</strong>为一个<strong>已经存在的对象</strong>所起的另一个名字（别名）</li><li>引用必须初始化（初始化时的右值是一个<strong>已经存在的对象</strong>）</li></ul><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> val;<span class="comment">//一个已经存在的“对象”</span></span><br><span class="line"><span class="type">int</span> &amp;ref = val;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> &amp;ref1;<span class="comment">//×</span></span><br></pre></td></tr></table></figure><h2 id="指向引用的指针"><a href="#指向引用的指针" class="headerlink" title="指向引用的指针"></a>指向引用的指针</h2><p>不存在该定义。<strong>因为引用不是对象</strong>，所以不能定义<strong>指向引用的指针</strong>。<br>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> val;</span><br><span class="line"><span class="type">int</span> &amp;ref=val;</span><br><span class="line"><span class="type">int</span> &amp;*p=ref;<span class="comment">//×</span></span><br></pre></td></tr></table></figure><h2 id="指向指针的引用"><a href="#指向指针的引用" class="headerlink" title="指向指针的引用"></a>指向指针的引用</h2><p><strong>因为指针是对象</strong>，所以能定义<strong>指向指针的引用</strong>。<br>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p;</span><br><span class="line"><span class="type">int</span> *&amp;ref = p;</span><br></pre></td></tr></table></figure><p><strong>分析技巧</strong>：</p><blockquote><p>从左往右<strong>阅读</strong>变量定义：</p><ul><li>离变量名最近的符号，对变量的类型有最直接的影响。表述为：“…<strong>类型</strong>”</li><li>其余符号确定变量名<strong>作用的</strong>类型。表述为：“<strong>指向</strong>…<strong>类型的</strong>”</li></ul></blockquote><p>在示例中，离变量名ref最近的符号是&amp;，表述为“引用<strong>类型</strong>”。其余符号是int *，表述为“<strong>指向</strong>整型指针<strong>类型的</strong>”。</p><blockquote><p>从右往左<strong>理解</strong>变量定义：</p><ul><li>离变量名最近的符号，对变量的类型有最直接的影响。表述为：“<strong>是</strong>…类型”</li><li>其余符号确定变量名<strong>作用的</strong>类型。表述为：“<strong>作用于</strong>…类型”</li></ul></blockquote><p>在示例中，离变量名ref最近的符号是&amp;，表述为“变量ref<strong>是</strong>引用类型”。其余符号是int *，表述为“变量ref<strong>作用于</strong>整型指针类型”。</p><p>综上，“int *&amp;ref &#x3D; p;”是“<strong>指向</strong>整型指针<strong>类型的</strong>引用<strong>类型</strong>”（阅读定义），本质上是“指针的别名”，<strong>右值</strong>是指针（理解定义）。</p><hr><h1 id="变量和常量"><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h1><p>一个变量的<strong>值</strong>不能被改变，该变量<strong>是</strong>常量。</p><blockquote><p>变量的概念宽泛，不易理解。在此可以理解为变量<strong>是</strong>常量，具有<strong>值</strong>不能被改变的特性</p></blockquote><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> val = <span class="number">0</span>;<span class="comment">//使用“const”限定符修饰“变量”</span></span><br></pre></td></tr></table></figure><hr><h1 id="指针类型的常量"><a href="#指针类型的常量" class="headerlink" title="指针类型的常量"></a>指针类型的常量</h1><p><strong>因为指针是对象</strong>，所以能定义<strong>指针类型的常量</strong>。<br>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> p = &amp;val;</span><br></pre></td></tr></table></figure><p><strong>分析技巧</strong>：</p><blockquote><p>从左往右<strong>阅读</strong>变量定义：</p><ul><li>离变量名最近的符号，对变量的类型有最直接的影响。表述为：“…<strong>类型</strong>”</li><li>其余符号确定变量名<strong>作用的</strong>类型。表述为：“<strong>指向</strong>…<strong>类型的</strong>”</li></ul></blockquote><p>在示例中，离变量名p”最近的符号是“const”，表述为“常量<strong>类型</strong>”。其余符号是“int *”，表述为“<strong>指向</strong>整型指针<strong>类型的</strong>”。</p><blockquote><p>从右往左<strong>理解</strong>变量定义：</p><ul><li>离变量名最近的符号，对变量的类型有最直接的影响。表述为：“<strong>是</strong>…类型”</li><li>其余符号确定变量名<strong>作用的</strong>类型。表述为：“<strong>作用于</strong>…类型”</li></ul></blockquote><p>在示例中，离变量名“p最近的符号是const，表述为“变量p<strong>是</strong>常量类型”（虽然将常量表述为一种数据类型不太准确）。其余符号是“int *”，表述为“变量p<strong>作用于</strong>整型指针类型”。</p><p>综上，“int *const p &#x3D; &val;”是“<strong>指向</strong>整型指针<strong>的</strong>常量<strong>类型</strong>”，即“指针类型的常量”（阅读定义）。</p><ul><li>不能修改其所指对象的<strong>地址</strong>（因为<strong>自身的</strong>常量特性）</li><li>是否能修改所指对象的<strong>值</strong>取决于所指对象的类型。若指针所指对象是非常量，则可修改；反之不可（因为<strong>所指对象的</strong>常量特性）</li></ul><p>(理解定义)</p><hr><h1 id="引用类型的常量"><a href="#引用类型的常量" class="headerlink" title="引用类型的常量"></a>引用类型的常量</h1><p>不存在该定义。<strong>因为引用不是对象</strong>，所以不能定义<strong>引用类型的常量</strong>。<br>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> &amp;<span class="type">const</span> ref = val;<span class="comment">//×</span></span><br></pre></td></tr></table></figure><hr><h1 id="指向常量的指针"><a href="#指向常量的指针" class="headerlink" title="指向常量的指针"></a>指向常量的指针</h1><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p = &amp;val;</span><br></pre></td></tr></table></figure><p><strong>分析技巧</strong>：</p><blockquote><p>从左往右<strong>阅读</strong>变量定义：</p><ul><li>离变量名最近的符号，对变量的类型有最直接的影响。表述为：“…<strong>类型</strong>”</li><li>其余符号确定变量名<strong>作用的</strong>类型。表述为：“<strong>指向</strong>…<strong>类型的</strong>”</li></ul></blockquote><p>在示例中，离变量名p最近的符号是*，表述为“指针<strong>类型</strong>”。其余符号是const int，表述为“<strong>指向</strong>常量整型（整型常量）<strong>类型的</strong>”。</p><blockquote><p>从右往左<strong>理解</strong>变量定义：</p><ul><li>离变量名最近的符号，对变量的类型有最直接的影响。表述为：“<strong>是</strong>…类型”</li><li>其余符号确定变量名<strong>作用的</strong>类型。表述为：“<strong>作用于</strong>…类型”</li></ul></blockquote><p>在示例中，离变量名p最近的符号是*，表述为“变量p<strong>是</strong>指针类型”。其余符号是const int，表述为“变量p<strong>作用于</strong>常量整型（整型常量）”。</p><p>综上，“const int *p &#x3D; &val;”是“<strong>指向</strong>整型常量<strong>的</strong>指针<strong>类型</strong>”，即“指向常量的指针”（阅读定义）。</p><ul><li><strong>普通指针不可指向常量</strong></li><li><strong>指向常量的指针可指向常量</strong></li><li>指向常量的指针可指向非常量</li><li>不能修改所指对象的值（因为<strong>所指对象的</strong>常量特性）</li></ul><p>（理解定义）</p><hr><h1 id="指向常量的引用"><a href="#指向常量的引用" class="headerlink" title="指向常量的引用"></a>指向常量的引用</h1><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;ref = val;</span><br></pre></td></tr></table></figure><p><strong>分析技巧</strong>：</p><blockquote><p>从左往右<strong>阅读</strong>变量定义：</p><ul><li>离变量名最近的符号，对变量的类型有最直接的影响。表述为：“…<strong>类型</strong>”</li><li>其余符号确定变量名<strong>作用的</strong>类型。表述为：“<strong>指向</strong>…<strong>类型的</strong>”</li></ul></blockquote><p>在示例中，离变量名ref最近的符号是&amp;，表述为“引用<strong>类型</strong>”。其余符号是const int，表述为“<strong>指向</strong>常量整型（整型常量）<strong>类型的</strong>”。</p><blockquote><p>从右往左<strong>理解</strong>变量定义：</p><ul><li>离变量名最近的符号，对变量的类型有最直接的影响。表述为：“<strong>是</strong>…类型”</li><li>其余符号确定变量名<strong>作用的</strong>类型。表述为：“<strong>作用于</strong>…类型”</li></ul></blockquote><p>在示例中，离变量名p最近的符号是&amp;，表述为“变量ref<strong>是</strong>引用类型”。其余符号是const int，表述为“变量ref<strong>作用于</strong>常量整型（整型常量）”。</p><p>综上，“const int &amp;ref &#x3D; val;”是“<strong>指向</strong>整型常量<strong>的</strong>引用<strong>类型</strong>”，即“指向常量的引用”（阅读定义）。</p><ul><li><strong>普通引用不可指向常量</strong></li><li><strong>指向常量的引用可指向常量</strong></li><li>指向常量的指针可指向非常量</li><li>不能修改所指对象的值（因为<strong>所指对象的</strong>常量特性）</li></ul><p>（理解定义）</p><hr><h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><h2 id="从左往右阅读变量定义"><a href="#从左往右阅读变量定义" class="headerlink" title="从左往右阅读变量定义"></a>从左往右<strong>阅读</strong>变量定义</h2><ul><li>离变量名最近的符号，对变量的类型有最直接的影响。表述为：“…<strong>类型</strong>”</li><li>其余符号确定变量名<strong>作用的</strong>类型。表述为：“<strong>指向</strong>…<strong>类型的</strong>”</li></ul><h2 id="从右往左理解变量定义"><a href="#从右往左理解变量定义" class="headerlink" title="从右往左理解变量定义"></a>从右往左<strong>理解</strong>变量定义</h2><ul><li>离变量名最近的符号，对变量的类型有最直接的影响。表述为：“<strong>是</strong>…类型”</li><li>其余符号确定变量名<strong>作用的</strong>类型。表述为：“<strong>作用于</strong>…类型”</li></ul><h2 id="顶、底层常量"><a href="#顶、底层常量" class="headerlink" title="顶、底层常量"></a>顶、底层常量</h2><ul><li>针对指针类型的判别，因为指针本身是一个对象，其可以指向另一个对象（概念实际上可以扩展到引用等复合类型）</li><li>离变量名最近的const符号，是顶层</li><li>离变量名最远的const符号，是底层</li><li>顶层常量，表示对象本身是常量</li><li>底层常量，表示对象所指的对象是常量</li></ul><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> p1;<span class="comment">//顶层常量，不能改变p1的值</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p2;<span class="comment">//底层常量，不能通过p2改变所指对象val的值</span></span><br></pre></td></tr></table></figure><ul><li>执行对象的拷贝（赋值）操作时，拷入和拷出的对象必须具有相同的底层常量资格；或者两个对象的数据类型能够相互转换，一般非常量能够转换成常量（<strong>除基本类型外</strong>）</li></ul><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *p1 = &amp;val;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p2 = &amp;val;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p3 = &amp;val;</span><br><span class="line"></span><br><span class="line">p1 = p2;<span class="comment">//× 不具有相同的底层常量资格，常量不能够转换成非常量</span></span><br><span class="line">p2 = p3;<span class="comment">//√具有相同的底层常量资格</span></span><br><span class="line">p2 = &amp;val;<span class="comment">//√非常量能够转换成常量</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> val2 = <span class="number">0</span>;</span><br><span class="line">val = val2;<span class="comment">//√基本类型的常量能够转换成非常量</span></span><br></pre></td></tr></table></figure><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>指针、引用和常量的关系因为不同位置、能够相互嵌套（套娃）而异常复杂</li><li>建议分别或集中对比，<strong>简要</strong>了解其概念、<strong>理解</strong>几个简单示例。在理解的基础上总结区分技巧即可</li><li>实际编程中<strong>几乎遇不到、用不到</strong>它们的复杂组合，可无需咬文嚼字、刨根问底</li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li>作者反复阅读书籍中对指针、引用和常量的描述，边理解边总结</li><li><strong>实际上这篇文章内容质量并不好，因为作者在分析时还是很容易懵逼。至少尽力地将自己的理解更好地表述出来</strong></li><li>文章内容基于读者对指针、引用和常量概念有一定的理解</li><li>一些详细概念请参阅其他资料</li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>《C++ Primer》中文版（第5版）作者：Stanley B. Lippman，Barbara E. Moo，JoséeLaJoie </p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IRC（Internet Relay Chat）（因特网中继聊天）协议——RFC1459文档要点总结</title>
      <link href="/2022/04/16/IRC%EF%BC%88Internet%20Relay%20Chat%EF%BC%89%EF%BC%88%E5%9B%A0%E7%89%B9%E7%BD%91%E4%B8%AD%E7%BB%A7%E8%81%8A%E5%A4%A9%EF%BC%89%E5%8D%8F%E8%AE%AE%E2%80%94%E2%80%94RFC1459%E6%96%87%E6%A1%A3%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93/"/>
      <url>/2022/04/16/IRC%EF%BC%88Internet%20Relay%20Chat%EF%BC%89%EF%BC%88%E5%9B%A0%E7%89%B9%E7%BD%91%E4%B8%AD%E7%BB%A7%E8%81%8A%E5%A4%A9%EF%BC%89%E5%8D%8F%E8%AE%AE%E2%80%94%E2%80%94RFC1459%E6%96%87%E6%A1%A3%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>IRC（Internet Relay Chat）（因特网中继聊天）协议是由芬兰人Jarkko Oikarinen于1988年首创的一种网络聊天协议。文章对“RFC 1459 - Internet Relay Chat Protocol”文档要点进行总结。</p><hr><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><ul><li>基于文本</li></ul><blockquote><p>“文本”：因为应用的功能是“聊天”，传输的数据类型是“文本文字”</p></blockquote><ul><li><strong>最简单的</strong>客户机是任何能够连接到服务器的套接字程序</li><li>使用TCP&#x2F;IP网络协议</li><li>依据客户机-服务器模型</li><li>典型的设置包括单个进程(服务器)形成客户机(或其他服务器)连接的中心点，执行所需的消息传递&#x2F;多路复用和其他功能。如图：</li></ul><blockquote><p>提示：类比树状网络</p></blockquote><p><img src="/../img/irc/cc0e700f6dc64ce3a5671216b67d9d36.png"></p><hr><h1 id="三种角色"><a href="#三种角色" class="headerlink" title="三种角色"></a>三种角色</h1><ul><li>服务器</li><li>客户机</li><li>运营商（特殊类别的客户，类比管理员）</li></ul><hr><h1 id="信道-频道"><a href="#信道-频道" class="headerlink" title="信道&#x2F;频道"></a>信道&#x2F;频道</h1><ul><li><strong>信道是由一个或多个客户端组成的命名组，这些客户端将接收到发送给该信道的消息</strong>。当第一个客户端加入信道时，信道隐式地创建，当最后一个客户端离开信道时，信道停止存在。当信道存在时，任何客户端都可以使用信道名引用信道。</li></ul><blockquote><p>“信道是由一个或多个客户端组成的命名组，这些客户端将接收到发送给该信道的消息”：信道是一个或多个客户端的集合，即“聊天群”。在同一个“聊天群”内，客户端可接收到其他（0、1或多个）客户端的消息</p></blockquote><ul><li>协议存在两种类型的信道。一种是<strong>分布式</strong>信道，<strong>所有的</strong>服务器都知道它（们）</li><li>要创建新信道或成为现有信道的一部分，需要用户加入该信道。如果信道在加入之前不存在，则创建信道，创建信道的用户成为信道操作符。如果信道已经存在，那么加入请求是否被接受取决于该信道的当前模式。例如，如果该信道只接受邀请，则用户只能在被邀请时加入</li></ul><blockquote><p>“信道操作符”：即“信道标识符”、“聊天群群主&#x2F;管理员”</p></blockquote><ul><li>一个用户可能同时属于多个信道的一部分</li></ul><hr><h1 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h1><p>没有为文本的字符数据类型指定特定的字符集。<strong>协议</strong>基于一系列由8位组成的代码（八位组&#x2F;字节）。每条消息可以由任意数量的字节构成。</p><blockquote><p>“协议”：原文档内容是：“ The protocol is based on a …”。表意不太明确。在编程实现时，可以简化理解为“<strong>每字符</strong>”基于一个字节，而“char”数据类型大小刚好为一个字节</p></blockquote><hr><h1 id="消息传递方式"><a href="#消息传递方式" class="headerlink" title="消息传递方式"></a>消息传递方式</h1><ul><li>客户机-服务器和服务器-服务器之间的通信是异步的</li><li>消息传递图类比网络拓扑图：</li></ul><p><img src="/../img/irc/27e8c7d5aaad4b92aeee0902a22e7bf2.png"></p><h2 id="一对一通信"><a href="#一对一通信" class="headerlink" title="一对一通信"></a>一对一通信</h2><ul><li>通常只在客户端间进行一对一通信，因为大多数服务器-服务器通信<strong>都不是</strong>服务器之间<strong>只进行通信</strong>的结果。理由见后面“一对所有通信”内容</li><li>消息传递的路径是生成树上任意两点之间的<strong>最短</strong>路径</li></ul><blockquote><p>“最短路径”：即“最低开销”路径，在<strong>尽可能少的</strong>客户机、服务器间传递消息</p></blockquote><p>示例1:<br>客户机1和客户机2之间的消息只被服务器A知道，服务器A将客户机1的消息直接发送给客户机2。</p><p>示例2:<br>客户机1和3之间的消息能够被服务器A和B知道。其他客户机、服务器不能知道该消息。</p><p>示例3:<br>客户机2和4之间的消息能够被服务器A、B、C和D知道。</p><h2 id="一对多通信"><a href="#一对多通信" class="headerlink" title="一对多通信"></a>一对多通信</h2><ul><li>三种通信方式：消息列表、信道&#x2F;群组和客户机、服务器掩码</li><li>消息列表：客户机提供消息要传递到的目的地的列表，服务器分解列表，依据列表项，将消息的各单独副本分发到每个给定的目的地</li><li>信道&#x2F;群组：客户机的消息只发送到服务器一次，服务器将消息发送到信道中的每个客户机。然后对每个服务器-客户机对重复此操作，直到原始消息呈扇形传播并到达通道中的每个服务器、客户机</li></ul><blockquote><p>提示：类比网络传输的“多播”进行理解</p></blockquote><ul><li>客户机、服务器掩码：通过“掩码消息”，将消息传递给指定的服务器、客户机</li></ul><h2 id="一对所有通信"><a href="#一对所有通信" class="headerlink" title="一对所有通信"></a>一对所有通信</h2><ul><li>客户机到客户机：无</li><li>客户机到服务器：客户机的大多数导致状态信息改变的命令(如信道成员、信道模式、用户状态等)在默认情况下必须发送到所有服务器</li><li>服务器到服务器：几乎所有来自服务器的消息都会广播到所有其他连接的服务器</li></ul><hr><h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><p>略</p><hr><h1 id="当前实现内容"><a href="#当前实现内容" class="headerlink" title="当前实现内容"></a>当前实现内容</h1><blockquote><p>“当前实现内容”：原文档标题是：“Current implementations”。描述的是当前IRC协议的实现细节</p></blockquote><h2 id="基于TCP网络协议"><a href="#基于TCP网络协议" class="headerlink" title="基于TCP网络协议"></a>基于TCP网络协议</h2><p>TCP是可靠的网络协议，适合于IRC协议的“<strong>一定规模文本数据交互</strong>”内容。</p><h2 id="支持Unix域套接字"><a href="#支持Unix域套接字" class="headerlink" title="支持Unix域套接字"></a>支持Unix域套接字</h2><p>鉴于Unix域套接字是监听&#x2F;连接操作，<strong>可以将当前实现配置为</strong>：监听和接受Unix域套接字上的客户机和服务器连接。</p><blockquote><p>“可以将当前实现配置为…”：即可使用套接字API（应用程序编程接口）进行网络编程实现IRC协议</p></blockquote><h2 id="命令解析"><a href="#命令解析" class="headerlink" title="命令解析"></a>命令解析</h2><p><strong>每个网络连接都有私有的“输入缓冲区”</strong>，其中保存<strong>最近的</strong>读取和解析<strong>命令</strong>结果。缓冲区设置的目的是为客户机和服务器提供有用的“<strong>非缓冲</strong>”网络IO。</p><blockquote><p>“每个网络连接都有私有的“输入缓冲区”：原文档内容是“each connection is given its own private ‘input buffer…”。结合上下文理解：一般是客户机给服务器发送“命令”消息，又是“输入”缓冲区，则该“缓冲区”应在每客户机-服务器连接对的客户机一端</p></blockquote><blockquote><p>“最近的”：缓冲区可能存储多个命令与解析结果</p></blockquote><blockquote><p>“非缓冲”：原文档内容是“ To provide useful ‘non-buffered’ network IO…”。描述上，其是具有缓冲区的，这里的意思可能是：“异步”网络IO：在缓冲区<strong>缓冲地</strong>存放命令和解析结果，由客户机、服务器<strong>异步地</strong>获取相应内容。编程实现时，可以考虑使用异步IO：“io_uring”技术</p></blockquote><h2 id="消息队列机制"><a href="#消息队列机制" class="headerlink" title="消息队列机制"></a>消息队列机制</h2><ul><li>为缓解“网络连接饱和”，使用TCP窗口、内部缓冲区和消息队列机制</li></ul><blockquote><p>“TCP窗口”：原文档内容：“Although Unix typically handles this through the TCP window and internal buffers…”。这里指的是TCP流量控制而不是拥塞控制内容，即缓解“收发数据<strong>两端</strong>流量速率不匹配问题”</p></blockquote><ul><li>消息队列机制：FIFO（先进先出）数据发送队列。<strong>服务器轮询它的连接时</strong>，首先读取并解析所有传入的数据，将所有<strong>要发送出去的</strong>数据排在队列中。处理完所有可用的输入后，发送排队的数据。能够<strong>减少write()系统调用的数量</strong>，并帮助TCP生成更大的包</li></ul><blockquote><p>“服务器轮询它的连接时”：一台服务器可能有多个“服务器-服务器”、“服务器-客户机”连接对，服务器需要依次处理消息</p></blockquote><blockquote><p>“能够减少write()系统调用的数量”：编程实现时，可以考虑使用“io_uring”技术，它的优势之一亦是减少系统调用的次数，降低系统开销</p></blockquote><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>IRC（Internet Relay Chat）（因特网中继聊天）协议是基于TCP&#x2F;IP的应用层协议，工作原理简单，能够通过网络编程：使用套接字API+“客户机-服务器”模型+其他技术实现。</p><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li>文章内容是作者为完成一项“基于C&#x2F;C++语言、异步IO：‘io_uring’技术的IRC协议实现”的网络编程小程序，通篇翻译、阅读“RFC 1459 - Internet Relay Chat Protocol”文档进行的要点总结。选取的内容基于<strong>作者认为</strong>对编程实现重要的点，描述并不全面，具体请参阅其他资料</li><li>文章在描述时有疑惑的地方，请留言，定会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://www.faqs.org/rfcs/rfc1459.html">RFC 1459 - Internet Relay Chat Protocol</a></p>]]></content>
      
      
      <categories>
          
          <category> 环境和网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境和网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象思想</title>
      <link href="/2022/04/15/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3/"/>
      <url>/2022/04/15/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学习设计模式，需要了解面向对象思想。利用面向对象思想的特性，能够帮助我们设计出优秀的程序。</p><hr><h1 id="面向过程思想"><a href="#面向过程思想" class="headerlink" title="面向过程思想"></a>面向过程思想</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>关注点：正在发生的过程</li><li>事情的发生按照一定的“逻辑时间顺序”</li><li>符合多数人思考、计算机处理问题的逻辑</li></ul><h2 id="示例（C-语言描述）"><a href="#示例（C-语言描述）" class="headerlink" title="示例（C++语言描述）"></a>示例（C++语言描述）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//定义并初始化变量</span></span><br><span class="line">    <span class="type">int</span> num1 = <span class="number">1</span>;<span class="comment">//操作数1</span></span><br><span class="line">    <span class="type">char</span> oper = <span class="string">&#x27;+&#x27;</span>;<span class="comment">//计算符</span></span><br><span class="line">    <span class="type">int</span> num2 = <span class="number">2</span>;<span class="comment">//操作数2</span></span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;<span class="comment">//计算结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判定并计算</span></span><br><span class="line">    <span class="keyword">switch</span> (oper)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">        result = num1 + num2;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        result = num1 - num2;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;<span class="comment">//输出计算结果</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序<strong>先</strong>定义并初始化变量，<strong>然后</strong>进行判断计算，<strong>最后</strong>输出结果。程序的执行“从上至下”（按照语句顺序），“从过去到未来”（按照时间顺序）经历一定的过程。</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>维护性差</li><li>复用性差</li><li>扩展性差</li><li>灵活性差</li></ul><hr><h1 id="优秀程序设计的四个特性"><a href="#优秀程序设计的四个特性" class="headerlink" title="优秀程序设计的四个特性"></a>优秀程序设计的四个特性</h1><p>在实际业务、服务开发中，需求变化，程序就要修改。<strong>优秀程序设计旨在用更短的时间、变动更少的代码、按一定设计步骤有序无差错地完成任务。</strong></p><ul><li>维护性：只修改相关代码&#x2F;功能，而不影响其他代码&#x2F;功能</li><li>复用性：代码&#x2F;功能可重复使用</li><li>扩展性：能在原有代码&#x2F;功能基础上，增添新的代码&#x2F;功能</li><li>灵活性：代码&#x2F;功能适用于多种场景</li></ul><hr><h1 id="面向对象思想"><a href="#面向对象思想" class="headerlink" title="面向对象思想"></a>面向对象思想</h1><p>关注点：正在受影响的对象<br>三大特性：封装，继承，多态</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>目的</p><ul><li>拆分逻辑</li><li>降低耦合度</li><li>隐藏实现细节</li><li>…</li></ul><p>示例（C++语言描述）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Operation</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> num1;<span class="comment">//操作数1</span></span><br><span class="line">    <span class="type">char</span> oper;<span class="comment">//计算符</span></span><br><span class="line">    <span class="type">int</span> num2;<span class="comment">//操作数2</span></span><br><span class="line">    <span class="type">int</span> result;<span class="comment">//计算结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//计算方式</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (oper)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            result = num1 + num2;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            result = num1 - num2;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建并初始化计算类的对象</span></span><br><span class="line">    Operation operation;</span><br><span class="line">    operation.num1 = <span class="number">1</span>;</span><br><span class="line">    operation.oper = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">    operation.num2 = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    operation.<span class="built_in">calculate</span>();<span class="comment">//计算</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; operation.result &lt;&lt; endl;<span class="comment">//输出计算结果</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序定义了一个计算类，将”操作数、操作符、计算结果和计算方式”逻辑相似且共同实现一种功能的“实体”<strong>封装</strong>；在主函数中将计算的业务逻辑和输出显示的界面的代码<strong>逻辑拆分</strong>，修改代码可选择只修改其中一部分而不影响另一部分，<strong>耦合度降低</strong>；对主函数而言，计算类的<strong>实现细节是隐藏的</strong>，主函数只需知道如何调用，可以将计算类<strong>复用</strong>在其他位置。</p><h2 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h2><p>目的</p><ul><li>拆分逻辑</li><li>降低耦合度</li><li>…</li></ul><p>当需要修改计算类时，仍然存在耦合度高的问题。例如想为其增添“乘法计算”功能，则需在“calculate()”函数的“switch”语句中添加代码，可能会错误修改“加法、减法计算”功能的代码。</p><p>示例（C++语言描述）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Operation</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> num1;   <span class="comment">//操作数1</span></span><br><span class="line">    <span class="type">char</span> oper;  <span class="comment">//计算符</span></span><br><span class="line">    <span class="type">int</span> num2;   <span class="comment">//操作数2</span></span><br><span class="line">    <span class="type">int</span> result; <span class="comment">//计算结果</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">//纯虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算加法类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Operation_add</span> : <span class="keyword">public</span> Operation <span class="comment">//继承</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">calculate</span><span class="params">()</span> <span class="comment">//重载  多态</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        result = num1 + num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算减法类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Operation_sub</span> : <span class="keyword">public</span> Operation</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        result = num1 - num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算乘法类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Operation_mul</span> : <span class="keyword">public</span> Operation</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        result = num1 * num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 程序设计思路：依据给定的计算符，创建计算类相应的子类对象，调用子类的方法计算</span></span><br><span class="line"><span class="comment"> * 使用简单工厂模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//计算工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Operation_factory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Operation *<span class="title">create_operation</span><span class="params">(<span class="type">char</span> oper)</span> <span class="comment">//静态函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Operation *operation = <span class="literal">NULL</span>; <span class="comment">//指向计算类的指针</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//依据给定的计算符，创建计算类相应的子类</span></span><br><span class="line">        <span class="keyword">switch</span> (oper)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            operation = <span class="keyword">new</span> <span class="built_in">Operation_add</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            operation = <span class="keyword">new</span> <span class="built_in">Operation_sub</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">            operation = <span class="keyword">new</span> <span class="built_in">Operation_mul</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> operation;<span class="comment">//返回相应的计算子类对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//依据给定的计算符，创建计算类相应的子类对象并初始化</span></span><br><span class="line">    Operation *operation = Operation_factory::<span class="built_in">create_operation</span>(<span class="string">&#x27;+&#x27;</span>);</span><br><span class="line">    <span class="comment">//静态函数属于类而不是对象，由类直接调用</span></span><br><span class="line">    operation-&gt;num1 = <span class="number">1</span>;</span><br><span class="line">    operation-&gt;num2 = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    operation-&gt;<span class="built_in">calculate</span>();<span class="comment">//计算</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; operation-&gt;result &lt;&lt; endl;<span class="comment">//输出计算结果</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<strong>继承</strong>，将“计算”的各个“子功能”<strong>逻辑拆分</strong>，每个功能单独成一“类”，<strong>耦合度降低</strong>；通过<strong>多态</strong>，将函数重载以实现不同的计算。当再想增加一个“除法计算”功能时，只需增加一个计算除法子类，并在计算工厂类的“switch”语句中增加一个创建计算除法子类对象的分支，而不会“触碰”&#x2F;误修改到“加、减和乘法计算”功能的代码，提高了程序的<strong>维护性</strong>。</p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>面向过程的关注点：正在发生的过程</li><li>优秀程序设计的四大特性：维护性，复用性，扩展性，灵活性</li><li>面向对象的关注点：正在受影响的对象</li><li>三大特性：封装，继承，多态</li></ul><hr><h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><ul><li>文章内容基于读者有一定程序设计基础，了解面向过程、对象思想等一定知识，主要目的是对知识的串讲、延拓，详细概念理解请参阅其他资料</li><li>文章内容示例简单，思想优越性的体现可能不理想。当拓展到大型业务、服务和程序时，务须具备高效的设计思想、使用良好的设计模式编程</li><li>文章在描述时有疑惑的地方，请留言，必会一一耐心讨论、解答</li><li>文章在认识上有错误的地方, 敬请批评指正</li><li>望读者们都能有所收获</li></ul><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>《大话设计模式》作者：程杰</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
